'ThisWorkbook	Document

Option Explicit


Private Sub Workbook_Open()
'@INCLUDE PROCEDURE RunVbaGui
'@INCLUDE PROCEDURE CreateAllBars
'@AssignedModule ThisWorkbook

    RunVbaGui
    CreateAllBars
End Sub


'List	Document

Option Explicit


'Dependencies	Module



'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Module     : Dependencies
'* Purpose    : list dependencies, export/import procedures/components
'* Copyright  :
'*
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : some time ago       Alex
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


#If VBA7 Then
    Public Declare PtrSafe Function CloseClipboard Lib "user32" () As Long
    Public Declare PtrSafe Function EmptyClipboard Lib "user32" () As Long
    Public Declare PtrSafe Function OpenClipboard Lib "user32" (ByVal hwnd As Long) As Long
#Else
    Public Declare Function CloseClipboard Lib "user32" () As Long
    Public Declare Function EmptyClipboard Lib "user32" () As Long
    Public Declare Function OpenClipboard Lib "user32" (ByVal hwnd As Long) As Long
#End If

Rem ___CHANGE THESE TO MATCH YOUR FOLDER AND REPO____
'------------------------------------------------------------------------------
Public Const GITHUB_LIBRARY = "https://raw.githubusercontent.com/alexofrhodes/VBA-Library/"
'------------------------------------------------------------------------------
    Public Const GITHUB_LIBRARY_DECLARATIONS = GITHUB_LIBRARY & "Declarations/"
    Public Const GITHUB_LIBRARY_PROCEDURES = GITHUB_LIBRARY & "Procedures/"
    Public Const GITHUB_LIBRARY_USERFORMS = GITHUB_LIBRARY & "Userforms/"
    Public Const GITHUB_LIBRARY_CLASSES = GITHUB_LIBRARY & "Classes/"
'------------------------------------------------------------------------------
Public Const GITHUB_BLOG = "https://alexofrhodes.github.io/"
Public Const GITHUB_URL = "https://github.com/alexofrhodes/"
'------------------------------------------------------------------------------
Public Const AUTHOR_YOUTUBE = "https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg"
Public Const AUTHOR_VK = "https://vk.com/video/playlist/735281600_1"
Public Const AUTHOR_NAME = "Anastasiou Alex"
Public Const AUTHOR_EMAIL = "AnastasiouAlex@gmail.com"
Public Const AUTHOR_COPYRIGHT = ""
Public Const AUTHOR_OTHERTEXT = ""

Public Const GUID = "NBGD41100771701DDE7600"

Public ShowInVBE As Boolean

'------------------------------------------------------------------------------
Public Function LOCAL_LIBRARY(): LOCAL_LIBRARY = LIBRARY_FOLDER: End Function
'------------------------------------------------------------------------------
    Public Function LOCAL_LIBRARY_DECLARATIONS(): LOCAL_LIBRARY_DECLARATIONS = LOCAL_LIBRARY & "Declarations\": End Function
    Public Function LOCAL_LIBRARY_PROCEDURES():   LOCAL_LIBRARY_PROCEDURES = LOCAL_LIBRARY & "Procedures\":     End Function
    Public Function LOCAL_LIBRARY_USERFORMS():    LOCAL_LIBRARY_USERFORMS = LOCAL_LIBRARY & "Userforms\":       End Function
    Public Function LOCAL_LIBRARY_CLASSES():      LOCAL_LIBRARY_CLASSES = LOCAL_LIBRARY & "Classes\":           End Function

Function LIBRARY_FOLDER() As String
    If GetMotherBoardProp = GUID Then
        LIBRARY_FOLDER = "C:\Users\acer\Documents\GitHub\VBA-Library\"
    Else
        LIBRARY_FOLDER = Environ$("USERPROFILE") & "\Documents\vbArc\Library\"
    End If
End Function

Public Function AUTHOR_MEDIA() As String
    AUTHOR_MEDIA = "'* BLOG       : " & GITHUB_BLOG & vbNewLine & _
                   "'* GITHUB     : " & GITHUB_URL & vbNewLine & _
                   "'* YOUTUBE    : " & AUTHOR_YOUTUBE & vbNewLine & _
                   "'* VK         : " & AUTHOR_VK & vbNewLine & "'*" & vbNewLine
End Function

Function DevInfo() As String
    Dim i As Long: i = 14
    Dim Character As String: Character = "_"
    DevInfo = DpHeader(Array( _
    "AUTHOR     " & AUTHOR_NAME, _
    "EMAIL      " & AUTHOR_EMAIL, _
    "BLOG       " & GITHUB_BLOG, _
    "GITHUB     " & GITHUB_URL, _
    "YOUTUBE    " & AUTHOR_YOUTUBE, _
    "VK         " & AUTHOR_VK) _
    , , "*", True, True)
End Function

'--------------------------------------------
Sub AddLinkedListsToActiveProcedure()
    AddLinkedLists ThisWorkbook, ActiveModule, ActiveProcedure
End Sub

Sub ExportActiveProcedure()
    ExportProcedure ThisWorkbook, ActiveModule, ActiveProcedure, ExportMergedTxt:=True
End Sub

Sub ExportAllProceduresOfThisWorkbook()
    ExportAllProcedures ThisWorkbook
End Sub

Sub ImportActiveProcedureDependencies()
    ImportProcedureDependencies ActiveProcedure, ThisWorkbook, ActiveModule, Overwrite:=True
End Sub

Sub AddLinkedListsToAllProcedures(TargetWorkbook As Workbook)
    Dim Procedure
    Dim Module As VBComponent
    For Each Module In TargetWorkbook.VBProject.VBComponents
        If Module.Type = vbext_ct_StdModule And Module.Name <> "Dependencies" Then
            For Each Procedure In ProceduresOfModule(Module)
                AddLinkedLists TargetWorkbook, Module, CStr(Procedure)
            Next Procedure
        End If
    Next Module
    MsgBox "Done"
End Sub

Sub tmp()
    
    Dim Module As VBComponent
    For Each Module In ThisWorkbook.VBProject.VBComponents
        Debug.Print "---" & Module.Name
        AddLinkedListsToProceduresOfModule Module
    Next
    MsgBox "ok"
End Sub

Sub AddLinkedListsToProceduresOfModule(Module As VBComponent)
    Dim Procedure
    On Error GoTo EH
    For Each Procedure In ProceduresOfModule(Module)
        Debug.Print Procedure
        AddLinkedLists , Module, CStr(Procedure)
    Next Procedure
    Debug.Print vbNewLine & "---" & "Done"
    Exit Sub
EH:
    Debug.Print "Error at: " & Module.Name & vbTab & Procedure
    Resume Next
End Sub

Sub ExportAllProcedures(TargetWorkbook As Workbook)
    Dim Procedure
    Dim Module As VBComponent
    For Each Module In TargetWorkbook.VBProject.VBComponents
        If Module.Type = vbext_ct_StdModule Then
            For Each Procedure In ProceduresOfModule(Module)
                ExportProcedure TargetWorkbook, Module, CStr(Procedure), False
            Next Procedure
        End If
    Next Module
End Sub

Sub RemoveComments(TargetWorkbook As Workbook)
    Dim Module As VBComponent
    Dim s As String
    Dim i As Long
    For Each Module In TargetWorkbook.VBProject.VBComponents
        For i = Module.CodeModule.CountOfLines To 1 Step -1
            s = Trim(Module.CodeModule.Lines(i, 1))
            If s Like "'*" Then Module.CodeModule.DeleteLines i, 1
        Next i
    Next
End Sub

Function ArrayAppend(ByVal arr1 As Variant, ByVal arr2 As Variant) As Variant
    Dim holdarr As Variant
    Dim ub1 As Long
    Dim ub2 As Long
    Dim i As Long
    Dim newind As Long
    If IsEmpty(arr1) Or Not IsArray(arr1) Then
        arr1 = Array()
    End If
    If IsEmpty(arr2) Or Not IsArray(arr2) Then
        arr2 = Array()
    End If
    ub1 = UBound(arr1)
    ub2 = UBound(arr2)
    If ub1 = -1 Then
        ArrayAppend = arr2
        Exit Function
    End If
    If ub2 = -1 Then
        ArrayAppend = arr1
        Exit Function
    End If
    holdarr = arr1
    ReDim Preserve holdarr(ub1 + ub2 + 1)
    newind = UBound(arr1) + 1
    For i = 0 To ub2
        If VarType(arr2(i)) = vbObject Then
            Set holdarr(newind) = arr2(i)
        Else
            holdarr(newind) = arr2(i)
        End If
        newind = newind + 1
    Next i
    ArrayAppend = holdarr
End Function

Public Sub ArrayQuickSort(ByRef SortableArray As Variant, Optional lngMin As Long = -1, Optional lngMax As Long = -1)
    On Error Resume Next
    Dim i As Long
    Dim j As Long
    Dim varMid As Variant
    Dim varX As Variant
    If IsEmpty(SortableArray) Then
        Exit Sub
    End If
    If InStr(TypeName(SortableArray), "()") < 1 Then
        Exit Sub
    End If
    If lngMin = -1 Then
        lngMin = LBound(SortableArray)
    End If
    If lngMax = -1 Then
        lngMax = UBound(SortableArray)
    End If
    If lngMin >= lngMax Then
        Exit Sub
    End If
    i = lngMin
    j = lngMax
    varMid = Empty
    varMid = SortableArray((lngMin + lngMax) \ 2)
    If IsObject(varMid) Then
        i = lngMax
        j = lngMin
    ElseIf IsEmpty(varMid) Then
        i = lngMax
        j = lngMin
    ElseIf IsNull(varMid) Then
        i = lngMax
        j = lngMin
    ElseIf varMid = "" Then
        i = lngMax
        j = lngMin
    ElseIf VarType(varMid) = vbError Then
        i = lngMax
        j = lngMin
    ElseIf VarType(varMid) > 17 Then
        i = lngMax
        j = lngMin
    End If
    While i <= j
        While SortableArray(i) < varMid And i < lngMax
            i = i + 1
        Wend
        While varMid < SortableArray(j) And j > lngMin
            j = j - 1
        Wend
        If i <= j Then
            varX = SortableArray(i)
            SortableArray(i) = SortableArray(j)
            SortableArray(j) = varX
            i = i + 1
            j = j - 1
        End If
    Wend
    If (lngMin < j) Then Call ArrayQuickSort(SortableArray, lngMin, j)
    If (i < lngMax) Then Call ArrayQuickSort(SortableArray, i, lngMax)
End Sub

Public Function cleanArray(varArray As Variant) As Variant()
  Dim TempArray() As Variant
  Dim OldIndex As Integer
  Dim NewIndex As Integer
  Dim output As String
  If Not ArrayAllocated(varArray) Then Exit Function
  ReDim TempArray(LBound(varArray) To UBound(varArray))
  For OldIndex = LBound(varArray) To UBound(varArray)
    output = CleanTrim(varArray(OldIndex))
    If Not output = "" Then
        TempArray(NewIndex) = output
        NewIndex = NewIndex + 1
    End If
 Next OldIndex
 ReDim Preserve TempArray(LBound(varArray) To NewIndex - 1)
 cleanArray = TempArray
End Function

Function ArrayDuplicatesRemove(myArray As Variant) As Variant
    Dim nFirst As Long, nLast As Long, i As Long
    Dim item As String

    Dim arrTemp() As String
    Dim coll As New Collection
    If Not ArrayAllocated(myArray) Then Exit Function
    nFirst = LBound(myArray)
    nLast = UBound(myArray)
    ReDim arrTemp(nFirst To nLast)

    For i = nFirst To nLast
        arrTemp(i) = CStr(myArray(i))
    Next i

    On Error Resume Next
    For i = nFirst To nLast
        coll.Add arrTemp(i), arrTemp(i)
    Next i
    Err.Clear
    On Error GoTo 0

    nLast = coll.count + nFirst - 1
    ReDim arrTemp(nFirst To nLast)

    For i = nFirst To nLast
        arrTemp(i) = coll(i - nFirst + 1)
    Next i

    ArrayDuplicatesRemove = arrTemp

End Function

Public Function ArrayToCollection(Items As Variant) As Collection
    If Not ArrayAllocated(Items) Then Exit Function
    Dim coll As New Collection
    Dim i As Integer
    For i = LBound(Items) To UBound(Items)
        coll.Add Items(i)
    Next
    Set ArrayToCollection = coll
End Function

Function CleanTrim(ByVal s As String, Optional ConvertNonBreakingSpace As Boolean = True) As String
    Dim x As Long, CodesToClean As Variant
    CodesToClean = Array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, _
                         21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 127, 129, 141, 143, 144, 157)
    If ConvertNonBreakingSpace Then s = Replace(s, Chr(160), " ")
    s = Replace(s, vbCr, "")
    For x = LBound(CodesToClean) To UBound(CodesToClean)
        If InStr(s, Chr(CodesToClean(x))) Then
            s = Replace(s, Chr(CodesToClean(x)), vbNullString)
        End If
    Next
    CleanTrim = s
    CleanTrim = Trim(s)
End Function

Sub AddLinkedLists(Optional TargetWorkbook As Workbook, _
                    Optional Module As VBComponent, _
                    Optional Procedure As String)
    If Not AssignCPSvariables(TargetWorkbook, Module, Procedure) Then Exit Sub
    ProcedureLinesRemoveInclude TargetWorkbook, Module, Procedure
    ProcedureAssignedModuleAdd TargetWorkbook, Module, Procedure
    AddListOfLinkedProceduresToProcedure TargetWorkbook, Module, Procedure
    AddListOfLinkedClassesToProcedure TargetWorkbook, Module, Procedure
    AddListOfLinkedUserformsToProcedure TargetWorkbook, Module, Procedure
    AddListOfLinkedDeclarationsToProcedure TargetWorkbook, Module, Procedure
    
End Sub


Sub AddListOfLinkedClassesToProcedure( _
                                     Optional TargetWorkbook As Workbook, _
                                     Optional Module As VBComponent, _
                                     Optional ProcedureName As String)

    If Not AssignCPSvariables(TargetWorkbook, Module, ProcedureName) Then Stop
    Dim ListOfImports As String
    Dim Code As String
        Code = ProcedureCode(TargetWorkbook, Module, ProcedureName)
    Dim myClasses As Collection
    Set myClasses = LinkedClasses(TargetWorkbook, Module, ProcedureName)
    Dim element As Variant
    For Each element In myClasses
        If InStr(1, Code, "@INCLUDE CLASS " & element) = 0 _
        And InStr(1, ListOfImports, "@INCLUDE CLASS " & element) = 0 Then
            If ListOfImports = "" Then
                ListOfImports = "'@INCLUDE CLASS " & element
            Else
                ListOfImports = ListOfImports & vbNewLine & "'@INCLUDE CLASS " & element
            End If
        End If
    Next
    If ListOfImports <> "" Then
        Module.CodeModule.InsertLines _
            ProcedureBodyLineFirstAfterComments(Module, ProcedureName), ListOfImports
    End If
End Sub

Sub AddListOfLinkedDeclarationsToProcedure( _
                                          Optional TargetWorkbook As Workbook, _
                                          Optional Module As VBComponent, _
                                          Optional ProcedureName As String)

    If ProcedureName = "" Then ProcedureName = ActiveProcedure
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim ListOfImports As String
    If Module Is Nothing Then Set Module = ModuleOfProcedure(TargetWorkbook, ProcedureName)
    Dim ProcedureText As String
    ProcedureText = ProcedureCode(TargetWorkbook, Module, ProcedureName)
    Dim myDeclarations As Collection
    Set myDeclarations = LinkedDeclarations(TargetWorkbook, Module, ProcedureName)
    Dim coll As New Collection
    Dim element As Variant
    For Each element In myDeclarations
        If InStr(1, ProcedureText, "'@INCLUDE DECLARATION " & element) = 0 Then
            If ListOfImports = "" Then
                ListOfImports = "'@INCLUDE DECLARATION " & element
            Else
                ListOfImports = ListOfImports & vbNewLine & "'@INCLUDE DECLARATION " & element
            End If
        End If
    Next
    If ListOfImports <> "" Then
        Module.CodeModule.InsertLines ProcedureBodyLineFirstAfterComments(Module, ProcedureName), ListOfImports
    End If
End Sub

Sub AddListOfLinkedProceduresToProcedure( _
                                        Optional TargetWorkbook As Workbook, _
                                        Optional Module As VBComponent, _
                                        Optional ProcedureName As String)

    If Not AssignCPSvariables(TargetWorkbook, Module, ProcedureName) Then Stop
    Dim Procedures As Collection
    Set Procedures = LinkedProcedures(TargetWorkbook, Module, ProcedureName)
    Dim ListOfImports As String
    Dim Code As String
        Code = ProcedureCode(TargetWorkbook, Module, ProcedureName)
    Dim Procedure As Variant
    For Each Procedure In Procedures
        If InStr(1, Code, "@INCLUDE PROCEDURE " & Procedure) = 0 And InStr(1, ListOfImports, "@INCLUDE PROCEDURE " & Procedure) = 0 Then
            If ListOfImports = "" Then
                ListOfImports = "'@INCLUDE PROCEDURE " & Procedure
            Else
                ListOfImports = ListOfImports & vbNewLine & "'@INCLUDE PROCEDURE " & Procedure
            End If
        End If
    Next
    If ListOfImports <> "" Then
        Module.CodeModule.InsertLines ProcedureBodyLineFirstAfterComments(Module, ProcedureName), ListOfImports
    End If
End Sub

Sub AddListOfLinkedUserformsToProcedure( _
                                       Optional TargetWorkbook As Workbook, _
                                       Optional Module As VBComponent, _
                                       Optional ProcedureName As String)
    
    If Not AssignCPSvariables(TargetWorkbook, Module, ProcedureName) Then Stop

    Dim ListOfImports As String
    Dim Code As String
        Code = ProcedureCode(TargetWorkbook, Module, ProcedureName)
    Dim myClasses As Collection
    Set myClasses = LinkedUserforms(TargetWorkbook, Module, ProcedureName)
    Dim element As Variant
    For Each element In myClasses
        If InStr(1, Code, "@INCLUDE USERFORM " & element) = 0 And InStr(1, ListOfImports, "@INCLUDE USERFORM " & element) = 0 Then
            If ListOfImports = "" Then
                ListOfImports = "'@INCLUDE USERFORM " & element
            Else
                ListOfImports = ListOfImports & vbNewLine & "'@INCLUDE USERFORM " & element
            End If
        End If
    Next
    If ListOfImports <> "" Then
        Module.CodeModule.InsertLines ProcedureBodyLineFirstAfterComments(Module, ProcedureName), ListOfImports
    End If
End Sub

Public Function ActiveProcedure() As String
    Application.VBE.ActiveCodePane.GetSelection L1&, c1&, L2&, c2&
    ActiveProcedure = Application.VBE.ActiveCodePane.CodeModule.ProcOfLine(L1&, vbext_pk_Proc)
End Function

'* Modified   : Date and Time       Author              Description
'* Updated    : 17-08-2023 12:58    Alex                (ActiveModule) switched SelectedVBComponent to ActiveCodePane

Public Function ActiveModule() As VBComponent
'@LastModified 2308171258
    Dim ActivePane As CodePane
    Set ActivePane = Application.VBE.ActiveCodePane
    If Not ActivePane Is Nothing Then Set ActiveModule = ActivePane.CodeModule.Parent
End Function

Public Function ActiveCodepaneWorkbook() As Workbook
    On Error GoTo ErrorHandler
    Dim WorkbookName As String
    WorkbookName = Application.VBE.SelectedVBComponent.Collection.Parent.fileName
    WorkbookName = Right(WorkbookName, Len(WorkbookName) - InStrRev(WorkbookName, "\"))
    Set ActiveCodepaneWorkbook = Workbooks(WorkbookName)
    Exit Function
ErrorHandler:
    MsgBox "doesn't work on new-unsaved workbooks"
End Function

Public Function ArrayAllocated(ByVal arr As Variant) As Boolean
    On Error Resume Next
    ArrayAllocated = IsArray(arr) And (Not IsError(LBound(arr, 1))) And LBound(arr, 1) <= UBound(arr, 1)
End Function

Public Function ArrayDimensionLength(SourceArray As Variant) As Integer
    Dim i As Integer
    Dim test As Long
    On Error GoTo Catch
    Do
        i = i + 1
        test = UBound(SourceArray, i)
    Loop
Catch:
    ArrayDimensionLength = i - 1
End Function

Public Sub ArrayToRange2D(arr2d As Variant, cell As Range)

    If ArrayDimensionLength(arr2d) = 1 Then arr2d = WorksheetFunction.Transpose(arr2d)
    Dim dif As Long
        dif = IIf(LBound(arr2d, 1) = 0, 1, 0)
    Dim rng As Range
    Set rng = cell.Resize(UBound(arr2d, 1) + dif, UBound(arr2d, 2) + dif)

    If Application.WorksheetFunction.CountA(rng) > 0 Then
        Exit Sub
    End If

    rng.Value = arr2d
End Sub

Function AssignCPSvariables( _
                            ByRef TargetWorkbook As Workbook, _
                            ByRef Module As VBComponent, _
                            ByRef Procedure As String) As Boolean

    If Not AssignWorkbookVariable(TargetWorkbook) Then Exit Function
    If Not AssignModuleVariable(TargetWorkbook, Module, Procedure) Then Exit Function
    If Not AssignProcedureVariable(TargetWorkbook, Procedure) Then Exit Function
    AssignCPSvariables = True
    
End Function

Function AssignModuleVariable( _
                             ByVal TargetWorkbook As Workbook, _
                             ByRef Module As VBComponent, _
                             Optional ByVal Procedure As String) As Boolean
    If Module Is Nothing Then
        If Procedure = "" Then
            Set Module = ActiveModule
        End If
        On Error Resume Next
        Set Module = ModuleOfProcedure(TargetWorkbook, Procedure)
        On Error GoTo 0
    End If
    AssignModuleVariable = Not Module Is Nothing
End Function

Function AssignProcedureVariable(TargetWorkbook As Workbook, ByRef Procedure As String) As Boolean
    If Procedure = "" Then
        Dim cps As String
        cps = CodepaneSelection
        If Len(cps) > 0 Then
            Procedure = cps
        Else
            Procedure = ActiveProcedure
        End If
        If Not ProcedureExists(TargetWorkbook, Procedure) Then
            Debug.Print Procedure & " not found in Workbook " & TargetWorkbook.Name
        End If
    End If
    AssignProcedureVariable = Not Procedure = ""
End Function

Function AssignWorkbookVariable(ByRef TargetWorkbook As Workbook) As Boolean
     If TargetWorkbook Is Nothing Then
        On Error Resume Next
        Set TargetWorkbook = ActiveCodepaneWorkbook
        On Error GoTo 0
    End If
    AssignWorkbookVariable = Not TargetWorkbook Is Nothing
End Function

Function CheckPath(Path) As String
    Dim RetVal
    RetVal = "I"
    If (RetVal = "I") And FileExists(Path) Then RetVal = "F"
    If (RetVal = "I") And FolderExists(Path) Then RetVal = "D"
    If (RetVal = "I") And URLExists(Path) Then RetVal = "U"
    CheckPath = RetVal
End Function

Function ClassNames(Optional TargetWorkbook As Workbook)
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Set ClassNames = ComponentNames(vbext_ct_ClassModule, TargetWorkbook)
End Function

Public Function CodepaneSelection() As String
    Dim startLine As Long, StartColumn As Long, endLine As Long, EndColumn As Long
    Application.VBE.ActiveCodePane.GetSelection startLine, StartColumn, endLine, EndColumn
    If endLine - startLine = 0 Then
        CodepaneSelection = Mid(Application.VBE.ActiveCodePane.CodeModule.Lines(startLine, 1), StartColumn, EndColumn - StartColumn)
        Exit Function
    End If
    Dim str As String
    Dim i As Long
    For i = startLine To endLine
        If str = "" Then
            str = Mid(Application.VBE.ActiveCodePane.CodeModule.Lines(i, 1), StartColumn)
        ElseIf i < endLine Then
            str = str & vbNewLine & Application.VBE.ActiveCodePane.CodeModule.Lines(i, 1)
        Else
            str = str & vbNewLine & Left(Application.VBE.ActiveCodePane.CodeModule.Lines(i, 1), EndColumn - 1)
        End If
    Next
    CodepaneSelection = str
End Function

Public Function CollectionContains( _
                                  Kollection As Collection, _
                                  Optional Key As Variant, _
                                  Optional item As Variant) As Boolean
    Dim strKey As String
    Dim var As Variant
    If Not IsMissing(Key) Then
        strKey = CStr(Key)
        On Error Resume Next
        CollectionContains = True
        var = Kollection(strKey)
        If Err.Number = 91 Then GoTo CheckForObject
        If Err.Number = 5 Then GoTo NotFound
        On Error GoTo 0
        Exit Function
CheckForObject:
        If IsObject(Kollection(strKey)) Then
            CollectionContains = True
            On Error GoTo 0
            Exit Function
        End If
NotFound:
        CollectionContains = False
        On Error GoTo 0
        Exit Function
    ElseIf Not IsMissing(item) Then
        CollectionContains = False
        For Each var In Kollection
            If var = item Then
                CollectionContains = True
                Exit Function
            End If
        Next var
    Else
        CollectionContains = False
    End If
End Function

Public Function CollectionSort(colInput As Collection) As Collection
    Dim iCounter As Integer
    Dim iCounter2 As Integer
    Dim Temp As Variant
    Set CollectionSort = New Collection
    For iCounter = 1 To colInput.count - 1
        For iCounter2 = iCounter + 1 To colInput.count
            If colInput(iCounter) > colInput(iCounter2) Then
                Temp = colInput(iCounter2)
                colInput.Remove iCounter2
                colInput.Add Temp, , iCounter
            End If
        Next iCounter2
    Next iCounter
    Set CollectionSort = colInput
End Function

Function CollectionsToArray2D(collections As Collection) As Variant
    If collections.count = 0 Then Exit Function
    Dim columnCount As Long
    columnCount = collections.count
    Dim rowCount As Long
    rowCount = collections.item(1).count
    Dim var As Variant
    ReDim var(1 To rowCount, 1 To columnCount)
    Dim cols As Long
    Dim rows As Long
    For rows = 1 To rowCount
        For cols = 1 To collections.count
            var(rows, cols) = collections(cols).item(rows)
        Next cols
    Next rows
    CollectionsToArray2D = var
End Function




Function ComponentNames( _
                       ModuleType As vbext_ComponentType, _
                       Optional TargetWorkbook As Workbook)
    Dim coll As New Collection
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim Module As VBComponent
    For Each Module In TargetWorkbook.VBProject.VBComponents
        If Module.Type = ModuleType Then
            coll.Add Module.Name
        End If
    Next
    Set ComponentNames = coll
End Function

Function DeclarationsKeywordSubstring(str As Variant, Optional delim As String _
                , Optional afterWord As String _
                , Optional beforeWord As String _
                , Optional counter As Integer _
                , Optional outer As Boolean _
                , Optional includeWords As Boolean) As String
    Dim i As Long
    If afterWord = "" And beforeWord = "" And counter = 0 Then
        MsgBox ("Pass at least 1 parameter betweenn -AfterWord- , -BeforeWord- , -counter-")
        Exit Function
    End If
    If TypeName(str) = "String" Then
        If delim <> "" Then
            str = Split(str, delim)
            If UBound(str) <> 0 Then
                If afterWord = "" And beforeWord = "" And counter <> 0 Then
                    If counter - 1 <= UBound(str) Then
                        DeclarationsKeywordSubstring = str(counter - 1)
                        Exit Function
                    End If
                End If
                For i = LBound(str) To UBound(str)
                    If afterWord <> "" And beforeWord = "" Then
                        If i <> 0 Then
                            If str(i - 1) = afterWord Or str(i - 1) = "#" & afterWord Then
                                DeclarationsKeywordSubstring = str(i)
                                Exit Function
                            End If
                        End If
                    ElseIf afterWord = "" And beforeWord <> "" Then
                        If i <> UBound(str) Then
                            If str(i + 1) = beforeWord Or str(i + 1) = "#" & beforeWord Then
                                DeclarationsKeywordSubstring = str(i)
                                Exit Function
                            End If
                        End If
                    ElseIf afterWord <> "" And beforeWord <> "" Then
                        If i <> 0 And i <> UBound(str) Then
                            If (str(i - 1) = afterWord Or str(i - 1) = "#" & afterWord) And (str(i + 1) = beforeWord Or str(i + 1) = "#" & beforeWord) Then
                                DeclarationsKeywordSubstring = str(i)
                                Exit Function
                            End If
                        End If
                    End If
                Next i
            End If
        Else
            If InStr(1, str, afterWord) > 0 And InStr(1, str, beforeWord) > 0 Then
                If includeWords = False Then
                    DeclarationsKeywordSubstring = Mid(str, InStr(1, str, afterWord) + Len(afterWord))
                Else
                    DeclarationsKeywordSubstring = Mid(str, InStr(1, str, afterWord))
                End If
                If outer = True Then
                    If includeWords = False Then
                        DeclarationsKeywordSubstring = Left(DeclarationsKeywordSubstring, InStrRev(DeclarationsKeywordSubstring, beforeWord) - 1)
                    Else
                        DeclarationsKeywordSubstring = Left(DeclarationsKeywordSubstring, InStrRev(DeclarationsKeywordSubstring, beforeWord) + Len(beforeWord) - 1)
                    End If
                Else
                    If includeWords = False Then
                        DeclarationsKeywordSubstring = Left(DeclarationsKeywordSubstring, InStr(1, DeclarationsKeywordSubstring, beforeWord) - 1)
                    Else
                        DeclarationsKeywordSubstring = Left(DeclarationsKeywordSubstring, InStr(1, DeclarationsKeywordSubstring, beforeWord) + Len(beforeWord) - 1)
                    End If
                End If
                Exit Function
            End If
        End If
    Else
    End If
    DeclarationsKeywordSubstring = vbNullString
End Function

Sub DeclarationsTableCreate(TargetWorkbook As Workbook)

    DeclarationsWorksheetCreate
    
    Dim TargetWorksheet As Worksheet
    Set TargetWorksheet = ThisWorkbook.Sheets("Declarations_Table")
    If Format(Now, "YYMMDDHHNN") - TargetWorksheet.Range("Z1").Value < 60 Then Exit Sub
    
    TargetWorksheet.Range("A2").CurrentRegion.offset(1).Clear
    ArrayToRange2D CollectionsToArray2D( _
                        getDeclarations( _
                            WB:=TargetWorkbook, _
                            includeScope:=True, _
                            includeType:=True, _
                            includeKeywords:=True, _
                            includeDeclarations:=True, _
                            includeComponentName:=True, _
                            includeComponentType:=True)), _
                    TargetWorksheet.Range("A2")
                                        
    TargetWorksheet.Range("Z1").Value = Format(Now, "YYMMDDHHNN")
    
    DeclarationsTableSort
End Sub


Function DeclarationsTableKeywords() As Collection
    Dim TargetWorksheet As Worksheet
    Set TargetWorksheet = ThisWorkbook.Sheets("Declarations_Table")
    Dim Lr As Long: Lr = getLastRow(TargetWorksheet)
    Dim coll As New Collection
    Dim cell As Range
    For Each cell In TargetWorksheet.Range("C2:C" & Lr)
        On Error Resume Next
        coll.Add cell.text, cell.text
        On Error GoTo 0
    Next
    Set DeclarationsTableKeywords = coll
End Function


Sub DeclarationsTableSort()

    Dim TargetWorksheet As Worksheet
    Set TargetWorksheet = ThisWorkbook.Worksheets("Declarations_Table")
    
    Dim sort1 As String: sort1 = "B1"
    Dim sort2 As String: sort2 = "C1"
    Dim sort3 As String ': sort3 = "D1"

    With TargetWorksheet.Sort
        .SortFields.Clear
        .SortFields.Add Key:=TargetWorksheet.Range(sort1), Order:=xlAscending
        
        If Not sort2 = "" Then
            .SortFields.Add Key:=TargetWorksheet.Range(sort2), Order:=xlAscending
        End If
        If Not sort3 = "" Then
            .SortFields.Add Key:=TargetWorksheet.Range(sort3), Order:=xlAscending
        End If

        .SetRange TargetWorksheet.Range("A1").CurrentRegion
        .Header = xlYes
        .Apply
    End With
    
End Sub



Function DeclarationsWorksheetCreate() As Boolean
    If WorksheetExists("Declarations_Table", ThisWorkbook) Then Exit Function
    Dim TargetWorksheet As Worksheet
    Set TargetWorksheet = ThisWorkbook.Sheets.Add
    With TargetWorksheet
        .Name = "Declarations_Table"
        .Cells.VerticalAlignment = xlVAlignTop
        .Range("A1:F1").Value = Split("SCOPE,TYPE,NAME,CODE,MODULE TYPE,MODULE NAME", ",")
        .rows(1).Cells.Font.Bold = True
        .rows(1).Cells.Font.Size = 14
    End With
End Function

Sub ExportLinkedDeclaration(TargetWorkbook As Workbook, DeclarationName As String)
    DeclarationsTableCreate TargetWorkbook
    Dim TargetWorksheet As Worksheet
    Set TargetWorksheet = ThisWorkbook.Sheets("Declarations_Table")

    Dim codeName As String
    Dim codeText As String
    Dim cell As Range
    On Error Resume Next
    Set cell = TargetWorksheet.Columns(3).Find(DeclarationName, LookAt:=xlWhole)
    On Error GoTo 0
    If cell Is Nothing Then Exit Sub

    codeName = DeclarationName
    codeText = cell.offset(0, 1).text
    TxtOverwrite LOCAL_LIBRARY_DECLARATIONS & DeclarationName & ".txt", codeText

End Sub



Sub ExportProcedure( _
                    Optional TargetWorkbook As Workbook, _
                    Optional Module As VBComponent, _
                    Optional ProcedureName As String, _
                    Optional ExportMergedTxt As Boolean)

    If Not AssignCPSvariables(TargetWorkbook, Module, ProcedureName) Then Exit Sub

    ProjetFoldersCreate

    Dim ExportedProcedures As New Collection
    On Error GoTo ErrorHandler

    ExportedProcedures.Add CStr(ProcedureName), CStr(ProcedureName)

    Dim Procedure
    For Each Procedure In LinkedProceduresDeep(ProcedureName, TargetWorkbook)
        ExportedProcedures.Add CStr(Procedure), CStr(Procedure)
    Next

    If ExportedProcedures.count > 1 Then
        For Each Procedure In ExportedProcedures
            ExportTargetProcedure TargetWorkbook, , CStr(Procedure)
        Next
        If ExportMergedTxt Then
            Dim MergedName As String:   MergedName = "Merged_" & ProcedureName
            Dim fileName As String:     fileName = LOCAL_LIBRARY_PROCEDURES & MergedName & ".txt"
            Dim MergedString As String
    
            For Each Procedure In ExportedProcedures
                MergedString = MergedString & vbNewLine & ProcedureCode(TargetWorkbook, , Procedure)
            Next
            Debug.Print "OVERWROTE " & MergedName
            TxtOverwrite fileName, MergedString
            TxtPrependContainedProcedures fileName
        End If
    End If
    
    FollowLink LOCAL_LIBRARY_PROCEDURES
    
    Exit Sub
ErrorHandler:
    MsgBox "An error occured in Sub ExportProcedure"
End Sub

Sub ExportTargetProcedure( _
        Optional TargetWorkbook As Workbook, _
        Optional Module As VBComponent, _
        Optional Procedure As String)

    If Not AssignCPSvariables(TargetWorkbook, Module, Procedure) Then Exit Sub

    Dim proclastmod
        proclastmod = ProcedureLastModified(TargetWorkbook, Module, Procedure)
    If proclastmod = 0 Then
        AddLinkedLists TargetWorkbook, Module, Procedure
        proclastmod = ProcedureLastModAdd(TargetWorkbook, Module, Procedure)
    End If

    Dim Code As String
        Code = ProcedureCode(TargetWorkbook, Module, CStr(Procedure))
    Dim FileFullName As String
        FileFullName = LOCAL_LIBRARY_PROCEDURES & Procedure & ".txt"
    If FileExists(FileFullName) Then
        Dim filelastmod
            filelastmod = StringLastModified(TxtRead(FileFullName))
        If proclastmod > filelastmod Then
            Debug.Print "OVERWROTE " & Procedure
            TxtOverwrite FileFullName, Code
        End If
    Else
        Debug.Print "NEW " & Procedure
        TxtOverwrite FileFullName, Code
    End If

    Dim element
    For Each element In LinkedUserforms(TargetWorkbook, Module, CStr(Procedure))
        TargetWorkbook.VBProject.VBComponents(element).Export LOCAL_LIBRARY_USERFORMS & element & ".frm"
    Next
    For Each element In LinkedClasses(TargetWorkbook, Module, CStr(Procedure))
        TargetWorkbook.VBProject.VBComponents(element).Export LOCAL_LIBRARY_CLASSES & element & ".cls"
    Next
    For Each element In LinkedDeclarations(TargetWorkbook, Module, CStr(Procedure))
        ExportLinkedDeclaration TargetWorkbook, CStr(element)
    Next
End Sub

Public Function FileExists(ByVal fileName As String) As Boolean
    If InStr(1, fileName, "\") = 0 Then Exit Function
    If Right(fileName, 1) = "\" Then fileName = Left(fileName, Len(fileName) - 1)
    FileExists = (Dir(fileName, vbArchive + vbHidden + vbReadOnly + vbSystem) <> "")
End Function

Function FolderExists(ByVal strPath As String) As Boolean
    On Error Resume Next
    FolderExists = ((GetAttr(strPath) And vbDirectory) = vbDirectory)
End Function

Sub FoldersCreate(FolderPath As String)
    On Error Resume Next
    Dim individualFolders() As String
    Dim tempFolderPath As String
    Dim ArrayElement As Variant
    individualFolders = Split(FolderPath, "\")
    For Each ArrayElement In individualFolders
        tempFolderPath = tempFolderPath & ArrayElement & "\"
        If FolderExists(tempFolderPath) = False Then
            MkDir tempFolderPath
        End If
    Next ArrayElement
End Sub

Sub FollowLink(FolderPath As String)
    If Right(FolderPath, 1) = "\" Then FolderPath = Left(FolderPath, Len(FolderPath) - 1)
    On Error Resume Next
    Dim oShell As Object
    Dim Wnd As Object
    Set oShell = CreateObject("Shell.Application")
    For Each Wnd In oShell.Windows
        If Wnd.Name = "File Explorer" Then
            If Wnd.document.Folder.Self.Path = FolderPath Then Exit Sub
        End If
    Next Wnd
    Application.ThisWorkbook.FollowHyperlink Address:=FolderPath, NewWindow:=True
End Sub

Function FormatVBA7(str As String) As String
    Dim selectedText
        selectedText = str
        selectedText = Replace(selectedText, " _" & vbNewLine, "")
        selectedText = Split(selectedText, vbNewLine)
    Dim IsVba7 As String
    Dim NotVba7 As String
    Dim colIsVBA7 As New Collection
    Dim colNotVBA7 As New Collection
    Dim i As Long
    For i = LBound(selectedText) To UBound(selectedText)
        If InStr(1, selectedText(i), "PtrSafe", vbTextCompare) Then
            IsVba7 = selectedText(i)
            NotVba7 = Replace(selectedText(i), "Declare ptrsafe ", "Declare ", , , vbTextCompare)
        Else
            IsVba7 = Replace(selectedText(i), "Declare ", "Declare PtrSafe ")
            NotVba7 = selectedText(i)
        End If
        colIsVBA7.Add IsVba7
        colNotVBA7.Add NotVba7
    Next
    Set colIsVBA7 = CollectionSort(colIsVBA7)
    Set colNotVBA7 = CollectionSort(colNotVBA7)
    Dim out As String
        out = "#If VBA7 then" & vbNewLine & _
        collectionToString(colIsVBA7, vbNewLine) & vbNewLine & _
        "#Else" & vbNewLine & _
        collectionToString(colNotVBA7, vbNewLine) & vbNewLine & _
        "#End If"
    FormatVBA7 = out

End Function

Function GetMotherBoardProp() As String

    Dim strComputer As String
    Dim objSvcs As Object
    Dim objItms As Object, objItm As Object
    Dim vItem
    strComputer = "."
    Set objSvcs = GetObject("winmgmts:\\" & strComputer & "\root\cimv2")
    Set objItms = objSvcs.execquery("Select * from Win32_BaseBoard")
    For Each objItm In objItms
        GetMotherBoardProp = objItm.SerialNumber
    Next

    Set objSvcs = Nothing
End Function

Public Function GetSheetByCodeName(WB As Workbook, codeName As String) As Worksheet
    Dim sh As Worksheet
    For Each sh In WB.Worksheets
        If UCase(sh.codeName) = UCase(codeName) Then Set GetSheetByCodeName = sh: Exit For
    Next sh
End Function

Sub ImportClass( _
                    Optional ClassName As String, _
                    Optional TargetWorkbook As Workbook, _
                    Optional Overwrite As Boolean)

    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    If ClassName = "" Then ClassName = CodepaneSelection
    If ClassName = "" Or InStr(1, ClassName, " ") > 0 Then Exit Sub
    Dim filepath As String
    filepath = LOCAL_LIBRARY_CLASSES & ClassName & ".cls"
    If CheckPath(filepath) = "I" Then
        On Error Resume Next
        Dim Code As String
        Code = TXTReadFromUrl(GITHUB_LIBRARY_CLASSES & ClassName & ".cls")
        On Error GoTo 0
        If Len(Code) > 0 And Not UCase(Code) Like ("*NOT FOUND*") Then
            TxtOverwrite filepath, Code
        Else
            MsgBox "File " & ClassName & ".cls not found neither localy nor online"
            Exit Sub
        End If
    End If

    If ModuleExists(ClassName, TargetWorkbook) Then
        If Overwrite = True Then
            TargetWorkbook.VBProject.VBComponents.Remove TargetWorkbook.VBProject.VBComponents(ClassName)
        Else
            Exit Sub
        End If
    End If
    TargetWorkbook.VBProject.VBComponents.Import filepath
End Sub


Sub ImportDeclaration( _
                        Optional DeclarationName As String, _
                        Optional Module As VBComponent, _
                        Optional TargetWorkbook As Workbook)

    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    If DeclarationName = "" Then DeclarationName = CodepaneSelection
    If DeclarationName = "" Or InStr(1, DeclarationName, " ") > 0 Then Exit Sub
    Dim filepath As String
    filepath = LOCAL_LIBRARY_DECLARATIONS & DeclarationName & ".txt"
    Dim Code As String
    On Error Resume Next
    Code = TxtRead(filepath)
    On Error GoTo 0

    If Len(Code) = 0 Then 'CheckPath(filePath) = "I" Then
        On Error Resume Next
        Code = TXTReadFromUrl(GITHUB_LIBRARY_DECLARATIONS & DeclarationName & ".txt")
        On Error GoTo 0
        If Len(Code) > 0 And Not UCase(Code) Like ("*NOT FOUND*") Then
            Code = FormatVBA7(Code)
            TxtOverwrite filepath, Code
        Else
            Debug.Print "File " & DeclarationName & ".txt not found localy or online"
            Exit Sub
        End If
    Else

    End If
    If InStr(1, WorkbookCode(TargetWorkbook), Code, vbTextCompare) > 0 Then Exit Sub
    If Module Is Nothing Then Set Module = ModuleAddOrSet(TargetWorkbook, "vbArcImports", vbext_ct_StdModule)
    Module.CodeModule.AddFromString Code

End Sub

Sub ImportProcedure( _
                    Optional Procedure As String, _
                    Optional TargetWorkbook As Workbook, _
                    Optional Module As VBComponent, _
                    Optional Overwrite As Boolean)

    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    If Procedure = "" Then Procedure = CodepaneSelection
    If Procedure = "" Or InStr(1, Procedure, " ") > 0 Then Exit Sub
    Dim ProcedurePath As String
        ProcedurePath = LOCAL_LIBRARY_PROCEDURES & Procedure & ".txt"

    Dim Code As String
    On Error Resume Next
    Code = TxtRead(ProcedurePath)
    On Error GoTo 0

    If Len(Code) = 0 Then
        On Error Resume Next
        Code = TXTReadFromUrl(GITHUB_LIBRARY_PROCEDURES & Procedure & ".txt")
        On Error GoTo 0
        If Len(Code) > 0 And Not UCase(Code) Like ("*NOT FOUND*") Then
            TxtOverwrite ProcedurePath, Code
        Else
            Debug.Print "File " & Procedure & ".txt not found neither localy nor online"
            Exit Sub
        End If
    End If

    Dim filelastmod
        filelastmod = StringLastModified(Code)
    Dim proclastmod

    If ProcedureExists(TargetWorkbook, Procedure) = True Then
        Set Module = ModuleOfProcedure(TargetWorkbook, Procedure)
        proclastmod = ProcedureLastModified(TargetWorkbook, Module, Procedure)
        If Overwrite = True Then
            If proclastmod = 0 Or proclastmod < filelastmod Then
                ProcedureReplace Module, Procedure, TxtRead(ProcedurePath)
            End If
        End If
    Else
        If Module Is Nothing Then
'            Dim ModuleName As String
'                ModuleName = StringProcedureAssignedModule(Code)
'            If ModuleName = "" Then ModuleName = "vbArcImports"
'            Set Module = ModuleAddOrSet(TargetWorkbook, ModuleName, vbext_ct_StdModule)
            Set Module = ModuleAddOrSet(TargetWorkbook, "vbArcImports", vbext_ct_StdModule)
        End If
        Module.CodeModule.AddFromFile ProcedurePath
    End If

    ImportProcedureDependencies Procedure, TargetWorkbook, Module, Overwrite
'    ProcedureMoveToAssignedModule TargetWorkbook, Module, Procedure
End Sub

Sub ImportProcedureDependencies( _
                 Optional Procedure As String, _
                 Optional TargetWorkbook As Workbook, _
                 Optional Module As VBComponent, _
                 Optional Overwrite As Boolean)

    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    If Procedure = "" Then
        Dim cps As String
        cps = CodepaneSelection
        If Len(cps) > 0 Then
            Procedure = cps
        Else
            Procedure = ActiveProcedure
        End If
        If Not ProcedureExists(TargetWorkbook, Procedure) Then Exit Sub
    End If
    On Error Resume Next
    If Module Is Nothing Then Set Module = ModuleOfProcedure(TargetWorkbook, Procedure)
    If Module Is Nothing Then Exit Sub
    On Error GoTo 0
    Dim var
    Dim importfile As String
    var = Split(ProcedureCode(TargetWorkbook, Module, Procedure), vbNewLine)
    var = Filter(var, "'@INCLUDE ")
    Dim TextLine As Variant
    For Each TextLine In var
        TextLine = Trim(TextLine)
        If TextLine Like "'@INCLUDE *" Then
            importfile = Split(TextLine, " ")(2)
            importfile = Replace(importfile, vbNewLine, "")
            If TextLine Like "'@INCLUDE PROCEDURE *" Then
                ImportProcedure importfile, TargetWorkbook, Module, Overwrite
            ElseIf TextLine Like "'@INCLUDE CLASS *" Then
                ImportClass importfile, TargetWorkbook, Overwrite
            ElseIf TextLine Like "'@INCLUDE USERFORM *" Then
                ImportUserform importfile, TargetWorkbook, Overwrite
            ElseIf TextLine Like "'@INCLUDE DECLARATION *" Then
                ImportDeclaration importfile, Module, TargetWorkbook
            End If
        End If
    Next
End Sub

Sub ImportUserform( _
                    Optional UserformName As String, _
                    Optional TargetWorkbook As Workbook, _
                    Optional Overwrite As Boolean)
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    If UserformName = "" Then UserformName = CodepaneSelection
    If UserformName = "" Or InStr(1, UserformName, " ") > 0 Then Exit Sub
    Dim FilePathFrM As String
        FilePathFrM = LOCAL_LIBRARY_USERFORMS & UserformName & ".frm"
    Dim FilePathFrX As String
        FilePathFrX = LOCAL_LIBRARY_USERFORMS & UserformName & ".frx"

    If CheckPath(FilePathFrM) = "I" Then
        On Error Resume Next
        Dim codeFrM As String
            codeFrM = TXTReadFromUrl(GITHUB_LIBRARY_USERFORMS & UserformName & ".frm")
        Dim codeFrX As String
            codeFrX = TXTReadFromUrl(GITHUB_LIBRARY_USERFORMS & UserformName & ".frx")
        On Error GoTo 0
        If Len(codeFrM) > 0 And Len(codeFrX) > 0 Then
            TxtOverwrite FilePathFrM, codeFrM
            TxtOverwrite FilePathFrX, codeFrX
        Else
            MsgBox "File " & UserformName & ".frm/.frx not found neither localy nor online"
            Exit Sub
        End If
    End If

    If ModuleExists(UserformName, TargetWorkbook) Then
        If Overwrite = True Then
            TargetWorkbook.VBProject.VBComponents.Remove TargetWorkbook.VBProject.VBComponents(UserformName)
        Else
            Exit Sub
        End If
    End If
    TargetWorkbook.VBProject.VBComponents.Import FilePathFrM
End Sub

Function LastCell(rng As Range, Optional booCol As Boolean) As Range
    Dim ws As Worksheet
    Set ws = rng.Parent
    Dim cell As Range
    If booCol = False Then
        Set cell = ws.Cells(rows.count, rng.Column).End(xlUp)
        If cell.MergeCells Then Set cell = Cells(cell.row + cell.rows.count - 1, cell.Column)
    Else
        Set cell = ws.Cells(rng.row, Columns.count).End(xlToLeft)
        If cell.MergeCells Then Set cell = Cells(cell.row, cell.Column + cell.Columns.count - 1)
    End If

    Set LastCell = cell
End Function

Public Function Len2( _
    ByVal val As Variant) _
    As Integer
    If IsArray(val) And Right(TypeName(val), 2) = "()" Then
        Len2 = UBound(val) - LBound(val) + 1
    ElseIf TypeName(val) = "String" Then
        Len2 = Len(val)
    ElseIf IsNumeric(val) Then
        Len2 = Len(CStr(val))
    Else
        Len2 = val.count
    End If
End Function




Function LinkedClasses( _
                      TargetWorkbook As Workbook, _
                      Module As VBComponent, _
                      Procedure As String) As Collection

    Dim coll As New Collection
    Dim var As Variant
        var = classCallsOfModule(Module)
    Dim Code As String
        Code = ProcedureCode(TargetWorkbook, Module, Procedure)
    Dim Keyword As String
    Dim ClassName As String
    Dim element As Variant
    Dim i As Long
    On Error Resume Next
    For i = LBound(var, 1) To UBound(var, 1)
        If InStr(1, Code, var(i, 1)) > 0 Or InStr(1, Code, var(i, 2)) > 0 Then
            coll.Add var(i, 1), var(i, 1)
        End If
    Next
    For Each element In ClassNames
        If InStr(1, Code, element) > 0 Then
            coll.Add element, CStr(element)
        End If
    Next
    On Error GoTo 0
    Set LinkedClasses = coll
End Function

Function LinkedDeclarations( _
                           Optional TargetWorkbook As Workbook, _
                           Optional Module As VBComponent, _
                           Optional Procedure As String) As Collection

    If Not AssignCPSvariables(TargetWorkbook, Module, Procedure) Then Stop
    
    DeclarationsTableCreate TargetWorkbook
    
    Dim TargetWorksheet As Worksheet: Set TargetWorksheet = ThisWorkbook.Sheets("Declarations_Table")
    Dim coll As New Collection
    Dim Code As String: Code = ProcedureCode(TargetWorkbook, Module, Procedure)
    Dim element
    For Each element In DeclarationsTableKeywords
        If RegexTest(Code, "\b ?" & CStr(element) & "\b") Then
            On Error Resume Next
            coll.Add CStr(element), CStr(element)
            On Error GoTo 0
        End If
    Next
    Set LinkedDeclarations = coll
End Function

Function LinkedProcedures( _
                         Optional TargetWorkbook As Workbook, _
                         Optional Module As VBComponent, _
                         Optional ProcedureName As String) As Collection
    If Not AssignCPSvariables(TargetWorkbook, Module, ProcedureName) Then Stop
    Dim Procedures As Collection
    Set Procedures = ProceduresOfWorkbook(TargetWorkbook)
    Dim Code As String
        Code = ProcedureCode(TargetWorkbook, Module, ProcedureName)
    Dim coll As New Collection
    Dim Procedure As Variant
    For Each Procedure In Procedures
        If UCase(CStr(Procedure)) <> UCase(CStr(ProcedureName)) Then
            If RegexTest(Code, "\W" & CStr(Procedure) & "[.(\W]") = True Then
                coll.Add Procedure, CStr(Procedure)
            End If
        End If
    Next
    Set LinkedProcedures = coll
End Function

Function LinkedProceduresDeep( _
                             ProcedureName As Variant, _
                             TargetWorkbook As Workbook) As Collection

    Dim AllProcedures As Collection:       Set AllProcedures = ProceduresOfWorkbook(TargetWorkbook)
    Dim Processed As Collection:           Set Processed = New Collection
    Dim CalledProcedures As Collection:    Set CalledProcedures = New Collection

    Dim Procedure As Variant
    Dim Module As VBComponent

    Processed.Add CStr(ProcedureName), CStr(ProcedureName)
    On Error Resume Next
    For Each Procedure In LinkedProcedures(TargetWorkbook, , CStr(ProcedureName))
    CalledProcedures.Add CStr(Procedure), CStr(Procedure)
    Next
    On Error GoTo 0

    Dim CalledProceduresCount As Long
        CalledProceduresCount = CalledProcedures.count
    Dim element
repeat:
    For Each element In CalledProcedures
        If Not CollectionContains(Processed, , CStr(element)) Then
            On Error Resume Next
            For Each Procedure In LinkedProcedures(TargetWorkbook, , CStr(element))
            CalledProcedures.Add CStr(Procedure), CStr(Procedure)
            Next
            On Error GoTo 0
            Processed.Add CStr(element), CStr(element)
        End If
    Next
    If CalledProcedures.count > CalledProceduresCount Then
        CalledProceduresCount = CalledProcedures.count
        GoTo repeat
    End If

    Set LinkedProceduresDeep = CollectionSort(CalledProcedures)
End Function


Sub LinkedProceduresMoveHere(Optional Procedure As String)
    Dim TargetWorkbook As Workbook
    Set TargetWorkbook = ActiveCodepaneWorkbook
    If Not AssignProcedureVariable(TargetWorkbook, Procedure) Then Exit Sub
    Dim el
    For Each el In LinkedProceduresDeep(Procedure, TargetWorkbook)
        ProcedureMoveHere CStr(el)
    Next
End Sub




Function LinkedUserforms( _
                        TargetWorkbook As Workbook, _
                        Module As VBComponent, _
                        Procedure As String) As Collection
    Dim coll As New Collection
    Dim Code As String
        Code = ProcedureCode(TargetWorkbook, Module, Procedure)
    Dim formName
    For Each formName In UserformNames(TargetWorkbook)
        If RegexTest(Code, "\W" & formName & "[.(\W]") = True Then coll.Add formName '& " " & "(Userform)"
    Next
    Set LinkedUserforms = coll
End Function

Function ModuleAddOrSet( _
                       TargetWorkbook As Workbook, _
                       TargetName As String, _
                       ModuleType As VBIDE.vbext_ComponentType) As VBComponent


    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim Module As VBComponent
    On Error Resume Next
    Set Module = TargetWorkbook.VBProject.VBComponents(TargetName)
    On Error GoTo 0
    If Module Is Nothing Then
        Set Module = TargetWorkbook.VBProject.VBComponents.Add(ModuleType)
        Module.Name = TargetName
    End If
    Set ModuleAddOrSet = Module
End Function




Function ModuleCode(Module As VBComponent) As String
    With Module.CodeModule
        If .CountOfLines = 0 Then ModuleCode = "": Exit Function
        ModuleCode = .Lines(1, .CountOfLines)
    End With
End Function

Public Function ModuleExists( _
                            TargetName As String, _
                            TargetWorkbook As Workbook) As Boolean
    Dim Module As VBComponent
    On Error Resume Next
    Set Module = TargetWorkbook.VBProject.VBComponents(TargetName)
    On Error GoTo 0
    ModuleExists = Not Module Is Nothing
End Function

Public Function ModuleOfProcedure( _
                                 TargetWorkbook As Workbook, _
                                 ProcedureName As Variant) As VBComponent
    Dim ProcKind As VBIDE.vbext_ProcKind
    Dim lineNum As Long, NumProc As Long
    Dim Procedure As String
    Dim Module As VBComponent
    For Each Module In TargetWorkbook.VBProject.VBComponents
        With Module.CodeModule
            lineNum = .CountOfDeclarationLines + 1
            Do Until lineNum >= .CountOfLines
                Procedure = .ProcOfLine(lineNum, ProcKind)
                If UCase(Procedure) = UCase(ProcedureName) Then
                    Set ModuleOfProcedure = Module
                    Exit Function
                End If
                lineNum = .procStartLine(Procedure, ProcKind) + .ProcCountLines(Procedure, ProcKind) + 1
            Loop
        End With
    Next Module
End Function

Function ModuleOrSheetName(Module As VBComponent) As String
    If Module.Type = vbext_ct_Document Then
        If Module.Name = "ThisWorkbook" Then
            ModuleOrSheetName = Module.Name
        Else
            ModuleOrSheetName = GetSheetByCodeName(WorkbookOfModule(Module), Module.Name).Name
        End If
    Else
        moduleName = Module.Name
    End If
End Function

Function ModuleTypeToString(componentType As VBIDE.vbext_ComponentType) As String
    Select Case componentType
    Case vbext_ct_ActiveXDesigner
        ModuleTypeToString = "ActiveX Designer"
    Case vbext_ct_ClassModule
        ModuleTypeToString = "Class"
    Case vbext_ct_Document
        ModuleTypeToString = "Document"
    Case vbext_ct_MSForm
        ModuleTypeToString = "UserForm"
    Case vbext_ct_StdModule
        ModuleTypeToString = "Module"
    Case Else
        ModuleTypeToString = "Unknown Type: " & CStr(componentType)
    End Select
End Function

Function ProcedureAssignedModule( _
                                TargetWorkbook As Workbook, _
                                Module As VBComponent, _
                                Procedure As String) As VBComponent
        Dim ComponentName As Variant
        ComponentName = Split(ProcedureCode(TargetWorkbook, Module, Procedure), vbNewLine)
        ComponentName = Filter(ComponentName, "'@AssignedModule")
        If Len2(ComponentName) <> 1 Then Exit Function
        Dim UB As Long
        UB = UBound(Split(ComponentName(0), " "))
        ComponentName = Split(ComponentName(0), " ")(UB)
        Set ProcedureAssignedModule = ModuleAddOrSet(TargetWorkbook, CStr(ComponentName), vbext_ct_StdModule)
End Function

Sub ProcedureAssignedModuleAdd( _
                                Optional TargetWorkbook As Workbook, _
                                Optional Module As VBComponent, _
                                Optional Procedure As String)
    If Not AssignCPSvariables(TargetWorkbook, Module, Procedure) Then Stop
    ProcedureLinesRemove "'@AssignedModule *", TargetWorkbook, Module, Procedure
    Module.CodeModule.InsertLines ProcedureBodyLineFirstAfterComments(Module, Procedure), _
                                  "'@AssignedModule " & Module.Name
End Sub

Function ProcedureBodyLineFirst( _
                               Module As VBComponent, _
                               Procedure As String) As Long
    ProcedureBodyLineFirst = ProcedureTitleLineFirst(Module, Procedure) + ProcedureTitleLineCount(Module, Procedure)
End Function

Function ProcedureBodyLineFirstAfterComments( _
                                            Module As VBComponent, _
                                            Procedure As String) As Long
    Dim N As Long
    Dim s As String
    For N = ProcedureBodyLineFirst(Module, Procedure) To Module.CodeModule.CountOfLines
        s = Trim(Module.CodeModule.Lines(N, 1))
        If s = vbNullString Then
            Exit For
        ElseIf Left(s, 1) = "'" Then
        ElseIf Left(s, 3) = "Rem" Then
        ElseIf Right(Trim(Module.CodeModule.Lines(N - 1, 1)), 1) = "_" Then
        ElseIf Right(s, 1) = "_" Then
        Else
            Exit For
        End If
    Next N
    ProcedureBodyLineFirstAfterComments = N
End Function



Public Function ProcedureCode( _
                             Optional TargetWorkbook As Workbook, _
                             Optional Module As VBComponent, _
                             Optional Procedure As Variant, _
                             Optional IncludeHeader As Boolean = True) As String
    If Not AssignCPSvariables(TargetWorkbook, Module, CStr(Procedure)) Then Exit Function
    Dim lProcStart            As Long
    Dim lProcBodyStart        As Long
    Dim lProcNoLines          As Long
    Const vbext_pk_Proc = 0
    On Error GoTo Error_Handler
    lProcStart = Module.CodeModule.procStartLine(Procedure, vbext_pk_Proc)
    lProcBodyStart = Module.CodeModule.ProcBodyLine(Procedure, vbext_pk_Proc)
    lProcNoLines = Module.CodeModule.ProcCountLines(Procedure, vbext_pk_Proc)
    If IncludeHeader = True Then
        ProcedureCode = Module.CodeModule.Lines(lProcStart, lProcNoLines)
    Else
        lProcNoLines = lProcNoLines - (lProcBodyStart - lProcStart)
        ProcedureCode = Module.CodeModule.Lines(lProcBodyStart, lProcNoLines)
    End If
Error_Handler_Exit:
    On Error Resume Next
    Exit Function
Error_Handler:
    Debug.Print "Error Source: ProcedureCode" & vbCrLf & _
    "Error Description: " & Err.Description & _
    Switch(Erl = 0, vbNullString, Erl <> 0, vbCrLf & "Line No: " & Erl)
    Resume Error_Handler_Exit
End Function

Function ProcedureExists( _
                        TargetWorkbook As Workbook, _
                        ProcedureName As Variant) As Boolean
    Dim Procedures As Collection
    Set Procedures = ProceduresOfWorkbook(TargetWorkbook)
    Dim Procedure As Variant
    For Each Procedure In Procedures
        If UCase(CStr(Procedure)) = UCase(ProcedureName) Then
            ProcedureExists = True
            Exit Function
        End If
    Next
End Function

Function ProcedureLastModAdd( _
                            Optional TargetWorkbook As Workbook, _
                            Optional Module As VBComponent, _
                            Optional Procedure As String, _
                            Optional ModificationDate As Double)
                       


If Not AssignCPSvariables(TargetWorkbook, Module, Procedure) Then Exit Function
    If ModificationDate = 0 Then ModificationDate = Format(Now, "yymmddhhnn")
    Dim LastModLine As Long
        LastModLine = ProcedureLineContaining(Module, Procedure, "'@LastModified *")
    If LastModLine = 0 Then GoTo PASS
    Dim LDate As Double
        LDate = Split(Module.CodeModule.Lines(LastModLine, 1), " ")(1)
    ProcedureLinesRemove "'@LastModified *", TargetWorkbook, Module, Procedure
PASS:
    Module.CodeModule.InsertLines ProcedureBodyLineFirst(Module, Procedure), _
                                  "'@LastModified " & ModificationDate
    
    ProcedureLastModAdd = ModificationDate
End Function

Function ProcedureLastModified( _
                            Optional TargetWorkbook As Workbook, _
                            Optional Module As VBComponent, _
                            Optional Procedure As String)
    If Not AssignCPSvariables(TargetWorkbook, Module, Procedure) Then Stop
    ProcedureLastModified = StringLastModified(ProcedureCode(TargetWorkbook, Module, Procedure))
End Function

Function ProcedureLinesCount( _
                            Module As VBComponent, _
                            Procedure As String) As Long
    ProcedureLinesCount = Module.CodeModule.ProcCountLines(Procedure, vbext_pk_Proc)
End Function

Public Function ProcedureLinesFirst( _
                                   Module As VBComponent, _
                                   Procedure As String) As Long
    Dim ProcKind As VBIDE.vbext_ProcKind
        ProcKind = vbext_pk_Proc
    ProcedureLinesFirst = Module.CodeModule.procStartLine(Procedure, ProcKind)
End Function


Public Function ProcedureLinesLast( _
                                  Module As VBComponent, _
                                  Procedure As String, _
                                  Optional IncludeTail As Boolean) As Long
    Dim ProcKind As VBIDE.vbext_ProcKind
        ProcKind = vbext_pk_Proc
    Dim startAt As Long
        startAt = Module.CodeModule.procStartLine(Procedure, ProcKind)
    Dim CountOf As Long
        CountOf = Module.CodeModule.ProcCountLines(Procedure, ProcKind)
    Dim endAt As Long
        endAt = startAt + CountOf - 1
    If Not IncludeTail Then
        Do While Not Trim(Module.CodeModule.Lines(endAt, 1)) Like "End *"
            endAt = endAt - 1
        Loop
    End If
    ProcedureLinesLast = endAt
End Function

Sub ProcedureLinesRemove( _
                        myCriteria As String, _
                        Optional TargetWorkbook As Workbook, _
                        Optional Module As VBComponent, _
                        Optional Procedure As String)
    If Not AssignCPSvariables(TargetWorkbook, Module, Procedure) Then Stop

    Dim Code As String
    Dim i As Long
    For i = ProcedureLinesLast(Module, Procedure) To ProcedureLinesFirst(Module, Procedure) Step -1
        Code = Trim(Module.CodeModule.Lines(i, 1))
        If Code Like myCriteria Then Module.CodeModule.DeleteLines i
    Next
End Sub

Sub ProcedureLinesRemoveInclude( _
                                Optional TargetWorkbook As Workbook, _
                                Optional Module As VBComponent, _
                                Optional Procedure As String)
    If Not AssignCPSvariables(TargetWorkbook, Module, Procedure) Then Stop
    ProcedureLinesRemove "'@INCLUDE", TargetWorkbook, Module, Procedure
End Sub


Sub ProcedureMoveHere( _
                     Optional Procedure As String)

    
    Dim TargetWorkbook As Workbook
    Set TargetWorkbook = ActiveCodepaneWorkbook
    If Not AssignProcedureVariable(TargetWorkbook, Procedure) Then Exit Sub
    Dim Module As VBComponent
    Set Module = ModuleOfProcedure(TargetWorkbook, Procedure)
    Dim s As String
        s = ProcedureCode(TargetWorkbook, Module, Procedure)

        If InStr(1, s, "'@AssignedModule") = 0 Then
            ProcedureAssignedModuleAdd TargetWorkbook, Module, Procedure
            s = ProcedureCode(TargetWorkbook, Module, Procedure)
        End If

    Dim sl As Long, cl As Long
        sl = ProcedureLinesFirst(Module, Procedure)
        cl = ProcedureLinesLast(Module, Procedure, False) - sl + 1
    ActiveModule.CodeModule.InsertLines ProcedureLinesLast(Module, ActiveProcedure, True) + 1, s
    Module.CodeModule.DeleteLines sl, cl
End Sub

Sub ProcedureMoveToAssignedModule( _
                                 Optional TargetWorkbook As Workbook, _
                                 Optional Module As VBComponent, _
                                 Optional Procedure As String)
    If Not AssignCPSvariables(TargetWorkbook, Module, Procedure) Then Exit Sub
    Dim MoveToModule As VBComponent
    Set MoveToModule = ProcedureAssignedModule(TargetWorkbook, Module, Procedure)
    If MoveToModule Is Nothing Then Exit Sub
    ProcedureMoveToModule TargetWorkbook, Module, Procedure, MoveToModule
End Sub

Sub ProcedureMoveToModule( _
                         TargetWorkbook As Workbook, _
                         Module As VBComponent, _
                         Procedure As String, _
                         MoveToModule As VBComponent)
    Dim Code As String
        Code = ProcedureCode(TargetWorkbook, Module, Procedure)
    Dim startLine As Long
        startLine = ProcedureLinesFirst(Module, Procedure)
    Dim CountLines As Long
        CountLines = ProcedureLinesCount(Module, Procedure)
    MoveToModule.CodeModule.InsertLines MoveToModule.CodeModule.CountOfLines + 1, vbNewLine & Code
    Module.CodeModule.DeleteLines startLine, CountLines

End Sub

Public Sub ProcedureReplace( _
                            Module As VBComponent, _
                            Procedure As String, _
                            Code As String)

    Dim startLine As Integer
    Dim NumLines As Integer
    With Module.CodeModule
        startLine = .procStartLine(Procedure, vbext_pk_Proc)
        NumLines = .ProcCountLines(Procedure, vbext_pk_Proc)
        .DeleteLines startLine, NumLines
        .InsertLines startLine, Code
    End With
End Sub

Function ProcedureTitle( _
                       Module As VBComponent, _
                       Procedure As String) As String
    Dim titleLine As Long
        titleLine = ProcedureTitleLineFirst(Module, Procedure)
    Dim Title As String
        Title = Module.CodeModule.Lines(titleLine, 1)
    Dim counter As Long
        counter = 1
    Do While Right(Title, 1) = "_"
        counter = counter + 1
        Title = Module.CodeModule.Lines(titleLine, counter)
    Loop

    ProcedureTitle = Title
End Function

Function ProcedureTitleLineCount( _
                                Module As VBComponent, _
                                Procedure As String) As Long

    ProcedureTitleLineCount = ProcedureTitleLineLast(Module, Procedure) - ProcedureTitleLineFirst(Module, Procedure) + 1
End Function



Public Function ProcedureTitleLineFirst( _
                                       Module As VBComponent, _
                                       Procedure As String) As Long
    ProcedureTitleLineFirst = Module.CodeModule.ProcBodyLine(Procedure, vbext_pk_Proc)
End Function

Function ProcedureTitleLineLast( _
                               Module As VBComponent, _
                               Procedure As String) As Long
    ProcedureTitleLineLast = ProcedureTitleLineFirst(Module, Procedure) + UBound(Split(ProcedureTitle(Module, Procedure), vbNewLine))
End Function

Public Function ProceduresOfModule( _
                                  Module As VBComponent) As Collection
    Dim ProcKind As VBIDE.vbext_ProcKind
    Dim lineNum As Long
    Dim coll As New Collection
    Dim Procedure As String
    With Module.CodeModule
        lineNum = .CountOfDeclarationLines + 1
        Do Until lineNum >= .CountOfLines
            ProcedureAs = .ProcOfLine(lineNum, ProcKind)
            coll.Add ProcedureAs
            lineNum = .procStartLine(ProcedureAs, ProcKind) + .ProcCountLines(ProcedureAs, ProcKind) + 1
        Loop
    End With
    Set ProceduresOfModule = coll
End Function

Function ProceduresOfTXT( _
                        Code As String) As Collection


    Code = Replace(Code, vbNewLine, vbLf)
    Dim var
        var = Split(Code, vbLf)

    Dim out
        out = ArrayAppend(Filter(var, "Sub" & Space(1), True, vbBinaryCompare), Filter(var, "Function ", True, vbBinaryCompare))
    If TypeName(out) = "Empty" Then Exit Function
    out = Filter(out, "(", True)
    out = Filter(out, "Declare", False)
    out = Filter(out, Chr(34) & "Sub", False)
    out = Filter(out, Chr(34) & "Function", False)
    out = Filter(out, "End Sub", False)
    out = Filter(out, "End Function", False)

    Dim i As Long
    For i = LBound(out) To UBound(out)
        out(i) = Left(out(i), InStr(1, out(i), "(") - 1)
        out(i) = Replace(out(i), "Private ", "")
        out(i) = Replace(out(i), "Public ", "")
        out(i) = Replace(out(i), "Sub ", "")
        out(i) = Replace(out(i), "Function ", "")
        If UBound(Split(out(i), " ")) > 0 Then
            out(i) = ""
        End If
    Next

    ArrayQuickSort out
    out = cleanArray(out)
    out = ArrayDuplicatesRemove(out)
    Set ProceduresOfTXT = ArrayToCollection(out)
End Function

Sub CallSeparateProcedures()
    Dim filepath As Variant
    filepath = DataFilePicker("*.txt", False)
    If filepath = vbNullString Then Exit Sub
    Dim OutputFolder As Variant
    OutputFolder = SelectFolder(Left(filepath, InStrRev(filepath, "\")))
    
    TxtSeparateProcedures filepath, OutputFolder
    
End Sub

Sub TxtSeparateProcedures(filepath As Variant, Optional OutputFolder As Variant)

'@AssignedModule F_FileFolder
'@INCLUDE PROCEDURE TxtOverwrite
'@INCLUDE PROCEDURE TxtRead
    Dim fname As String
    If OutputFolder = "" Then
        OutputFolder = Left(filepath, InStrRev(filepath, "\"))
    Else
        FoldersCreate CStr(OutputFolder)
    End If
    Dim Code As Variant
        Code = Split(TxtRead(filepath), vbLf)
    Dim out As String
    Dim i As Long
    For i = LBound(Code) To UBound(Code)

        out = IIf(out = "", Code(i), out & Code(i)) & vbNewLine
        If RegexTest(Code(i), "Sub ") _
        And Not Code(i) Like Chr(34) & "*Sub*" Then
            fname = Split(Code(i), "Sub ")(1)
            fname = Trim(Split(fname, "(")(0)) & ".txt"
        ElseIf RegexTest(Code(i), "Function ") _
        And Not Code(i) Like Chr(34) & "*Function*" Then
            fname = Split(Code(i), "Function ")(1)
            fname = Trim(Split(fname, "(")(0)) & ".txt"
        End If
        If Trim(Code(i)) = "End Sub" Or Trim(Code(i)) = "End Function" Then
            TxtOverwrite OutputFolder & fname, out
            out = ""
            fname = ""
        End If
    Next

End Sub

Function ProceduresOfWorkbook( _
                             TargetWorkbook As Workbook, _
                             Optional ExcludeDocument As Boolean = True, _
                             Optional ExcludeClass As Boolean = True, _
                             Optional ExcludeForm As Boolean = True) As Collection
    Dim Module As VBComponent
    Dim ProcKind As VBIDE.vbext_ProcKind
    Dim lineNum As Long
    Dim coll As New Collection
    Dim ProcedureName As String
    For Each Module In TargetWorkbook.VBProject.VBComponents
        If ExcludeClass = True And Module.Type = vbext_ct_ClassModule Then GoTo SKIP
        If ExcludeDocument = True And Module.Type = vbext_ct_Document Then GoTo SKIP
        If ExcludeForm = True And Module.Type = vbext_ct_MSForm Then GoTo SKIP
        With Module.CodeModule
            lineNum = .CountOfDeclarationLines + 1
            Do Until lineNum >= .CountOfLines
                ProcedureName = .ProcOfLine(lineNum, ProcKind)
                If InStr(1, ProcedureName, "_") = 0 Then
                    coll.Add ProcedureName
                End If
                lineNum = .procStartLine(ProcedureName, ProcKind) + .ProcCountLines(ProcedureName, ProcKind) + 1
            Loop
        End With
SKIP:
    Next Module
    Set ProceduresOfWorkbook = coll
End Function

Sub ProjetFoldersCreate()
    Dim element
    For Each element In vbarcFolders
        FoldersCreate CStr(element)
    Next
End Sub

Public Function RegexTest( _
                         ByVal string1 As String, _
                         ByVal stringPattern As String, _
                         Optional ByVal globalFlag As Boolean, _
                         Optional ByVal ignoreCaseFlag As Boolean, _
                         Optional ByVal multilineFlag As Boolean) As Boolean
    Dim REGEX As Object
    Set REGEX = CreateObject("VBScript.RegExp")
    With REGEX
        .Global = globalFlag
        .IgnoreCase = ignoreCaseFlag
        .MultiLine = multilineFlag
        .pattern = stringPattern
    End With
    RegexTest = REGEX.test(string1)
End Function


Function StringLastModified(txt As String)

    Dim Code As Variant
        Code = Filter(Split(txt, vbLf), "'@LastModified ")
    If ArrayAllocated(Code) Then
        Dim lastDate As Variant
        If Trim(Code(0)) Like "'@LastModified *" Then
            lastDate = Split(Code(0), " ")(1)
            lastDate = DateSerial(Left(lastDate, 2), Mid(lastDate, 3, 2), Mid(lastDate, 5, 2)) _
                       & " " & TimeSerial(Mid(lastDate, 7, 2), Mid(lastDate, 9, 2), 0)
            StringLastModified = Split(Code(0), " ")(1)
        End If
    Else

    End If
End Function



Function StringProcedureAssignedModule(txt As String) As String
        Dim ComponentName As Variant
        ComponentName = Split(txt, vbLf)
        ComponentName = Filter(ComponentName, "'@AssignedModule")
        If Not ArrayAllocated(ComponentName) Then Exit Function
        Dim UB As Long
            UB = UBound(Split(ComponentName(0), " "))
        ComponentName = Split(ComponentName(0), " ")(UB)
        StringProcedureAssignedModule = ComponentName
End Function



Function TXTReadFromUrl(url As String) As String
    On Error GoTo Err_GetFromWebpage
    Dim objWeb As Object
    Dim strXML As String
    Set objWeb = CreateObject("Msxml2.ServerXMLHTTP")
    objWeb.Open "GET", url, False
    objWeb.setRequestHeader "Content-Type", "text/xml"
    objWeb.setRequestHeader "Cache-Control", "no-cache"
    objWeb.setRequestHeader "Pragma", "no-cache"
    objWeb.send
    Do While objWeb.readyState <> 4
        DoEvents
    Loop
    strXML = objWeb.responseText
    TXTReadFromUrl = strXML
End_GetFromWebpage:
    Set objWeb = Nothing
    Exit Function
Err_GetFromWebpage:
    MsgBox Err.Description & " (" & Err.Number & ")"
    Resume End_GetFromWebpage
End Function

Sub TxtOverwrite(sFile As String, sText As String)
    On Error GoTo ERR_HANDLER
    Dim FileNumber As Integer
    FileNumber = FreeFile
    Open sFile For Output As #FileNumber
    Print #FileNumber, sText
    Close #FileNumber
Exit_Err_Handler:
    Exit Sub
ERR_HANDLER:
    MsgBox "The following error has occurred" & vbCrLf & vbCrLf & _
    "Error Number: " & Err.Number & vbCrLf & _
    "Error Source: TxtOverwrite" & vbCrLf & _
    "Error Description: " & Err.Description, vbCritical, "An Error has Occurred!"
    GoTo Exit_Err_Handler
End Sub

Sub TxtPrepend(filepath As String, txt As String)
    Dim s As String
    s = TxtRead(filepath)
    TxtOverwrite filepath, txt & vbNewLine & s
End Sub


Sub CallTxtPrependContainedProcedures()
    Dim filepath As Variant
    filepath = DataFilePicker("*.txt", False)
    If filepath = vbNullString Then Exit Sub
    TxtPrependContainedProcedures CStr(filepath)
End Sub

Sub TxtPrependContainedProcedures(fileName As String)
    Dim s As String: s = TxtRead(fileName)
    Dim v As New Collection
    Set v = ProceduresOfTXT(s)
    If v.count = 0 Then Exit Sub
    Dim Line As String: Line = String(30, "'")
    TxtPrepend fileName, _
    "'Contains the following " & "#" & v.count & " procedures " & vbNewLine & Line & vbNewLine & _
    "'" & collectionToString(v, vbNewLine & "'") & vbNewLine & Line & vbNewLine & vbNewLine
End Sub

Function TxtRead(sPath As Variant) As String
    Dim sTXT As String
    If Dir(sPath) = "" Then
        Debug.Print "File was not found."
        Debug.Print sPath
        Exit Function
    End If
    Open sPath For Input As #1
    Do Until EOF(1)
        Line Input #1, sTXT
        TxtRead = TxtRead & sTXT & vbLf
    Loop
    Close
    If Len(TxtRead) = 0 Then
        TxtRead = ""
    Else
        TxtRead = Left(TxtRead, Len(TxtRead) - 1)
    End If
End Function

Function URLExists(url) As Boolean
    Dim Request As Object
    Dim FF As Integer
    Dim rc As Variant

    On Error GoTo EndNow
    Set Request = CreateObject("WinHttp.WinHttpRequest.5.1")

    With Request
      .Open "GET", url, False
      .send
      rc = .statusText
    End With
    Set Request = Nothing
    If rc = "OK" Then URLExists = True

    Exit Function
EndNow:
End Function

Function UserformNames(TargetWorkbook As Workbook)
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Set UserformNames = ComponentNames(vbext_ct_MSForm, TargetWorkbook)
End Function






Function WorkbookCode(TargetWorkbook) As String
    If TypeName(TargetWorkbook) <> "Workbook" Then Stop
    Dim Module As VBComponent
    Dim txt
    For Each Module In TargetWorkbook.VBProject.VBComponents
        If Module.CodeModule.CountOfLines > 0 Then
            txt = txt & _
                  vbNewLine & _
                  "'" & String(10, "=") & ModuleOrSheetName(Module) & " (" & Module.Type & ") " & String(10, "=") & _
                  vbNewLine & _
                  ModuleCode(Module)
        End If
    Next
    WorkbookCode = txt
End Function


Function WorkbookOfModule(vbComp As VBComponent) As Workbook
    Set WorkbookOfModule = WorkbookOfProject(vbComp.Collection.Parent)
End Function

Function WorkbookOfProject(vbProj As VBProject) As Workbook
    tmpStr = vbProj.fileName
    tmpStr = Right(tmpStr, Len(tmpStr) - InStrRev(tmpStr, "\"))
    Set WorkbookOfProject = Workbooks(tmpStr)
End Function



Function WorksheetExists(SheetName As String, TargetWorkbook As Workbook) As Boolean
    Dim TargetWorksheet  As Worksheet
    On Error Resume Next
    Set TargetWorksheet = TargetWorkbook.Sheets(SheetName)
    On Error GoTo 0
    WorksheetExists = Not TargetWorksheet Is Nothing
End Function

Function classCallsOfModule(Module As VBComponent) As Variant


    Dim Code As Variant
    Dim element As Variant
    Dim Keyword As Variant
    Dim var As Variant
    ReDim var(1 To 2, 1 To 1)
    Dim counter As Long
    counter = 0
    If Module.CodeModule.CountOfDeclarationLines > 0 Then
        Code = Module.CodeModule.Lines(1, Module.CodeModule.CountOfDeclarationLines)
        Code = Replace(Code, "_" & vbNewLine, "")
        Code = Split(Code, vbNewLine)
        Code = Filter(Code, " As ", , vbTextCompare)
        For Each element In Code
            element = Trim(element)
            If element Like "* As *" Then
                Keyword = Split(element, " As ")(0)
                Keyword = Split(Keyword, " ")(UBound(Split(Keyword, " ")))
                element = Split(element, " As ")(1)
                element = Replace(element, "New ", "")
                
                For Each ClassName In ClassNames
                    If element = ClassName Then
                        
                        ReDim Preserve var(1 To 2, 1 To counter + 1)
                        var(1, UBound(var, 2)) = element
                        var(2, UBound(var, 2)) = Keyword
                        counter = counter + 1
                    End If
                Next
            End If
        Next
        If var(1, 1) <> "" Then

            If UBound(var, 2) > 1 Then
                classCallsOfModule = WorksheetFunction.Transpose(var)
            Else
                Dim VAR2(1 To 1, 1 To 2)
                VAR2(1, 1) = var(1, 1)
                VAR2(1, 2) = var(2, 1)
                classCallsOfModule = VAR2
            End If
        End If
    End If

End Function

Function collectionToString(coll As Collection, delim As String) As String
    Dim element
    Dim out As String
    For Each element In coll
        out = IIf(out = "", element, out & delim & element)
    Next
    collectionToString = out
End Function

Function getDeclarations( _
                        WB As Workbook, _
                        Optional includeScope As Boolean, _
                        Optional includeType As Boolean, _
                        Optional includeKeywords As Boolean, _
                        Optional includeDeclarations As Boolean, _
                        Optional includeComponentName As Boolean, _
                        Optional includeComponentType As Boolean) As Collection

    Dim ComponentCollection     As New Collection
    Dim ComponentTypecollection As New Collection
    Dim DeclarationsCollection  As New Collection
    Dim KeywordsCollection      As New Collection
    Dim output                  As New Collection
    Dim ScopeCollection         As New Collection
    Dim TypeCollection          As New Collection

    Dim element                 As Variant
    Dim OriginalDeclarations    As Variant
    Dim str                     As Variant
    
    Dim tmp                     As String
    Dim helper                  As String
    Dim i                       As Long
    
    Dim Module                  As VBComponent
    For Each Module In WB.VBProject.VBComponents
        If Module.Type = vbext_ct_StdModule Or Module.Type = vbext_ct_MSForm Then
            If Module.CodeModule.CountOfDeclarationLines > 0 Then
                str = Module.CodeModule.Lines(1, Module.CodeModule.CountOfDeclarationLines)
                str = Replace(str, "_" & vbNewLine, "")
                OriginalDeclarations = str
                tmp = str
                Do While InStr(1, str, "End Type") > 0
                    tmp = Mid(str, InStr(1, str, "Type "), InStr(1, str, "End Type") - InStr(1, str, "Type ") + 8)
                    str = Replace(str, tmp, Split(tmp, vbNewLine)(0))
                Loop
                Do While InStr(1, str, "End Enum") > 0
                    tmp = Mid(str, InStr(1, str, "Enum "), InStr(1, str, "End Enum") - InStr(1, str, "Enum ") + 8)
                    str = Replace(str, tmp, Split(tmp, vbNewLine)(0))
                Loop
                Do While InStr(1, str, "  ") > 0
                    str = Replace(str, "  ", " ")
                Loop
                
                str = Split(str, vbNewLine)
                tmp = OriginalDeclarations
                
                For Each element In str
                    If Len(CStr(element)) > 0 And Not Trim(CStr(element)) Like "'*" And Not Trim(CStr(element)) Like "Rem*" Then
                        If RegexTest(CStr(element), "\b ?Enum \b") Then
                            KeywordsCollection.Add DeclarationsKeywordSubstring(CStr(element), " ", "Enum")
                            DeclarationsCollection.Add DeclarationsKeywordSubstring(tmp, , "Enum " & KeywordsCollection.item(KeywordsCollection.count), "End Enum", , , True)
                            TypeCollection.Add "Enum"
                            ComponentCollection.Add Module.Name
                            ComponentTypecollection.Add ModuleTypeToString(Module.Type)
                            ScopeCollection.Add IIf(InStr(1, DeclarationsCollection.item(DeclarationsCollection.count), "Public", vbTextCompare), "Public", "Private")
                        ElseIf RegexTest(CStr(element), "\b ?Type \b") Then
                            KeywordsCollection.Add DeclarationsKeywordSubstring(CStr(element), " ", "Type")
                            DeclarationsCollection.Add DeclarationsKeywordSubstring(tmp, , "Type " & KeywordsCollection.item(KeywordsCollection.count), "End Type", , , True)
                            TypeCollection.Add "Type"
                            ComponentCollection.Add Module.Name
                            ComponentTypecollection.Add ModuleTypeToString(Module.Type)
                            ScopeCollection.Add IIf(InStr(1, DeclarationsCollection.item(DeclarationsCollection.count), "Public", vbTextCompare), "Public", "Private")
                        ElseIf InStr(1, CStr(element), "Const ", vbTextCompare) > 0 Then
                            KeywordsCollection.Add DeclarationsKeywordSubstring(CStr(element), " ", "Const")
                            DeclarationsCollection.Add CStr(element)
                            TypeCollection.Add "Const"
                            ComponentCollection.Add Module.Name
                            ComponentTypecollection.Add ModuleTypeToString(Module.Type)
                            ScopeCollection.Add IIf(InStr(1, DeclarationsCollection.item(DeclarationsCollection.count), "Public", vbTextCompare), "Public", "Private")
                        ElseIf RegexTest(CStr(element), "\b ?Sub \b") Then
                            KeywordsCollection.Add DeclarationsKeywordSubstring(CStr(element), " ", "Sub")
                            DeclarationsCollection.Add CStr(element)
                            TypeCollection.Add "Sub"
                            ComponentCollection.Add Module.Name
                            ComponentTypecollection.Add ModuleTypeToString(Module.Type)
                            ScopeCollection.Add IIf(InStr(1, DeclarationsCollection.item(DeclarationsCollection.count), "Public", vbTextCompare), "Public", "Private")
                        ElseIf RegexTest(CStr(element), "\b ?Function \b") Then
                            KeywordsCollection.Add DeclarationsKeywordSubstring(CStr(element), " ", "Function")
                            DeclarationsCollection.Add CStr(element)
                            TypeCollection.Add "Function"
                            ComponentCollection.Add Module.Name
                            ComponentTypecollection.Add ModuleTypeToString(Module.Type)
                            ScopeCollection.Add IIf(InStr(1, DeclarationsCollection.item(DeclarationsCollection.count), "Public", vbTextCompare), "Public", "Private")
                        ElseIf element Like "*(*) As *" Then
                            helper = Left(element, InStr(1, CStr(element), "(") - 1)
                            helper = Mid(helper, InStrRev(helper, " ") + 1)
                            KeywordsCollection.Add helper
                            DeclarationsCollection.Add CStr(element)
                            TypeCollection.Add "Other"
                            ComponentCollection.Add Module.Name
                            ComponentTypecollection.Add ModuleTypeToString(Module.Type)
                            ScopeCollection.Add IIf(InStr(1, DeclarationsCollection.item(DeclarationsCollection.count), "Public", vbTextCompare), "Public", "Private")
                        ElseIf element Like "* As *" Then
                            KeywordsCollection.Add DeclarationsKeywordSubstring(CStr(element), " ", , "As")
                            DeclarationsCollection.Add CStr(element)
                            TypeCollection.Add "Other"
                            ComponentCollection.Add Module.Name
                            ComponentTypecollection.Add ModuleTypeToString(Module.Type)
                            ScopeCollection.Add IIf(InStr(1, DeclarationsCollection.item(DeclarationsCollection.count), "Public", vbTextCompare), "Public", "Private")
                        Else
                        End If
                    End If
                Next element
            End If
        End If
    Next Module
    
    If includeScope = True Then output.Add ScopeCollection
    If includeType = True Then output.Add TypeCollection
    If includeKeywords = True Then output.Add KeywordsCollection
    If includeDeclarations = True Then output.Add DeclarationsCollection
    If includeComponentType = True Then output.Add ComponentTypecollection
    If includeComponentName = True Then output.Add ComponentCollection
    
    Set getDeclarations = output
End Function

Function getLastRow(TargetSheet As Worksheet)
    Dim LastCell As Range
    Set LastCell = TargetSheet.Cells.Find("*", SearchOrder:=xlByRows, SearchDirection:=xlPrevious)
    getLastRow = LastCell.row
End Function

Function vbarcFolders() As Collection



    Dim coll As New Collection
    coll.Add LOCAL_LIBRARY_PROCEDURES
    coll.Add LOCAL_LIBRARY_CLASSES
    coll.Add LOCAL_LIBRARY_USERFORMS
    coll.Add LOCAL_LIBRARY_DECLARATIONS

    coll.Add Environ$("USERPROFILE") & "\Documents\vbArc\oleVba\"
    coll.Add Environ$("USERPROFILE") & "\Documents\vbArc\MergedTXT\"
    coll.Add Environ$("USERPROFILE") & "\Documents\vbArc\MemoryKnots\"
    coll.Add Environ$("USERPROFILE") & "\Documents\vbArc\ExportedImages\"
    Set vbarcFolders = coll
End Function

Function ProcedureLineContaining(Module As VBComponent, Procedure As String, This As String) As Long
    Dim i As Long
    For i = ProcedureLinesFirst(Module, Procedure) To ProcedureLinesLast(Module, Procedure)
        If Module.CodeModule.Lines(i, 1) Like This Then
            ProcedureLineContaining = i
            Exit Function
        End If
    Next
End Function

Public Function ClearClipboard()
    OpenClipboard (0&)
    EmptyClipboard
    CloseClipboard
End Function

Public Function CLIP(Optional StoreText As String) As String
    Dim x As Variant
    x = StoreText
    With CreateObject("htmlfile")
        With .parentWindow.clipboardData
            Select Case True
            Case Len(StoreText)
                .SetData "text", x
            Case Else
                CLIP = .GetData("text")
            End Select
        End With
    End With
End Function



'aCodeModule	Class


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Class      : aCodeModule
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 04-05-2023 12:17    Alex
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Dim oWorkbook As Workbook
Dim oModule   As VBComponent
Private cm    As CodeModule

Public ColumnFirst As Long
Public ColumnLast  As Long
Public rowCount    As Long
Public RowFirst    As Long
Public RowLast     As Long

Public Selection          As String
Public SelectionAfter     As String
Public SelectionBefore    As String
Public SelectionLength    As Long
Public SelectionLinesCode As String

Sub ImportProcedure()
'@INCLUDE CLASS aCodeModule
'@INCLUDE CLASS aProcedure
'@AssignedModule aCodeModule
    aProcedure.Active.ImportProcedure Me.Selection, False
End Sub

Public Function Parent() As VBComponent
    Set Parent = oModule
End Function
Public Function Active() As aCodeModule
'@INCLUDE PROCEDURE ActiveModule
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Init ActiveModule
    Set Active = Me
End Function

Public Function Init(Module As VBComponent) As aCodeModule
'@INCLUDE PROCEDURE WorkbookOfModule
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Set oModule = Module
    Set cm = oModule.CodeModule
    Set oWorkbook = WorkbookOfModule(Module)
    AssignVariables
    Set Init = Me
End Function

Private Sub Class_Terminate()
    'do something
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule

End Sub

Private Sub AssignVariables()
'@INCLUDE PROCEDURE CountOfCharacters
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule

    Dim startLine As Long, StartColumn As Long, endLine As Long, EndColumn As Long
    cm.CodePane.GetSelection startLine, StartColumn, endLine, EndColumn
    
    ColumnFirst = StartColumn
    ColumnLast = EndColumn
    
    RowFirst = startLine
    RowLast = endLine
    If RowLast > startLine And EndColumn = 1 Then
        RowLast = endLine - 1
    End If
    rowCount = RowLast - RowFirst + 1
    
    SelectionLinesCode = cm.Lines(RowFirst, rowCount)
    

    If ColumnLast - ColumnFirst = 0 Then
        If endLine > RowLast Then
            ColumnLast = Len(cm.Lines(RowLast, 1)) + 1
        End If
    End If
    
    SelectionAfter = Mid(cm.Lines(RowLast, 1), ColumnLast) ' + IIf(Len(Me.Selection) > 0, 1, 0))
    SelectionBefore = Mid(cm.Lines(RowFirst, 1), 1, ColumnFirst - 1)
    
    If rowCount = 1 And (ColumnLast - ColumnFirst > 0) Then
        SelectionLength = ColumnLast - ColumnFirst
    Else
        SelectionLength = Len(SelectionLinesCode) - Len(SelectionBefore) - Len(SelectionAfter) - 1 - Len(CountOfCharacters(Selection, vbNewLine)) * 2
    End If
    
    If RowLast - RowFirst = 0 Then
        Me.Selection = Mid(cm.Lines(RowFirst, 1), ColumnFirst, ColumnLast - ColumnFirst)
        Exit Sub
    End If
    Dim str As String
    Dim i As Long
    For i = RowFirst To RowLast
        If str = "" Then
            str = Mid(cm.Lines(i, 1), ColumnFirst)
        ElseIf i < RowLast Then
            str = str & vbNewLine & cm.Lines(i, 1)
        Else
            str = str & vbNewLine & Left(cm.Lines(i, 1), ColumnLast - 1)
        End If
    Next
    Me.Selection = str

End Sub

Sub Todo()
'@INCLUDE CLASS aCodeModule
'@INCLUDE DECLARATION AUTHOR_NAME
'@AssignedModule aCodeModule
    Const tFormat = "dd-mm-yyyy hh:nn"
    Dim Module As VBComponent
    Set Module = oModule
    Dim txtName As String
        txtName = AUTHOR_NAME
    If txtName = vbNullString Then txtName = Environ("UserName")
    Dim nLine As Long
        nLine = aCodeModule.Init(Module).RowFirst
        Do While nLine > 1 And Right(Module.CodeModule.Lines(nLine, 1), 1) = "_"
            nLine = nLine - 1
        Loop
    Dim sLine As String
        sLine = Module.CodeModule.Lines(nLine, 1)
    Dim sSpec As String
        sSpec = Space(Len(sLine) - Len(Trim(sLine)))
    Dim sTodo As String
        sTodo = sSpec & "'* @TODO Created: " & _
                VBA.Format$(Now, tFormat) & _
                " Author: " & txtName & vbCrLf & _
                sSpec & "'* @TODO "
        Module.CodeModule.InsertLines nLine, vbNewLine & sTodo & vbNewLine
End Sub

Sub ToggleComments()
'@INCLUDE PROCEDURE IsCommentLine
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Dim sLine As String
    Dim i As Long
    For i = RowFirst To RowLast
        sLine = cm.Lines(i, 1)
        If IsCommentLine(sLine) Then
            If Trim(sLine) Like "Rem*" Then
                UnremTargetLine i
            ElseIf Trim(sLine) Like "'*" Then
                UncommentTargetLine i
            End If
        Else
            CommentTargetLine i
        End If
    Next
    SetSelection RowFirst, 1, RowLast, 10000
End Sub





Public Sub DimSeparate()
'@INCLUDE PROCEDURE StringFormatAlignRowsElements
'@INCLUDE PROCEDURE IndentationCount
'@INCLUDE CLASS aCodeModule
'@INCLUDE CLASS aCollection
'@AssignedModule aCodeModule
    Dim coll As New Collection
    Dim Code As String:         Code = SelectionLinesCode
    Dim FirstLine As Long:      FirstLine = RowFirst
    Dim iSpace As Long
    Dim iCount As Long:         iCount = rowCount
    
    If iCount = 1 Then
        iSpace = IndentationCount(cm.Lines(FirstLine, 1))
        Code = cm.Lines(FirstLine, iCount)
        Code = Join(Split(Code, ", "), vbNewLine & Space(iSpace) & "Dim ")
    Else
        Dim element
        For Each element In Split(Code, vbNewLine)
            iSpace = IndentationCount(CStr(element))
            coll.Add Join(Split(element, ", "), vbNewLine & Space(iSpace) & "Dim ")
        Next
        Code = aCollection.Init(coll).ToString(vbNewLine)
    End If
    Code = StringFormatAlignRowsElements(Code, " As ", True)

    cm.DeleteLines FirstLine, iCount
    cm.InsertLines FirstLine, Code
    SetSelection FirstLine, 1, FirstLine + UBound(Split(Code, vbNewLine)), 10000
End Sub

Sub DimMerge()
'@INCLUDE PROCEDURE RegExpReplace
'@INCLUDE PROCEDURE IndentationCount
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Dim Code      As String:   Code = SelectionLinesCode
    Dim FirstLine As Long:     FirstLine = RowFirst
    Dim iCount    As Long:     iCount = rowCount
    Dim iSpace    As Long:     iSpace = IndentationCount(cm.Lines(FirstLine, 1))
    Code = cm.Lines(FirstLine, iCount)
    If Code Like "*" & vbNewLine Then Code = Left(Code, Len(Code) - Len(vbNewLine))
    Code = Replace(Join(Split(Code, vbNewLine)), "Dim ", ", ")
    Code = Replace(Code, ",", "Dim", , 1)
    Code = Space(iSpace) & RegExpReplace(Code, "\s{2,}", " ")
    Code = Replace(Code, " ,", ",")
    Code = Mid(Code, 2)
    cm.DeleteLines FirstLine, iCount
    cm.InsertLines FirstLine, Code
    SetSelection FirstLine, 1, FirstLine, 10000
End Sub

Public Sub SetSelection(startLine As Long, StartColumn As Long, endLine As Long, EndColumn As Long)
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    cm.CodePane.SetSelection startLine, StartColumn, endLine, EndColumn
    AssignVariables
End Sub

Public Sub Move_Up()
'@INCLUDE PROCEDURE ActiveProcedure
'@INCLUDE CLASS aCodeModule
'@INCLUDE CLASS aProcedure
'@AssignedModule aCodeModule
    Dim blockStart        As Long:      blockStart = RowFirst
    Dim blockEnd          As Long:      blockEnd = RowLast
    Dim blockCountOfLines As Long:      blockCountOfLines = blockEnd - blockStart + 1
    Dim blockString       As String:    blockString = cm.Lines(blockStart, blockCountOfLines)
    Dim insertBlockAtLine As Long:      insertBlockAtLine = blockStart - 1
    Dim AP                As String:    AP = ActiveProcedure
    If AP = "" Then Exit Sub
    Select Case insertBlockAtLine
        Case 1, aProcedure.Init(, , AP).LineIndex(Declaration_First)
            Exit Sub
    End Select
    cm.DeleteLines blockStart, blockCountOfLines
    cm.InsertLines insertBlockAtLine, blockString
    SetSelection insertBlockAtLine, 1, insertBlockAtLine + blockCountOfLines - 1, 10000
End Sub

Public Sub Move_Down()
'@INCLUDE PROCEDURE ActiveProcedure
'@INCLUDE CLASS aCodeModule
'@INCLUDE CLASS aProcedure
'@AssignedModule aCodeModule
    Dim blockStart        As Long:      blockStart = RowFirst
    Dim blockEnd          As Long:      blockEnd = RowLast
    Dim blockCountOfLines As Long:      blockCountOfLines = blockEnd - blockStart + 1
    Dim blockString       As String:    blockString = cm.Lines(blockStart, blockCountOfLines)
    Dim insertBlockAtLine As Long:      insertBlockAtLine = blockStart + 1
    Dim AP                As String:    AP = ActiveProcedure
    If AP = "" Then Exit Sub
    Select Case insertBlockAtLine + blockCountOfLines - 1
        Case cm.CountOfLines, aProcedure.Init(, , AP).LineIndex(Procedure_Last)
            Exit Sub
    End Select
    cm.DeleteLines blockStart, blockCountOfLines
    cm.InsertLines insertBlockAtLine, blockString
    SetSelection insertBlockAtLine, 1, insertBlockAtLine + blockCountOfLines - 1, 10000
End Sub

Public Sub Inject(str As String)
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Dim Code    As String: Code = SelectionBefore & str & SelectionAfter
    Dim endLine As Long
    'catch error when selected all lines
    If rowCount > cm.CountOfLines Then endLine = endLine - 1
    cm.DeleteLines RowFirst, rowCount
    cm.InsertLines RowFirst, Code
    Debug.Print cm.Name & vbTab & RowFirst
    SetSelection RowFirst, _
                 ColumnFirst, _
                 RowFirst + UBound(Split(str, vbLf)), _
                 IIf((UBound(Split(str, vbLf))) = 0, ColumnLast, 1) + Len(Split(str, vbLf)(UBound(Split(str, vbLf))))
End Sub

Sub InjectTemplateModule()
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Inject TemplateModule
End Sub

Private Function TemplateModule(Optional Module As VBComponent) As String
'@INCLUDE PROCEDURE DevInfo
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Dim ComponentName As String: ComponentName = oModule.Name
    Dim s As String
    s = s & DevInfo & vbNewLine & vbNewLine
    s = s & "'   Version:    <Last Update Date goes here>" & vbNewLine
    s = s & "'   Description: General purpose library included in all projects" & vbNewLine & vbNewLine
    s = s & "'   Changelog" & vbNewLine
    s = s & "'   Date" & vbTab & vbTab & "Modification" & vbNewLine
    s = s & "'   " & Format(Date, "dd/mm/yy") & vbTab & "Initial Development" & vbNewLine
    s = s & vbNewLine
    s = s & "'Options" & vbNewLine
    s = s & "    Option Explicit" & vbNewLine
    s = s & "    Option Private Module" & vbNewLine
    s = s & "    Option Compare Text" & vbNewLine & vbNewLine
    s = s & "'Private Constants" & vbNewLine
    s = s & "    Private Const cModule    As String = " & ComponentName & vbNewLine
    TemplateModule = s
End Function

Function CopyTemplateFromSheet(Template As String)
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Dim cell As Range
    Dim ws As Worksheet
    Set ws = ThisWorkbook.Sheets("Templates")
    On Error Resume Next
    Set cell = ws.Columns(1).SpecialCells(xlCellTypeConstants).Find(Template, LookAt:=xlWhole)
    On Error GoTo 0

    CopyTemplateFromSheet = cell.offset(0, 1)
End Function

Sub InjectTemplateFromSheet(Template As String)
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    If Len(Selection) > 0 Then Exit Sub
    Dim ws As Worksheet: Set ws = ThisWorkbook.Sheets("Templates")
    Dim cell As Range
    On Error Resume Next
    Set cell = ws.Columns(1).SpecialCells(xlCellTypeConstants).Find(Template, LookAt:=xlWhole)
    On Error GoTo 0
    If Not cell Is Nothing Then Inject cell.offset(0, 1)
End Sub

Sub InjectTemplateProcedure(functionName As String)
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Inject TemplateProcedure(functionName)
End Sub

Function ErrHandlerTemplate(ProcedureName As String) As String
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    ErrHandlerTemplate = CopyTemplateFromSheet("ErrHandler")
End Function

Private Function TemplateProcedure(functionName As String) As String
'@INCLUDE PROCEDURE DevInfo
'@INCLUDE PROCEDURE StartTimer
'@INCLUDE PROCEDURE EndTimer
'@INCLUDE CLASS aCodeModule
'@INCLUDE DECLARATION DspError
'@INCLUDE DECLARATION Failure
'@INCLUDE DECLARATION Success
'@AssignedModule aCodeModule
    Dim Q As String: Q = """"
    Dim s As String
    s = s & "Function " & functionName & "(ByVal MyParameter as String) As Variant" & vbNewLine
    s = s & DevInfo & vbNewLine
    s = s & vbNewLine
    s = s & "'   Description:Procedure Description" & vbNewLine
    s = s & "'   Inputs:     MyParameter  Describe its purpose" & vbNewLine
    s = s & "'   Outputs:    Success: <return this>" & vbNewLine
    s = s & "'               Failure: <return this>" & vbNewLine
    s = s & "'   Requisites  Routines    ModuleName.ProcedureName" & vbNewLine
    s = s & "'               Classes      Class Module Name" & vbNewLine
    s = s & "'               Forms        User Form Name" & vbNewLine
    s = s & "'               Tables       Table Name" & vbNewLine
    s = s & "'               References   Reference" & vbNewLine
    s = s & "'   Notes <add if needed>" & vbNewLine
    s = s & "'   Example: ?" & functionName & "(MyParameter)" & vbNewLine & vbNewLine
    s = s & "'   Changelog" & vbNewLine
    s = s & "'   Date        Modification" & vbNewLine
    s = s & "'   " & Format(Date, "DD/MM/YY") & "    Initial Release" & vbNewLine
    s = s & vbNewLine
    s = s & "'   Check Inputs and Requisites" & vbNewLine
    s = s & "    If sParameter = vbNullString then Err.Raise DspError, , ""Parameter missing""" & vbNewLine
    s = s & vbNewLine
    s = s & "'   Declarations" & vbNewLine
    s = s & "    Const cRoutine as String = " & Q & functionName & Q
    s = s & "    LogProcedureUsage cRoutine"
    s = s & "'   Error Handling Initialization" & vbNewLine
    s = s & "    On Error GoTo ErrHandler" & vbNewLine
    s = s & "    " & functionName & " = Failure    'Assume failure" & vbNewLine
    s = s & vbNewLine
    s = s & "'   Initialize Variables" & vbNewLine & vbNewLine
    s = s & "'   Procedure" & vbNewLine
    s = s & "    Application.screenupdating=false" & vbNewLine
    s = s & "    StartTimer " & functionName & vbNewLine & "    " & vbNewLine
    s = s & "    " & functionName & " = Success    'Successful finish" & vbNewLine
    s = s & "    EndTimer" & vbNewLine & vbNewLine
    s = s & "NormalExit:" & vbNewLine
    s = s & "    Application.screenupdating=false" & vbNewLine
    s = s & "    Exit Sub" & vbNewLine
    s = s & vbNewLine
    s = s & ErrHandlerTemplate(functionName) & vbNewLine
    s = s & "End Function"
    TemplateProcedure = s
End Function


Sub Format_VBA7()
'@INCLUDE PROCEDURE FormatVBA7
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    SelectRows
    Inject FormatVBA7(Selection)
End Sub

Private Function StringToVBA7() As String
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
  
End Function

Public Sub Substitute(oldValue As String, NewValue As String, Optional count As Long = -1)
'@INCLUDE PROCEDURE CountOfCharacters
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Dim str           As String: str = Selection
    Dim lastRowLength As Long
        lastRowLength = 1 + Len(Replace(Split(str, vbNewLine)(UBound(Split(str, vbNewLine))), oldValue, NewValue))
    Dim Code          As String
    Code = SelectionBefore & _
           Replace(str, oldValue, NewValue, , count, vbTextCompare) & _
           SelectionAfter
    cm.DeleteLines RowFirst, rowCount
    cm.InsertLines RowFirst, Code
    SetSelection RowFirst, _
                 ColumnFirst, _
                 RowFirst + CountOfCharacters(Code, vbNewLine), _
                 IIf(CountOfCharacters(Code, vbNewLine) > 0, lastRowLength, ColumnFirst + Len(Code))
End Sub

Public Sub CaseLower()
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Inject LCase(Selection)
End Sub

Public Sub CaseProper()
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Inject WorksheetFunction.Proper(Selection)
End Sub

Public Sub CaseUpper()
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Inject UCase(Selection)
End Sub

Sub Sort_Comma()
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Sort ","
End Sub

Private Sub SelectRows()
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    SetSelection RowFirst, 1, RowLast, 10000
End Sub

Sub Sort_Lines()
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    SelectRows
    Sort vbNewLine
End Sub

Public Sub Sort(delimeter As String)
'@INCLUDE PROCEDURE SortSelectionArray
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Dim Code As String:     Code = Me.Selection
    Dim arr
        arr = Split(Code, delimeter)
        arr = SortSelectionArray(arr)
    Dim str As String:  str = Join(arr, delimeter)
    Code = SelectionBefore & _
           str & _
           SelectionAfter

           
    cm.DeleteLines RowFirst, rowCount
    cm.InsertLines RowFirst, Code
    SetSelection RowFirst, _
                  ColumnFirst, _
                  RowLast, _
                  IIf(InStr(1, Code, vbNewLine) = 0, ColumnLast, Len(arr(UBound(arr)))) + IIf(InStr(1, Code, vbNewLine) = 0, 0, 1)
End Sub

Sub InjectArgumentStyle()
'@INCLUDE PROCEDURE ActiveCodepaneWorkbook
'@INCLUDE CLASS aCodeModule
'@INCLUDE CLASS aProcedure
'@AssignedModule aCodeModule
    Dim Result As String: Result = aProcedure.Init(ActiveCodepaneWorkbook, , Selection).ArgumentStyle
    If Result <> "" Then Inject Result
End Sub

Sub Encapsulate_Quotes()
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Encapsulate Chr(34), Chr(34)
End Sub

Sub Encapsulate_Parenthesis()
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Encapsulate "(", ")"
End Sub

Public Sub Encapsulate(Before As String, After As String)
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Dim str  As String:  str = Selection
    Dim Code As String
    Code = SelectionBefore & _
           Before & str & After & _
           SelectionAfter
    cm.DeleteLines RowFirst, rowCount
    cm.InsertLines RowFirst, Code
    SetSelection RowFirst, ColumnFirst, RowLast, ColumnLast + 2
End Sub

'Sub Encapsulate_CommaSeparatedValues_Quotes()
'    cpsFormatEncapsulateMultiple Chr(34), Chr(34), ","
'End Sub
'
'Sub Encapsulate_CommaSeparatedValues_Parenthesis()
'    cpsFormatEncapsulateMultiple "(", ")", ","
'End Sub
'
'Sub EncapsulateMultipleLinesWithParenthesis()
'    cpsFormatEncapsulateMultiple "(", ")", ","
'End Sub
'
'Sub EncapsulateMultipleLinesWithQuotes()
'    cpsFormatEncapsulateMultiple Chr(34), Chr(34), vbNewLine
'End Sub
'
Public Sub EncapsulateMultiple(Before As String, After As String, Splitter As String)
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Dim Code    As String: Code = Selection
    Dim arr:               arr = Split(Code, Splitter)
    Dim counter As Long
    For counter = LBound(arr) To UBound(arr) - IIf(Right(UBound(arr), Len(Splitter)) = Splitter, Len(Splitter), 0)
        arr(counter) = Before & arr(counter) & After
    Next
    Code = Join(arr, Splitter)
    Code = SelectionBefore & Code & SelectionAfter
    cm.DeleteLines RowFirst, rowCount
    cm.InsertLines RowFirst, Code
    SetSelection RowFirst, ColumnFirst, RowLast, ColumnLast + ((Len(Before) + (Len(After))) * (UBound(arr) + 1))
End Sub

Public Sub UnFoldLine()
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Dim str  As String:  str = Selection
    Dim Code As String
    Code = SelectionBefore & _
           Join(Split(str, "_" & vbNewLine), " ") & _
           SelectionAfter

    cm.DeleteLines RowFirst, rowCount
    cm.InsertLines RowFirst, Code
    SetSelection RowFirst, ColumnFirst, RowFirst, 10000
End Sub

Public Sub FoldLine()
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    If rowCount > 1 Then UnFoldLine
    If InStr(1, Me.Selection, ",") = 0 And InStr(1, Me.Selection, "(") = 0 Then
        SetSelection RowFirst, ColumnFirst, RowFirst, 10000
'        Debug.Print "Select a whole line or part of a line with comma separated arguments."
'        Exit Sub
    End If
    Dim str As String
    str = Me.Selection
    
    str = Join(Split(str, ", "), ", _" & vbNewLine & Space(ColumnFirst - 1))
    str = Replace(str, "(", "( _" & vbNewLine & Space(ColumnFirst - 1), , 1)

    Dim Code As String
    Code = SelectionBefore & _
           str & _
           SelectionAfter
    cm.DeleteLines RowFirst, rowCount
    cm.InsertLines RowFirst, Code
    SetSelection RowFirst, ColumnFirst, RowFirst + UBound(Split(Code, " _" & vbNewLine)), 10000
End Sub

Sub RotateCommas()
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Rotate ","
End Sub

Sub RotateLines()
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Rotate vbNewLine
End Sub

Public Sub Rotate(delim As String)
    Rem Rotate multiple  eg. a,b,c,d -> b,c,d,a
'@INCLUDE PROCEDURE ArrayRotate
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Dim s As String
        s = Selection
        s = Join(ArrayRotate(Split(s, delim)), delim)
        s = SelectionBefore & s & SelectionAfter
    Dim idx As Long:    idx = RowFirst
    cm.DeleteLines idx, rowCount
    cm.InsertLines idx, s
    SetSelection RowFirst, ColumnFirst, RowLast, ColumnLast
End Sub

Sub rotateEqualInLines()
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    RotateMultiple "=", vbNewLine
End Sub

Public Sub RotateMultiple(flipper As String, Splitter As String)
'@INCLUDE PROCEDURE ArrayRemoveEmptyElements
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Dim startLine As Long, StartColumn As Long, endLine As Long, EndColumn As Long
    Application.VBE.ActiveCodePane.GetSelection startLine, StartColumn, endLine, EndColumn
    Dim Code As String:    Code = Selection
    Dim arr As Variant
        arr = Split(Code, Splitter)
        arr = ArrayRemoveEmptyElements(arr)
    Dim counter As Long
    For counter = LBound(arr) To UBound(arr) - IIf(Right(UBound(arr), Len(Splitter)) = Splitter, Len(Splitter), 0)
        arr(counter) = Split(arr(counter), flipper)(1) & flipper & Split(arr(counter), flipper)(0)
    Next
    Code = Join(arr, Splitter)
    Code = SelectionBefore & _
            Code & _
            SelectionAfter
    cm.DeleteLines startLine, endLine - startLine + 1
    cm.InsertLines startLine, Code
    SetSelection startLine, StartColumn, endLine, EndColumn
End Sub

Sub Duplicate()
'@INCLUDE PROCEDURE ActiveProcedure
'@INCLUDE CLASS aCodeModule
'@INCLUDE CLASS aProcedure
'@AssignedModule aCodeModule
    Dim s As String
    If rowCount > 1 Then
        SelectRows
        s = Selection & vbNewLine & Selection
    Else
        Dim RowNumber As Long:      RowNumber = RowFirst
        Dim AP As String:           AP = ActiveProcedure:       If AP = "" Then Exit Sub
        Dim Limit As Long:          Limit = aProcedure.Init(, , AP).LineIndex(Body_First_AfterComments)
        Do While Len(Trim(cm.Lines(RowNumber, 1))) = 0 _
        And RowNumber - 1 >= Limit
            RowNumber = RowNumber - 1
        Loop
        If Len(Trim(cm.Lines(RowNumber, 1))) > 0 Then
            s = cm.Lines(RowNumber, 1)
        Else
            Exit Sub
        End If
    End If
    cm.InsertLines RowFirst, s
End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 17-08-2023 08:24    Alex                (Increment)

Sub Increment()
'@LastModified 2308170824
'@INCLUDE PROCEDURE IncreaseAllNumbersInString
'@INCLUDE CLASS aCodeModule
'@INCLUDE CLASS aProcedure
'@AssignedModule aCodeModule
    If rowCount > 1 Then Exit Sub
    Dim RowNumber As Long:      RowNumber = RowFirst
    
    Do While Len(Trim(cm.Lines(RowNumber, 1))) = 0 'And RowNumber - 1 >= Limit
        RowNumber = RowNumber - 1
    Loop
    
    Dim s         As String
    If Len(Trim(cm.Lines(RowNumber, 1))) > 0 Then
        s = cm.Lines(RowNumber, 1)
    Else
        Exit Sub
    End If
    
    Dim AP As String
    Dim i As Long
    For i = 0 To 3
        On Error Resume Next
        AP = cm.ProcOfLine(RowNumber, i)
        On Error GoTo 0
        If AP <> "" Then Exit For
    Next
    If AP = "" Then Exit Sub
    
    s = IncreaseAllNumbersInString(s)
    cm.InsertLines RowNumber + 1, s
    SetSelection RowNumber + 1, 1, RowFirst + 1, 10000
End Sub

Sub Cut()
'@INCLUDE PROCEDURE CLIP
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    CLIP SelectionLinesCode
    Debug.Print Selection
    cm.DeleteLines RowFirst, rowCount
    SetSelection RowFirst, 1, RowFirst, 1
    AssignVariables
End Sub

Sub Copy()
'@INCLUDE PROCEDURE CLIP
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    SelectRows
    CLIP Selection
    AssignVariables
End Sub

Public Sub BeautifyFunction()
'@INCLUDE PROCEDURE StringFormatFunctionNested
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Dim txt As String: txt = Selection
    txt = StringFormatFunctionNested(txt)
    IndentForInject txt
    Inject txt
End Sub

Private Sub IndentForInject(ByRef txt As String)
'@INCLUDE PROCEDURE ActiveProcedure
'@INCLUDE PROCEDURE ActiveModule
'@INCLUDE PROCEDURE ProcedureLinesLast
'@INCLUDE PROCEDURE ProcedureTitleLineLast
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Dim var:            var = Split(txt, vbNewLine): If UBound(var) < 1 Then Exit Sub
    Dim Indent As Long: Indent = ColumnFirst:        If Indent < 2 Then Exit Sub
    Dim i As Long
    For i = LBound(var) + 1 To UBound(var)
        var(i) = Space(Indent) & var(i)
        txt = Join(var, vbNewLine)
    Next
End Sub
'
'Function cpsCurrentRegionLineBlockFirst() As String
'    Dim Module As VBComponent
'    Set Module = ActiveModule
'    If Len(Module.codeModule.Lines(cpsLineFirst, 1)) = 0 Then Exit Function
'
'    Dim Procedure As String
'        Procedure = ActiveProcedure
'    Dim StartLine As Long
'        StartLine = cpsLineFirst
'    Dim nLine As Long
'        nLine = StartLine
'    If nLine - 1 > 1 _
'    And nLine - 1 > ProcedureTitleLineLast(Module, Procedure) Then
'        Do Until Len(Module.codeModule.Lines(nLine, 1)) _
'               - Len(Trim(Module.codeModule.Lines(nLine, 1))) = 4
'            nLine = nLine - 1
'        Loop
'    End If
'    StartLine = nLine
'    cpsCurrentRegionLineBlockFirst = StartLine
'End Function
'
'Function cpsCurrentRegionLineBlockLast() As String
'    Dim Module As VBComponent
'    Set Module = ActiveModule
'    If Len(Module.codeModule.Lines(cpsLineFirst, 1)) = 0 Then Exit Function
'    Dim Procedure As String
'        Procedure = ActiveProcedure
'    Dim EndLine As Long
'        EndLine = cpsLineLast
'    Dim nLine As Long
'        nLine = EndLine
'    If nLine + 1 < ProcedureLinesLast(Module, Procedure) Then
'        Do Until Len(Module.codeModule.Lines(nLine, 1)) _
'               - Len(Trim(Module.codeModule.Lines(nLine, 1))) = 4
'            nLine = nLine + 1
'        Loop
'    End If
'    EndLine = nLine
'    cpsCurrentRegionLineBlockLast = EndLine
'End Function
'
'Function cpsCurrentRegionLineFirst() As String
'    Dim Module As VBComponent
'    Set Module = ActiveModule
'    If Len(Module.codeModule.Lines(cpsLineFirst, 1)) = 0 Then Exit Function
'
'    Dim Procedure As String
'        Procedure = ActiveProcedure
'    Dim StartLine As Long
'        StartLine = cpsLineFirst
'    Dim nLine As Long
'        nLine = StartLine
'    Do While nLine - 1 > 1 _
'    And nLine - 1 > ProcedureTitleLineLast(Module, Procedure) _
'    And Len(Trim(Module.codeModule.Lines(nLine - 1, 1))) > 0
'        nLine = nLine - 1
'    Loop
'    StartLine = nLine
'    cpsCurrentRegionLineFirst = StartLine
'End Function
'
'Function cpsCurrentRegionLineLast() As String
'    Dim Module As VBComponent
'    Set Module = ActiveModule
'    If Len(Module.codeModule.Lines(cpsLineFirst, 1)) = 0 Then Exit Function
'    Dim Procedure As String
'        Procedure = ActiveProcedure
'    Dim EndLine As Long
'        EndLine = cpsLineLast
'    Dim nLine As Long
'        nLine = EndLine
'    Do While nLine + 1 < ProcedureLinesLast(Module, Procedure) _
'    And Len(Trim(Module.codeModule.Lines(nLine + 1, 1))) > 0
'        nLine = nLine + 1
'    Loop
'    EndLine = nLine
'    cpsCurrentRegionLineLast = EndLine
'End Function
'
'Function cpsCurrentRegionLinesCode() As String
'    Dim Module As VBComponent
'    Set Module = ActiveModule
'    If Len(Module.codeModule.Lines(cpsLineFirst, 1)) = 0 Then Exit Function
'
'    Dim Procedure As String
'        Procedure = ActiveProcedure
'    Dim StartLine As Long
'        StartLine = cpsLineFirst
'    Dim nLine As Long
'        nLine = StartLine
'    Do While nLine - 1 > 1 _
'    And nLine - 1 > ProcedureTitleLineLast(Module, Procedure) _
'    And Len(Trim(Module.codeModule.Lines(nLine - 1, 1))) > 0
'        nLine = nLine - 1
'    Loop
'    StartLine = nLine
'
'    Dim EndLine As Long
'        EndLine = cpsLineLast
'    nLine = EndLine
'    Do While nLine + 1 < ProcedureLinesLast(Module, Procedure) _
'    And Len(Trim(Module.codeModule.Lines(nLine + 1, 1))) > 0
'        nLine = nLine + 1
'    Loop
'    EndLine = nLine
'    cpsCurrentRegionLinesCode = Module.codeModule.Lines(StartLine, EndLine - StartLine + 1)
'End Function

Sub Comment()
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Dim rowLine As String
    Dim i As Long
    For i = RowFirst To RowLast
        CommentTargetLine i
    Next
    oModule.CodeModule.CodePane.SetSelection RowFirst, 1, RowLast, 1000
End Sub

Public Sub CommentTargetLine(targetLine As Long)
'@INCLUDE PROCEDURE IsCommentLine
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Dim sLine As String:  sLine = oModule.CodeModule.Lines(targetLine, 1)
    If IsCommentLine(sLine) Then Exit Sub
    Dim dif As Long:        dif = Len(sLine) - Len(LTrim(sLine))
    oModule.CodeModule.ReplaceLine targetLine, Space(dif) & "'" & Trim(sLine)
End Sub

Sub UnComment()
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Dim i As Long
    For i = RowFirst To RowLast
        UncommentTargetLine i
    Next
    oModule.CodeModule.CodePane.SetSelection RowFirst, 1, RowLast, 1000
End Sub

Public Sub UncommentTargetLine(targetLine As Long)
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Dim sLine As String
    With oModule.CodeModule
        sLine = .Lines(targetLine, 1)
        If Left(Trim(sLine), 1) = "'" Then
            .ReplaceLine targetLine, Replace(sLine, "'", "", , 1)
        End If
    End With
End Sub

Sub RemAdd()
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Dim i As Long
    For i = RowFirst To RowLast
        RemTargetLine i
    Next
    oModule.CodeModule.CodePane.SetSelection RowFirst, 1, RowLast, 1000
End Sub

Sub RemTargetLine(targetLine As Long)
'@INCLUDE PROCEDURE IsCommentLine
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Dim rowLine As String: rowLine = oModule.CodeModule.Lines(targetLine, 1)
    If IsCommentLine(rowLine) Then Exit Sub
    oModule.CodeModule.ReplaceLine targetLine, Space(Len(rowLine) - Len(LTrim(rowLine))) & "Rem " & Trim(rowLine)
End Sub

Sub RemRemove()
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Dim i As Long
    For i = RowFirst To RowLast
        UnremTargetLine i
    Next
    oModule.CodeModule.CodePane.SetSelection RowFirst, 1, RowLast, 1000
End Sub

Sub UnremTargetLine(targetLine As Long)
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Dim sLine As String
    With oModule.CodeModule
        sLine = .Lines(targetLine, 1)
        If Left(Trim(sLine), 4) = "Rem " Then
            .ReplaceLine targetLine, Replace(sLine, "Rem ", "", , 1)
        End If
    End With
End Sub

Sub BringProcedureHere()
'@INCLUDE PROCEDURE ActiveProcedure
'@INCLUDE PROCEDURE ActiveModule
'@INCLUDE PROCEDURE ActiveCodepaneWorkbook
'@INCLUDE CLASS aCodeModule
'@INCLUDE CLASS aProcedure
'@AssignedModule aCodeModule
    aProcedure.Init(ActiveCodepaneWorkbook, ActiveModule, ActiveProcedure).BringProcedureHere Selection
End Sub

Sub AlignAs()
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Align " As ", SearchFromLeft:=True
End Sub

Sub AlignColumn()
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Align ":", SearchFromLeft:=True
    Align ":", SearchFromLeft:=False
End Sub

Sub AlignComments()
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule
    Align "'", SearchFromLeft:=False
End Sub

Sub Align(AlignString As String, SearchFromLeft As Boolean, Optional AlignAtColumn As Long)
'@INCLUDE PROCEDURE StringFormatAlignRowsElements
'@INCLUDE CLASS aCodeModule
'@AssignedModule aCodeModule

    Dim s As String:        s = StringFormatAlignRowsElements(SelectionLinesCode, AlignString, SearchFromLeft, AlignAtColumn)
    Dim LineFirst As Long:  LineFirst = RowFirst
    oModule.CodeModule.DeleteLines LineFirst, rowCount
    oModule.CodeModule.InsertLines LineFirst, s
    SelectRows
End Sub

Public Property Get ProceduresByName() As Collection
    Dim out           As New Collection
    Dim s             As String: s = Selection
    Dim ProcedureName As String
    Dim Procedures    As Collection
    Set Procedures = aWorkbook.Init(oWorkbook).Procedures(True, False, False, False)
    Dim Procedure     As aProcedure
    For Each Procedure In Procedures
        ProcedureName = Procedure.Name
        If RegexTest(s, ProcedureName) Then out.Add ProcedureName, ProcedureName
    Next
    Set ProceduresByName = out
End Property

Function ProceduresByDeclaration() As Collection
'@AssignedModule aCodeModule
'@INCLUDE PROCEDURE ProceduresOfTXT
'@INCLUDE PROCEDURE RegexTest
'@INCLUDE CLASS aCodeModule
'@INCLUDE CLASS aProcedure
    Dim out           As New Collection
    Dim s             As String: s = Selection
    Dim ProcedureName As String
    Dim Procedures    As Collection
    Set Procedures = ProceduresOfTXT(s)
    Dim Procedure     As aProcedure
    For Each Procedure In Procedures
        ProcedureName = Procedure.Name
        If RegexTest(s, ProcedureName) Then out.Add ProcedureName, ProcedureName
    Next
    Set ProceduresByDeclaration = out
End Function




Public Sub AssignEnumValues(Optional ToThePower As Boolean = True)
'@AssignedModule aCodeModule
'@INCLUDE CLASS aCodeModule
    Dim row1 As Long, row2 As Long
    row1 = ActiveEnumStartLine
    row2 = ActiveEnumEndLine
    Dim Code As String: Code = cm.Lines(row1 + 1, row2 - row1 - 1)
    Dim arr: arr = Split(Code, vbNewLine)
    Code = ""
    Dim out As String
    Dim i As Long
    For i = 0 To UBound(arr)
        If InStr(1, arr(i), "=") > 0 Then arr(i) = Split(arr(i), "=")(0)
        arr(i) = Space(4) & Trim(arr(i))
    Next
    If ToThePower = True Then
        For i = 0 To UBound(arr)
            out = arr(i) & "= 2 ^ " & i
            Code = IIf(Code = "", out, Code & vbNewLine & out)
        Next
    Else
        For i = 0 To UBound(arr)
            out = arr(i) & "= " & i + 1
            Code = IIf(Code = "", out, Code & vbNewLine & out)
        Next
    End If
    cm.DeleteLines row1 + 1, row2 - row1 - 1
    cm.InsertLines row1 + 1, Code
End Sub

Public Sub EnumToCase()
    Rem point inside enum before calling this from immediate window or vbe menu button
'@AssignedModule aCodeModule
'@INCLUDE PROCEDURE CLIP
'@INCLUDE CLASS aCodeModule
    Dim enumName As String: enumName = ActiveEnumName
    Dim arr:                arr = Split(oModule.CodeModule.Lines(ActiveEnumStartLine + 1, ActiveEnumEndLine - ActiveEnumStartLine - 1), vbNewLine)
    Dim out As String:      out = "Select case Variable "
    Dim Code As String:     Code = out
    Dim i As Long
    For i = 0 To UBound(arr)
        If InStr(1, arr(i), "=") > 0 Then arr(i) = Split(arr(i), "=")(0)
        arr(i) = Trim(arr(i))
    Next
    For i = 0 To UBound(arr)
        If arr(i) <> "" Then
            out = "    Case is = " & enumName & "." & arr(i) & vbNewLine
            Code = IIf(Code = "", out, Code & vbNewLine & out)
        End If
    Next
    Code = Code & vbNewLine & "End Select"
    Debug.Print "The following was copied to clipboard:"
    Debug.Print String(20, "-")
    Debug.Print Code
    CLIP Code
End Sub

Private Function ActiveEnumName() As String
'@AssignedModule aCodeModule
'@INCLUDE CLASS aCodeModule
    Dim Line As String
    Dim i As Long
    For i = aCodeModule.Init(oModule).RowFirst To 1 Step -1
        Line = oModule.CodeModule.Lines(i, 1)
        If InStr(1, Line, "Enum ") > 0 Then
            ActiveEnumName = Trim(Split(Line, "Enum ")(1))
            Exit Function
        End If
    Next
End Function

Private Function ActiveEnumStartLine() As Long
'@AssignedModule aCodeModule
'@INCLUDE CLASS aCodeModule
    Dim i    As Long
    Dim Line As String
    For i = aCodeModule.Init(oModule).RowFirst To 1 Step -1
        Line = oModule.CodeModule.Lines(i, 1)
        If InStr(1, Line, "Enum ") > 0 Then
            ActiveEnumStartLine = i
            Exit Function
        End If
    Next
End Function

Function ActiveEnumEndLine() As Long
'@AssignedModule aCodeModule
'@INCLUDE CLASS aCodeModule
    Dim i        As Long
    Dim enumName As String
    Dim Line     As String
    For i = aCodeModule.Init(oModule).RowFirst To oModule.CodeModule.CountOfLines
        Line = oModule.CodeModule.Lines(i, 1)
        If InStr(1, Line, "End Enum") > 0 Then
            ActiveEnumEndLine = i
            Exit Function
        End If
    Next
End Function

Function Procedure() As aProcedure
'@INCLUDE CLASS aProcedure
'@AssignedModule aCodeModule
'@INCLUDE PROCEDURE ActiveProcedure
'@INCLUDE PROCEDURE Toast
'@INCLUDE CLASS aCodeModule
    If ActiveProcedure = "" Then
        Toast "The carret is not inside a procedure"
        Exit Function
    End If
    Set Procedure = aProcedure.Active
End Function

Sub injectDivider(Optional Character As String = "~")
'@AssignedModule aCodeModule
'@INCLUDE CLASS aCodeModule
    If Len(Trim(cm.Lines(RowFirst, 1))) = 0 Then
        cm.ReplaceLine RowFirst, "'" & String(Procedure.LargestLineLength - 1, "character")
    Else
        cm.InsertLines RowFirst, "'" & String(Procedure.LargestLineLength - 1, "character")
    End If
End Sub

'aProcedure	Class


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Class      : aProcedure
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 04-05-2023 12:18    Alex
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


Option Explicit

Private oProcedure As String
Private oWorkbook As Workbook
Private oModule As VBComponent
Private oProcKind As vbext_ProcKind

Private coll_LinkedProcedures As Collection
Private coll_LinkedProceduresDeep As Collection

Public Enum Code_Part
    All_Code
    Declaration_Code
    Declaration_Clean_Code
    Body_Code
    Header_Code
End Enum

Public Enum Line_Index
    Procedure_First
    Procedure_Last
    Procedure_Count
    Body_First
    Body_First_AfterComments
    Body_Last
    Body_Count
    Declaration_First
    Declaration_Last
    Declaration_Count
    Header_First
    Header_Last
    Header_Count
End Enum

Public Enum Property_Type
    Modified
    Ignore
    Parent_Assigned
End Enum

Private Sub Class_Initialize()
'    ProjetFoldersCreate
'@AssignedModule aProcedure
'@INCLUDE PROCEDURE ProjetFoldersCreate
'@INCLUDE CLASS aProcedure
End Sub

Public Function Init( _
                    Optional TargetWorkbook As Workbook, _
                    Optional Module As VBComponent, _
                    Optional Procedure As String, _
                    Optional ProcKind As vbext_ProcKind) As aProcedure
'@AssignedModule aProcedure
'@INCLUDE PROCEDURE AssignCPSvariables
'@INCLUDE CLASS aProcedure
    If Not AssignCPSvariables(TargetWorkbook, Module, Procedure) Then End
    oProcedure = Procedure
    Set oWorkbook = TargetWorkbook
    Set oModule = Module
    oProcKind = ProcKind
    Set Init = Me
    Set coll_LinkedProceduresDeep = Nothing
End Function

Public Function Active() As aProcedure
'@AssignedModule aProcedure
'@INCLUDE PROCEDURE ActiveModule
'@INCLUDE PROCEDURE ActiveCodepaneWorkbook
'@INCLUDE CLASS aCodeModule
'@INCLUDE CLASS aProcedure
    Dim Module As VBComponent: Set Module = ActiveModule
    Dim Procedure As String
    Dim i As Long
    Dim ProcKind As vbext_ProcKind
    Dim lineNum As Long: lineNum = aCodeModule.Init(Module).RowFirst
    For i = 0 To 4
        ProcKind = i
        Procedure = Module.CodeModule.ProcOfLine(lineNum, ProcKind)
        If Procedure <> vbNullString Then
            Init ActiveCodepaneWorkbook, Module, Procedure, ProcKind
            Set Active = Me
            Exit For
        End If
    Next
End Function

Public Sub Copy( _
                TargetWorkbook As Workbook, _
                Overwrite As Boolean)
'@AssignedModule aProcedure
'@INCLUDE PROCEDURE LinkedProceduresDeep
'@INCLUDE PROCEDURE ModuleAddOrSet
'@INCLUDE PROCEDURE ModuleOfProcedure
'@INCLUDE PROCEDURE ProcedureExists
'@INCLUDE PROCEDURE ProcedureReplace
'@INCLUDE CLASS aProcedure
    Dim Module As VBComponent
    Dim s As String
    Dim Procedure As Variant
    Dim AP As aProcedure
    For Each Procedure In LinkedProceduresDeep
        Set AP = New aProcedure
        AP.Init oWorkbook, , CStr(Procedure)
        s = AP.Code_All
        If Not ProcedureExists(TargetWorkbook, CStr(Procedure)) Then
            Set Module = ModuleAddOrSet(TargetWorkbook, "vbArcImports", vbext_ct_StdModule)
            Module.CodeModule.AddFromString s
        Else
            Set Module = ModuleOfProcedure(TargetWorkbook, CStr(Procedure))
            If Overwrite = True Then ProcedureReplace Module, CStr(Procedure), s
        End If
    Next
End Sub

Public Function Contains( _
                        This As String, _
                        WholeWord As Boolean, _
                        MatchCase As Boolean, _
                        PatternSearch As Boolean) As String
'@AssignedModule aProcedure
'@INCLUDE CLASS aProcedure

    Contains = oModule.CodeModule.Find( _
                                        This, _
                                        1, _
                                        LineIndex(Procedure_First), _
                                        LineIndex(Procedure_Last), _
                                        10000, _
                                        WholeWord, _
                                        MatchCase, _
                                        PatternSearch)
End Function

Public Function Contains_InHeader( _
                                This As String, _
                                WholeWord As Boolean, _
                                MatchCase As Boolean, _
                                PatternSearch As Boolean) As String
'@AssignedModule aProcedure
'@INCLUDE CLASS aProcedure

    Contains_InHeader = oModule.CodeModule.Find( _
                                        This, _
                                        1, _
                                        LineIndex(Header_First), _
                                        LineIndex(Header_Last), _
                                        10000, _
                                        WholeWord, _
                                        MatchCase, _
                                        PatternSearch)
End Function

Public Function Contains_InBody( _
                                This As String, _
                                WholeWord As Boolean, _
                                MatchCase As Boolean, _
                                PatternSearch As Boolean) As String
'@AssignedModule aProcedure
'@INCLUDE CLASS aProcedure

    Contains_InBody = oModule.CodeModule.Find( _
                                        This, _
                                        1, _
                                        LineIndex(Body_First), _
                                        LineIndex(Body_Last), _
                                        10000, _
                                        WholeWord, _
                                        MatchCase, _
                                        PatternSearch)
End Function

Public Function Scope() As String
'@AssignedModule aProcedure
'@INCLUDE CLASS aProcedure
    Dim sTitle As String
        sTitle = Code_Declaration_Clean
    If UCase(sTitle) Like UCase("*" & "Public " & "*" & oProcedure & "*") Then
        Scope = "Public"
    ElseIf UCase(sTitle) Like UCase("*" & "Private " & "*" & oProcedure & "*") Then
        Scope = "Private"
    Else
        Select Case Parent.Type
        Case vbext_ct_StdModule, vbext_ct_ClassModule
            Scope = "Public"
        Case Else
            Scope = "Private"
        End Select
    End If
End Function

Private Sub AssignLineStartEnd(CodePart As Code_Part, ByRef LineStart As Long, ByRef LineEnd As Long)
'@AssignedModule aProcedure
'@INCLUDE CLASS aProcedure
    Select Case CodePart
    Case Code_Part.All_Code
        LineStart = LineIndex(Procedure_First)
        LineEnd = LineIndex(Procedure_Last)
    Case Code_Part.Body_Code
        LineStart = LineIndex(Body_First)
        LineEnd = LineIndex(Body_Last)
    Case Code_Part.Header_Code
        LineStart = LineIndex(Header_First)
        LineEnd = LineIndex(Header_Last)
    End Select
End Sub

Public Sub CommentsToOwnLine()
'@AssignedModule aProcedure
'@INCLUDE PROCEDURE CommentsMoveToOwnLine
'@INCLUDE CLASS aProcedure
    Dim s As String:    s = CommentsMoveToOwnLine(Code_All)
    Dim i As Long:      i = LineIndex(Procedure_First)
    Delete
    oModule.CodeModule.InsertLines i, s
End Sub

Public Function Property(PropertyType As Property_Type) As Variant
'@AssignedModule aProcedure
'@INCLUDE CLASS aProcedure
    Select Case PropertyType
    
        Case Property_Type.Modified:           Property = PropertyGet(Modified)
        Case Property_Type.Parent_Assigned:    Property = PropertyGet(Parent_Assigned)
        
    End Select
End Function

Public Property Get ArgumentCount() As Long
    Dim s As String: s = Code_Declaration_Clean
    If s Like "*" & oProcedure & "()*" Then Exit Property
    ArgumentCount = UBound(Split(s, ",")) + 1
End Property

Public Property Get Name() As String
    Name = oProcedure
End Property

Public Property Get ReturnType() As String
    ReturnType = "Invalid"
    If KindAsString <> "Function" Then Exit Property
    Dim Title As String: Title = Code_Declaration_Clean
    If Title Like "*) As *" Then
        ReturnType = Split(Title, ") As ")(1)
    Else
        ReturnType = "Unspecified"
    End If
End Property

Public Property Get Parent() As VBComponent
    Set Parent = oModule
End Property

Public Property Get ParentAssigned() As VBComponent
    Dim moduleName As String: moduleName = Property(Parent_Assigned)
    If moduleName = "" Then Exit Property
    Set ParentAssigned = ModuleAddOrSet(oWorkbook, moduleName, vbext_ct_StdModule)
'End Property

'Public Property Set ParentAssigned(Module As VBComponent)
'
'    Set oModule = Module
End Property

Public Property Get KindAsLong() As Long
    Dim s As String: s = Code_Declaration_Clean
    Select Case True
        Case InStr(1, s, "Get " & oProcedure) > 0:  KindAsLong = vbext_pk_Get '3
        Case InStr(1, s, "Let " & oProcedure) > 0:  KindAsLong = vbext_pk_Let '1
        Case InStr(1, s, "Set " & oProcedure) > 0:  KindAsLong = vbext_pk_Set '2
        Case Else:                                  KindAsLong = vbext_pk_Proc '0
    End Select
End Property

Public Property Get KindAsString() As String
    Dim s As String: s = Code_Declaration_Clean
    Select Case True
        Case InStr(1, s, "Get " & oProcedure) > 0:  KindAsString = "Get"
        Case InStr(1, s, "Let " & oProcedure) > 0:  KindAsString = "Let"
        Case InStr(1, s, "Set " & oProcedure) > 0:  KindAsString = "Set"
        Case Else
            If InStr(1, s, "Function " & oProcedure) > 0 Then
                KindAsString = "Function"
            ElseIf InStr(1, s, "Sub " & oProcedure) > 0 Then
                KindAsString = "Sub"
            End If
    End Select
End Property


Private Sub Class_Terminate()
   ReSetVariables
End Sub

Private Sub ReSetVariables()
    Set oWorkbook = Nothing
    Set oModule = Nothing
        oProcedure = ""
End Sub

Public Function LineIndex(idx As Line_Index) As Long
    Select Case idx
        Case Line_Index.Procedure_First:            LineIndex = LineFirst
        Case Line_Index.Procedure_Last:             LineIndex = LineLast
        Case Line_Index.Procedure_Count:            LineIndex = LineCount
        Case Line_Index.Declaration_First:          LineIndex = DeclarationLineFirst
        Case Line_Index.Declaration_Last:           LineIndex = DeclarationLineLast
        Case Line_Index.Declaration_Count:          LineIndex = DeclarationLineCount
        Case Line_Index.Body_First:                 LineIndex = BodyLineFirst
        Case Line_Index.Body_First_AfterComments:   LineIndex = BodyLineFirstAfterComments
        Case Line_Index.Body_Last:                  LineIndex = BodyLineLast
        Case Line_Index.Body_Count:                 LineIndex = BodyLineCount
        Case Line_Index.Header_First:               LineIndex = HeaderLineFirst
        Case Line_Index.Header_Last:                LineIndex = HeaderLineLast
        Case Line_Index.Header_Count:               LineIndex = HeaderLineCount
                
    End Select
End Function

Public Function LineLike(This As String, CodePart As Code_Part) As Long
    Dim LineStart As Long, LineEnd As Long
    AssignLineStartEnd CodePart, LineStart, LineEnd
    Dim targetLine As String
    Dim i As Long
    For i = LineStart To LineEnd
        targetLine = Trim(oModule.CodeModule.Lines(i, 1))
        If UCase(targetLine) Like UCase(This) Then
            LineLike = i
            Exit Function
        End If
    Next
End Function

Public Sub EnsureBlankLineBeforeProcedure()
    Dim Line As Long: Line = DeclarationLineFirst
    If Line = 1 Then oModule.CodeModule.InsertLines 1, "": Exit Sub
    Dim check As String
    On Error Resume Next
    check = oModule.CodeModule.ProcOfLine(Line - 1, oProcKind)
    On Error GoTo 0
    If check <> Name Then oModule.CodeModule.InsertLines Line, ""
End Sub

Public Function HeaderLineFirst() As Long
    EnsureBlankLineBeforeProcedure
    HeaderLineFirst = LineFirst
End Function

Public Function HeaderLineLast() As Long
    EnsureBlankLineBeforeProcedure
    HeaderLineLast = DeclarationLineFirst - 1
End Function

Public Function HeaderLineCount()
    HeaderLineCount = HeaderLineLast - HeaderLineFirst + 1
End Function

Public Function LineFirst() As Long
    '@todo Fix
    LineFirst = oModule.CodeModule.procStartLine(oProcedure, oProcKind) 'findProcedureKind(omodule,oprocedure)
    If LineFirst = 0 Then Debug.Print "error in firstline (wrong procKind)": End
End Function

Public Function LineCount() As Long
    LineCount = oModule.CodeModule.ProcCountLines(oProcedure, oProcKind)
End Function

Public Function LineLast() As Long
    LineLast = LineFirst + LineCount - 1
End Function

Public Function BodyLineFirst() As Long
    BodyLineFirst = DeclarationLineFirst + DeclarationLineCount
End Function

Public Function BodyLineFirstAfterComments() As Long
    Dim i As Long
    Dim s As String
    For i = LineIndex(Body_First) To LineIndex(Body_Last)
        s = Trim(oModule.CodeModule.Lines(i, 1))
        If s = vbNullString Then
            Exit For
        ElseIf Left(s, 1) = "'" Then
        ElseIf Left(s, 3) = "Rem" Then
        ElseIf Right(Trim(oModule.CodeModule.Lines(i - 1, 1)), 1) = "_" Then
        ElseIf Right(s, 1) = "_" Then
        Else
            Exit For
        End If
    Next
    BodyLineFirstAfterComments = i
End Function

Public Function BodyLineLast() As Long
    BodyLineLast = LineLast - 1
End Function

Public Function BodyLineCount() As Long
    BodyLineCount = BodyLineLast - BodyLineFirst + 1
End Function

Public Function DeclarationLineFirst() As Long

    DeclarationLineFirst = oModule.CodeModule.ProcBodyLine(oProcedure, oProcKind)
End Function


Public Function DeclarationLineLast() As Long
    DeclarationLineLast = DeclarationLineFirst + DeclarationLineCount - 1
End Function

Public Function DeclarationLineCount() As Long
    Dim targetLine As Long: targetLine = DeclarationLineFirst
    Dim counter As Long: counter = 1
    Dim s As String: s = oModule.CodeModule.Lines(targetLine, counter)
    Do While Right(s, 1) = "_"
        counter = counter + 1
        s = oModule.CodeModule.Lines(targetLine, counter)
    Loop
    DeclarationLineCount = counter
End Function

Public Function Code_All()
    Code_All = oModule.CodeModule.Lines(LineFirst, LineCount)
End Function
Public Function Code_Body()
    Code_Body = oModule.CodeModule.Lines(BodyLineFirst, BodyLineCount)
End Function
Public Function Code_Header()
    Code_Header = oModule.CodeModule.Lines(HeaderLineFirst, HeaderLineCount)
End Function
Public Function Code_Declaration()
    Code_Declaration = oModule.CodeModule.Lines(DeclarationLineFirst, DeclarationLineCount)
End Function
Public Function Code_Declaration_Clean()
        If InStr(1, Code_Declaration, "_") = 0 Then
            Code_Declaration_Clean = Trim(Code_Declaration)
        Else
            Code_Declaration_Clean = VBA.Replace(Join(ArrayRemoveEmptyElements(ArrayTrim(Split(Code_Declaration, "_" & vbNewLine))), " "), "( ", "(")
        End If
End Function

Public Function collLinkedProceduresDeep() As Collection
    If coll_LinkedProceduresDeep Is Nothing Then
        Set coll_LinkedProceduresDeep = LinkedProceduresDeep
    End If
    Set collLinkedProceduresDeep = coll_LinkedProceduresDeep
End Function

Public Function collLinkedProcedures() As Collection
    If coll_LinkedProcedures Is Nothing Then
        Set coll_LinkedProcedures = LinkedProcedures
    End If
    Set collLinkedProcedures = coll_LinkedProcedures
End Function

Public Function LinkedProcedures() As Collection
'@TODO befor Procedues was a collection of strings, now objects. Use aWorkbook...ProceduresArray???
    Dim Procedures As Collection
    Set Procedures = aWorkbook.Init(oWorkbook).ProceduresNames(True, False, False, False)
    Dim s As String: s = Code_All
    Dim coll As New Collection
    Dim Procedure As Variant
    For Each Procedure In Procedures
        If UCase(CStr(Procedure)) <> UCase(CStr(oProcedure)) Then
            If RegexTest(s, "\W" & CStr(Procedure) & "[.(\W]") = True Then
                coll.Add Procedure, CStr(Procedure)
            End If
        End If
    Next
    Set LinkedProcedures = coll
End Function

'* Modified   : Date and Time       Author              Description
'* Updated    : 20-07-2023 10:45    Alex                code fix

Public Function LinkedProceduresDeep() As Collection
'@LastModified 2307201045
    Dim AllProcedures As Collection:       Set AllProcedures = aWorkbook.Init(oWorkbook).ProceduresNames(True, False, False, False)
    Dim Processed As Collection:           Set Processed = New Collection
    Dim CalledProcedures As Collection:    Set CalledProcedures = New Collection

    Dim Procedure As Variant
    Dim Module As VBComponent

    Processed.Add CStr(oProcedure), CStr(oProcedure)
    CalledProcedures.Add CStr(oProcedure), CStr(oProcedure)
    On Error Resume Next
    For Each Procedure In LinkedProcedures
    CalledProcedures.Add CStr(Procedure), CStr(Procedure)
    Next
    On Error GoTo 0
    
    Dim AP As aProcedure
    Dim CalledProceduresCount As Long
        CalledProceduresCount = CalledProcedures.count
    Dim element
repeat:
    For Each element In CalledProcedures
        If Not aCollection.Init(Processed).Contains(, CStr(element)) Then
            On Error Resume Next
            Set AP = New aProcedure
            For Each Procedure In AP.Init(oWorkbook, , CStr(element)).LinkedProcedures
            CalledProcedures.Add CStr(Procedure), CStr(Procedure)
            Next
            On Error GoTo 0
            Processed.Add CStr(element), CStr(element)
        End If
    Next
    If CalledProcedures.count > CalledProceduresCount Then
        CalledProceduresCount = CalledProcedures.count
        GoTo repeat
    End If

    Set LinkedProceduresDeep = aCollection.Init(CalledProcedures).Sort.Items
End Function

Sub UnfoldDeclaration()
    Dim Result As String: Result = Code_Declaration_Clean & vbLf & Code_Body & vbLf & oModule.CodeModule.Lines(LineIndex(Procedure_Last), 1)
    Replace Result
End Sub
Sub FoldDeclaration()
    Dim startLine As Long
    Dim LastLine As Long
    Dim FirstColumn As Long
    Dim LastColumn As Long

    If ArgumentCount = 0 Then Exit Sub
    Dim cp As aCodeModule
    Set cp = aCodeModule.Init(oModule)
    
    startLine = LineIndex(Declaration_First)
    FirstColumn = InStr(1, oModule.CodeModule.Lines(startLine, 1), "(")
    LastLine = LineIndex(Declaration_Last)
'    Do While InStr(1, oModule.CodeModule.Lines(LastLine, 1), ")") = 0
'        LastLine = LastLine - 1
'    Loop
    LastColumn = InStr(1, oModule.CodeModule.Lines(LastLine, 1), ")") + 1
    If LastColumn = 0 Then Exit Sub
    
    cp.SetSelection startLine, FirstColumn, LastLine, LastColumn
    cp.FoldLine
    cp.SetSelection startLine, FirstColumn, LineIndex(Declaration_Last), 10000
End Sub

Public Sub Export()
    Dim Procedure
    For Each Procedure In collLinkedProceduresDeep
        LinkedExport CStr(Procedure)
    Next
End Sub

Private Sub LinkedExport(Procedure As String)
    Dim Module As VBComponent
    Set Module = ModuleOfProcedure(oWorkbook, Procedure)
    Dim c As New aProcedure
    c.Init oWorkbook, Module, Procedure
    Dim proclastmod     As String:        proclastmod = c.Property(Modified)
    If proclastmod = vbNullString Then
        c.InjectLinkedLists
        c.PropertySet Modified, Format(Now, "yymmddhhnn")
        proclastmod = c.Property(Modified)
    End If
    Dim s               As String:      s = c.Code_All
    Dim FileFullName    As String:      FileFullName = LOCAL_LIBRARY_PROCEDURES & Procedure & ".txt"
    
    If FileExists(FileFullName) Then
        Dim filelastmod
            filelastmod = StringLastModified(TxtRead(FileFullName))
        If proclastmod > filelastmod Then
            Debug.Print "OVERWROTE " & Procedure
            TxtOverwrite FileFullName, s
        Else
            Debug.Print "Skipping " & Procedure & " because:"
            Debug.Print vbTab & "StringLastModified(TxtRead(FileFullName)) >= Property(Modified)"
        End If
    Else
        Debug.Print "NEW " & Procedure
        TxtOverwrite FileFullName, s
    End If
    Dim element
    For Each element In c.LinkedUserforms
        oWorkbook.VBProject.VBComponents(element).Export LOCAL_LIBRARY_USERFORMS & element & ".frm"
    Next
    For Each element In c.LinkedClasses
        oWorkbook.VBProject.VBComponents(element).Export LOCAL_LIBRARY_CLASSES & element & ".cls"
    Next
    For Each element In c.LinkedDeclarations
        ExportDeclaration CStr(element)
    Next
End Sub

Sub ExportDeclaration(DeclarationName As String)
    aWorkbook.Init(oWorkbook).DeclarationsTableCreate
    Dim TargetWorksheet As Worksheet
    Set TargetWorksheet = ThisWorkbook.Sheets("Declarations_Table")

    Dim codeName As String
    Dim codeText As String
    Dim cell As Range
    On Error Resume Next
    Set cell = TargetWorksheet.Columns(3).Find(DeclarationName, LookAt:=xlWhole)
    On Error GoTo 0
    If cell Is Nothing Then Exit Sub

    codeName = DeclarationName
    codeText = cell.offset(0, 1).text
    TxtOverwrite LOCAL_LIBRARY_DECLARATIONS & DeclarationName & ".txt", codeText

End Sub
Public Sub InjectLinkedLists()
    RemoveIncludeLines
    InjectLinkedDeclarations
    InjectLinkedClasses
    InjectLinkedUserforms
    InjectLinkedProcedures
End Sub

Public Sub Indent()
    Dim s As String
    Dim nIndent As Long
    Dim i As Long
    For i = LineIndex(Procedure_First) To LineIndex(Procedure_Last)
        s = LTrim$(oModule.CodeModule.Lines(i, 1))
        If Trim(s) <> "" Then
            If IsBlockEnd(s) Then nIndent = nIndent - 1
            If nIndent < 0 Then nIndent = 0
            s = Space$(nIndent * 4) & s
            oModule.CodeModule.ReplaceLine i, s
            If IsBlockStart(LTrim$(s)) Then nIndent = nIndent + 1
        End If
    Next
End Sub

Public Sub NumbersAdd()
    Dim counter As Long: counter = 1
    Dim LineStart As Long, LineEnd As Long
    AssignLineStartEnd Body_Code, LineStart, LineEnd
    Dim s As String
    Dim i As Long
    For i = LineStart To LineEnd
        s = oModule.CodeModule.Lines(i, 1)
        If IsLineNumberAble(s) _
        And Right(Trim(oModule.CodeModule.Lines(i - 1, 1)), 1) <> "_" Then
            oModule.CodeModule.ReplaceLine i, counter & ":" & s
            counter = counter + 1
        End If
    Next i
End Sub

Public Sub NumbersRemove()
    Dim counter As Long: counter = 1
    Dim LineStart As Long, LineEnd As Long
    AssignLineStartEnd Body_Code, LineStart, LineEnd
    Dim s As String
    Dim i As Long
    For i = LineStart To LineEnd
        s = oModule.CodeModule.Lines(i, 1)
        If IsNumeric(Left(Trim(s), 1)) Then
            oModule.CodeModule.ReplaceLine i, _
                Mid(s, InStr(s, ":") + 1)
                'Space(InStr(s, ":"))
        End If
    Next i
End Sub

Public Sub RemoveEmptyLines()
    Dim LineStart As Long, LineEnd As Long
    AssignLineStartEnd Body_Code, LineStart, LineEnd
    Dim i As Long
    For i = LineEnd To LineStart Step -1
        If Len(Trim(oModule.CodeModule.Lines(i, 1))) = 0 Then
            oModule.CodeModule.DeleteLines i, 1
        End If
    Next
End Sub

Public Sub CommentsRemove(RemoveRem As Boolean, CodePart As Code_Part)
    Replace StringCommentsRemove(Code_All, RemoveRem)

'    Dim N               As Long
'    Dim lineText        As String
'    Dim QUOTES          As Long
'    Dim Q               As Long
'    Dim StartPos        As Long
'    Dim L As Long
'    Dim LineStart As Long, LineEnd As Long
'    AssignLineStartEnd CodePart, LineStart, LineEnd
'    Dim j As Long
'    For j = LineEnd To LineStart Step -1
'        lineText = LTrim(oModule.CodeModule.Lines(j, 1))
'        If Not RemoveRem Then If lineText Like "Rem *" Then GoTo SKIP
'        StartPos = 1
'Retry:
'        N = InStr(StartPos, lineText, "'")
'        Q = InStr(StartPos, lineText, """")
'        QUOTES = 0
'        If Q < N Then
'            For L = 1 To N
'                If Mid(lineText, L, 1) = """" Then
'                    QUOTES = QUOTES + 1
'                End If
'            Next L
'        End If
'        If QUOTES = Application.WorksheetFunction.Odd(QUOTES) Then
'            StartPos = N + 1
'            GoTo Retry:
'        Else
'            Select Case N
'                Case Is = 0
'
'                Case Is = 1
'                    oModule.CodeModule.DeleteLines j, 1
'                Case Is > 1
'                    oModule.CodeModule.ReplaceLine j, Left(oModule.CodeModule.Lines(j, 1), N - 1)
'            End Select
'        End If
'SKIP:
'    Next j
End Sub

Public Sub RemoveIncludeLines()
    RemoveLinesLike "'@INCLUDE *"
End Sub

Public Sub RemoveLinesLike(This As String)
    Dim s As String
    Dim i As Long
    For i = LineIndex(Body_Last) To LineIndex(Body_First) Step -1
        s = Trim(oModule.CodeModule.Lines(i, 1))
        If s Like This Then oModule.CodeModule.DeleteLines i
    Next
End Sub

Public Sub InjectLinkedClasses()
    Dim ListOfImports As String
    Dim s As String: s = Code_All
    Dim element As Variant
    For Each element In LinkedClasses
        If InStr(1, s, "@INCLUDE CLASS " & element) = 0 _
        And InStr(1, ListOfImports, "@INCLUDE CLASS " & element) = 0 Then
            If ListOfImports = "" Then
                ListOfImports = "'@INCLUDE CLASS " & element
            Else
                ListOfImports = ListOfImports & vbNewLine & "'@INCLUDE CLASS " & element
            End If
        End If
    Next
    If ListOfImports <> "" Then
        oModule.CodeModule.InsertLines _
            LineIndex(Body_First_AfterComments), ListOfImports
    End If
End Sub

Public Sub InjectLinkedProcedures()
    Dim Procedures As Collection
    Set Procedures = collLinkedProcedures
    Dim ListOfImports As String
    Dim s As String: s = Code_All
    Dim Procedure As Variant
    For Each Procedure In Procedures
        If InStr(1, s, "@INCLUDE PROCEDURE " & Procedure) = 0 And InStr(1, ListOfImports, "@INCLUDE PROCEDURE " & Procedure) = 0 Then
            If ListOfImports = "" Then
                ListOfImports = "'@INCLUDE PROCEDURE " & Procedure
            Else
                ListOfImports = ListOfImports & vbNewLine & "'@INCLUDE PROCEDURE " & Procedure
            End If
        End If
    Next
    If ListOfImports <> "" Then
        oModule.CodeModule.InsertLines LineIndex(Body_First_AfterComments), ListOfImports
    End If
End Sub

Public Sub InjectLinkedUserforms()
    Dim ListOfImports As String
    Dim s As String: s = Code_All
    Dim element As Variant
    For Each element In LinkedUserforms
        If InStr(1, s, "@INCLUDE USERFORM " & element) = 0 And InStr(1, ListOfImports, "@INCLUDE USERFORM " & element) = 0 Then
            If ListOfImports = "" Then
                ListOfImports = "'@INCLUDE USERFORM " & element
            Else
                ListOfImports = ListOfImports & vbNewLine & "'@INCLUDE USERFORM " & element
            End If
        End If
    Next
    If ListOfImports <> "" Then
        oModule.CodeModule.InsertLines LineIndex(Body_First_AfterComments), ListOfImports
    End If
End Sub

Public Sub InjectLinkedDeclarations()
    Dim ListOfImports As String
    Dim s As String: s = Code_All
    Dim coll As New Collection
    Dim element As Variant
    For Each element In LinkedDeclarations
        If InStr(1, s, "'@INCLUDE DECLARATION " & element) = 0 Then
            If ListOfImports = "" Then
                ListOfImports = "'@INCLUDE DECLARATION " & element
            Else
                ListOfImports = ListOfImports & vbNewLine & "'@INCLUDE DECLARATION " & element
            End If
        End If
    Next
    If ListOfImports <> "" Then
        oModule.CodeModule.InsertLines LineIndex(Body_First_AfterComments), ListOfImports
    End If
End Sub

Public Function LinkedDeclarations() As Collection
    aWorkbook.Init(oWorkbook).DeclarationsTableCreate
    Dim TargetWorksheet As Worksheet: Set TargetWorksheet = ThisWorkbook.Sheets("Declarations_Table")
    Dim coll As New Collection
    Dim s As String: s = Code_All
    Dim element
    For Each element In DeclarationsTableKeywords
        If RegexTest(s, "\b ?" & CStr(element) & "\b") Then
            On Error Resume Next
            coll.Add CStr(element), CStr(element)
            On Error GoTo 0
        End If
    Next
    Set LinkedDeclarations = coll
End Function

Function DeclarationsTableKeywords() As Collection
    Dim TargetWorksheet As Worksheet
    Set TargetWorksheet = ThisWorkbook.Sheets("Declarations_Table")
    Dim Lr As Long: Lr = getLastRow(TargetWorksheet)
    Dim coll As New Collection
    Dim cell As Range
    For Each cell In TargetWorksheet.Range("C2:C" & Lr)
        On Error Resume Next
        coll.Add cell.text, cell.text
        On Error GoTo 0
    Next
    Set DeclarationsTableKeywords = coll
End Function

Public Function LinkedUserforms()
    Dim coll As New Collection
    Dim s As String: s = Code_All
    Dim formName
    For Each formName In aModules.Init(oWorkbook).UserformNames
        If RegexTest(s, "\W" & formName & "[.(\W]") = True Then coll.Add formName
    Next
    Set LinkedUserforms = coll
End Function




Public Function LinkedClasses() As Collection
    Dim coll As New Collection
    Dim var As Variant
        var = aModule.Init(oModule).ClassCalls
    Dim s As String: s = Code_All
    Dim Keyword As String
    Dim ClassName As String
    Dim element As Variant
    Dim i As Long
    On Error Resume Next
    For i = LBound(var, 1) To UBound(var, 1)
        If InStr(1, s, var(i, 1)) > 0 Or InStr(1, s, var(i, 2)) > 0 Then
            coll.Add var(i, 1), var(i, 1)
        End If
    Next
    For Each element In aModules.Init(oWorkbook).ClassNames
        If InStr(1, s, element) > 0 Then
            coll.Add element, CStr(element)
        End If
    Next
    On Error GoTo 0
    Set LinkedClasses = coll
End Function


Function LinkedSheets() As Collection
    Dim SheetNames As New Collection
    Dim TargetWorksheet As Worksheet
    For Each TargetWorksheet In oWorkbook.Worksheets
        On Error Resume Next
        SheetNames.Add TargetWorksheet.Name
        SheetNames.Add oWorkbook.Worksheets(TargetWorksheet.Name).codeName
        On Error GoTo 0
    Next
    Dim element
    Dim s As String: s = Code_All
    Dim coll As New Collection
    For Each element In SheetNames
        If InStr(1, CStr(element), " ") > 0 And InStr(1, s, CStr(element)) > 0 Then
            coll.Add CStr(element)
        ElseIf RegexTest(s, "\W" & CStr(element) & "[.(\W]") = True Then
            coll.Add CStr(element), CStr(element)
        End If
    Next
    Set LinkedSheets = coll
End Function


Public Sub ExportLinkedCode()
    Dim Code       As String:   Code = LinkedCode
    Dim MergedName As String:   MergedName = "Merged_" & oProcedure
    Dim fileName   As String:   fileName = LOCAL_LIBRARY_PROCEDURES & MergedName & ".txt"
    Debug.Print "OVERWROTE " & MergedName
    TxtOverwrite fileName, Code
    TxtPrependContainedProcedures fileName
    FollowLink fileName
End Sub

Private Function LinkedCode() As String
    Dim MergedString As String: MergedString = Code_All
    Dim Procedure
    For Each Procedure In collLinkedProceduresDeep
        MergedString = MergedString & vbNewLine & aProcedure.Init(oWorkbook, , CStr(Procedure)).Code_All
    Next
    LinkedCode = MergedString
End Function

Public Sub ImportDependencies(Optional Overwrite As Boolean)
    ImportProcedureDependencies oProcedure, Overwrite
End Sub

Private Sub ImportProcedureDependencies( _
                                        Procedure As String, _
                                        Overwrite As Boolean)

    Dim Module As VBComponent
    On Error Resume Next
    Set Module = ModuleOfProcedure(oWorkbook, Procedure)
    If Module Is Nothing Then Exit Sub
    On Error GoTo 0
    Dim obj As String
    Dim Code As String
        Code = aProcedure.Init(oWorkbook, Module, Procedure).Code_All
    Dim var
        var = Split(Code, vbNewLine)
        var = Filter(var, "'@INCLUDE ")
    Dim TextLine As Variant
    For Each TextLine In var
        TextLine = UCase(Trim(TextLine))
        If TextLine Like "'@INCLUDE *" Then
            obj = Split(TextLine, " ")(2)
            obj = VBA.Replace(obj, vbNewLine, "")
            Select Case True
                Case TextLine Like "'@INCLUDE PROCEDURE *":     ImportProcedure obj, Overwrite
                Case TextLine Like "'@INCLUDE CLASS *":         ImportClass obj, Overwrite
                Case TextLine Like "'@INCLUDE USERFORM *":      ImportUserform obj, Overwrite
                Case TextLine Like "'@INCLUDE DECLARATION *":   ImportDeclaration obj
            End Select
        End If
    Next
End Sub

Sub Update()
    ImportProcedure oProcedure, True
End Sub

Public Sub ImportProcedure( _
                            Procedure As String, _
                            Overwrite As Boolean)
'
    Dim ProcedurePath   As String:  ProcedurePath = LOCAL_LIBRARY_PROCEDURES & Procedure & ".txt"
    Dim Result As String
    On Error Resume Next
    Result = TxtRead(ProcedurePath)
    On Error GoTo 0

    If Len(Result) = 0 Then
        On Error Resume Next
        Result = TXTReadFromUrl(GITHUB_LIBRARY_PROCEDURES & Procedure & ".txt")
        On Error GoTo 0
        If Len(Result) > 0 And Not UCase(Result) Like ("*NOT FOUND*") Then
            TxtOverwrite ProcedurePath, Result
        Else
            Debug.Print "File " & Procedure & ".txt not found neither localy nor online"
            Exit Sub
        End If
    End If

    Dim filelastmod:    filelastmod = StringLastModified(Result)
    Dim proclastmod
    
    Dim Module As VBComponent
    If ProcedureExists(oWorkbook, Procedure) = True Then
        Set Module = ModuleOfProcedure(oWorkbook, Procedure)
        proclastmod = ProcedureLastModified(oWorkbook, Module, Procedure)
        If Overwrite = True Then
            If proclastmod = 0 Or proclastmod < filelastmod Then
                ProcedureReplace Module, Procedure, TxtRead(ProcedurePath)
            End If
        End If
    Else
'        Dim ModuleName As String
'            ModuleName = StringProcedureAssignedModule(Result)
'        If ModuleName = "" Then ModuleName = "vbArcImports"
'        Set Module = ModuleAddOrSet(oWorkbook, ModuleName, vbext_ct_StdModule)
    Set Module = ModuleAddOrSet(oWorkbook, "vbArcImports", vbext_ct_StdModule)
        Module.CodeModule.AddFromFile ProcedurePath
    End If

    ImportProcedureDependencies Procedure, Overwrite
End Sub

Sub ImportDeclaration(DeclarationName As String)
    Dim filepath As String
    filepath = LOCAL_LIBRARY_DECLARATIONS & DeclarationName & ".txt"
    Dim Result As String
    On Error Resume Next
    Result = TxtRead(filepath)
    On Error GoTo 0

    If Len(Result) = 0 Then 'CheckPath(filePath) = "I" Then
        On Error Resume Next
        Result = TXTReadFromUrl(GITHUB_LIBRARY_DECLARATIONS & DeclarationName & ".txt")
        On Error GoTo 0
        If Len(Result) > 0 And Not UCase(Result) Like ("*NOT FOUND*") Then
            TxtOverwrite filepath, Result
        Else
            Debug.Print "File " & DeclarationName & ".txt not found localy or online"
            Exit Sub
        End If
    Else

    End If
    If InStr(1, aWorkbook.Init(oWorkbook).Code, Result, vbTextCompare) > 0 Then Exit Sub
    Dim Module As VBComponent
    Set Module = ModuleAddOrSet(oWorkbook, "vbArcImports", vbext_ct_StdModule)
    Module.CodeModule.AddFromString FormatVBA7(Result)

End Sub

Sub ImportUserform(UserformName As String, _
                    Overwrite As Boolean)

    Dim FilePathFrM As String
        FilePathFrM = LOCAL_LIBRARY_USERFORMS & UserformName & ".frm"
    Dim FilePathFrX As String
        FilePathFrX = LOCAL_LIBRARY_USERFORMS & UserformName & ".frx"

    If CheckPath(FilePathFrM) = "I" Then
        On Error Resume Next
        Dim codeFrM As String
            codeFrM = TXTReadFromUrl(GITHUB_LIBRARY_USERFORMS & UserformName & ".frm")
        Dim codeFrX As String
            codeFrX = TXTReadFromUrl(GITHUB_LIBRARY_USERFORMS & UserformName & ".frx")
        On Error GoTo 0
        If Len(codeFrM) > 0 And Len(codeFrX) > 0 Then
            TxtOverwrite FilePathFrM, codeFrM
            TxtOverwrite FilePathFrX, codeFrX
        Else
            Debug.Print "File " & UserformName & ".frm/.frx not found neither localy nor online"
            Exit Sub
        End If
    End If

    If ModuleExists(UserformName, oWorkbook) Then
        If Overwrite = True Then
            oWorkbook.VBProject.VBComponents.Remove oWorkbook.VBProject.VBComponents(UserformName)
        Else
            Exit Sub
        End If
    End If
    oWorkbook.VBProject.VBComponents.Import FilePathFrM
End Sub

Sub ImportClass(ClassName As String, _
                Overwrite As Boolean)

    Dim filepath As String
    filepath = LOCAL_LIBRARY_CLASSES & ClassName & ".cls"
    If CheckPath(filepath) = "I" Then
        On Error Resume Next
        Dim Code As String
        Code = TXTReadFromUrl(GITHUB_LIBRARY_CLASSES & ClassName & ".cls")
        On Error GoTo 0
        If Len(Code) > 0 And Not UCase(Code) Like ("*NOT FOUND*") Then
            TxtOverwrite filepath, Code
        Else
            MsgBox "File " & ClassName & ".cls not found neither localy nor online"
            Exit Sub
        End If
    End If

    If ModuleExists(ClassName, oWorkbook) Then
        If Overwrite = True Then
            oWorkbook.VBProject.VBComponents.Remove oWorkbook.VBProject.VBComponents(ClassName)
        Else
            Exit Sub
        End If
    End If
    oWorkbook.VBProject.VBComponents.Import filepath
End Sub

Public Sub Replace(Result As String)

    Dim startLine As Integer
    Dim NumLines As Integer
    With oModule.CodeModule
        startLine = .procStartLine(oProcedure, oProcKind)
        NumLines = .ProcCountLines(oProcedure, oProcKind)
        .DeleteLines startLine, NumLines
        .InsertLines startLine, Result
    End With
End Sub

Private Function EnumOptionToString(PropertyType As Property_Type) As String
    Select Case PropertyType
        Case Property_Type.Modified:          EnumOptionToString = "LastModified"
        Case Property_Type.Ignore:            EnumOptionToString = "Ignore"
        Case Property_Type.Parent_Assigned:   EnumOptionToString = "AssignedModule"
        
    End Select
End Function

Private Function PropertyGet(PropertyType As Property_Type) As String
    PropertyGet = vbNullString
    Dim Line As String: Line = PropertyLine(PropertyType)
    If Line = 0 Then Exit Function
    Dim targetLine As String: targetLine = Trim(oModule.CodeModule.Lines(Line, 1))
    PropertyGet = Split(targetLine, " ")(1)
End Function

Public Function PropertySet(PropertyType As Property_Type, Value As String)
    Dim Line As Long: Line = PropertyLine(PropertyType)
    If Line = 0 Then
        oModule.CodeModule.InsertLines BodyLineFirst, "'@" & EnumOptionToString(PropertyType) & " " & Value
    Else
        Dim targetLine As String: targetLine = Trim(oModule.CodeModule.Lines(Line, 1))
        oModule.CodeModule.ReplaceLine Line, Split(targetLine)(0) & " " & Value
    End If

End Function

Private Function PropertyLine(PropertyType As Property_Type) As Long
    Dim This As String: This = EnumOptionToString(PropertyType)
    Dim targetLine  As String
    Dim i As Long
    For i = LineFirst To LineLast
        targetLine = Trim(oModule.CodeModule.Lines(i, 1))
        If UCase(targetLine) Like UCase("'@" & This & " *") Then
            PropertyLine = i
            Exit Function
        End If
    Next
End Function

Public Sub InjectObjectsRelease()
    Dim LineStart As Long, LineEnd As Long
    AssignLineStartEnd Body_Code, LineStart, LineEnd
    Dim i As Long
    Dim s As String, This As String, Keyword As String
    For i = LineStart To LineEnd
        s = Trim(oModule.CodeModule.Lines(i, 1))
        If (s Like "Set * = *" Or s Like "Dim*As New*") _
        And Not s Like "*= Nothing*" Then
            Keyword = Split(s, " ")(1)
            This = IIf(This <> "", This & vbNewLine, "") & "Set " & Keyword & " = Nothing"
        End If
    Next
    If This = "" Then Exit Sub
    Dim var: var = Split(This, vbNewLine)
    Dim sCode As String: sCode = Code_All
    Dim out, el
    ReDim out(0 To 0)
    For Each el In var
        If InStr(1, sCode, el) = 0 Then
            If out(0) <> "" Then ReDim Preserve out(0 To UBound(out) + 1)
            out(UBound(out)) = el
        End If
    Next
    This = Join(out, vbNewLine)
    If This <> "" Then oModule.CodeModule.InsertLines LineIndex(Procedure_Last), This
End Sub

Public Sub InjectModification()
    PropertySet Modified, Format(Now, "yymmddhhnn")
    
    Const vbTab2 = vbTab & vbTab
    Const vbTab4 = vbTab2 & vbTab2
    Dim sTime As String: sTime = Format(Now, "dd-mm-yyyy hh:nn")
    Dim sProc As String: sProc = oProcedure

    '* @TODO Created: 01-02-2023 07:46 Author: Anastasiou Alex
    '* @TODO if name is too long have to recalculate tab length

    Dim sUser As String: sUser = "Alex"
    If sUser = vbNullString Then sUser = Environ("UserName")
    Const sUPDATE    As String = "'* Updated    :"
    Dim sFirstLine As String
        sFirstLine = "'* Modified   :" & vbTab & "Date and Time" & vbTab2 & _
                    "Author" & vbTab4 & "Description" & vbCrLf
    Dim sSecondLine  As String
        sSecondLine = sUPDATE & vbTab & sTime & vbTab & sUser & vbTab4 & "(" & sProc & ")"

    If InStr(1, Code_Header, "'* Created    :") Then
        Dim lineNo As Long
        Dim i As Long
        For i = LineIndex(Header_First) To LineIndex(Header_Last)
            If oModule.CodeModule.Lines(i, 1) Like "'* Created    :*" Then
                lineNo = i
                Exit For
            End If
        Next
        If oModule.CodeModule.Lines(lineNo + 1, 1) Like sUPDATE & "*" Then
            Do
                lineNo = lineNo + 1
            Loop While oModule.CodeModule.Lines(lineNo + 1, 1) Like sUPDATE & "*"
        End If
        oModule.CodeModule.InsertLines lineNo + 1, sSecondLine
        Exit Sub
    End If

    Dim nLine As Long:   nLine = LineIndex(Declaration_First)
    If nLine < 4 Then
        sSecondLine = vbLf & sFirstLine & sSecondLine
    ElseIf Not oModule.CodeModule.Lines(nLine - 2, 1) Like sUPDATE & "*" Then
        sSecondLine = vbLf & sFirstLine & sSecondLine
    End If
    If Len(oModule.CodeModule.Lines(nLine - 1, 1)) = 0 And nLine > 1 Then
        oModule.CodeModule.InsertLines nLine - 1, sSecondLine
    Else
        oModule.CodeModule.InsertLines nLine, sSecondLine & vbNewLine
    End If
End Sub

Public Function IndexInModule() As Long
    Dim Procedures As New Collection
    Set Procedures = aModule.Init(oModule).ProceduresNames
    Dim index As Long
        index = aCollection.Init(Procedures).IndexOf(oProcedure)
    IndexInModule = index
End Function

Public Sub MoveToTop()
    Dim Procedures As New Collection:   Set Procedures = aModule.Init(oModule).ProceduresNames
    Dim idx As Long:                    idx = IndexInModule
    
    If idx = 1 Then Exit Sub
    
    Dim s As String:                    s = Code_All
    Dim TargetProcedure As String:      TargetProcedure = Procedures(1)
    
    Delete
    
    With oModule.CodeModule
        .InsertLines .procStartLine(TargetProcedure, oProcKind), s
    End With
    
    idx = LineIndex(Declaration_First)
    Application.VBE.ActiveCodePane.SetSelection idx, 1, idx, 1
End Sub

Public Sub MoveToBottom()
    Dim Procedures As New Collection:   Set Procedures = aModule.Init(oModule).ProceduresNames
    Dim idx As Long:                  idx = IndexInModule
    
    If idx = Procedures.count Then Exit Sub
    
    Dim s As String:                    s = Code_All
    Dim TargetProcedure As String:      TargetProcedure = Procedures(Procedures.count)
        
    Delete
    
    With oModule.CodeModule
        .InsertLines .procStartLine(TargetProcedure, oProcKind) + _
                     .ProcCountLines(TargetProcedure, oProcKind) + 1, _
                     s
    End With
    
    idx = LineIndex(Declaration_First)
    Application.VBE.ActiveCodePane.SetSelection idx, 1, idx, 1
End Sub

Public Sub MoveDown()
    Dim Procedures As New Collection:   Set Procedures = aModule.Init(oModule).ProceduresNames
    Dim idx As Long:                    idx = IndexInModule
    
    If idx = Procedures.count Then Exit Sub
    
    Dim s As String:                    s = Code_All
    Dim TargetProcedure As String:      TargetProcedure = Procedures(idx + 1)
    
    Delete
    
    With oModule.CodeModule
        .InsertLines .procStartLine(TargetProcedure, oProcKind) + _
                     .ProcCountLines(TargetProcedure, oProcKind) + 1, _
                     s
    End With
    
    idx = LineIndex(Declaration_First)
    Application.VBE.ActiveCodePane.SetSelection idx, 1, idx, 1

End Sub

Public Sub MoveUp()
    Dim Procedures As New Collection:   Set Procedures = aModule.Init(oModule).ProceduresNames
    Dim idx As Long:                    idx = IndexInModule
    
    If idx = 1 Then Exit Sub
    
    Dim s As String:                    s = Code_All
    Dim TargetProcedure As String:      TargetProcedure = Procedures(idx - 1)
    
    Delete
    
    With oModule.CodeModule
        .InsertLines .procStartLine(TargetProcedure, oProcKind), s
    End With
    
    idx = LineIndex(Declaration_First)
    Application.VBE.ActiveCodePane.SetSelection idx, 1, idx, 1

End Sub

Public Sub MoveToAssignedModule()
    Dim Module As VBComponent
    Set Module = ParentAssigned
    If Module Is Nothing Or Module.Name = oModule.Name Then Exit Sub
    MoveToModule Module
End Sub

Public Sub MoveToModule(Module As VBComponent)
    Dim s As String: s = Code_All
    Delete
    With Module.CodeModule
        .InsertLines .CountOfLines + 1, vbNewLine & s
    End With
    Set oModule = Module
End Sub

Public Sub Delete()
    TxtOverwrite Environ("TEMP") & "\" & oProcedure & ".txt", Code_All
    Debug.Print "made a backup of " & oProcedure & " in " & Environ("TEMP")
    oModule.CodeModule.DeleteLines LineIndex(Procedure_First), LineIndex(Procedure_Count)
End Sub

Public Sub TestCreate()
    Dim arg As String
    arg = ArgumentStyle
    Dim Procedures As Collection
    Set Procedures = aWorkbook.Init(oWorkbook).Procedures(True, False, False, False)
    
    Dim s As String: s = vbNewLine
    If Not aCollection.Init(Procedures).Contains(, "test" & oProcedure) Then
        If KindAsString = "Sub" Then
            s = s & "Sub test" & oProcedure & "()" & vbNewLine
            s = s & "call " & arg & vbNewLine
            s = s & "End Sub"
        Else
            s = s & "Function test" & oProcedure & "()" & vbNewLine
            s = s & "Something = " & arg & vbNewLine
            s = s & "End Function"
        End If
    Else

    End If
    oModule.CodeModule.InsertLines LineIndex(Procedure_First), s
    Debug.Print "Created test" & oProcedure & " in " & oModule.Name
End Sub

Public Function ArgumentStyle() As String
    If ArgumentCount = 0 Then Exit Function
    Dim str As Variant, s As String
    Dim firstPart As String, secondPart As String, output As String
        str = Code_Declaration_Clean
    output = oProcedure & "( _"
    Dim indentation As String
        indentation = Space(Len(output) - 1)
        str = Right(str, Len(str) - InStr(1, str, "("))
        str = Left(str, InStrRev(str, ")") - 1)
    If InStr(1, str, Chr(34) & "," & Chr(34)) > 0 Then
        str = VBA.Replace(str, Chr(34) & "," & Chr(34), Chr(34) & "|" & Chr(34))
    End If
        str = Split(str, ",")
    Dim i As Long
    For i = LBound(str) To UBound(str)
        str(i) = VBA.Replace(str(i), Chr(34) & "|" & Chr(34), Chr(34) & "," & Chr(34))
    Next
    For i = LBound(str) To UBound(str)
        s = Trim(str(i))

        s = VBA.Replace(s, "Optional ", "")
        s = VBA.Replace(s, "As ", "")
        s = VBA.Replace(s, "ByVal ", "")
        s = VBA.Replace(s, "ByRef ", "")
        s = VBA.Replace(s, "ParamArray ", "")
        s = VBA.Replace(s, "_", "")

        firstPart = Split(s, " ")(0)
        If InStr(1, s, " ") Then
            secondPart = Split(s, " ")(1)
        Else
            secondPart = "Variant"
        End If
        output = output & vbNewLine & indentation & firstPart & ":= " & "as" & secondPart & IIf(i <> UBound(str), ", _", ")")
    Next

    ArgumentStyle = output
End Function

Public Function ArgumentStyleClean() As String
    Dim var As Variant
    Dim s As String
    var = Split(ArgumentStyle, vbNewLine)
    var = ArrayTrim(var)
    If UBound(var) = -1 Then
'        ProcedureArgumentStyleClean = Procedure & "()"
        Exit Function
    End If
    s = Join(var, vbNewLine)
    s = VBA.Replace(s, " _" & vbNewLine, "")
    ArgumentStyleClean = s
End Function

Sub PrintDims()
    dp Dims
End Sub
    
Public Property Get Dims() As Variant
    Dim s As Variant:   s = Split(Code_All, vbNewLine)
    Dim tmp:            ReDim tmp(0 To 0)
    
    Dim i As Long
    For i = LBound(s) To UBound(s)
        s(i) = Trim(s(i))
        If s(i) Like "*:*" Then s(i) = Split(s(i), ":")(0)
    Next

    s = ArrayFilterLike(s, "Dim *", True)
    Dim h As String
    Dim element
    For i = LBound(s) To UBound(s)
        s(i) = Trim(StringCommentsRemove(s(i), False))
        If s(i) Like "Dim *,* As *" Then
            For Each element In Split(s(i), ", ")
                If InStr(1, element, "Dim ") = 0 Then element = "Dim " & element
                If InStr(1, element, " As ") = 0 Then element = element & " As "
                tmp(UBound(tmp)) = element
                ReDim Preserve tmp(0 To UBound(tmp) + 1)
            Next
        Else
            For Each element In Split(s(i), ", ")
                tmp(UBound(tmp)) = element
                ReDim Preserve tmp(0 To UBound(tmp) + 1)
            Next
        End If
    Next

    s = ArrayFilterLike(tmp, "Dim *", True)

    Dim var
    ReDim var(0 To 1, 0 To 0)
    For i = LBound(s) To UBound(s)
        element = s(i)
        If element Like "Dim * As *" Then

            element = Mid(element, 5)
            var(0, UBound(var, 2)) = Split(element, " As ")(0)
            var(1, UBound(var, 2)) = Split(element, " As ")(1)
            If Split(element, " As ")(1) Like "New *" Then
                var(1, UBound(var, 2)) = Split(var(1, UBound(var, 2)), " ")(1)
            End If
            If i < UBound(s) Then
                ReDim Preserve var(0 To 1, 0 To UBound(var, 2) + 1)
            End If
        ElseIf element Like "Dim *" Then
        
            Select Case Right(element, 1)
            Case "$": h = "String"
            Case "%": h = "Integer"
            Case "&": h = "Long"
            Case "!": h = "Single"
            Case "#": h = "Double"
            Case "@": h = "Currency"
            Case "^": h = "LongLong"
            Case Else: h = "Variant"
            End Select
            If h = "Variant" Then
                var(0, UBound(var, 2)) = Mid(element, 5)
            Else
                var(0, UBound(var, 2)) = Mid(element, 5, Len(element) - 1)
                Select Case Right(element, 1)
                Case "$", "%", "&", "!", "#", "@", "^"
                    var(0, UBound(var, 2)) = Left(var(0, UBound(var, 2)), Len(var(0, UBound(var, 2))) - 1)
                End Select
            End If
            var(1, UBound(var, 2)) = h
            If i < UBound(s) Then
                ReDim Preserve var(0 To 1, 0 To UBound(var, 2) + 1)
            End If
        End If
    Next

    Dims = WorksheetFunction.Transpose(var)

End Property

Public Sub InjectToHeaderTop( _
                    This As String, _
                    SkipIfExists As Boolean)
    If SkipIfExists Then
        If InStr(1, Code_Body, This) > 0 Then Exit Sub
    End If
    oModule.CodeModule.InsertLines LineIndex(Procedure_First), _
                                   IIf(Len(oModule.CodeModule.Lines(LineIndex(Procedure_First), 1)) = 0, vbNewLine, "") & _
                                   This
End Sub

Public Sub InjectToHeaderBottom( _
                        This As String, _
                        SkipIfExists As Boolean)
    If SkipIfExists Then
        If InStr(1, Code_Body, This) > 0 Then Exit Sub
    End If
    oModule.CodeModule.InsertLines LineIndex(Declaration_First), This
End Sub

Public Sub InjectToBodyTop( _
                    This As String, _
                    SkipIfExists As Boolean)
    If SkipIfExists Then
        If InStr(1, Code_Body, This) > 0 Then Exit Sub
    End If
    oModule.CodeModule.InsertLines LineIndex(Body_First), This
End Sub

Public Sub InjectToBodyAfterComments( _
                                    This As String, _
                                    SkipIfExists As Boolean)
    If SkipIfExists Then
        If InStr(1, Code_Body, This) > 0 Then Exit Sub
    End If
    oModule.CodeModule.InsertLines LineIndex(Body_First_AfterComments), This
End Sub

Public Sub InjectToBodyBottom( _
                             This As String, _
                             SkipIfExists As Boolean)
    If SkipIfExists Then
        If InStr(1, Code_Body, This) > 0 Then Exit Sub
    End If
    oModule.CodeModule.InsertLines LineIndex(Body_Last) + 1, This
End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 17-08-2023 08:28    Alex                (InjectDescription)

Sub InjectDescription()
'@LastModified 2308170828

    Const vbTab2 = vbTab & vbTab
    Const vbTab4 = vbTab2 & vbTab2
    Const sFersLine     As String = "'* Modified   :" & vbTab & "Date and Time" & vbTab2 & "Author" & vbTab4 & "Description" & vbCrLf

    Dim txtName         As String: txtName = AUTHOR_NAME
    If txtName = vbNullString Then txtName = Environ("UserName")

    Dim txtContacts     As String: txtContacts = AUTHOR_EMAIL
    If txtContacts <> vbNullString Then txtContacts = "'* Contacts   :" & vbTab & txtContacts & vbCrLf

    Dim txtCopyright    As String:  txtCopyright = AUTHOR_COPYRIGHT
    If txtCopyright <> vbNullString Then txtCopyright = "'* Copyright  :" & vbTab & txtCopyright & vbCrLf

    Dim txtOther        As String:   txtOther = AUTHOR_OTHERTEXT
    If txtOther <> vbNullString Then txtOther = "'* Note       :" & vbTab & txtOther & vbCrLf

    Dim txtMedia        As String:   txtMedia = "'* " & vbLf & AUTHOR_MEDIA
    Dim CurentCodePane  As CodePane: Set CurentCodePane = oModule.CodeModule.CodePane
    Dim i               As Byte
    Dim ProcKind        As VBIDE.vbext_ProcKind
    Dim sProc           As String: sProc = ActiveProcedure
    Dim nLine           As Long
        nLine = LineIndex(Declaration_First)
    Dim sTemp           As String
    Dim sTime           As String
    Dim sType           As String
    Dim sProcDeclartion As String
    Dim sProcArguments  As String

    Dim sUser As String

    '* @TODO Created: 01-02-2023 08:20 Author: Anastasiou Alex
    '* @TODO if name is too long have to recalculate tab length

    sUser = "Alex"
    If sUser = vbNullString Then sUser = Environ("UserName")

    On Error Resume Next

    With CurentCodePane
        sTemp = VBA.Replace(String(90, "*"), "**", "* ")
        sTime = Format(Now, "dd-mm-yyyy hh:nn")

        For i = 0 To 4
            ProcKind = i
            sProcDeclartion = Code_Declaration_Clean
            If sProcDeclartion <> vbNullString Then Exit For
        Next
        sProcArguments = AddStringParameterFromProcedureHeader(sProcDeclartion)
        sType = TypeProcedureComment(sProcDeclartion)
        sTemp = _
                "'" & sTemp & vbCrLf & _
                "'" & sType & vbTab & sProc & vbCrLf & _
                "'* Author     :" & vbTab & txtName & vbCrLf & _
                txtContacts & _
                txtCopyright & _
                txtOther & _
                "'* Purpose    :" & vbTab & vbCrLf & _
                txtMedia & _
                sFersLine & _
                "'* Created    :" & vbTab & sTime & vbTab & sUser & vbCrLf & _
                sProcArguments & _
                "'" & sTemp
        InjectToHeaderTop sTemp, False

    End With
End Sub

Private Function AddStringParameterFromProcedureHeader(ByVal sPocDeclartion As String) As String
'@BlogPosted
    Const vbTab2 = vbTab & vbTab
    Const vbTab4 = vbTab2 & vbTab2
    Dim sDeclaration As String
        sDeclaration = Right$(sPocDeclartion, Len(sPocDeclartion) - InStr(1, sPocDeclartion, "("))
        sDeclaration = Left$(sDeclaration, InStr(1, sDeclaration, ")") - 1)
    If sDeclaration = vbNullString Then Exit Function
    Dim arStr() As String
        arStr = Split(sDeclaration, ",")
    Dim iMaxLen As Byte
        iMaxLen = 0
    Dim iTempLen As Byte
    Dim sTemp  As String
    Dim i      As Byte
    For i = 0 To UBound(arStr)
        iTempLen = Len(Trim$(arStr(i)))
        If iMaxLen < iTempLen Then iMaxLen = iTempLen
    Next i
    Dim numOfSpaces As Long
        numOfSpaces = iMaxLen - Len(Trim$("'* Argument(s):"))
    If numOfSpaces < 0 Then numOfSpaces = 0
    sDeclaration = "'*" & vbLf & "'* Argument(s):" & Space(numOfSpaces) & vbTab2 & "Description" & vbCrLf & "'*" & vbCrLf
    For i = 0 To UBound(arStr)
        sTemp = "'* " & Trim$(arStr(i)) & Space(iMaxLen - Len(Trim$(arStr(i)))) & " :"
        sDeclaration = sDeclaration & sTemp & vbCrLf
    Next i
    AddStringParameterFromProcedureHeader = sDeclaration & "'* " & vbCrLf
End Function

Private Function TypeProcedureComment(ByVal StrDeclarationProcedure As String) As String
'@BlogPosted
    If StrDeclarationProcedure Like "*Sub*" Then
        TypeProcedureComment = "* Sub        :"
    ElseIf StrDeclarationProcedure Like "*Function*" Then
        TypeProcedureComment = "* Function   :"
    ElseIf StrDeclarationProcedure Like "*Property Set*" Then
        TypeProcedureComment = "* Prop Set   :"
    ElseIf StrDeclarationProcedure Like "*Property Get*" Then
        TypeProcedureComment = "* Prop Get   :"
    ElseIf StrDeclarationProcedure Like "*Property Let*" Then
        TypeProcedureComment = "* Prop Let   :"
    Else
        TypeProcedureComment = "* Un Type    :"
    End If
End Function

Sub InjectTimer()
    Dim ProcedureText As String
    ProcedureText = Code_All
    If Contains("StartTimer", True, True, False) Then Exit Sub
    InjectToBodyAfterComments "StartTimer " & """" & oProcedure & """", True
    Sleep 200
    InjectToBodyBottom "EndTimer", True
End Sub

Function SuggestedScope() As String
    
    Dim Result As String

    Select Case CallerModules.count
    Case 0
        SuggestedScope = "Unspecified"
        Result = Result & vbNewLine & "Procedure " & Name & " has unclarified scope in " & oWorkbook.Name
        Result = Result & vbNewLine & "It is called 0 times, so it may be Unused, Unassigned, or Called from elsewhere"
        Exit Function
    Case 1
        SuggestedScope = "Private"
        Result = Result & vbNewLine & "Suggested scope for procedure " & Name & " is Private"
    Case Is > 1
        SuggestedScope = "Public"
        Result = Result & vbNewLine & "Suggested scope for procedure " & Name & " is Public"
    End Select

    Result = Result & vbNewLine & "because it is used in " & CallerModules.count & " module(s) of " & oWorkbook.Name
    
End Function

Sub ScopeSuggested()
    Dim idx         As Long:        idx = LineIndex(Declaration_First)
    Dim s           As String:      s = oModule.CodeModule.Lines(idx, 1)
    Dim Suggestion  As String:      Suggestion = SuggestedScope
    
    If Suggestion = "Private" Or Suggestion = "Public" Then
        Select Case True
        Case s Like "*Public*" & Name & "*"
            ScopePublic
        Case s Like "*Private*" & Name & "*"
            ScopePrivate
        Case Else
            Dim sKind As String:    sKind = KindAsString
            oModule.CodeModule.ReplaceLine idx, Trim(VBA.Replace(s, sKind, " " & Suggestion & " " & sKind, , 1, vbTextCompare))
        End Select
    End If
End Sub

Sub ScopePrivate()
    Dim idx         As Long:        idx = LineIndex(Declaration_First)
    Dim s           As String:      s = Code_Declaration_Clean
    Dim Suggestion  As String:      Suggestion = "Private"
    Select Case True
    Case s Like "*Public*" & Name & "*"
        Debug.Print Name
        oModule.CodeModule.ReplaceLine idx, VBA.Replace(s, "Public", "Private", , 1, vbTextCompare)
    Case s Like "*Private*" & Name & "*"
        
    Case Else
        Dim sKind As String:    sKind = KindAsString
        Select Case sKind
            Case sKind Like "*Property*"
                Debug.Print Name
                oModule.CodeModule.ReplaceLine idx, VBA.Replace(s, "Property", Suggestion & " " & "Property", , 1, vbTextCompare)
            Case Else
                Debug.Print Name
                oModule.CodeModule.ReplaceLine idx, VBA.Replace(s, sKind, Suggestion & " " & sKind, , 1, vbTextCompare)
        End Select
    End Select
End Sub

Sub ScopePublic()
    Dim idx         As Long:        idx = LineIndex(Declaration_First)
    Dim s           As String:      s = Code_Declaration_Clean
    Dim Suggestion  As String:      Suggestion = "Public"
    Select Case True
    Case s Like "*Public*" & Name & "*"
        
    Case s Like "*Private*" & Name & "*"
        Debug.Print Name
        oModule.CodeModule.ReplaceLine idx, VBA.Replace(s, "Private", "Public", , 1, vbTextCompare)
    Case Else
        Dim sKind As String:    sKind = KindAsString
        Debug.Print Name
        oModule.CodeModule.ReplaceLine idx, Trim(VBA.Replace(s, sKind, " " & Suggestion & " " & sKind, , 1, vbTextCompare))
    End Select
End Sub

Function CallerModules() As Collection
    Dim myName As String: myName = Name
    Dim coll As New Collection
    Dim Module As aModule
    Dim matchCollection As New Collection
    For Each Module In aModules.Init(oWorkbook).Items
        If Module.Contains(myName, True, True, False) Then
            On Error Resume Next
            coll.Add Module.Name, Module.Name
            On Error GoTo 0
        End If
    Next
    Set CallerModules = coll
End Function

Function CallerModulesToString() As String
    Dim element
    Dim Result As String
    For Each element In CallerModules
        Result = Result & IIf(Result <> "", vbNewLine, "") & element
    Next
    CallerModulesToString = Result
End Function

Function Callers() As Collection
    Dim myName As String: myName = Name
    Dim Result As New Collection
    Dim Module As aModule
    Dim Procedure As aProcedure
    For Each Module In CallerModules
        For Each Procedure In Module.Procedures
            If Procedure.Name <> myName Then
                If Procedure.Contains(myName, True, True, False) Then
                    On Error Resume Next
                    Result.Add Procedure.Name, Procedure.Name
                    Exit For
                    On Error GoTo 0
                End If
            End If
        Next
    Next
    Set Callers = Result
End Function

Function CallersToString() As String
    Dim element
    Dim Result As String
    For Each element In Callers
        Result = Result & IIf(Result <> "", vbNewLine, "") & element
    Next
    CallersToString = Result
End Function

Public Sub BringProcedureHere(Procedure As String)
    Dim AP As New aProcedure
    AP.Init , , Procedure
    Dim s As String
        s = AP.Code_All
        If InStr(1, s, "'@AssignedModule") = 0 Then
            AP.PropertySet Parent_Assigned, AP.Parent.Name
            s = AP.Code_All
        End If
    AP.Delete
    oModule.CodeModule.InsertLines LineIndex(Procedure_Last) + 1, s
End Sub

Sub BringLinkedProceduresHere()
    Dim el
    Dim AP As aProcedure
    For Each el In LinkedProceduresDeep
        BringProcedureHere CStr(el)
    Next
End Sub



Sub AddToLinkedTable()
    
    Dim aw As aWorkbook
    Set aw = aWorkbook.Init(oWorkbook)
    Dim cell As Range
    Dim TargetWorksheet As Worksheet
    On Error Resume Next
    Set TargetWorksheet = ThisWorkbook.Sheets("Linked_Table_" & aw.NameClean)
    If TargetWorksheet Is Nothing Then Toast "Worksheet Linked_Table_" & aw.NameClean & " does not exist. Create first. Terminating": Exit Sub
    Set cell = TargetWorksheet.Columns(4).Find(aProcedure, LookAt:=xlWhole)
    If Not cell Is Nothing Then Debug.Print "Procedure " & aProcedure & " was already exporterd. Terminating.": Exit Sub
    On Error GoTo 0

    Dim var
    ReDim var(1 To 8)
    var(1) = oWorkbook.Name
    var(2) = aModule.Init(oModule).TypeToString
    var(3) = oModule.Name
    var(4) = oProcedure
    var(5) = aCollection.Init(LinkedProcedures).ToString(vbNewLine)
    var(6) = aCollection.Init(LinkedClasses).ToString(vbNewLine)
    var(7) = aCollection.Init(LinkedUserforms).ToString(vbNewLine)
    var(8) = aCollection.Init(LinkedDeclarations).ToString(vbNewLine)

    Dim Lr As Long
    Lr = getLastRow(TargetWorksheet) + 1
    TargetWorksheet.Range("A" & Lr & ":H" & Lr).Value = var
End Sub



Public Sub Enable_DebugPrint()
    Dim N As Long
    Dim s As String
    With oModule.CodeModule
        For N = LineIndex(Procedure_Last) To LineIndex(Procedure_First) Step -1
            s = .Lines(N, 1)
            If Left(Trim(s), 6) = "'Debug" Then
                aCodeModule.Init(oModule).UncommentTargetLine N
'                s = VBA.Replace(s, "'", "", , 1)
'                .ReplaceLine N, s
            End If
        Next N
    End With
End Sub
Public Sub Disable_DebugPrint()
    Dim N As Long
    Dim s As String
    With oModule.CodeModule
        For N = LineIndex(Procedure_Last) To LineIndex(Procedure_First) Step -1
            s = .Lines(N, 1)
            If Left(Trim(s), 5) = "Debug" Then
                aCodeModule.Init(oModule).CommentTargetLine N
'                .ReplaceLine N, "'" & s
            End If
        Next N
    End With
End Sub


Public Sub Enable_Stop()
    Dim N As Long
    Dim s As String
    Dim Keyword As String
    Keyword = "Stop"
    With oModule.CodeModule
        For N = LineIndex(Procedure_Last) To LineIndex(Procedure_First) Step -1
            s = .Lines(N, 1)
            If InStrExact(1, s, Keyword) > 0 Then
                s = VBA.Replace(s, "'", "", , 1)
                .ReplaceLine N, s
            End If
        Next N
    End With
End Sub
Public Sub Disable_Stop()
    Dim N As Long
    Dim s As String
    Dim Keyword As String: Keyword = "Stop"
    With oModule.CodeModule
        For N = LineIndex(Procedure_Last) To LineIndex(Procedure_First) Step -1
            s = .Lines(N, 1)
            If InStrExact(1, s, Keyword) > 0 Then
                .ReplaceLine N, "'" & s
            End If
        Next N
    End With
End Sub


Public Sub Comments_ReplaceQuoteWithRem()
    Dim N As Long
    Dim s As String
    With oModule.CodeModule
        For N = LineIndex(Procedure_Last) To LineIndex(Procedure_First) Step -1
            s = .Lines(N, 1)
            If Left(Trim(s), 1) = "'" Then
                .ReplaceLine N, VBA.Replace(s, "'", "Rem ", , 1)
            End If
        Next N
    End With
End Sub


Public Sub UpdatableVariable_Add(This As String)
    Dim i As Long: i = LineLike("*UpdatableVariable = *", Body_Code)
    If i = 0 Then Exit Sub
    Dim Q As String: Q = Chr(34)
    Dim Line As String: Line = oModule.CodeModule.Lines(i, 1)
    If UCase(Trim(Line)) Like UCase("UpdatableVariable = *") And InStr(1, Line, This, vbTextCompare) = 0 Then
        oModule.CodeModule.ReplaceLine i, VBA.Replace(VBA.Replace(Line, Q, Q & This & ",", , 1, vbTextCompare), "," & Q, Q)
        Line = oModule.CodeModule.Lines(i, 1)
        If InStr(1, Line, Q & ",") > 0 Then oModule.CodeModule.ReplaceLine i, VBA.Replace(Line, Q & ",", Q)
    End If
End Sub

Public Sub UpdatableVariable_Remove(This As String)
    Dim i As Long: i = LineLike("*UpdatableVariable = *", Body_Code)
    If i = 0 Then Exit Sub
    Dim Q As String: Q = Chr(34)
    Dim Result As String
    Dim Line As String: Line = oModule.CodeModule.Lines(i, 1)
    If Trim(Line) Like "UpdatableVariable = *" Then
        If InStr(1, Line, Q & This & Q, vbTextCompare) > 0 Then
            Result = VBA.Replace(Line, Q & This & Q, "")
            Result = VBA.Replace(Result, ",,", ",")
            Result = VBA.Replace(Result, Q & ",", Q)
            oModule.CodeModule.ReplaceLine i, Result
        End If
    End If
End Sub

Sub CreateCaller(rng As Range)
    Dim shp As Shape
    Set shp = ActiveSheet.Shapes.AddShape _
    (msoShapeRoundedRectangle, 1, 1, 500, 10)
    With shp.ThreeD
        .BevelTopType = msoBevelCircle
        .BevelTopInset = 6
        .BevelTopDepth = 6
    End With
    With shp.Fill
        .Visible = msoTrue
        .ForeColor.RGB = RGB(0, 176, 80)
        .Transparency = 0
        .Solid
    End With
    With shp.Line
        .Visible = msoTrue
        .ForeColor.ObjectThemeColor = msoThemeColorBackground1
        .ForeColor.TintAndShade = 0
        .ForeColor.Brightness = 0
        .Transparency = 0
    End With
    
    With shp
        .OnAction = "'" & oWorkbook.Name & "'!" & oProcedure
        .Name = "Run_" & oProcedure
        .TextFrame2.TextRange.text = oProcedure
        .TextFrame2.TextRange.Font.Bold = msoTrue
        .TextFrame2.TextRange.Font.Size = 11
        .TextFrame.HorizontalAlignment = xlHAlignCenter
        .TextFrame2.WordWrap = msoFalse
        .TextFrame2.AutoSize = msoAutoSizeShapeToFitText
        .Left = Selection.Left
        .Top = Selection.Top
    End With
End Sub

Function LargestLineLength()
    LargestLineLength = LargestLength(Split(Code_All, vbNewLine))
End Function

Sub ConvertBlankLinesToDividers(Optional Character As String = "~")
    Dim L As Long: L = LargestLineLength
    Dim i As Long
    For i = LineIndex(Procedure_Last) To LineIndex(Declaration_First) Step -1
        If Len(Trim(oModule.CodeModule.Lines(i, 1))) = 0 Then
            oModule.CodeModule.ReplaceLine i, "'" & String(L - 1, Character)
        End If
    Next
End Sub

'A_MAIN	Module

'NOTE:
'     I'VE BEEN MOVING THINGS TO CLASSES. There be bugs.

'These macros use the new classes and target ACTIVE procedure/module/designer
'There are plenty more procedures in the classes, have a look
'Give feedback

'____ Code Module Formatting _____

Public Sub cm_AlignAs():                aCodeModule.Active.AlignAs:                        End Sub
Public Sub cm_AlignColumn():            aCodeModule.Active.AlignColumn:                    End Sub
Public Sub cm_AlignComments():          aCodeModule.Active.AlignComments:                  End Sub
Public Sub cm_AssignEnumValues():       aCodeModule.Active.AssignEnumValues:               End Sub
Public Sub cm_BeautifyFunction():       aCodeModule.Active.BeautifyFunction:               End Sub
Public Sub cm_BringProcedureHere():     aCodeModule.Active.BringProcedureHere:             End Sub
Public Sub cm_CaseLower():              aCodeModule.Active.CaseLower:                      End Sub
Public Sub cm_CaseProper():             aCodeModule.Active.CaseProper:                     End Sub
Public Sub cm_CaseUpper():              aCodeModule.Active.CaseUpper:                      End Sub
Public Sub cm_Comment():                aCodeModule.Active.Comment:                        End Sub
Public Sub cm_Copy():                   aCodeModule.Active.Copy:                           End Sub
Public Sub cm_Cut():                    aCodeModule.Active.Cut:                            End Sub
Public Sub cm_DimMerge():               aCodeModule.Active.DimMerge:                       End Sub
Public Sub cm_DimSeparate():            aCodeModule.Active.DimSeparate:                    End Sub
Public Sub cm_Duplicate():              aCodeModule.Active.Duplicate:                      End Sub
Public Sub cm_EncapsulateParenthesis(): aCodeModule.Active.Encapsulate_Parenthesis:        End Sub
Public Sub cm_EncapsulateQuotes():      aCodeModule.Active.Encapsulate_Quotes:             End Sub
Public Sub cm_EnumToCase():             aCodeModule.Active.EnumToCase:                     End Sub
Public Sub cm_FindCode():               FindCode aCodeModule.Active.Selection:             End Sub
Public Sub cm_FoldLine():               aCodeModule.Active.FoldLine:                       End Sub
Public Sub cm_FormatVBA7():             aCodeModule.Active.Format_VBA7:                    End Sub
Public Sub cm_ImportProcedure():        aCodeModule.Active.ImportProcedure:                End Sub
Public Sub cm_Increment():              aCodeModule.Active.Increment:                      End Sub
Public Sub cm_InjectArgumentStyle():    aCodeModule.Active.InjectArgumentStyle:            End Sub
Public Sub cm_MoveDown():               aCodeModule.Active.Move_Down:                      End Sub
Public Sub cm_MoveUp():                 aCodeModule.Active.Move_Up:                        End Sub
Public Sub cm_PrintLinesLike():         PrintLinesContaining aCodeModule.Active.Selection: End Sub
Public Sub cm_RemAdd():                 aCodeModule.Active.RemAdd:                         End Sub
Public Sub cm_RemRemove():              aCodeModule.Active.RemRemove:                      End Sub
Public Sub cm_RotateCommas():           aCodeModule.Active.RotateCommas:                   End Sub
Public Sub cm_SortComma():              aCodeModule.Active.Sort_Comma:                     End Sub
Public Sub cm_SortLines():              aCodeModule.Active.Sort_Lines:                     End Sub
Public Sub cm_ToDo():                   aCodeModule.Active.Todo:                           End Sub
Public Sub cm_ToggleComments():         aCodeModule.Active.ToggleComments:                 End Sub
Public Sub cm_UnFoldLine():             aCodeModule.Active.UnFoldLine:                     End Sub
Public Sub cm_Uncomment():              aCodeModule.Active.UnComment:                      End Sub
Public Sub cm_injectDivider():          aCodeModule.Active.injectDivider:                  End Sub


'____ PROCEDURE Ops _____

Public Sub ap_AddToLinkedTable():            aProcedure.Active.AddToLinkedTable:                                 End Sub
Public Sub ap_BringLinkedProceduresHere():   aProcedure.Active.BringLinkedProceduresHere:                        End Sub
Public Sub ap_CommentsRemove():              aProcedure.Active.CommentsRemove False, Body_Code:                  End Sub
Public Sub ap_CommentsToOwnLine():           aProcedure.Active.CommentsToOwnLine:                                End Sub
Public Sub ap_ConvertBlankLinesToDividers(): aProcedure.Active.ConvertBlankLinesToDividers:                      End Sub
Public Sub ap_CreateCaller():                On Error Resume Next: aProcedure.Active.CreateCaller InputBoxRange: End Sub
Public Sub ap_Export():                      aProcedure.Active.Export:                                           End Sub
Public Sub ap_ExportLinkedCode():            aProcedure.Active.ExportLinkedCode:                                 End Sub
Public Sub ap_FoldDeclaration():             aProcedure.Active.FoldDeclaration:                                  End Sub
Public Sub ap_ImportDependencies():          aProcedure.Active.ImportDependencies:                               End Sub
Public Sub ap_Indent():                      aProcedure.Active.Indent:                                           End Sub
Public Sub ap_InjectDescription():           aProcedure.Active.InjectDescription:                                End Sub
Public Sub ap_InjectLinkedLists():           aProcedure.Active.InjectLinkedLists:                                End Sub
Public Sub ap_InjectModification():          aProcedure.Active.InjectModification:                               End Sub
Public Sub ap_InjectObjectsRelease():        aProcedure.Active.InjectObjectsRelease:                             End Sub
Public Sub ap_InjectTimer():                 aProcedure.Active.InjectTimer:                                      End Sub
Public Sub ap_MoveDown():                    aProcedure.Active.MoveDown:                                         End Sub
Public Sub ap_MoveToAssignedModule():        aProcedure.Active.MoveToAssignedModule:                             End Sub
Public Sub ap_MoveToBottom():                aProcedure.Active.MoveToBottom:                                     End Sub
Public Sub ap_MoveToTop():                   aProcedure.Active.MoveToTop:                                        End Sub
Public Sub ap_MoveUp():                      aProcedure.Active.MoveUp:                                           End Sub
Public Sub ap_NumbersAdd():                  aProcedure.Active.NumbersAdd:                                       End Sub
Public Sub ap_NumbersRemove():               aProcedure.Active.NumbersRemove:                                    End Sub
Public Sub ap_PrintDims():                   aProcedure.Active.PrintDims:                                        End Sub
Public Sub ap_RemoveEmptyLines():            aProcedure.Active.RemoveEmptyLines:                                 End Sub
Public Sub ap_RemoveIncludeLines():          aProcedure.Active.RemoveIncludeLines:                               End Sub
Public Sub ap_ScopePrivate():                aProcedure.Active.ScopePrivate:                                     End Sub
Public Sub ap_ScopePublic():                 aProcedure.Active.ScopePublic:                                      End Sub
Public Sub ap_ScopeSuggested():              aProcedure.Active.ScopeSuggested:                                   End Sub
Public Sub ap_TestCreate():                  aProcedure.Active.TestCreate:                                       End Sub
Public Sub ap_UnfoldDeclaration():           aProcedure.Active.UnfoldDeclaration:                                End Sub
Public Sub ap_Update():                      aProcedure.Active.Update:                                           End Sub

'____ MODULE    Ops _____
Public Sub am_CodeRemove():                  aModule.Active.CodeRemove:                  End Sub
Public Sub am_CommentsRemove():              aModule.Active.CommentsRemove:              End Sub
Public Sub am_CommentsToOwnLine():           aModule.Active.CommentsToOwnLine:           End Sub
Public Sub am_DisableDebugPrint():           aModule.Active.DisableDebugPrint:           End Sub
Public Sub am_DisableStop():                 aModule.Active.DisableStop:                 End Sub
Public Sub am_Duplicate():                   aModule.Active.Duplicate:                   End Sub
Public Sub am_EnableDebugPrint():            aModule.Active.EnableDebugPrint:            End Sub
Public Sub am_EnableStop():                  aModule.Active.EnableStop:                  End Sub
Public Sub am_Export():                      aModule.Active.Export PickFolder:           End Sub
Public Sub am_ExportProcedures():            aModule.Active.ExportProcedures PickFolder: End Sub
Public Sub am_HeaderAdd():                   aModule.Active.HeaderAdd:                   End Sub
Public Sub am_Indent():                      aModule.Active.Indent:                      End Sub
Public Sub am_ListProcedures():              aModule.Active.ListProcedures:              End Sub
Public Sub am_ListProceduresPublic():        aModule.Active.ListProceduresPublic:        End Sub
Public Sub am_PrintListOfInclude():          aModule.Active.PrintListOfInclude:          End Sub
Public Sub am_PrintTodoList():               aModule.Active.PrintTodoList:               End Sub
Public Sub am_ProcedureFoldDeclarations():   aModule.Active.ProcedureFoldDeclarations:   End Sub
Public Sub am_ProcedureScopePrivate():       aModule.Active.ProcedureScopePrivate:       End Sub
Public Sub am_ProcedureScopePublic():        aModule.Active.ProcedureScopePublic:        End Sub
Public Sub am_ProceduresNames():             dp aModule.Active.ProceduresNames:          End Sub
Public Sub am_RemoveEmptyLinesButLeaveOne(): aModule.Active.RemoveEmptyLinesButLeaveOne: End Sub
Public Sub am_RemoveEmptyLines():            aModule.Active.RemoveEmptyLines:            End Sub
Public Sub am_SortAZ():                      aModule.Active.ProcedureSortAZ:             End Sub
Public Sub am_SortByKind():                  aModule.Active.ProcedureSortByKind:         End Sub
Public Sub am_SortByScope():                 aModule.Active.ProcedureSortByScope:        End Sub
Public Sub am_UpdateProcedures():            aModule.Active.UpdateProcedures:            End Sub

'____ DESIGNER  Ops _____

Public Sub ad_CenterLabelCaption():            aDesigner.Active.CenterLabelCaption:            End Sub
Public Sub ad_CopyControlProperties():         aDesigner.Active.CopyControlProperties:         End Sub
Public Sub ad_PasteControlProperties():        aDesigner.Active.PasteControlProperties:        End Sub
Public Sub ad_RemoveCaption():                 aDesigner.Active.RemoveCaption:                 End Sub
Public Sub ad_RenameControlAndCode():          aDesigner.Active.RenameControlAndCode:          End Sub
Public Sub ad_ReplaceCommandButtonWithLabel(): aDesigner.Active.ReplaceCommandButtonWithLabel: End Sub
Public Sub ad_SetHandCursor():                 aDesigner.Active.SetHandCursor:                 End Sub
Public Sub ad_SetHandCursorToSubControls():    aDesigner.Active.SetHandCursorToSubControls:    End Sub
Public Sub ad_SortControlsHorizontally():      aDesigner.Active.SortControlsHorizontally:      End Sub
Public Sub ad_SortControlsVertivally():        aDesigner.Active.SortControlsVertivally:        End Sub
Public Sub ad_SwitchNames():                   aDesigner.Active.SwitchNames:                   End Sub
Public Sub ad_SwitchPositions():               aDesigner.Active.SwitchPositions:               End Sub
Public Sub ad_SideBySide():                    aModules.SideBySide ActiveModule.Name:          End Sub

'____ WORKBOOK  Ops _____


'____ USERFORMS ____

Public Sub uShow_CodeOnTheFly():     uCodeOnTheFly.Show:    End Sub
Public Sub uShow_ComponentsAdd():    uModulesAdd.Show:      End Sub
Public Sub uShow_ComponentsRemove(): uModulesRemove.Show:   End Sub
Public Sub uShow_ComponentsRename(): uModulesRename.Show:   End Sub
Public Sub uShow_FormBuilder():      uFormBuilder.Show:     End Sub
Public Sub uShow_ProjectExplorer():  uProjectExplorer.Show: End Sub
Public Sub uShow_ProjectManager():   uProjectManager.Show:  End Sub
Public Sub uShow_References():       uReferences.Show:      End Sub
Public Sub uShow_Skeleton():         uSkeleton.Show:        End Sub

Public Sub uShow_SnippetsWorkbook()
    ShowInVBE = False
    uSnippets.Show
End Sub

Public Sub uShow_SnippetsVBE()
    ShowInVBE = True
    Application.VBE.MainWindow.Visible = True
    Application.VBE.MainWindow.SetFocus
    uSnippets.Show
End Sub

'____ TXT _____

Public Sub txt_SeparateProcedures(): CallSeparateProcedures:            End Sub
Public Sub txt_TxtPrepend():         CallTxtPrependContainedProcedures: End Sub


'-------------------------

Public Sub RunVbaGui()
    Dim strProgramName As String
    strProgramName = ThisWorkbook.Path & "\AHK\vbaGUI.exe"
    If Not FileExists(strProgramName) Then Exit Sub
    Shell """" & strProgramName & """, vbNormalFocus)"
End Sub


'aWorkbook	Class


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Class      : aWorkbook
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 04-05-2023 12:19    Alex
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Private oWorkbook As Workbook

Public Function Init(TargetWorkbook As Workbook) As aWorkbook
'@AssignedModule aWorkbook
'@INCLUDE CLASS aWorkbook
    Set oWorkbook = TargetWorkbook
    Set Init = Me
End Function

Public Function item() As Workbook
'@AssignedModule aWorkbook
'@INCLUDE CLASS aWorkbook
    Set item = oWorkbook
End Function

Sub ReferencesList()
'@AssignedModule aWorkbook
'@INCLUDE CLASS aWorkbook
'@INCLUDE DECLARATION GUID
    Dim ws As Worksheet
    Set ws = ThisWorkbook.Sheets("References")
    ws.Cells(1, 1).Value = "Reference Description"
    ws.Cells(1, 2).Value = "GUID"
    ws.Cells(1, 3).Value = "Path"
    ws.Cells(1, 4).Value = "Version"
    Dim myRef As Reference
    Dim refs As VBIDE.REFERENCES
    Set refs = oWorkbook.VBProject.REFERENCES
    Dim i As Long
    i = 2
    For Each myRef In refs
        ws.Cells(i, 1) = IIf(myRef.Description <> "", myRef.Description, myRef.Name)
        ws.Cells(i, 2) = myRef.GUID
        ws.Cells(i, 3) = myRef.fullPath
        ws.Cells(i, 4) = myRef.Major & "." & myRef.Minor
        i = i + 1
    Next myRef
End Sub

Sub AddReferenceFromFile(filepath As String)
'@AssignedModule aWorkbook
'@INCLUDE CLASS aWorkbook
    Dim oRefs As REFERENCES: Set oRefs = oWorkbook.VBProject.REFERENCES
    oRefs.AddFromFile filepath
End Sub

Sub AddReferenceFromGUID(GUID As String, Major As String, Minor As String)
'@AssignedModule aWorkbook
'@INCLUDE CLASS aWorkbook
'@INCLUDE DECLARATION GUID
    Dim oRefs As REFERENCES: Set oRefs = oWorkbook.VBProject.REFERENCES
    oRefs.AddFromGuid GUID, Major, Minor
End Sub

Sub RemoveReferenceByName(RefName As String)
'@AssignedModule aWorkbook
'@INCLUDE CLASS aWorkbook
    Dim oRef As Reference
    Dim oRefs As REFERENCES: Set oRefs = oWorkbook.VBProject.REFERENCES
    For Each oRef In oRefs
        If oRef.Name = RefName Then
            oRefs.Remove oRef
            Exit For
        End If
    Next oRef
End Sub

Sub RemoveReferenceByDescription(RefDescription As String)
'@AssignedModule aWorkbook
'@INCLUDE CLASS aWorkbook
    Dim oRef As Reference
    Dim oRefs As REFERENCES: Set oRefs = oWorkbook.VBProject.REFERENCES
    For Each oRef In oRefs
        If oRef.Description = RefDescription Then
            oRefs.Remove oRef
            Exit For
        End If
    Next oRef
End Sub

Sub RemoveReferenceByGUID(refGUID As String)
'@AssignedModule aWorkbook
'@INCLUDE CLASS aWorkbook
'@INCLUDE DECLARATION GUID
    Dim oRefs As REFERENCES: Set oRefs = oWorkbook.VBProject.REFERENCES
    Dim oRef As Reference
    For Each oRef In oRefs
'        debug.print oRef.Name
        If oRef.GUID = refGUID Then
            oRefs.Remove oRef
            Exit For
        End If
    Next oRef
End Sub

Public Sub ExportReferences(filepath As String)
'@AssignedModule aWorkbook
'@INCLUDE PROCEDURE TxtOverwrite
'@INCLUDE CLASS aWorkbook
'@INCLUDE DECLARATION GUID
    Dim Result As String
    Dim oRef As Reference
    For Each oRef In oWorkbook.VBProject.REFERENCES
        Result = Result & IIf(Result <> "", vbNewLine, "") & oRef.Name & vbTab & oRef.GUID & vbTab & oRef.Major & vbTab & oRef.Minor
    Next
    TxtOverwrite filepath, Result
End Sub


Public Sub ImportReferences(filepath As String)
'@AssignedModule aWorkbook
'@INCLUDE CLASS aWorkbook
    Dim FSO As New Scripting.FileSystemObject
    With FSO.OpenTextFile(filepath, ForReading, True)
        Dim Line As Long
        Do While Not .AtEndOfStream
            Dim Values As Variant
            Values = Split(.ReadLine, vbTab)
            On Error Resume Next
            oWorkbook.VBProject.REFERENCES.AddFromGuid Values(1), Values(2), Values(3)
        Loop
    End With
End Sub

Public Sub ReferenceAdd_VBIDE()
'@AssignedModule aWorkbook
'@INCLUDE CLASS aWorkbook
    On Error Resume Next
    ActiveWorkbook.VBProject.REFERENCES.AddFromGuid "{0002E157-0000-0000-C000-000000000046}", 5, 3
End Sub

Sub ReferenceAdd_ScriptControl()
'@AssignedModule aWorkbook
'@INCLUDE CLASS aWorkbook
    On Error Resume Next
    Application.VBE.ActiveVBProject.REFERENCES.AddFromGuid "{0E59F1D2-1FBE-11D0-8FF2-00A0D10038BC}", 1, 0
End Sub


Function TodoList()
'@AssignedModule aWorkbook
'@INCLUDE CLASS aWorkbook
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aModules
    Dim out As String
    Dim am As aModule
    For Each am In aModules.Init(oWorkbook).Items
        out = out & IIf(out <> "", vbNewLine, "") & am.TodoList
    Next am
    TodoList = out
End Function

Function ProceduresLike(This As String) As Collection
'@AssignedModule aWorkbook
'@INCLUDE CLASS aProcedure
'@INCLUDE CLASS aWorkbook
    Dim Procedure As aProcedure
    Dim out As New Collection
    For Each Procedure In Procedures(True, False, False, False)
        If UCase(Procedure.Name) Like UCase(This) Then
            out.Add Procedure
        End If
    Next
    Set ProceduresLike = out
End Function


Public Function Code() As String
'@AssignedModule aWorkbook
'@INCLUDE CLASS aWorkbook
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aModules
    Dim Module As aModule
    Dim txt
    For Each Module In aModules.Items
        If Module.item.CodeModule.CountOfLines > 0 Then
            txt = txt & _
                  vbNewLine & _
                  "'" & String(10, "=") & " (" & Module.TypeToString & ") " & Module.Name & String(10, "=") & _
                  vbNewLine & _
                  Module.Code
        End If
    Next
    Code = txt
End Function

Sub ModulesMerge(TargetModule As VBComponent, ParamArray Modules() As Variant)
'@AssignedModule aWorkbook
'@INCLUDE CLASS aWorkbook
'@INCLUDE CLASS aModule
    Dim element As Variant
    Dim Module As VBComponent
    For Each element In Modules
        Set Module = element
        If Module.Type = vbext_ct_StdModule Then
            If Module.Name <> TargetModule.Name Then
                aModule.Init(Module).CodeMove TargetModule
            End If
        End If
    Next
End Sub


Public Property Get ProceduresNames( _
                              includeModule As Boolean, _
                              includeDocument As Boolean, _
                              includeClass As Boolean, _
                              includeForm As Boolean) As Collection

    Dim Module As VBComponent
    Dim ProcKind As VBIDE.vbext_ProcKind
    Dim lineNum As Long
    Dim coll As New Collection
    Dim ProcedureName As String
    Dim i As Long
    For Each Module In oWorkbook.VBProject.VBComponents
        If Not includeModule And Module.Type = vbext_ct_StdModule Then GoTo SKIP
        If Not includeClass And Module.Type = vbext_ct_ClassModule Then GoTo SKIP
        If Not includeDocument And Module.Type = vbext_ct_Document Then GoTo SKIP
        If Not includeForm And Module.Type = vbext_ct_MSForm Then GoTo SKIP
        With Module.CodeModule
            lineNum = .CountOfDeclarationLines + 1
            Do Until lineNum >= .CountOfLines
            
                For i = 0 To 4
                    ProcKind = i
                    ProcedureName = .ProcOfLine(lineNum, ProcKind)
                    If ProcedureName <> vbNullString Then
                        
                        'Possible Error:
                        '---------------
                        ' Procedures with an underscore _ which is used in events
                        ' and Private Procedures
                        ' may have the same name in different components
                        
                        If InStr(1, ProcedureName, "_") = 0 Then
                            ProcedureName = .ProcOfLine(lineNum, ProcKind)
                            On Error Resume Next
                            coll.Add ProcedureName, Module.Name & "|" & ProcedureName & "|" & ProcKind
                            On Error GoTo 0
                        End If
                        
                        Exit For
                        
                    End If
                Next
                lineNum = .procStartLine(ProcedureName, ProcKind) + .ProcCountLines(ProcedureName, ProcKind) + 1
            Loop
        End With
SKIP:
    Next Module
    
    Set ProceduresNames = coll
End Property

Public Property Get Procedures( _
                              includeModule As Boolean, _
                              includeDocument As Boolean, _
                              includeClass As Boolean, _
                              includeForm As Boolean) As Collection
'as aProcedure objects
    Dim Module As VBComponent
    Dim ProcKind As VBIDE.vbext_ProcKind
    Dim lineNum As Long
    Dim coll As New Collection
    Dim ProcedureName As String
    Dim cProcedure As aProcedure
    Dim i As Long
    For Each Module In oWorkbook.VBProject.VBComponents
        If Not includeModule And Module.Type = vbext_ct_StdModule Then GoTo SKIP
        If Not includeClass And Module.Type = vbext_ct_ClassModule Then GoTo SKIP
        If Not includeDocument And Module.Type = vbext_ct_Document Then GoTo SKIP
        If Not includeForm And Module.Type = vbext_ct_MSForm Then GoTo SKIP
        With Module.CodeModule
            lineNum = .CountOfDeclarationLines + 1
            Do Until lineNum >= .CountOfLines
            
                For i = 0 To 4
                    ProcKind = i
                    ProcedureName = .ProcOfLine(lineNum, ProcKind)
                    If ProcedureName <> vbNullString Then
                        
                        'Possible Error:
                        '---------------
                        ' Procedures with an underscore _ which is used in events
                        ' and Private Procedures
                        ' may have the same name in different components
                        
                        If InStr(1, ProcedureName, "_") = 0 Then
                            ProcedureName = .ProcOfLine(lineNum, ProcKind)
                            Set cProcedure = New aProcedure
                            cProcedure.Init oWorkbook, Module, ProcedureName, ProcKind
                            On Error Resume Next
                            coll.Add cProcedure, cProcedure.Name & ProcKind
'                            coll.Add ProcedureName, ProcedureName
'                            If Err.Number > 0 Then Debug.Print ProcedureName & " exists multiple times, added only once, may lead to error"
'                            Err.clear
                            On Error GoTo 0
                        End If
                        
                        Exit For
                        
                    End If
                Next
                lineNum = .procStartLine(ProcedureName, ProcKind) + .ProcCountLines(ProcedureName, ProcKind) + 1
            Loop
        End With
SKIP:
    Next Module
    
    Set Procedures = coll
End Property


Function ProceduresArray()
    Dim Module As VBComponent
    Dim ProcKind As VBIDE.vbext_ProcKind
    Dim lineNum As Long
    Dim coll As New Collection
    Dim ProcedureName As String
    Dim cProcedure As aProcedure
    Dim arr
    Dim i As Long
    Dim BodyLine As Long
    ReDim arr(1 To 4, 1 To 1)
    For Each Module In oWorkbook.VBProject.VBComponents
        With Module.CodeModule
            lineNum = .CountOfDeclarationLines + 1
            Do Until lineNum >= .CountOfLines
                If arr(UBound(arr, 1), 1) <> "" Then
                    ReDim Preserve arr(1 To 4, 1 To UBound(arr, 2) + 1)
                End If
                On Error Resume Next
                For i = 0 To 4
                    ProcKind = i
                    ProcedureName = .ProcOfLine(lineNum, ProcKind)
                    If ProcedureName <> vbNullString Then
                        BodyLine = Module.CodeModule.ProcBodyLine(ProcedureName, ProcKind)
                        arr(1, UBound(arr, 2)) = Switch(Module.Type = vbext_ct_StdModule, "Module", _
                                                        Module.Type = vbext_ct_ClassModule, "Class", _
                                                        Module.Type = 3, "Userform", _
                                                        Module.Type = 100, "Document", _
                                                        Module.Type = 11, "ActiveXDesigner")
                        arr(2, UBound(arr, 2)) = Module.Name
                        arr(3, UBound(arr, 2)) = Switch(ProcKind = vbext_pk_Proc, IIf(Module.CodeModule.Lines(BodyLine, 1) Like "*Sub " & ProcedureName & "*", "Sub", "Function"), _
                                                        ProcKind = vbext_pk_Let, "Let", _
                                                        ProcKind = vbext_pk_Set, "Set", _
                                                        ProcKind = vbext_pk_Get, "Get")
                        arr(4, UBound(arr, 2)) = ProcedureName
                        Exit For
                    End If
                Next
                On Error GoTo 0
                lineNum = .procStartLine(ProcedureName, ProcKind) + .ProcCountLines(ProcedureName, ProcKind) + 1
            Loop
        End With
SKIP:
    Next Module
    ProceduresArray = WorksheetFunction.Transpose(arr)
End Function

Sub Export()
    uProjectManager.Show
End Sub

Sub Backup(TargetFolder As String)
    oWorkbook.SaveCopyAs TargetFolder & _
                         Format(Now, "yyyy-mm-dd hh-nn") & " " & oWorkbook.Name
End Sub

Function Name()
    Name = oWorkbook.Name
End Function
Function Extension()
    Extension = Mid(Name, InStr(1, Name, "."))
End Function

Function NameClean()
    NameClean = Left(Name, InStrRev(Name, ".") - 1)
End Function

Public Sub ExportProject( _
            Optional bSeparateProcedures As Boolean, _
            Optional bExportComponents As Boolean, _
            Optional bWorkbookBackup As Boolean, _
            Optional bExportUnified As Boolean, _
            Optional bExportDeclarations As Boolean, _
            Optional bExportReferences As Boolean, _
            Optional bExportXML As Boolean, _
            Optional UseWorkbookFolder As Boolean, _
            Optional OpenFolderAfterExport As Boolean)
    
    Dim exportPath As String:
    If UseWorkbookFolder Then
        exportPath = oWorkbook.Path & "\"
    Else
        exportPath = Environ("USERprofile") & "\Documents\" & "vbArc\Backups\" & NameClean & "\"
    End If
    exportPath = exportPath & "src " & NameClean & " " & Format(Now, "YY-MM-DD HH-NN") & "\"
    
    FoldersCreate exportPath
    Dim ams As aModules:    Set ams = aModules.Init(oWorkbook)
    If bWorkbookBackup = True Then Backup exportPath
    If bExportUnified Then ExportCode exportPath
    If bExportReferences = True Then ExportReferences exportPath & "References.txt"
    If bExportComponents = True Then ams.Export exportPath, CreateSubFolders:=True
    If bExportDeclarations = True Then ExportDeclarations exportPath
    If bExportXML = True Then ExportXML exportPath
    If bSeparateProcedures = True Then ams.ExportProcedures exportPath
    On Error Resume Next
    Toast , "Export complete"
    If OpenFolderAfterExport Then FollowLink exportPath
End Sub

Sub ExportXML(TargetPath As String)
    TargetPath = Replace(TargetPath & "\", "\\", "\")
    FoldersCreate TargetPath
    Dim TmpFile As String
    TmpFile = oWorkbook.Path & "\temp_workbook_file" & Extension
    oWorkbook.SaveCopyAs TmpFile
    Dim c As New clsEditOpenXML
    c.ExtractRibbonX TmpFile, TargetPath & "customUI.xml"
    Kill TmpFile
    Set c = Nothing
End Sub
Sub ExportCode(TargetPath As String)
    TargetPath = Replace(TargetPath & "\", "\\", "\")
    FoldersCreate TargetPath
    Dim Result As String, tmp As String
    Dim am As aModule
    For Each am In aModules.Init(oWorkbook).Items
        tmp = "'" & am.Name & vbTab & am.TypeToString & vbNewLine & vbNewLine & am.Code
        Result = IIf(Result = "", tmp, Result & vbNewLine & vbNewLine & tmp)
    Next
    TxtAppend TargetPath & "#UnifiedProject.txt", Result
End Sub

Sub ExportHalf()
    ExportProject _
                 bSeparateProcedures:=False, _
                 bExportComponents:=True, _
                 bWorkbookBackup:=True, _
                 bExportUnified:=True, _
                 bExportDeclarations:=False, _
                 bExportReferences:=True, _
                 bExportXML:=False
End Sub

Function HasProject() As Boolean
    Dim WbProjComp As Object
    On Error Resume Next
    Set WbProjComp = oWorkbook.VBProject.VBComponents
    HasProject = Not WbProjComp Is Nothing
End Function

Sub CreateLinkedTable_Sheet()
    Dim TargetWorksheet As Worksheet
    Set TargetWorksheet = CreateOrSetSheet("Linked_Table_" & NameClean, ThisWorkbook)
    If TargetWorksheet.Range("A1") <> "" Then Exit Sub
    Dim var
    ReDim var(1 To 8)

    var(1) = "WORKBOOK"
    var(2) = "MODULE TYPE"
    var(3) = "MODULE NAME"
    var(4) = "PROCEDURE"
    var(5) = "LINKED PROCEDURES"
    var(6) = "LINKED CLASSES"
    var(7) = "LINKED USERFORMS"
    var(8) = "LINKED DECLARATIONS"
    
    With TargetWorksheet
        .Range("A1:H1").Value = var
        With .rows(1).Cells.Font
            .Bold = True
            .Size = 14
        End With
    End With
    
End Sub

Sub CreateLinkedTable()

    StartTimer "tableOfProcedures"

    aWorkbook.Init(oWorkbook).DeclarationsTableCreate
    
    CreateLinkedTable_Sheet
    
    Dim TargetWorksheet As Worksheet
    Set TargetWorksheet = ThisWorkbook.Sheets("Linked_Table_" & NameClean)
    On Error Resume Next
    TargetWorksheet.ListObjects(1).Unlist
    On Error GoTo 0
    TargetWorksheet.Range("A1").CurrentRegion.offset(1).Clear

    Dim var
    ReDim var(1 To 8, 1 To 1)
    
    Dim counter As Long
    counter = 1

    Dim Module As VBComponent
    Dim Procedures As Collection
    
    Dim Procedure As aProcedure
    For Each Module In oWorkbook.VBProject.VBComponents
        Select Case Module.Type
        Case vbext_ct_StdModule, vbext_ct_Document, vbext_ct_MSForm  '@TODO check if adding these is ok
            Set Procedures = aModule.Init(Module).Procedures
            For Each Procedure In Procedures
                ReDim Preserve var(1 To 8, 1 To counter)
                var(1, counter) = oWorkbook.Name
                var(2, counter) = aModule.Init(Module).TypeToString
                var(3, counter) = Module.Name
                var(4, counter) = Procedure.Name
                var(5, counter) = aCollection.Init(Procedure.LinkedProcedures).ToString(vbNewLine)
                var(6, counter) = aCollection.Init(Procedure.LinkedClasses).ToString(vbNewLine)
                var(7, counter) = aCollection.Init(Procedure.LinkedUserforms).ToString(vbNewLine)
                var(8, counter) = aCollection.Init(Procedure.LinkedDeclarations).ToString(vbNewLine)

                counter = counter + 1
            Next
        End Select
    Next
    
    var = WorksheetFunction.Transpose(var)
    ArrayToRange2D var, TargetWorksheet.Range("A2")

    LinkedProceduresTableSort
    TargetWorksheet.ListObjects.Add xlSrcRange, TargetWorksheet.Range("A1").CurrentRegion, , xlYes
    TargetWorksheet.Cells.VerticalAlignment = xlVAlignTop

    EndTimer

End Sub

Private Sub LinkedProceduresTableSort()
    Dim TargetWorksheet As Worksheet
    Set TargetWorksheet = ThisWorkbook.Worksheets("Linked_Table_" & NameClean)
    Dim sort1 As String
    sort1 = "A1"
    Dim sort2 As String
    sort2 = "C1"
    Dim sort3 As String
    sort3 = "D1"

    With TargetWorksheet.Sort
        .SortFields.Clear
        .SortFields.Add Key:=TargetWorksheet.Range(sort1), Order:=xlAscending
        If Not sort2 = "" Then
            .SortFields.Add Key:=TargetWorksheet.Range(sort2), Order:=xlAscending
        End If
        If Not sort3 = "" Then
            .SortFields.Add Key:=TargetWorksheet.Range(sort3), Order:=xlAscending
        End If

        .SetRange TargetWorksheet.Range("A1").CurrentRegion
'        .header = xlYes
        .Apply
    End With
End Sub

'Sub LinkedProceduresTableFilter()
'    Dim TargetWorksheet As Worksheet: Set TargetWorksheet = ThisWorkbook.SHEETS("LinkedProcedures_Table")
'    TargetWorksheet.rows.Hidden = False
'    On Error Resume Next
'    TargetWorksheet.ShowAllData
'    On Error GoTo 0
'    TargetWorksheet.Range("A6").CurrentRegion.AdvancedFilter _
'        action:=xlFilterInPlace, _
'        criteriaRange:=TargetWorksheet.Range("A1").CurrentRegion
'    LinkedProceduresTableSort
'End Sub


Sub ExportDeclarations(TargetPath As String)
    TargetPath = Replace(TargetPath & "\", "\\", "\")
    FoldersCreate TargetPath

    Dim DeclarationArray As Variant
    DeclarationArray = aCollection.CollectionsToArray2D(getDeclarations)
    If TypeName(DeclarationArray) <> "Empty" Then
        TxtOverwrite TargetPath & "Declarations.txt", ArrayToString(DeclarationArray)
    End If
End Sub

Private Function DeclarationsWorksheetCreate() As Boolean
    If WorksheetExists("Declarations_Table", ThisWorkbook) Then Exit Function
    Dim TargetWorksheet As Worksheet
    Set TargetWorksheet = ThisWorkbook.Sheets.Add
    With TargetWorksheet
        .Name = "Declarations_Table"
        .Cells.VerticalAlignment = xlVAlignTop
        .Range("A1:F1").Value = Split("SCOPE,TYPE,NAME,CODE,MODULE TYPE,MODULE NAME", ",")
        .rows(1).Cells.Font.Bold = True
        .rows(1).Cells.Font.Size = 14
    End With
End Function

Public Sub DeclarationsTableCreate()

    DeclarationsWorksheetCreate

    Dim TargetWorksheet As Worksheet
    Set TargetWorksheet = ThisWorkbook.Sheets("Declarations_Table")
    'if sheet was created within the hour, you probably don't have new declarations
    If Format(Now, "YYMMDDHHNN") - TargetWorksheet.Range("Z1").Value < 60 Then Exit Sub

    TargetWorksheet.Range("A2").CurrentRegion.offset(1).Clear
    ArrayToRange2D aCollection.CollectionsToArray2D( _
                        getDeclarations( _
                            includeScope:=True, _
                            includeType:=True, _
                            includeKeywords:=True, _
                            includeDeclarations:=True, _
                            includeComponentName:=True, _
                            includeComponentType:=True)), _
                    TargetWorksheet.Range("A2")

    TargetWorksheet.Range("Z1").Value = Format(Now, "YYMMDDHHNN")

    DeclarationsTableSort
End Sub

Private Sub DeclarationsTableSort()
    Dim TargetWorksheet As Worksheet
    Set TargetWorksheet = ThisWorkbook.Worksheets("Declarations_Table")

    Dim sort1 As String: sort1 = "B1"
    Dim sort2 As String: sort2 = "C1"
    Dim sort3 As String ': sort3 = "D1"

    With TargetWorksheet.Sort
        .SortFields.Clear
        .SortFields.Add Key:=TargetWorksheet.Range(sort1), Order:=xlAscending

        If Not sort2 = "" Then
            .SortFields.Add Key:=TargetWorksheet.Range(sort2), Order:=xlAscending
        End If
        If Not sort3 = "" Then
            .SortFields.Add Key:=TargetWorksheet.Range(sort3), Order:=xlAscending
        End If

        .SetRange TargetWorksheet.Range("A1").CurrentRegion
        .Header = xlYes
        .Apply
    End With
End Sub


Public Function DeclarationsTableKeywords() As Collection
    Dim TargetWorksheet As Worksheet
    Set TargetWorksheet = ThisWorkbook.Sheets("Declarations_Table")
    Dim Lr As Long: Lr = getLastRow(TargetWorksheet)
    Dim coll As New Collection
    Dim cell As Range
    For Each cell In TargetWorksheet.Range("C2:C" & Lr)
        On Error Resume Next
        coll.Add cell.text, cell.text
        On Error GoTo 0
    Next
    Set DeclarationsTableKeywords = coll
End Function

Public Function getDeclarations( _
                        Optional includeScope As Boolean, _
                        Optional includeType As Boolean, _
                        Optional includeKeywords As Boolean, _
                        Optional includeDeclarations As Boolean, _
                        Optional includeComponentName As Boolean, _
                        Optional includeComponentType As Boolean) As Collection

    Dim ComponentCollection     As New Collection
    Dim ComponentTypecollection As New Collection
    Dim DeclarationsCollection  As New Collection
    Dim KeywordsCollection      As New Collection
    Dim output                  As New Collection
    Dim ScopeCollection         As New Collection
    Dim TypeCollection          As New Collection

    Dim element                 As Variant
    Dim OriginalDeclarations    As Variant
    Dim str                     As Variant

    Dim tmp                     As String
    Dim helper                  As String
    Dim i                       As Long

    Dim Module                  As VBComponent
    For Each Module In oWorkbook.VBProject.VBComponents
'        If Module.Type = vbext_ct_StdModule Or Module.Type = vbext_ct_MSForm Then
            If Module.CodeModule.CountOfDeclarationLines > 0 Then
                str = Module.CodeModule.Lines(1, Module.CodeModule.CountOfDeclarationLines)
                str = Replace(str, "_" & vbNewLine, "")
                OriginalDeclarations = str
                tmp = str
                Do While InStr(1, str, "End Type") > 0
                    tmp = Mid(str, InStr(1, str, "Type "), InStr(1, str, "End Type") - InStr(1, str, "Type ") + 8)
                    str = Replace(str, tmp, Split(tmp, vbNewLine)(0))
                Loop
                Do While InStr(1, str, "End Enum") > 0
                    tmp = Mid(str, InStr(1, str, "Enum "), InStr(1, str, "End Enum") - InStr(1, str, "Enum ") + 8)
                    str = Replace(str, tmp, Split(tmp, vbNewLine)(0))
                Loop
                Do While InStr(1, str, "  ") > 0
                    str = Replace(str, "  ", " ")
                Loop

                str = Split(str, vbNewLine)
                tmp = OriginalDeclarations

                For Each element In str
                    If Len(CStr(element)) > 0 And Not Trim(CStr(element)) Like "'*" And Not Trim(CStr(element)) Like "Rem*" Then
                        If RegexTest(CStr(element), "\b ?Enum \b") Then
                            KeywordsCollection.Add DeclarationsKeywordSubstring(CStr(element), " ", "Enum")
                            DeclarationsCollection.Add DeclarationsKeywordSubstring(tmp, , "Enum " & KeywordsCollection.item(KeywordsCollection.count), "End Enum", , , True)
                            TypeCollection.Add "Enum"
                            ComponentCollection.Add Module.Name
                            ComponentTypecollection.Add aModule.Init(Module).TypeToString
                            ScopeCollection.Add IIf(InStr(1, DeclarationsCollection.item(DeclarationsCollection.count), "Public", vbTextCompare), "Public", "Private")
                        ElseIf RegexTest(CStr(element), "\b ?Type \b") Then
                            KeywordsCollection.Add DeclarationsKeywordSubstring(CStr(element), " ", "Type")
                            DeclarationsCollection.Add DeclarationsKeywordSubstring(tmp, , "Type " & KeywordsCollection.item(KeywordsCollection.count), "End Type", , , True)
                            TypeCollection.Add "Type"
                            ComponentCollection.Add Module.Name
                            ComponentTypecollection.Add aModule.Init(Module).TypeToString
                            ScopeCollection.Add IIf(InStr(1, DeclarationsCollection.item(DeclarationsCollection.count), "Public", vbTextCompare), "Public", "Private")
                        ElseIf InStr(1, CStr(element), "Const ", vbTextCompare) > 0 Then
                            KeywordsCollection.Add DeclarationsKeywordSubstring(CStr(element), " ", "Const")
                            DeclarationsCollection.Add CStr(element)
                            TypeCollection.Add "Const"
                            ComponentCollection.Add Module.Name
                            ComponentTypecollection.Add aModule.Init(Module).TypeToString
                            ScopeCollection.Add IIf(InStr(1, DeclarationsCollection.item(DeclarationsCollection.count), "Public", vbTextCompare), "Public", "Private")
                        ElseIf RegexTest(CStr(element), "\b ?Sub \b") Then
                            KeywordsCollection.Add DeclarationsKeywordSubstring(CStr(element), " ", "Sub")
                            DeclarationsCollection.Add CStr(element)
                            TypeCollection.Add "Sub"
                            ComponentCollection.Add Module.Name
                            ComponentTypecollection.Add aModule.Init(Module).TypeToString
                            ScopeCollection.Add IIf(InStr(1, DeclarationsCollection.item(DeclarationsCollection.count), "Public", vbTextCompare), "Public", "Private")
                        ElseIf RegexTest(CStr(element), "\b ?Function \b") Then
                            KeywordsCollection.Add DeclarationsKeywordSubstring(CStr(element), " ", "Function")
                            DeclarationsCollection.Add CStr(element)
                            TypeCollection.Add "Function"
                            ComponentCollection.Add Module.Name
                            ComponentTypecollection.Add aModule.Init(Module).TypeToString
                            ScopeCollection.Add IIf(InStr(1, DeclarationsCollection.item(DeclarationsCollection.count), "Public", vbTextCompare), "Public", "Private")
                        ElseIf element Like "*(*) As *" Then
                            helper = Left(element, InStr(1, CStr(element), "(") - 1)
                            helper = Mid(helper, InStrRev(helper, " ") + 1)
                            KeywordsCollection.Add helper
                            DeclarationsCollection.Add CStr(element)
                            TypeCollection.Add "Other"
                            ComponentCollection.Add Module.Name
                            ComponentTypecollection.Add aModule.Init(Module).TypeToString
                            ScopeCollection.Add IIf(InStr(1, DeclarationsCollection.item(DeclarationsCollection.count), "Public", vbTextCompare), "Public", "Private")
                        ElseIf element Like "* As *" Then
                            KeywordsCollection.Add DeclarationsKeywordSubstring(CStr(element), " ", , "As")
                            DeclarationsCollection.Add CStr(element)
                            TypeCollection.Add "Other"
                            ComponentCollection.Add Module.Name
                            ComponentTypecollection.Add aModule.Init(Module).TypeToString
                            ScopeCollection.Add IIf(InStr(1, DeclarationsCollection.item(DeclarationsCollection.count), "Public", vbTextCompare), "Public", "Private")
                        Else
                        End If
                    End If
                Next element
            End If
'        End If
    Next Module

    If includeScope = True Then output.Add ScopeCollection
    If includeType = True Then output.Add TypeCollection
    If includeKeywords = True Then output.Add KeywordsCollection
    If includeDeclarations = True Then output.Add DeclarationsCollection
    If includeComponentType = True Then output.Add ComponentTypecollection
    If includeComponentName = True Then output.Add ComponentCollection

    Set getDeclarations = output
End Function

Private Function DeclarationsKeywordSubstring( _
                                            str As Variant, Optional delim As String _
                                            , Optional afterWord As String _
                                            , Optional beforeWord As String _
                                            , Optional counter As Integer _
                                            , Optional outer As Boolean _
                                            , Optional includeWords As Boolean) As String

    Dim i As Long
    If afterWord = "" And beforeWord = "" And counter = 0 Then
        MsgBox ("Pass at least 1 parameter betweenn -AfterWord- , -BeforeWord- , -counter-")
        Exit Function
    End If
    If TypeName(str) = "String" Then
        If delim <> "" Then
            str = Split(str, delim)
            If UBound(str) <> 0 Then
                If afterWord = "" And beforeWord = "" And counter <> 0 Then
                    If counter - 1 <= UBound(str) Then
                        DeclarationsKeywordSubstring = str(counter - 1)
                        Exit Function
                    End If
                End If
                For i = LBound(str) To UBound(str)
                    If afterWord <> "" And beforeWord = "" Then
                        If i <> 0 Then
                            If str(i - 1) = afterWord Or str(i - 1) = "#" & afterWord Then
                                DeclarationsKeywordSubstring = str(i)
                                Exit Function
                            End If
                        End If
                    ElseIf afterWord = "" And beforeWord <> "" Then
                        If i <> UBound(str) Then
                            If str(i + 1) = beforeWord Or str(i + 1) = "#" & beforeWord Then
                                DeclarationsKeywordSubstring = str(i)
                                Exit Function
                            End If
                        End If
                    ElseIf afterWord <> "" And beforeWord <> "" Then
                        If i <> 0 And i <> UBound(str) Then
                            If (str(i - 1) = afterWord Or str(i - 1) = "#" & afterWord) And (str(i + 1) = beforeWord Or str(i + 1) = "#" & beforeWord) Then
                                DeclarationsKeywordSubstring = str(i)
                                Exit Function
                            End If
                        End If
                    End If
                Next i
            End If
        Else
            If InStr(1, str, afterWord) > 0 And InStr(1, str, beforeWord) > 0 Then
                If includeWords = False Then
                    DeclarationsKeywordSubstring = Mid(str, InStr(1, str, afterWord) + Len(afterWord))
                Else
                    DeclarationsKeywordSubstring = Mid(str, InStr(1, str, afterWord))
                End If
                If outer = True Then
                    If includeWords = False Then
                        DeclarationsKeywordSubstring = Left(DeclarationsKeywordSubstring, InStrRev(DeclarationsKeywordSubstring, beforeWord) - 1)
                    Else
                        DeclarationsKeywordSubstring = Left(DeclarationsKeywordSubstring, InStrRev(DeclarationsKeywordSubstring, beforeWord) + Len(beforeWord) - 1)
                    End If
                Else
                    If includeWords = False Then
                        DeclarationsKeywordSubstring = Left(DeclarationsKeywordSubstring, InStr(1, DeclarationsKeywordSubstring, beforeWord) - 1)
                    Else
                        DeclarationsKeywordSubstring = Left(DeclarationsKeywordSubstring, InStr(1, DeclarationsKeywordSubstring, beforeWord) + Len(beforeWord) - 1)
                    End If
                End If
                Exit Function
            End If
        End If
    Else
    '
    End If
    DeclarationsKeywordSubstring = vbNullString
End Function

Public Sub DeclarationsTableExport()
    Dim ws As Worksheet
    Set ws = ThisWorkbook.Sheets("Declarations_Table")
    Dim codeName As String
    Dim codeText As String
    Dim cell As Range
    Dim Lr As Long
    Lr = getLastRow(ws)
    Dim codeCollection As Collection
    For Each cell In ws.Range("C2:C" & Lr)
        codeName = cell.text
        Set codeCollection = New Collection
        On Error Resume Next
        codeCollection.Add cell.offset(0, 1).text, cell.offset(0, 1).text
        On Error GoTo 0
        Do While cell.offset(1, 0).text = cell.text
            Set cell = cell.offset(1, 0)
            On Error Resume Next
            codeCollection.Add cell.offset(0, 1).text, cell.offset(0, 1).text
            On Error GoTo 0
        Loop
        codeText = aCollection.Init(codeCollection).ToString(IIf(codeCollection.count > 1, vbNewLine, ""))
        TxtOverwrite LOCAL_LIBRARY_DECLARATIONS & codeName & ".txt", codeText
    Next
End Sub

Function getDeclaredKeywordsOfWorkbook() As Variant
    getDeclaredKeywordsOfWorkbook = WorksheetFunction.Transpose(aCollection.CollectionsToArray2D(getDeclarations(, , True)))
End Function

Function getDeclaredEnumOfWorkbook() As String
    Dim c As Variant
    Dim out As String
    For Each c In aCollection.CollectionsToArray2D(getDeclarations(, , , True))
        If InStr(1, CStr(c), "Enum ") > 0 Then out = IIf(out = "", c, out & vbNewLine & c)
    Next
    getDeclaredEnumOfWorkbook = out
End Function

Function getDeclaredTypeOfWorkbook() As String
    Dim c As Variant
    Dim out As String
    For Each c In aCollection.CollectionsToArray2D(getDeclarations(, , , True))
        If InStr(1, CStr(c), "Type ") > 0 Then out = IIf(out = "", c, out & vbNewLine & c)
    Next
    getDeclaredTypeOfWorkbook = out
End Function

Function getDeclaredSubOfWorkbook(TargetWorkbook As Workbook) As String
    Dim c As Variant
    Dim out As String
    For Each c In aCollection.CollectionsToArray2D(getDeclarations(, , , True))
        If InStr(1, CStr(c), "Sub ") > 0 Then out = IIf(out = "", c, out & vbNewLine & c)
    Next
    getDeclaredSubOfWorkbook = out
End Function

Function getDeclaredFunctionOfWorkbook() As String
    Dim c As Variant
    Dim out As String
    For Each c In aCollection.CollectionsToArray2D(getDeclarations(, , , True))
        If InStr(1, CStr(c), "Function ") > 0 Then out = IIf(out = "", c, out & vbNewLine & c)
    Next
    getDeclaredFunctionOfWorkbook = out
End Function



'aModule	Class


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Class      : aModule
'* Purpose    :
'* Copyright  :
'*
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 29-06-2023 14:39    Alex
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


Option Explicit

Private oModule As VBComponent
Private oWorkbook As Workbook


Public Sub SetPredeclaredId(Toggle As Boolean)
'@AssignedModule aModule
'@INCLUDE PROCEDURE TxtOverwrite
'@INCLUDE PROCEDURE TxtRead
'@INCLUDE CLASS aModule
    
    Dim FName1 As String: FName1 = ThisWorkbook.Path & "\" & "TempClass.cls"
    oWorkbook.VBProject.VBComponents(oModule.Name).Export FName1
        TxtOverwrite FName1, VBA.Replace( _
                                VBA.Replace(TxtRead(FName1), _
                                    IIf(Toggle = True, _
                                        "Attribute VB_PredeclaredId = False", _
                                        "Attribute VB_PredeclaredId = True"), _
                                    IIf(Toggle = True, _
                                        "Attribute VB_PredeclaredId = True", _
                                        "Attribute VB_PredeclaredId = False"), _
                                    1, _
                                    1), _
                                vbLf, vbCrLf, _
                                1, _
                                -1)

   
    Delete
    oWorkbook.VBProject.VBComponents.Import FName1
    Kill FName1
    
End Sub

Public Function ClassCalls() As Variant
    'classCallsOfModule(0) is the class name
    'classCallsOfModule(1) is the keyword for the class name (eg dim clsCal as new classCalendar)
'@AssignedModule aModule
'@INCLUDE PROCEDURE ClassNames
'@INCLUDE PROCEDURE classCallsOfModule
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aModules

    Dim Code      As Variant
    Dim element   As Variant
    Dim Keyword   As Variant
    Dim var       As Variant
    ReDim var(1 To 2, 1 To 1)
    Dim counter   As Long: counter = 0
    Dim ClassName As Variant
    If oModule.CodeModule.CountOfDeclarationLines > 0 Then
        Code = oModule.CodeModule.Lines(1, oModule.CodeModule.CountOfDeclarationLines)
        Code = Replace(Code, "_" & vbNewLine, "")
        Code = Split(Code, vbNewLine)
        Code = Filter(Code, " As ", , vbTextCompare)
        For Each element In Code
            element = Trim(element)
            If element Like "* As *" Then
                Keyword = Split(element, " As ")(0)
                Keyword = Split(Keyword, " ")(UBound(Split(Keyword, " ")))
                element = Split(element, " As ")(1)
                element = Replace(element, "New ", "")
                For Each ClassName In aModules.Init(oWorkbook).ClassNames
                    If element = ClassName Then
                        ReDim Preserve var(1 To 2, 1 To counter + 1)
                        var(1, UBound(var, 2)) = element
                        var(2, UBound(var, 2)) = Keyword
                        counter = counter + 1
'                        Exit For
                    End If
                Next
            End If
        Next
        If var(1, 1) <> "" Then
            If UBound(var, 2) > 1 Then
                ClassCalls = WorksheetFunction.Transpose(var)
            Else
                Dim VAR2(1 To 1, 1 To 2)
                VAR2(1, 1) = var(1, 1)
                VAR2(1, 2) = var(2, 1)
                ClassCalls = VAR2
            End If
        End If
    End If

End Function
Public Function Active() As aModule
'@AssignedModule aModule
'@INCLUDE PROCEDURE ActiveModule
'@INCLUDE CLASS aModule
    Init ActiveModule
    Set Active = Me
End Function

Public Function Init(Module As Variant) As aModule
'@AssignedModule aModule
'@INCLUDE CLASS aModule
    If TypeName(Module) = "VBComponent" Then
        Set oModule = Module
    Else
        Set Module = Module.Parent.VBProject.VBComponents(Module.codeName)
    End If
    Set oWorkbook = Parent
    Set Init = Me
End Function


Sub PrintListOfInclude()
'@AssignedModule aModule
'@INCLUDE PROCEDURE dp
'@INCLUDE CLASS aModule
    dp ListOfInclude
End Sub

Function ListOfInclude() As Collection
'@AssignedModule aModule
'@INCLUDE PROCEDURE ArrayQuickSort
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aCollection

    Dim var: var = Split(Code, vbNewLine)
    ArrayQuickSort Filter(var, "'@INCLUDE ", True)
    Dim coll As New Collection
    Dim el
    On Error Resume Next
    For Each el In var
        el = Trim(el)
        If el Like "'@INCLUDE *" Then
            coll.Add el, CStr(el)
        End If
    Next
    On Error GoTo 0
    var = aCollection.Init(coll).ToArray
    Dim matches As String: matches = Join(var, vbNewLine)
    Dim out As String: out = out & vbNewLine & "'=== Module: " & oModule.Name & "===" & vbNewLine & matches
    Set ListOfInclude = coll
End Function

Public Function Duplicate( _
                        Optional NewName As String, _
                        Optional ActivateNewModule As Boolean = True) As Boolean
'@AssignedModule aModule
'@INCLUDE CLASS aModule
    
    If NewName = "" Then NewName = Name & "_Copy"
    On Error GoTo Error_Handler
    Dim targetFile    As String
    targetFile = Environ("Temp") & "\" & NewName & Extension
    oModule.Name = NewName
    oModule.Export targetFile
    oModule.Name = Name
    oWorkbook.VBProject.VBComponents.Import targetFile
    If Len(Dir(targetFile)) > 0 Then Kill Replace(targetFile, Extension, ".*")
    If ActivateNewModule = True Then oWorkbook.VBProject.VBComponents(NewName).Activate
'    DuplicateUserForm = True
Error_Handler_Exit:
    On Error Resume Next
    Exit Function
Error_Handler:
    MsgBox "The following error has occured" & vbCrLf & vbCrLf & _
    "Error Number: " & Err.Number & vbCrLf & _
    "Error Source: aModule.Duplicate" & vbCrLf & _
    "Error Description: " & Err.Description & _
    Switch(Erl = 0, "", Erl <> 0, vbCrLf & "Line No: " & Erl) _
    , vbOKOnly + vbCritical, "An Error has Occured!"
    Resume Error_Handler_Exit
End Function

Sub PrintTodoList()
'@AssignedModule aModule
'@INCLUDE PROCEDURE dp
'@INCLUDE CLASS aModule
    dp TodoList
End Sub

Function TodoList()
'@AssignedModule aModule
'@INCLUDE CLASS aModule
    Dim out     As String
    Dim matches As String
    matches = Join(Filter(Split(Code, vbNewLine), "@TODO", True), vbNewLine)
    out = out & vbNewLine & "'---------"
    out = out & vbNewLine & "'Module: " & Name
    out = out & vbNewLine & "'---------"
'    out = out & vbNewLine & "'" & Replace(Matches, vbNewLine, vbNewLine & "'")
    out = out & vbNewLine & matches ' "'" & Replace(Matches, vbNewLine, vbNewLine & "'")
    TodoList = out
End Function


Sub HeaderAdd()
'@AssignedModule aModule
'@INCLUDE PROCEDURE ActiveProcedure
'@INCLUDE PROCEDURE PadRight
'@INCLUDE CLASS aModule
'@INCLUDE DECLARATION AUTHOR_COPYRIGHT
'@INCLUDE DECLARATION AUTHOR_EMAIL
'@INCLUDE DECLARATION AUTHOR_NAME
'@INCLUDE DECLARATION AUTHOR_OTHERTEXT
    
    Const vbTab2 = vbTab & vbTab
    Const vbTab4 = vbTab & vbTab & vbTab & vbTab
    Const sFersLine     As String = "'* Modified   :" & vbTab & "Date and Time" & vbTab & vbTab & "Author" & vbTab4 & "Description" & vbCrLf

    Dim txtName         As String: txtName = AUTHOR_NAME
    If txtName = vbNullString Then txtName = Environ("UserName")
    txtName = "'* Author     :" & vbTab & txtName & vbCrLf
    
    Dim txtContacts     As String: txtContacts = AUTHOR_EMAIL
    If txtContacts <> vbNullString Then txtContacts = "'* Contacts   :" & vbTab & txtContacts & vbCrLf

    Dim txtCopyright    As String:  txtCopyright = AUTHOR_COPYRIGHT
'    If txtCopyright <> vbNullString Then txtCopyright = "'* Copyright  :" & vbTab & txtCopyright & vbCrLf
    txtCopyright = "'* Copyright  :" & vbTab & txtCopyright & vbCrLf
    
    Dim txtOther        As String:   txtOther = AUTHOR_OTHERTEXT
    If txtOther <> vbNullString Then txtOther = "'* Note       :" & vbTab & txtOther & vbCrLf

    Dim txtMedia        As String:   txtMedia = "'* " & vbLf & AUTHOR_MEDIA
    Dim CurentCodePane  As CodePane: Set CurentCodePane = oModule.CodeModule.CodePane
    Dim i               As Byte
    Dim ProcKind        As VBIDE.vbext_ProcKind
    Dim sProc           As String: sProc = ActiveProcedure
    Dim nLine           As Long: nLine = 1
    Dim sTemp           As String
    Dim sTime           As String
    Dim sType           As String
    Dim sProcDeclartion As String
    Dim sProcArguments  As String

    Dim sUser As String
    On Error GoTo ErrorHandler

    '* @TODO Created: 01-02-2023 08:20 Author: Anastasiou Alex
    '* @TODO if name is too long have to recalculate tab length

    sUser = "Alex"
    If sUser = vbNullString Then sUser = Environ("UserName")

    sTemp = Replace(String(90, "*"), "**", "* ")
    sTime = Format(Now, "dd-mm-yyyy hh:nn")
    sProc = oModule.Name
    sType = "'* " & PadRight(Me.TypeToString, 11) & ":" & vbTab & sProc & vbCrLf
     
    If LineLike("* " & PadRight(Me.TypeToString, 11) & ": " & oModule.Name, True, True) > 0 Then GoTo UpdateHeader
    
    With oModule.CodeModule.CodePane
        sTemp = vbLf & "'" & sTemp & vbCrLf & _
                sType & _
                "'* Purpose    :" & vbCrLf & _
                txtCopyright & "'* " & vbCrLf & _
                txtName & _
                txtContacts & _
                txtOther & _
                txtMedia & _
                sFersLine & _
                "'* Created    :" & vbTab & sTime & vbTab & sUser & vbCrLf & _
                sProcArguments & _
                "'" & sTemp
        .CodeModule.InsertLines 1, sTemp & vbNewLine
    End With
NormalExit:
    Exit Sub
UpdateHeader:
    nLine = LineLike("'* Created    : *", True, True) + 1
    'put update to bottom of changes list
    Do While Trim(oModule.CodeModule.Lines(nLine, 1)) Like "'* Modified*)"
        nLine = nLine + 1
    Loop
    
    oModule.CodeModule.InsertLines nLine, "'* Modified   :" & vbTab & sTime & vbTab & sUser
    GoTo NormalExit
ErrorHandler:
    GoTo NormalExit
End Sub

Function item() As VBComponent
'@AssignedModule aModule
'@INCLUDE CLASS aModule
    Set item = oModule
End Function

Public Sub ListProcedures()
'@AssignedModule aModule
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aCollection
    Dim coll As New Collection
    Set coll = ProceduresNames
    If coll.count = 0 Then Exit Sub
    Dim txt As String
    txt = "'@FOLDER ListOfProcedures" & vbNewLine & "'" & String(20, "-") & vbNewLine
    txt = txt & "'" & Join(aCollection.Init(coll).ToArray, vbNewLine & "'") & vbNewLine
    txt = txt & "'" & String(20, "-") & vbNewLine
    txt = txt & "'@EndFolder ListOfProcedures" & vbNewLine
    FolderDelete "ListOfProcedures"
    oModule.CodeModule.InsertLines 1, txt
End Sub

Public Sub ListProceduresPublic()
'@AssignedModule aModule
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aCollection
    Dim coll As New Collection
    Set coll = PublicProceduresNames
    If coll.count = 0 Then Exit Sub
    Dim txt As String
    txt = "'@FOLDER ListOfProcedures" & vbNewLine & "'" & String(20, "-") & vbNewLine
    txt = txt & "'" & Join(aCollection.Init(coll).ToArray, vbNewLine & "'") & vbNewLine
    txt = txt & "'" & String(20, "-") & vbNewLine
    txt = txt & "'@EndFolder ListOfProcedures" & vbNewLine
    FolderDelete "ListOfProcedures"
    oModule.CodeModule.InsertLines 1, txt
End Sub

Public Sub FolderDelete(FolderName As String)
'    If oModule.CodeModule.CountOfDeclarationLines = 0 Then Exit Sub
'    If Not HeaderContains("'@FOLDER " & FolderName) Then Exit Sub
'    If Not HeaderContains("'@EndFolder " & FolderName) Then Exit Sub
'@AssignedModule aModule
'@INCLUDE CLASS aModule
    Dim startLine As Long, endLine As Long
    Dim sLine As String
    Dim i As Long
    For i = 1 To oModule.CodeModule.CountOfLines
        sLine = Trim(oModule.CodeModule.Lines(i, 1))
        If sLine = "'@FOLDER " & FolderName Then startLine = i
        If startLine <> 0 Then
            If sLine = "'@EndFolder " & FolderName Then endLine = i
        End If
        If startLine <> 0 And endLine <> 0 Then Exit For
    Next
    'for some unknown reason this procedure failed
    'and for another ur adding the following line (which will not execute!!!!) fixes it........
    If startLine = 0 Or endLine = 0 Then Exit Sub
    oModule.CodeModule.DeleteLines startLine, endLine - startLine + 1
'    If LineLike("'@FOLDER" & FolderName, False, False) < 0 Then FolderDelete FolderName
End Sub

Public Sub ProcedureSortByKind()
'@AssignedModule aModule
'@INCLUDE PROCEDURE ArrayQuickSort
'@INCLUDE CLASS aProcedure
'@INCLUDE CLASS aModule
    If oModule.CodeModule.CountOfLines = 0 Then Exit Sub
    Dim coll      As New Collection: Set coll = Procedures
    Dim var       As Variant:        ReDim var(1 To coll.count)
    Dim p         As aProcedure
    Dim startLine As Long
    Dim i         As Long
    For i = 1 To coll.count
        Set p = coll(i)
        var(i) = p.Name
        If i = 1 Then startLine = p.LineIndex(Procedure_First)
    Next
    ArrayQuickSort var
    Dim h As String:    h = Header
    Dim s As String
    Dim TheSubs As String, TheFunctions As String
    For i = LBound(var) To UBound(var)
        Set p = aProcedure.Init(Parent, oModule, CStr(var(i)))
        s = p.Code_All
        If p.KindAsString = "Sub" Then
            TheSubs = TheSubs & IIf(TheSubs <> "", vbNewLine, "") & s
        Else
            TheFunctions = TheFunctions & IIf(TheFunctions <> "", vbNewLine, "") & s
        End If
    Next i
    CodeRemove
    oModule.CodeModule.AddFromString h & vbLf & TheSubs & vbLf & TheFunctions
    
End Sub
Public Sub ProcedureSortByScope()
'@AssignedModule aModule
'@INCLUDE PROCEDURE ArrayQuickSort
'@INCLUDE CLASS aProcedure
'@INCLUDE CLASS aModule
    If oModule.CodeModule.CountOfLines = 0 Then Exit Sub
    Dim coll      As New Collection: Set coll = Procedures
    Dim var       As Variant:        ReDim var(1 To coll.count)
    Dim p         As aProcedure
    Dim startLine As Long
    Dim i         As Long
    For i = 1 To coll.count
        Set p = coll(i)
        var(i) = p.Name
        If i = 1 Then startLine = p.LineIndex(Procedure_First)
    Next
    ArrayQuickSort var
    Dim h As String:    h = Header
    Dim s As String
    Dim ThePublic As String, ThePrivate As String
    For i = LBound(var) To UBound(var)
        Set p = aProcedure.Init(Parent, oModule, CStr(var(i)))
        s = p.Code_All
        If p.Scope = "Public" Then
            ThePublic = ThePublic & IIf(ThePublic <> "", vbNewLine, "") & s
        Else
            ThePrivate = ThePrivate & IIf(ThePublic <> "", vbNewLine, "") & s
        End If
    Next i
    CodeRemove
    oModule.CodeModule.AddFromString h & vbLf & ThePrivate & vbLf & ThePublic
End Sub

Public Sub ProcedureSortAZ()
'@AssignedModule aModule
'@INCLUDE PROCEDURE ArrayQuickSort
'@INCLUDE CLASS aProcedure
'@INCLUDE CLASS aModule
    If oModule.CodeModule.CountOfLines = 0 Then Exit Sub
    Dim coll      As New Collection: Set coll = Procedures
    Dim var       As Variant:        ReDim var(1 To coll.count)
    Dim p         As aProcedure
    Dim startLine As Long
    Dim i         As Long
    For i = 1 To coll.count
        Set p = coll(i)
        var(i) = p.Name
        If i = 1 Then startLine = p.LineIndex(Procedure_First)
    Next
    ArrayQuickSort var
    Dim s As String:    s = Header
    For i = LBound(var) To UBound(var)
        Set p = aProcedure.Init(Parent, oModule, CStr(var(i)))
        s = s & IIf(s <> "", vbNewLine, "") & p.Code_All
    Next i
    CodeRemove
    oModule.CodeModule.AddFromString s
End Sub

Public Function Component() As VBComponent
'@AssignedModule aModule
'@INCLUDE CLASS aModule
    Set Component = oModule
End Function

Public Function LineLike( _
                             This As String, _
                             IgnoreIndentation As Boolean, _
                             IgnoreCase As Boolean) As Long
'@AssignedModule aModule
'@INCLUDE CLASS aModule
    If oModule.CodeModule.CountOfLines = 0 Then Exit Function
    If IgnoreCase Then This = UCase(This)
    Dim sLine As String
    Dim i As Long
    For i = 1 To oModule.CodeModule.CountOfLines
        sLine = oModule.CodeModule.Lines(i, 1)
        If IgnoreIndentation Then sLine = Trim(sLine)
        If IgnoreCase Then sLine = UCase(sLine)
        If sLine Like This Then
            LineLike = i
            Exit Function
        End If
    Next
End Function

Public Function LinesLike( _
                             This As String, _
                             IgnoreIndentation As Boolean, _
                             IgnoreCase As Boolean) As Collection
'@AssignedModule aModule
'@INCLUDE CLASS aModule
    If oModule.CodeModule.CountOfLines = 0 Then Exit Function
    If IgnoreCase Then This = UCase(This)
    Dim coll As New Collection
    Dim sLine As String
    Dim i As Long
    For i = 1 To oModule.CodeModule.CountOfLines
        sLine = oModule.CodeModule.Lines(i, 1)
        If IgnoreIndentation Then sLine = Trim(sLine)
        If IgnoreCase Then sLine = UCase(sLine)
        If sLine Like This Then
            coll.Add i
        End If
    Next
    Set LinesLike = coll

End Function

Public Sub ProcedureScopePrivate()
'@AssignedModule aModule
'@INCLUDE CLASS aProcedure
'@INCLUDE CLASS aModule
    Dim AP As aProcedure
    For Each AP In Procedures
        AP.ScopePrivate
    Next
End Sub

Public Sub ProcedureScopePublic()
'@AssignedModule aModule
'@INCLUDE CLASS aProcedure
'@INCLUDE CLASS aModule
    Dim AP As aProcedure
    For Each AP In Procedures
        AP.ScopePublic
    Next
End Sub
Sub EnableDebugPrint()
'@AssignedModule aModule
'@INCLUDE CLASS aProcedure
'@INCLUDE CLASS aModule
    Dim AP As aProcedure
    For Each AP In Procedures
        AP.Enable_DebugPrint
    Next
End Sub
Sub DisableDebugPrint()
'@AssignedModule aModule
'@INCLUDE CLASS aProcedure
'@INCLUDE CLASS aModule
    Dim AP As aProcedure
    For Each AP In Procedures
        AP.Disable_DebugPrint
    Next
End Sub
Public Sub EnableStop()
'@AssignedModule aModule
'@INCLUDE CLASS aProcedure
'@INCLUDE CLASS aModule
    Dim AP As aProcedure
    For Each AP In Procedures
        AP.Enable_Stop
    Next
End Sub
Public Sub DisableStop()
'@AssignedModule aModule
'@INCLUDE CLASS aProcedure
'@INCLUDE CLASS aModule
    Dim AP As aProcedure
    For Each AP In Procedures
        AP.Disable_Stop
    Next
End Sub

Public Sub ProcedureFoldDeclarations()
'@AssignedModule aModule
'@INCLUDE CLASS aProcedure
'@INCLUDE CLASS aModule
    Dim AP As aProcedure
    For Each AP In Procedures
        AP.FoldDeclaration
    Next
End Sub


Public Function Procedures() As Collection  'ExcludeUnderscore as Boolean '@TODO
'@AssignedModule aModule
'@INCLUDE CLASS aProcedure
'@INCLUDE CLASS aModule
    Dim lineNum       As Long
    Dim ProcedureName As String
    Dim ProcKind      As Long
    Dim coll          As New Collection
    Dim i             As Long
    Dim cProcedure    As aProcedure
    With oModule.CodeModule
    
        lineNum = .CountOfDeclarationLines + 1
        Do Until lineNum >= .CountOfLines
            On Error Resume Next
            For i = 0 To 4
                ProcKind = i
                ProcedureName = .ProcOfLine(lineNum, ProcKind)
                If ProcedureName <> vbNullString Then Exit For
            Next
            On Error GoTo 0
            'Err.clear
            If ProcedureName = vbNullString Then Exit Function
            
            'Possible Error:
            '---------------
            ' Procedures with an underscore _ which is used in events
            ' and Private Procedures
            ' may have the same name in different components

            If InStr(1, ProcedureName, "_") = 0 Then    '>0 and ExcludeUnderscore then goto SKIP

                Set cProcedure = New aProcedure
                cProcedure.Init oWorkbook, oModule, ProcedureName, ProcKind
                On Error Resume Next
                coll.Add cProcedure ', cProcedure.Name
'                    coll.Add ProcedureName, ProcedureName
'                    If Err.Number > 0 Then Debug.Print ProcedureName & " exists multiple times, added only once, may lead to error"
'                    Err.clear
                On Error GoTo 0
                lineNum = .procStartLine(ProcedureName, ProcKind) + .ProcCountLines(ProcedureName, ProcKind) + 1
            End If
            lineNum = .procStartLine(ProcedureName, ProcKind) + .ProcCountLines(ProcedureName, ProcKind) + 1
            ProcedureName = vbNullString
        Loop
    End With
    Set Procedures = coll
End Function

Function ProceduresNames() As Collection
'@AssignedModule aModule
'@INCLUDE CLASS aProcedure
'@INCLUDE CLASS aModule
    Dim AP            As aProcedure
    Dim coll          As New Collection
    Dim ProcedureName As String
    For Each AP In Procedures
        ProcedureName = AP.Name
        On Error Resume Next
        coll.Add ProcedureName, ProcedureName
        On Error GoTo 0
        If Err.Number > 0 Then Debug.Print ProcedureName & " exists multiple times, added only once, may lead to error"
        Err.Clear
    Next
    Set ProceduresNames = coll
End Function
Function PublicProceduresNames() As Collection
'@AssignedModule aModule
'@INCLUDE CLASS aProcedure
'@INCLUDE CLASS aModule
    Dim AP            As aProcedure
    Dim coll          As New Collection
    Dim ProcedureName As String
    For Each AP In Procedures
        ProcedureName = AP.Name
        On Error Resume Next
        If AP.Scope = "Public" Then coll.Add ProcedureName, ProcedureName
        On Error GoTo 0
        If Err.Number > 0 Then Debug.Print ProcedureName & " exists multiple times, added only once, may lead to error"
        Err.Clear
    Next
    Set PublicProceduresNames = coll
End Function
Sub UpdateProcedures()
'@AssignedModule aModule
'@INCLUDE CLASS aProcedure
'@INCLUDE CLASS aModule
    Dim Procedure As aProcedure
    For Each Procedure In Procedures
        Procedure.Update
    Next
End Sub

Sub CommentsToOwnLine()
'@AssignedModule aModule
'@INCLUDE PROCEDURE CommentsMoveToOwnLine
'@INCLUDE CLASS aModule
    Dim s As String
    With oModule.CodeModule
        If .CountOfLines = 0 Then Exit Sub
        s = CommentsMoveToOwnLine(Code)
        CodeRemove
        .AddFromString s
    End With
End Sub

Public Sub Indent()
'@AssignedModule aModule
'@INCLUDE PROCEDURE IsBlockEnd
'@INCLUDE PROCEDURE IsBlockStart
'@INCLUDE CLASS aModule
    If oModule.CodeModule.CountOfLines = 0 Then Exit Sub
    Dim LineStart As Long, LineEnd As Long
    LineStart = 1
    LineEnd = oModule.CodeModule.CountOfLines
    Dim nIndent As Long
    Dim s As String
    Dim i As Long
    For i = LineStart To LineEnd
        s = LTrim$(oModule.CodeModule.Lines(i, 1))
        If Trim(s) <> "" Then
            If IsBlockEnd(s) Then nIndent = nIndent - 1
            If nIndent < 0 Then nIndent = 0
            s = Space$(nIndent * 4) & s
            oModule.CodeModule.ReplaceLine i, s
            If IsBlockStart(LTrim$(s)) Then nIndent = nIndent + 1
        End If
    Next
End Sub

Sub Activate()
'@AssignedModule aModule
'@INCLUDE CLASS aModule
    With Application.VBE.MainWindow
        .Visible = True
        .WindowState = vbext_ws_Maximize
    End With
    With oModule.CodeModule.CodePane
        .Show
        .Window.Visible = True
        .Window.WindowState = vbext_ws_Maximize
        .Window.SetFocus
        .SetSelection 1, 1, 1, 1
    End With
End Sub

Function Code() As String
'@AssignedModule aModule
'@INCLUDE CLASS aModule
    With oModule.CodeModule
        If .CountOfLines = 0 Then Code = "": Exit Function
        Code = .Lines(1, .CountOfLines)
    End With
End Function

Public Function body() As String
'@AssignedModule aModule
'@INCLUDE CLASS aModule
    With oModule.CodeModule
        If .CountOfLines - .CountOfDeclarationLines = 0 Then Exit Function
        body = .Lines(.CountOfDeclarationLines + 1, .CountOfLines - .CountOfDeclarationLines)
    End With
End Function

Function Contains( _
                    This As String, _
                    WholeWord As Boolean, _
                    MatchCase As Boolean, _
                    PatternSearch As Boolean)
'@AssignedModule aModule
'@INCLUDE CLASS aModule

    If oModule.CodeModule.CountOfLines = 0 Then Exit Function
    Contains = oModule.CodeModule.Find( _
                                        This, _
                                        1, _
                                        1, _
                                        oModule.CodeModule.CountOfLines, _
                                        10000, _
                                        WholeWord, _
                                        MatchCase, _
                                        PatternSearch)
End Function

Function Header() As String
'@AssignedModule aModule
'@INCLUDE CLASS aModule
    If oModule.CodeModule.CountOfDeclarationLines = 0 Then Exit Function
    With oModule.CodeModule
        Header = .Lines(1, .CountOfDeclarationLines)
    End With
End Function

Function HeaderContains(This As String) As Boolean
'@AssignedModule aModule
'@INCLUDE CLASS aModule
    HeaderContains = (InStr(1, Header, This) > 0)
End Function

Function Ignore() As Boolean
'@AssignedModule aModule
'@INCLUDE CLASS aModule
    Ignore = InStr(1, Header, "@IGNORE", vbTextCompare) > 0
End Function

Public Property Get Parent() As Workbook
    Dim s As String
    s = oModule.Collection.Parent.fileName
    s = Right(s, Len(s) - InStrRev(s, "\"))
    Set Parent = Workbooks(s)
End Property

Function Name() As String
    Name = oModule.Name
    If oModule.Type = vbext_ct_Document And oModule.Name <> "ThisWorkbook" Then
        On Error GoTo HELL
        Name = GetSheetByCodeName(Parent, oModule.Name).Name
        On Error GoTo 0
    End If
    Exit Function
HELL:
    Debug.Print "Probably the file is in another language"
    Name = "ThisWorkbook"
End Function

Function TypeToLong() As vbext_ComponentType
    TypeToLong = oModule.Type
End Function

Function TypeToString() As String
    Select Case oModule.Type
    Case vbext_ct_ActiveXDesigner
        TypeToString = "ActiveX Designer"
    Case vbext_ct_ClassModule
        TypeToString = "Class"
    Case vbext_ct_Document
        TypeToString = "Document"
    Case vbext_ct_MSForm
        TypeToString = "UserForm"
    Case vbext_ct_StdModule
        TypeToString = "Module"
    Case Else
        TypeToString = "Unknown Type: " & CStr(oModule.Type)
    End Select
End Function

Sub ExportProcedures(TargetPath As String)
    If TargetPath = "" Then Exit Sub '<- FOR when called with FolderPicker
    TargetPath = Replace(TargetPath & "\", "\\", "\")
    FoldersCreate TargetPath
    Dim AP As aProcedure
    Dim coll As New Collection: Set coll = Procedures
    If coll.count > 0 Then
        For Each AP In coll
'            TxtAppend TargetPath & AP.Name & " " & AP.KindAsString & ".txt", AP.Code_All
            TxtAppend TargetPath & AP.Name & ".txt", AP.Code_All
        Next
    End If
End Sub

Sub Export(TargetPath As String)
    If TargetPath = "" Then Exit Sub '<- FOR when called with FolderPicker
    TargetPath = Replace(TargetPath & "\", "\\", "\")
    FoldersCreate TargetPath
    oModule.Export TargetPath & Name & Extension
End Sub

'Public Sub ToggleOnAttributePredeclaredID()
'    ToggleAttribute True, , , , True
'End Sub

'Sub ToggleAttribute(NewValue As Boolean, _
'                   Optional Creatable As Boolean, _
'                   Optional Exposed As Boolean, _
'                   Optional GlobalNameSpace As Boolean, _
'                   Optional PredeclaredID As Boolean)

'NOTE: THIS DOESN'T WORK.
'Modifying the .cls file like this causes it to be imported as normal module.
'I don't know why it breaks

'    If Not Extension Like "*cls" Then Exit Sub
'    Dim Path As String: Path = ThisWorkbook.Path & "\"
'    Export Path
'    Sleep 1000
'    Debug.Print "Exported to " & Path
'    Dim s As String: s = TxtRead(Path & Name & Extension)
'    If Creatable Then s = VBA.Replace(s, "Attribute VB_Creatable = " & IIf(NewValue = True, CStr("False"), CStr("True")), "Attribute VB_Creatable = " & IIf(NewValue = True, CStr("True"), CStr("False")), 1, 1, vbTextCompare)
'    If Exposed Then s = VBA.Replace(s, "Attribute VB_GlobalNameSpace = " & IIf(NewValue = True, CStr("False"), CStr("True")), "Attribute VB_GlobalNameSpace = " & IIf(NewValue = True, CStr("True"), CStr("False")), 1, 1, vbTextCompare)
'    If PredeclaredID Then s = VBA.Replace(s, "Attribute VB_PredeclaredId = " & IIf(NewValue = True, CStr("False"), CStr("True")), "Attribute VB_PredeclaredId = " & IIf(NewValue = True, CStr("True"), CStr("False")), 1, 1, vbTextCompare)
'    If Exposed Then s = VBA.Replace(s, "Attribute VB_Exposed = " & IIf(NewValue = True, CStr("False"), CStr("True")), "Attribute VB_Exposed = " & IIf(NewValue = True, CStr("True"), CStr("False")), 1, 1, vbTextCompare)
'    TxtOverwrite Path & Name & Extension, s
'    aModules.Init(ThisWorkbook).ImportPaths True, Path & Name & Extension
'End Sub

Public Sub Rename(NewName As String)
    If Not ModuleExists(NewName, oWorkbook) Then oModule.Name = NewName
End Sub

Function Extension() As String
    Dim ext As String
    Select Case oModule.Type
        Case vbext_ct_MSForm
            ext = ".frm"
        Case vbext_ct_ClassModule, vbext_ct_Document
            ext = ".cls"
'        Case vbext_ct_Document
'            If oModule.Name = "ThisWorkbook" Then
'                Extension = ".WBcls"
'            Else
'                Extension = ".DOCcls"
'            End If
        Case vbext_ct_StdModule
            ext = ".bas"
        Case Else
            ext = ".txt"
    End Select
    Extension = ext
End Function

Public Function Copy( _
                    TargetWorkbook As Workbook, _
                    OverwriteExisting As Boolean) As Boolean

    If Name = "ThisWorkbook" Then Exit Function
    If oModule.Type = vbext_ct_Document Then Exit Function
    If Parent.Name = TargetWorkbook.Name Then Exit Function
    Dim TempModule As VBIDE.VBComponent

    If ModuleExists(Name, TargetWorkbook) Then
        If OverwriteExisting = True Then
            With TargetWorkbook.VBProject
                .VBComponents.Remove .VBComponents(Name)
            End With
        Else
            Exit Function
        End If
    End If

    Dim fname As String
        fname = Environ("Temp") & "\" & Name & Extension
    oModule.Export fileName:=fname

    TargetWorkbook.VBProject.VBComponents.Import fileName:=fname
    Kill fname
    Copy = True
End Function

Sub Delete()
    If Ignore Then Exit Sub
    Application.DisplayAlerts = False
    If oModule.Type = vbext_ct_Document Then
        If oModule.Name = "ThisWorkbook" Then
            oModule.CodeModule.DeleteLines 1, oModule.CodeModule.CountOfLines
        Else
            If Parent.Sheets.count = 1 Then Parent.Sheets.Add
            GetSheetByCodeName(oWorkbook, Name).Delete
        End If
    Else
        Parent.VBProject.VBComponents.Remove oModule
    End If
    Application.DisplayAlerts = True
End Sub

Sub CodeRemove()
    If Ignore Then Exit Sub
    If oModule.CodeModule.CountOfLines = 0 Then Exit Sub
    oModule.CodeModule.DeleteLines 1, oModule.CodeModule.CountOfLines '+ 1
End Sub

Sub CodeMove(ToModule As VBComponent)
    If Ignore Then Exit Sub
    With ToModule.CodeModule
        .InsertLines 1, Header
        .InsertLines .CountOfLines + 1, body
    End With
    CodeRemove
End Sub

Sub DeleteIfEmpty()
    If Ignore Then Exit Sub
    If Name = "ThisWorkbook" Then Exit Sub
    If oModule.CodeModule.CountOfLines = 0 Then Delete
End Sub

Public Sub RemoveEmptyLinesButLeaveOne()
    Dim Code As String
    Dim currentline As String, nextline As String
    Dim i As Long
    With oModule.CodeModule
        If .CountOfLines > 0 Then
            For i = .CountOfLines - 1 To 1 Step -1
                currentline = Trim(.Lines(i, 1))
                nextline = Trim(.Lines(i + 1, 1))
                If Len(currentline) = 0 Then
                    If Len(nextline) = 0 Then
                        .DeleteLines i + 1, 1
                    End If
                End If
            Next
        End If
    End With
End Sub
Public Sub RemoveEmptyLines()
    Dim Code As String
    Dim currentline As String, nextline As String
    Dim i As Long
    With oModule.CodeModule
        If .CountOfLines > 0 Then
            For i = .CountOfLines - 1 To 1 Step -1
                currentline = Trim(.Lines(i, 1))
                If Len(currentline) = 0 Then
                    .DeleteLines i, 1
                End If
            Next
        End If
    End With
End Sub

Public Sub CommentsRemove()
    Dim AP As aProcedure
    For Each AP In Procedures
        AP.CommentsRemove False, Body_Code
    Next AP
End Sub

'aModules	Class


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Class      : aModules
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 29-06-2023 13:46    Alex
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit
Private ModuleCollection As Collection
Private oWorkbook As Workbook

Function Init(TargetWorkbook As Workbook) As aModules
'@AssignedModule aModules
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aModules
    Set oWorkbook = TargetWorkbook
    Dim Module As VBComponent
    Dim coll As New Collection
    Dim am As aModule
    For Each Module In oWorkbook.VBProject.VBComponents
        Set am = New aModule
        coll.Add am.Init(Module), Module.Name
    Next
    Set ModuleCollection = coll
    Set Init = Me
End Function

Sub PrintTodoList()
'@AssignedModule aModules
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aModules
    Dim am As aModule
    For Each am In Items
        am.PrintTodoList
    Next
End Sub

Sub Export(TargetPath As String, CreateSubFolders As Boolean)
'@AssignedModule aModules
'@INCLUDE PROCEDURE FoldersCreate
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aModules
    Dim ClassFolder As String:          ClassFolder = TargetPath
    Dim FormFolder As String:           FormFolder = TargetPath
    Dim NormalModuleFolder As String:   NormalModuleFolder = TargetPath
    Dim DocumentFolder As String:       DocumentFolder = TargetPath

    If CreateSubFolders Then
        FormFolder = TargetPath & "Userforms"
        NormalModuleFolder = TargetPath & "Modules"
        DocumentFolder = TargetPath & "Documents"
        ClassFolder = TargetPath & "Classes"
    
        FoldersCreate FormFolder
        FoldersCreate NormalModuleFolder
        FoldersCreate ClassFolder
        FoldersCreate DocumentFolder
    End If
    
    Dim am As aModule
    For Each am In Me.Classes:          am.Export ClassFolder:          Next am
    For Each am In Me.Userforms:        am.Export FormFolder:           Next am
    For Each am In Me.NormalModules:    am.Export NormalModuleFolder:   Next am
    For Each am In Me.Documents:        am.Export DocumentFolder:       Next am
End Sub

Sub InjectOptionExplicit()
'@AssignedModule aModules
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aModules
    Dim am As aModule
    For Each am In Items
        If Not am.Contains("Option Explicit", False, True, False) Then am.item.CodeModule.InsertLines 1, "Option Explicit"
    Next
End Sub



Public Sub Indent()
'@AssignedModule aModules
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aModules
    Dim Module As aModule
    For Each Module In Modules.Items
        Module.Indent
    Next
End Sub
Sub RemoveEmptyLinesButLeaveOne()
'@AssignedModule aModules
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aModules
    Dim Module As aModule
    For Each Module In Items
        Module.RemoveEmptyLinesButLeaveOne
    Next
End Sub
Sub UpdateProcedures()
'@AssignedModule aModules
'@INCLUDE CLASS aProcedure
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aModules
    Dim Procedure As aProcedure
    Dim Module As aModule
    For Each Module In Items
        If Module.TypeToLong = vbext_ct_StdModule Then
            For Each Procedure In Module.Procedures
                If UCase(CStr(Procedure)) <> UCase("UpdateAllProcedures") Then
                    Procedure.Update
                End If
            Next
        End If
    Next
End Sub

Function Items() As Collection
'@AssignedModule aModules
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aModules
    Set Items = ModuleCollection
End Function

Public Function item(IndexOrName As Variant) As aModule
'@AssignedModule aModules
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aModules
    Set item = Items.item(IndexOrName)
End Function

Function NormalModules() As Collection
'@AssignedModule aModules
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aModules
    Dim coll As New Collection
    Dim element As aModule
    For Each element In ModuleCollection
        If element.TypeToLong = vbext_ct_StdModule Then
            coll.Add element, element.Name
        End If
    Next
    Set NormalModules = coll
End Function

Function Userforms() As Collection
'@AssignedModule aModules
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aModules
    Dim coll    As New Collection
    Dim element As aModule
    For Each element In ModuleCollection
        If element.TypeToLong = vbext_ct_MSForm Then
            coll.Add element, element.Name
        End If
    Next
    Set Userforms = coll
End Function

Function Classes() As Collection
'@AssignedModule aModules
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aModules
    Dim coll    As New Collection
    Dim element As aModule
    For Each element In ModuleCollection
        If element.TypeToLong = vbext_ct_ClassModule Then
'            Debug.Print element.Name
            coll.Add element, element.Name
        End If
    Next
    Set Classes = coll
End Function

Function Documents() As Collection
'@AssignedModule aModules
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aModules
    Dim coll    As New Collection
    Dim element As aModule
    For Each element In ModuleCollection
        If element.TypeToLong = vbext_ct_Document Then
            coll.Add element, element.Name
        End If
    Next
    Set Documents = coll
End Function

Public Function Exists(TargetName As String) As Boolean
'@AssignedModule aModules
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aModules
    Dim Module As VBComponent
    On Error Resume Next
    Set Module = oWorkbook.VBProject.VBComponents(TargetName)
    On Error GoTo 0
    Exists = Not Module Is Nothing
End Function

Function AddOrSet( _
                    TargetName As String, _
                    ModuleType As VBIDE.vbext_ComponentType) As aModule
'@AssignedModule aModules
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aModules

    Dim Module As VBComponent
    On Error Resume Next
    Set Module = oWorkbook.VBProject.VBComponents(TargetName)
    On Error GoTo 0
    If Module Is Nothing Then
        Set Module = oWorkbook.VBProject.VBComponents.Add(ModuleType)
        Module.Name = TargetName
    End If
    Dim am As New aModule
    am.Init Module
    Set AddOrSet = am
End Function

Sub ImportPaths(ReplaceExisting As Boolean, ParamArray Paths() As Variant)
'@AssignedModule aModules
'@INCLUDE PROCEDURE Toast
'@INCLUDE PROCEDURE DataFilePartExtension
'@INCLUDE PROCEDURE DataFilePartName
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aModules
    If LBound(Paths) = -1 Then Exit Sub
    
    Dim Extension          As String
    Dim TargetName         As String
    Dim element
    
    Dim PASS As Boolean
    For Each element In Paths
        Select Case True
        Case element Like "*.cls", "*.frm", "*.bas", "*.bas"
        Case Else: Exit Sub
        End Select
    Next
    For Each element In Paths
        TargetName = DataFilePartName(CStr(element), False)
        Extension = DataFilePartExtension(CStr(element))
        If Exists(TargetName) Then
            If ReplaceExisting Then
                aModule.Init(oWorkbook.VBProject.VBComponents(TargetName)).Delete
                oWorkbook.VBProject.VBComponents.Import CStr(element)
            End If
        Else
            oWorkbook.VBProject.VBComponents.Import CStr(element)
        End If
    Next element

    'https://github.com/rfl808/Notify
    Toast , "Import successful"
End Sub

Sub ImportPicker(ReplaceExisting As Boolean)
'@AssignedModule aModules
'@INCLUDE PROCEDURE ArrayAllocated
'@INCLUDE PROCEDURE WorksheetExists
'@INCLUDE PROCEDURE Toast
'@INCLUDE PROCEDURE DataFilePartFolder
'@INCLUDE PROCEDURE DataFilePicker
'@INCLUDE PROCEDURE DataFilePartExtension
'@INCLUDE PROCEDURE DataFilePartName
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aModules
    Dim SelectedModules: SelectedModules = DataFilePicker(Array("bas", "frm", "cls"), True)
    If Not ArrayAllocated(SelectedModules) Then Exit Sub
    Dim basePath           As String:   basePath = DataFilePartFolder(SelectedModules(1), True)
'    Dim SourceWorkbook     As Workbook
'    Dim SourceWorkbookName As String:   SourceWorkbookName = Dir(basePath & "*.xl*")
'    Dim wasOpen            As Boolean
'
'    If SourceWorkbookName <> "" Then: wasOpen = WorkbookExists(SourceWorkbookName)

    Dim Extension          As String
    Dim TargetName         As String
    Dim element
    For Each element In SelectedModules
        TargetName = DataFilePartName(CStr(element), False)
        Extension = DataFilePartExtension(CStr(element))
'        If UCase(Extension) <> UCase("doccls") Then
        If Exists(TargetName) Then
            If ReplaceExisting Then
                aModule.Init(oWorkbook.VBProject.VBComponents(TargetName)).Delete
                oWorkbook.VBProject.VBComponents.Import CStr(element)
            End If
        Else
            oWorkbook.VBProject.VBComponents.Import CStr(element)
        End If

'        ElseIf UCase(Extension) = UCase("doccls") And SourceWorkbookName <> "" Then
'            If WorksheetExists(TargetName, oWorkbook) Then
'                If ReplaceExisting Then
''                    TargetWorkbook.Worksheets.Copy
'                    TargetWorkbook.Worksheets(TargetName).Delete
'                Else
'                    GoTo NextElement
'                End If
'
'                If wasOpen = False Then
'                    Application.EnableEvents = False
'                    Set SourceWorkbook = Workbooks.Open(basePath & SourceWorkbookName)
'                Else
'                    Set SourceWorkbook = Workbooks(SourceWorkbookName)
'                End If
'                SourceWorkbook.SHEETS(TargetName).Copy Before:=TargetWorkbook.SHEETS(1)
'                Application.EnableEvents = True
'            End If
'        End If
NextElement:
    Next element

'    If wasOpen = False And WorkbookExists(SourceWorkbookName) Then SourceWorkbook.Close False
    'https://github.com/rfl808/Notify
    Toast , "Import successful"
End Sub

Sub ListProcedures()
'@AssignedModule aModules
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aModules
    Dim Module As VBComponent
    For Each Module In oWorkbook.VBProject.VBComponents
        If Module.Type <> vbext_ct_ClassModule And Module.Type <> vbext_ct_Document Then
            If Module.CodeModule.CountOfLines > 0 Then
                aModule.Init(Module).ListProcedures
            End If
        End If
    Next
End Sub

Sub SideBySide(ParamArray TwoModuleNamesOrOneFormName() As Variant)
'@AssignedModule aModules
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aModules
 
    Dim Module1 As VBComponent
    Dim Module2 As VBComponent
    Set Module1 = oWorkbook.VBProject.VBComponents(TwoModuleNamesOrOneFormName(0))
    If UBound(TwoModuleNamesOrOneFormName) > 0 Then Set Module2 = oWorkbook.VBProject.VBComponents(TwoModuleNamesOrOneFormName(1))
    With Module1.CodeModule.CodePane.Window
        .Width = 800
        .Left = 1
        .Top = 1
        .Height = 932
        .Visible = True
        .WindowState = vbext_ws_Normal
        .SetFocus
    End With
    If Not Module2 Is Nothing Then
        With Module2.CodeModule.CodePane.Window
            .Width = 800
            .Left = 800
            .Top = 1
            .Height = 932
            .Visible = True
            .WindowState = vbext_ws_Normal
            .SetFocus
        End With
    ElseIf Module1.Type = vbext_ct_MSForm Then
        With Module1.DesignerWindow
            .Width = 800
            .Left = 800
            .Top = 1
            .Height = 932
            .Visible = True
            .WindowState = vbext_ws_Normal
            Module1.DesignerWindow.SetFocus
        End With
        Exit Sub

    End If
End Sub
'
'Sub CaseProperModulesOfWorkbook(Optional TargetWorkbook As Workbook)
'    Dim Module As VBComponent
'    For Each Module In TargetWorkbook.VBProject.VBComponents
'        If Module.Name <> "ThisWorkbook" Then
'            Module.Name = UCase(Left(Module.Name, 1)) & Mid(Module.Name, 2)
'        End If
'    Next
'End Sub

Public Sub Refresh()
'@AssignedModule aModules
'@INCLUDE PROCEDURE Toast
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aModules
    If oWorkbook.Name <> ThisWorkbook.Name Then
        ExportModules
        ImportModules
    Else
        Toast "Can't touch this"
    End If
End Sub

Sub ExportProcedures(TargetPath As String)
'@AssignedModule aModules
'@INCLUDE PROCEDURE FoldersCreate
'@INCLUDE CLASS aProcedure
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aModules
    TargetPath = Replace(TargetPath & "\", "\\", "\")
    Dim ProcedurePath As String
    Dim am            As aModule
    Dim AP            As aProcedure
    Dim coll          As New Collection
    Dim ModulePath    As String
    For Each am In NormalModules
    'Userforms and Classes should be exported as they are
        ModulePath = TargetPath & "Procedures\" & am.Name & "\"
        FoldersCreate ModulePath
        am.ExportProcedures ModulePath
    Next
End Sub

Private Sub ExportModules()
'@AssignedModule aModules
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aModules
    Dim bExport      As Boolean
    Dim szExportPath As String
    Dim szFileName   As String
    Dim cmpComponent As VBIDE.VBComponent
    If FolderWithVBAProjectFiles = "Error" Then
        MsgBox "Export Folder not exist"
        Exit Sub
    End If
    On Error Resume Next
    Kill FolderWithVBAProjectFiles & "\*.*"
    On Error GoTo 0
    szExportPath = FolderWithVBAProjectFiles & "\"
    For Each cmpComponent In oWorkbook.VBProject.VBComponents
        bExport = True
        szFileName = cmpComponent.Name
        Select Case cmpComponent.Type
        Case vbext_ct_ClassModule
            szFileName = szFileName & ".cls"
        Case vbext_ct_MSForm
            szFileName = szFileName & ".frm"
        Case vbext_ct_StdModule
            szFileName = szFileName & ".bas"
        Case vbext_ct_Document
            bExport = False
        End Select
        If bExport Then
            cmpComponent.Export szExportPath & szFileName
        End If
    Next cmpComponent
End Sub

Private Sub ImportModules()
'@AssignedModule aModules
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aModules
    Dim objFSO        As Scripting.FileSystemObject
    Dim objFile       As Scripting.File
    Dim szImportPath  As String
    Dim szFileName    As String
    Dim cmpComponents As VBIDE.VBComponents
    If oWorkbook.Name = ThisWorkbook.Name Then
        MsgBox "Select another destination workbook" & _
        "Not possible to import in this workbook "
        Exit Sub
    End If
    If FolderWithVBAProjectFiles = "Error" Then
        MsgBox "Import Folder not exist"
        Exit Sub
    End If
    szImportPath = FolderWithVBAProjectFiles & "\"
    Set objFSO = New Scripting.FileSystemObject
    If objFSO.GetFolder(szImportPath).Files.count = 0 Then
        MsgBox "There are no files to import"
        Exit Sub
    End If
    Call DeleteVBAModulesAndUserForms
    Set cmpComponents = oWorkbook.VBProject.VBComponents
    For Each objFile In objFSO.GetFolder(szImportPath).Files
        If (objFSO.GetExtensionName(objFile.Name) = "cls") Or _
            (objFSO.GetExtensionName(objFile.Name) = "frm") Or _
            (objFSO.GetExtensionName(objFile.Name) = "bas") Then
            cmpComponents.Import objFile.Path
        End If
    Next objFile
End Sub

Private Function FolderWithVBAProjectFiles() As String
'@AssignedModule aModules
'@INCLUDE PROCEDURE FolderExists
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aModules
    Dim WshShell    As Object
    Dim FSO         As Object
    Dim SpecialPath As String
    Set WshShell = CreateObject("WScript.Shell")
    Set FSO = CreateObject("scripting.filesystemobject")
    SpecialPath = WshShell.SpecialFolders("MyDocuments")
    If Right(SpecialPath, 1) <> "\" Then
        SpecialPath = SpecialPath & "\"
    End If
    If FSO.FolderExists(SpecialPath & "VBAProjectFiles") = False Then
        On Error Resume Next
        MkDir SpecialPath & "VBAProjectFiles"
        On Error GoTo 0
    End If
    If FSO.FolderExists(SpecialPath & "VBAProjectFiles") = True Then
        FolderWithVBAProjectFiles = SpecialPath & "VBAProjectFiles"
    Else
        FolderWithVBAProjectFiles = "Error"
    End If
End Function

Private Sub DeleteVBAModulesAndUserForms()
'@AssignedModule aModules
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aModules
    Dim vbProj As VBIDE.VBProject
    Dim vbComp As VBIDE.VBComponent
    Set vbProj = oWorkbook.VBProject
    For Each vbComp In vbProj.VBComponents
        If vbComp.Type = vbext_ct_Document Then
        Else
            vbProj.VBComponents.Remove vbComp
        End If
    Next vbComp
End Sub

Public Sub CommentsRemove()
'@AssignedModule aModules
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aModules
    Dim am As aModule
    For Each am In Items
        am.CommentsRemove
    Next
End Sub

Sub RemoveProcedureList()
'@AssignedModule aModules
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aModules
    Dim am As aModule
    For Each am In Items
        am.FolderDelete "ListOfProcedures"
    Next
End Sub

Function ClassNames()
'@AssignedModule aModules
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aModules
    Set ClassNames = NamesOf(vbext_ct_ClassModule)
End Function
Function ModuleNames()
'@AssignedModule aModules
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aModules
    Set ModuleNames = NamesOf(vbext_ct_StdModule)
End Function

Function UserformNames()
'@AssignedModule aModules
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aModules
    Set UserformNames = NamesOf(vbext_ct_MSForm)
End Function
'Sub CaseProperModulesOfWorkbook()
'    Dim Module As VBComponent
'    For Each Module In oWorkbook.VBProject.VBComponents
'        If Module.Name <> "ThisWorkbook" Then
'            Module.Name = UCase(Left(Module.Name, 1)) & Mid(Module.Name, 2)
'        End If
'    Next
'End Sub


Public Function NamesOf(ModuleType As vbext_ComponentType)
'@AssignedModule aModules
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aModules
    Dim coll   As New Collection
    Dim Module As VBComponent
    For Each Module In oWorkbook.VBProject.VBComponents
        If Module.Type = ModuleType Then
            coll.Add Module.Name
        End If
    Next
    Set NamesOf = coll
End Function



'aCollection	Class


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Class      : aCollection
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 04-05-2023 12:17    Alex
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Public RestrictionTypename As String
Private myCollection As Collection

Public Property Get Items() As Collection
    Set Items = myCollection
End Property

Public Function Init(coll As Collection) As aCollection
    Select Case RestrictionTypename
    Case ""
        Set myCollection = coll
 
    Case Else
        Set myCollection = New Collection
        Dim element
        For Each element In coll
            Add element
        Next
    End Select
    Set Init = Me
End Function

Public Property Get item(NameOrNumber As Variant) As Variant
  Set item = myCollection(IndexOf(NameOrNumber))
End Property

Public Function IndexOf(ByVal item As Variant, _
                        Optional ByVal StartIndex As Long = 1) As Long
    Dim collindex As Long
    Dim collitemtype As Integer
    Dim itemtype As Integer

    itemtype = VarType(item)
    For collindex = StartIndex To myCollection.count
        collitemtype = VarType(myCollection(collindex))
        If collitemtype = itemtype Then
            Select Case collitemtype
                Case 0 To 1: IndexOf = collindex: Exit Function
                Case 2 To 8, 11, 14, 17: If myCollection(collindex) = item Then IndexOf = collindex: Exit Function
                Case 9: If myCollection(collindex) Is item Then IndexOf = collindex: Exit Function
                Case Else
                    Debug.Print "Unsupported type for CollectionIndexOf."
                    Debug.Assert False
            End Select
        End If
    Next
    IndexOf = 0
End Function

Public Sub RestrictionSet(ByVal Value As String)
    RestrictionTypename = Value
End Sub

Public Sub RestrictionRemove()
    RestrictionTypename = ""
End Sub

Public Sub Add(NewItem As Variant, Optional Description As String)
    Err.Clear
    Select Case RestrictionTypename
    Case ""
        myCollection.Add NewItem
    Case Else
        If TypeName(NewItem) <> RestrictionTypename Then
            MsgBox "TypeName does not match restriction: " & RestrictionTypename
        Else
            On Error Resume Next
            myCollection.Add NewItem, Description
            On Error GoTo 0
            If Err.Number <> 0 Then Debug.Print "Item " & Description & " already contained"
        End If
    End Select
End Sub

Public Property Get count() As Long
    count = myCollection.count
End Property

Public Sub Remove(NameOrNumber As Variant)
  myCollection.Remove NameOrNumber
End Sub

Public Function ToString(delim As String) As String
    Dim element
    Dim out As String
    For Each element In myCollection
        out = IIf(out = "", element, out & delim & element)
    Next
    ToString = out
End Function

Public Function Distinct() As aCollection
    Dim Result As Collection: Set Result = New Collection
    Dim eachItem As Variant
    On Error Resume Next
    For Each eachItem In myCollection
        Result.Add eachItem, CStr(eachItem)
    Next
    On Error GoTo 0
    Set myCollection = Result
    Set Distinct = Me
End Function

Public Function Unique() As aCollection
    '-----------------------------------------------------------------------------------------------------------
    ' CollectionUnique     - Returns a collection of unique values from a full collection
    '                                   - In : myCollection As Collection
    '                                   - Out: Result of values, or error
    '                                   - Last Updated: 8/7/11 by AJS
    '-----------------------------------------------------------------------------------------------------------
    Dim Result As New Collection
    Dim eachItem As Variant, eachUnique As Variant
    Dim MatchFound As Boolean
'    On Error GoTo IsError:
        For Each eachItem In myCollection
            MatchFound = False
            For Each eachUnique In Result
                If eachItem = eachUnique Then
                    MatchFound = True
                    Exit For
                End If
            Next
            If MatchFound = False Then Result.Add eachItem
        Next
        Set myCollection = Result
        Set Unique = Me
'    Exit Function
'IsError:
'    Unique = CVErr(xlErrNA)
'    Debug.Print "Error in aCollection.Unique: " & Err.Number & ": " & Err.Description
End Function

Public Function Sort() As aCollection
    Dim iCounter As Integer
    Dim iCounter2 As Integer
    Dim Temp As Variant
    For iCounter = 1 To myCollection.count - 1
        For iCounter2 = iCounter + 1 To myCollection.count
            If myCollection(iCounter) > myCollection(iCounter2) Then
                Temp = myCollection(iCounter2)
                myCollection.Remove iCounter2
                myCollection.Add Temp, , iCounter
            End If
        Next iCounter2
    Next iCounter
    Set Sort = Me
End Function

Public Function Contains( _
                        Optional Key As Variant, _
                        Optional item As Variant) As Boolean
    Dim strKey As String
    Dim var As Variant
    If Not IsMissing(Key) Then
        strKey = CStr(Key)
        On Error Resume Next
        Contains = True
        var = myCollection(strKey)
        If Err.Number = 91 Then GoTo CheckForObject
        If Err.Number = 5 Then GoTo NotFound
        On Error GoTo 0
        Exit Function
CheckForObject:
        If IsObject(myCollection(strKey)) Then
            Contains = True
            On Error GoTo 0
            Exit Function
        End If
NotFound:
        Contains = False
        On Error GoTo 0
        Exit Function
    ElseIf Not IsMissing(item) Then
        Contains = False
        For Each var In myCollection
            If var = item Then
                Contains = True
                Exit Function
            End If
        Next var
    Else
        Contains = False
    End If
End Function

Function ToArray() As Variant
    Dim a() As Variant: ReDim a(0 To myCollection.count - 1)
    Dim i As Long
    For i = 1 To myCollection.count
        a(i - 1) = myCollection.item(i)
    Next
    ToArray = a
End Function

Public Function Reverse() As aCollection
    Dim output As New Collection
    Dim i As Long
    For i = myCollection.count To 1 Step -1
        output.Add myCollection.item(i)
    Next i
    Set myCollection = output
    Set Reverse = Me
End Function

'------------------------------------------------------------------------'
'Function Mid : returns subset of a collection                       '
'  Similar to Mid$() on strings.                                         '
'See also: FromToColl, LeftColl, RightColl, ButLastColl                  '
'------------------------------------------------------------------------'
Public Function Mid(ByVal Start As Long, Optional ByVal Length As Variant) As aCollection
    Dim Result As New Collection
    Dim count As Long
    Dim c As Long

    count = myCollection.count
    If Start < 1 Then Error 5
    If Start > count Then
        Set Result = Result
    Else
        If IsMissing(Length) Then
            For c = Start To count
                Result.Add myCollection(c)
            Next
        ElseIf (Length >= (count + 1 - Start)) Then
            For c = Start To count
                Result.Add myCollection(c)
            Next
        ElseIf Length < 0 Then
            Error 5
        Else
            For c = Start To Start + count - 1
                Result.Add myCollection(c)
            Next
        End If
    End If
    Set myCollection = Result
    Set Mid = Me
End Function

'------------------------------------------------------------------------'
'Function FromTo : returns subset of a collection                    '
'See also: MidColl, LeftColl, RightColl                                  '
'------------------------------------------------------------------------'
Public Function FromTo(ByVal FromOffset As Long, ByVal ToOffset As Long) As aCollection
    Dim Result As New Collection
    Dim c As Long

    If FromOffset > myCollection.count Then
        Set FromTo = Result
        Exit Function
    ElseIf FromOffset < 1 Then
        Error 5
    End If

    If ToOffset > myCollection.count Then
        ToOffset = myCollection.count
    ElseIf ToOffset < 1 Then
        Error 5
    End If

    If ToOffset < FromOffset Then
        Set FromTo = Result
        Exit Function
    Else
        For c = FromOffset To ToOffset
            Result.Add myCollection(c)
        Next
    End If

    Set myCollection = Result
    Set FromTo = Me
End Function

'------------------------------------------------------------------------'
'Function LeftColl : returns left-most elements of a collection          '
'  Similar to Left$() on strings.                                        '
'See also: MidColl, RightColl, ButLastColl                               '
'------------------------------------------------------------------------'
Public Function Left(ByVal Length As Long) As aCollection
    Dim Result As New Collection
    Dim c As Long

    If Length > myCollection.count Then Length = myCollection.count
    For c = 1 To Length
        Result.Add myCollection(c)
    Next
    Set myCollection = Result
    Set Left = Me
End Function

'------------------------------------------------------------------------'
'Function RightColl : returns right-most elements of a collection        '
'  Similar to Right$() on strings.                                       '
'See also: MidColl, LeftColl                                             '
'------------------------------------------------------------------------'
Public Function Right(ByVal Length As Long) As aCollection
    Dim Result As New Collection
    Dim c As Long

    If Length > myCollection.count Then Length = myCollection.count
    For c = myCollection.count - Length + 1 To myCollection.count
        Result.Add myCollection(c)
    Next
    Set myCollection = Result
    Set Right = Me

End Function

Function Filter( _
            Match As String, _
            IgnoreCase As Boolean, _
            Include As Boolean) As aCollection
    Dim Result As New Collection
    If IgnoreCase Then Match = UCase(Match)
    Dim element
    For Each element In myCollection
        If IgnoreCase Then
            If Include Then
                If UCase(element) Like Match Then Result.Add element
            Else
                If Not UCase(element) Like Match Then Result.Add element
            End If
        Else
            If Include Then
                If UCase(element) Like Match Then Result.Add element
            Else
                If UCase(element) Like Match Then Result.Add element
            End If
        End If
    Next
    Set myCollection = Result
    Set Filter = Me
End Function


Public Function CollectionsToArray2D(collections As Collection) As Variant
    If collections.count = 0 Then Exit Function
    Dim columnCount As Long:    columnCount = collections.count
    Dim rowCount As Long:       rowCount = collections.item(1).count
    Dim var As Variant
    ReDim var(1 To rowCount, 1 To columnCount)
    Dim cols As Long
    Dim rows As Long
    For rows = 1 To rowCount
        For cols = 1 To collections.count
            var(rows, cols) = collections(cols).item(rows)
        Next cols
    Next rows
    CollectionsToArray2D = var
End Function

'M_Notify	Module

Option Explicit

#If VBA7 Then
    Private Declare PtrSafe Function Shell_NotifyIconW Lib "shell32.dll" (ByVal dwMessage As Long, ByRef nfIconData As NOTIFYICONDATAW) As Long
    Private Declare PtrSafe Sub CopyMemory Lib "kernel32.dll" Alias "RtlMoveMemory" (ByRef Destination As Any, ByRef Source As Any, ByVal Length As Long)
#Else
    Private Declare Function Shell_NotifyIconW Lib "shell32.dll" (ByVal dwMessage As Long, ByRef nfIconData As NOTIFYICONDATAW) As Long
    Private Declare Sub CopyMemory Lib "kernel32.dll" Alias "RtlMoveMemory" (ByRef Destination As Any, ByRef source As Any, ByVal Length As Long)
#End If

Private Type NOTIFYICONDATAW
    cbSize As Long

    #If Win64 Then
        padding1 As Long
    #End If

    hwnd As LongPtr
    uID As Long
    uFlags As Long
    uCallbackMessage As Long

    #If Win64 Then
        padding2 As Long
    #End If

    hIcon As LongPtr
    szTip(1 To 128 * 2) As Byte
    dwState As Long
    dwStateMask As Long
    szInfo(1 To 256 * 2) As Byte
    uTimeout As Long
    szInfoTitle(1 To 64 * 2) As Byte
    dwInfoFlags As Long
End Type

Private Const NIM_ADD As Long = &H0&
Private Const NIM_MODIFY As Long = &H1&
Private Const NIF_INFO As Long = &H10&

Private Function Min(ByVal a As Long, ByVal b As Long) As Long
'@AssignedModule M_Notify
    If a < b Then Min = a Else Min = b
End Function

Public Sub Toast(Optional ByVal Title As String, Optional ByVal info As String, Optional ByVal flag As Long)
    Rem toast "Hello World", "from Excel",1
    Rem https://github.com/rfl808/Notify
    '@INCLUDE Min
'@AssignedModule M_Notify
'@INCLUDE PROCEDURE Min
'@INCLUDE DECLARATION NIF_INFO
'@INCLUDE DECLARATION NIM_ADD
'@INCLUDE DECLARATION NIM_MODIFY
'@INCLUDE DECLARATION Shell_NotifyIconW
'@INCLUDE DECLARATION CopyMemory
'@INCLUDE DECLARATION NOTIFYICONDATAW
    Dim nfIconData As NOTIFYICONDATAW
    info = info & " "
    Title = Title & " "
    With nfIconData
        .cbSize = Len(nfIconData)
        .uFlags = NIF_INFO
        .dwInfoFlags = flag
        If Len(Title) > 0 Then
            CopyMemory ByVal VarPtr(.szInfoTitle(LBound(.szInfoTitle))), ByVal StrPtr(Title), Min(Len(Title) * 2, UBound(.szInfoTitle) - LBound(.szInfoTitle) + 1 - 2)
        End If
        If Len(info) > 0 Then
            CopyMemory ByVal VarPtr(.szInfo(LBound(.szInfo))), ByVal StrPtr(info), Min(Len(info) * 2, UBound(.szInfo) - LBound(.szInfo) + 1 - 2)
        End If
    End With
    Shell_NotifyIconW NIM_ADD, nfIconData
    Shell_NotifyIconW NIM_MODIFY, nfIconData
End Sub

Rem Flags for the balloon message..
Rem None = 0
Rem Information = 1
Rem Exclamation = 2
Rem Critical = 3

'uProjectManager	UserForm

'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Userform   : uProjectManager
'* Created    : 06-10-2022 10:39
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Private Sub goToFolder_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
'@AssignedModule uProjectManager
'@INCLUDE PROCEDURE FollowLink
'@INCLUDE USERFORM uProjectManager
    FollowLink Environ("USERprofile") & "\Documents\vbArc\"
End Sub

Private Sub GetInfo_Click()
'@AssignedModule uProjectManager
'@INCLUDE PROCEDURE PlayTheSound
'@INCLUDE CLASS aUserform
'@INCLUDE USERFORM uProjectManager
'@INCLUDE USERFORM uAuthor
    With aUserform.Init(Me)
        .Transition .Effect(GetInfo, "Top", GetInfo.Top - 10, 150)
        PlayTheSound ThisWorkbook.Path & "\sound\coin.wav"
        .Transition .Effect(GetInfo, "Top", GetInfo.Top + 10, 150)
    End With
    uAuthor.Show
End Sub


Private Sub ReloadListbox_Click()
'@AssignedModule uProjectManager
'@INCLUDE CLASS aListBox
'@INCLUDE USERFORM uProjectManager
    listOpenBooks.Clear
    aListBox.Init(listOpenBooks).LoadVBProjects
    Label1.Caption = ""
End Sub

Private Sub listOpenBooks_Click()
'@AssignedModule uProjectManager
'@INCLUDE USERFORM uProjectManager
    AssignPathLabel
End Sub

Private Sub AssignPathLabel()
'@AssignedModule uProjectManager
'@INCLUDE USERFORM uProjectManager
    If listOpenBooks.ListIndex = -1 Then Exit Sub
    Label1.Caption = IIf(UseWBpath, _
                        Workbooks(listOpenBooks.List(listOpenBooks.ListIndex)).Path & "\", _
                        Environ("USERprofile") & "\Documents\" & "vbArc\Backups\")
End Sub

Private Sub SelectFromList_Click()
'@AssignedModule uProjectManager
'@INCLUDE USERFORM uProjectManager
    If listOpenBooks.ListIndex = -1 Then
        MsgBox "No book selected"
        Exit Sub
    End If
    Dim TargetWorkbook As Workbook
    Set TargetWorkbook = Workbooks(listOpenBooks.List(listOpenBooks.ListIndex))
    DoExport TargetWorkbook
End Sub

Private Sub UserForm_Initialize()
'@AssignedModule uProjectManager
'@INCLUDE CLASS aListBox
'@INCLUDE CLASS aUserform
'@INCLUDE USERFORM uProjectManager
    aListBox.Init(listOpenBooks).LoadVBProjects
    aListBox.Init(listOpenBooks).SortOnColumn 0
    aUserform.Init(Me).LoadOptions
    AssignPathLabel
End Sub

Private Sub DoExport(TargetWorkbook As Workbook)
'@AssignedModule uProjectManager
'@INCLUDE PROCEDURE Toast
'@INCLUDE PROCEDURE WorkbookProjectProtected
'@INCLUDE CLASS aWorkbook
'@INCLUDE USERFORM uProjectManager


    If WorkbookProjectProtected(TargetWorkbook) Then
        Toast "Project of " & TargetWorkbook.Name & " is protected."
        Exit Sub
    End If

    Me.Hide

    aWorkbook.Init(TargetWorkbook).ExportProject _
                                                 bExportComponents:=chExportComponents.Value _
                                                , bSeparateProcedures:=chExportProcedures.Value _
                                                , bExportXML:=chExportXML.Value _
                                                , bExportReferences:=chExportReferences.Value _
                                                , bExportDeclarations:=chExportDeclarations.Value _
                                                , bExportUnified:=chExportUnified.Value _
                                                , bWorkbookBackup:=chWorkbookBackup.Value _
                                                , UseWorkbookFolder:=UseWBpath _
                                                , OpenFolderAfterExport:=OpenFolder.Value
        
    Me.Show
End Sub

Private Sub SelectFile_Click()
'@AssignedModule uProjectManager
'@INCLUDE PROCEDURE PickExcelFile
'@INCLUDE USERFORM uProjectManager
    Dim fPath As String: fPath = PickExcelFile
    If fPath = "" Then Exit Sub
    Dim TargetWorkbook As Workbook
    Set TargetWorkbook = Workbooks.Open(fileName:=fPath, UpdateLinks:=0, ReadOnly:=False)
    DoExport TargetWorkbook
    TargetWorkbook.Close True
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
'@AssignedModule uProjectManager
'@INCLUDE CLASS aUserform
'@INCLUDE USERFORM uProjectManager
    aUserform.Init(Me).SaveOptions includeListbox:=False
End Sub

Private Sub UseWBpath_Click()
'@AssignedModule uProjectManager
'@INCLUDE USERFORM uProjectManager
    AssignPathLabel
End Sub

'clsEditOpenXML	Class

Option Explicit
Private mbCreateBackup As Boolean
Private mvSourceFile As Variant
Private msSheet2Change As String
Private msSheetId As String
Private msSheetFileName As String
Private mbAddedZip As Boolean
Private mvXMLFolderRoot As Variant
Private mvxmlfolder As Variant
Public Enum XMLFolder
    XMLFolder_root = 1
    XMLFolder_rels = 2
    XMLFolder_xl = 3
    XMLFolder_customUI = 4
    XMLFolder_docProps = 5
End Enum

Public Sub ExtractRibbonX(sFullFile As String, sSaveFile As String)
'@AssignedModule clsEditOpenXML
'@INCLUDE CLASS clsEditOpenXML
    Dim cEditOpenXML As clsEditOpenXML
    Dim sXML As String
    Dim oxmldoc As MSXML2.DOMDocument
    Set cEditOpenXML = New clsEditOpenXML
    With cEditOpenXML
        .CreateBackup = False
        .SourceFile = sFullFile
        .UnzipFile
        sXML = .GetXMLFromFile("customUI.xml", XMLFolder_customUI)
        If Len(sXML) > 0 Then
            Set oxmldoc = New DOMDocument
            oxmldoc.LoadXML sXML
            oxmldoc.Save sSaveFile
        End If
        sXML = .GetXMLFromFile("customUI14.xml", XMLFolder_customUI)
        If Len(sXML) > 0 Then
            Set oxmldoc = New DOMDocument
            oxmldoc.LoadXML sXML
            oxmldoc.Save Replace(sSaveFile, ".xml", "14.xml")
        End If
    End With
    Set cEditOpenXML = Nothing
End Sub

Public Sub WriteRibbonXML2File(sFile As String, sXML As String)
'@AssignedModule clsEditOpenXML
'@INCLUDE CLASS clsEditOpenXML
    Dim cEditOpenXML As clsEditOpenXML

    Set cEditOpenXML = New clsEditOpenXML

    With cEditOpenXML
        .SourceFile = sFile

        .UnzipFile

        .WriteXML2File sXML, "customUI.xml", XMLFolder_customUI

        .ZipAllFilesInFolder
    End With

    Set cEditOpenXML = Nothing
End Sub

Public Function GetXMLFromFile(sFileName As String, sXMLFolder As XMLFolder) As String
'@AssignedModule clsEditOpenXML
'@INCLUDE CLASS clsEditOpenXML
    Dim oxmldoc As MSXML2.DOMDocument
    If Len(XMLFolder(sXMLFolder)) = 0 Then
        GetXMLFromFile = ""
    Else
        Set oxmldoc = New MSXML2.DOMDocument
        oxmldoc.Load XMLFolder(sXMLFolder) & sFileName
        GetXMLFromFile = oxmldoc.xml
        Set oxmldoc = Nothing
    End If
End Function

Public Sub WriteXML2File(sXML As String, sFileName As String, sXMLFolder As XMLFolder)
'@AssignedModule clsEditOpenXML
'@INCLUDE PROCEDURE FolderExists
'@INCLUDE CLASS clsEditOpenXML
    Dim oxmldoc As MSXML2.DOMDocument
    Set oxmldoc = New MSXML2.DOMDocument
    If sXMLFolder = XMLFolder_customUI Then
        If Not FolderExists(XMLFolder(XMLFolder_customUI)) Then
            MkDir XMLFolder(XMLFolder_customUI)
            oxmldoc.LoadXML sXML
            oxmldoc.Save XMLFolder(sXMLFolder) & sFileName
            AddCustomUIToRels
        End If
    End If
    oxmldoc.LoadXML sXML
    oxmldoc.Save XMLFolder(sXMLFolder) & sFileName
End Sub

Public Sub AddCustomUIToRels()
'@AssignedModule clsEditOpenXML
'@INCLUDE CLASS clsEditOpenXML
    Dim oxmldoc As MSXML2.DOMDocument
    Dim oXMLElement As MSXML2.IXMLDOMNode
    Dim oXMLAttrib As MSXML2.IXMLDOMAttribute
    Dim oNamedNodeMap As MSXML2.IXMLDOMNamedNodeMap
    Dim oXMLRelsList As MSXML2.IXMLDOMNodeList
    Set oxmldoc = New MSXML2.DOMDocument
    oxmldoc.Load XMLFolder(XMLFolder_rels) & ".rels"
    Set oXMLElement = oxmldoc.createNode(1, "Relationship", "http://schemas.openxmlformats.org/package/2006/relationships")
    Set oNamedNodeMap = oXMLElement.Attributes
    Set oXMLAttrib = oxmldoc.createAttribute("Id")
    oXMLAttrib.NodeValue = "cuID"
    oNamedNodeMap.setNamedItem oXMLAttrib
    Set oXMLAttrib = oxmldoc.createAttribute("Type")
    oXMLAttrib.NodeValue = "http://schemas.microsoft.com/office/2006/relationships/ui/extensibility"
    oNamedNodeMap.setNamedItem oXMLAttrib
    Set oXMLAttrib = oxmldoc.createAttribute("Target")
    oXMLAttrib.NodeValue = "customUI/customUI.xml"
    oNamedNodeMap.setNamedItem oXMLAttrib
    Set oXMLRelsList = oxmldoc.SelectNodes("/Relationships")
    oXMLRelsList.item(0).appendChild oXMLElement
    oxmldoc.Save XMLFolder(XMLFolder_rels) & ".rels"
    Set oXMLAttrib = Nothing
    Set oXMLElement = Nothing
    Set oxmldoc = Nothing
End Sub

Private Function GetSheetIdFromSheetName(sSheetName) As String
'@AssignedModule clsEditOpenXML
'@INCLUDE CLASS clsEditOpenXML
    Dim oxmldoc As MSXML2.DOMDocument
    Dim oxmlNode As MSXML2.IXMLDOMNode
    Dim oXMLChildNode As MSXML2.IXMLDOMNode
    Dim oXMLTemp As MSXML2.IXMLDOMNode
    If XMLFolder(XMLFolder_xl) <> "" And Sheet2Change <> "" Then
        Set oxmldoc = New MSXML2.DOMDocument
        oxmldoc.Load XMLFolder(XMLFolder_xl) & "workbook.xml"
        For Each oxmlNode In oxmldoc.ChildNodes
            For Each oXMLChildNode In oxmlNode.ChildNodes
                If oXMLChildNode.BaseName = "sheets" Then
                    For Each oXMLTemp In oXMLChildNode.ChildNodes
                        If oXMLTemp.Attributes.getNamedItem("name").NodeValue = sSheetName Then
                            GetSheetIdFromSheetName = oXMLTemp.Attributes.getNamedItem("r:id").NodeValue
                            Exit Function
                        End If
                    Next
                End If
            Next
        Next
    End If
End Function

Public Function GetSheetFileNameFromId(sSheetId As String) As String
'@AssignedModule clsEditOpenXML
'@INCLUDE CLASS clsEditOpenXML
    Dim oxmldoc As MSXML2.DOMDocument
    Dim oxmlNode As MSXML2.IXMLDOMNode
    Dim oXMLChildNode As MSXML2.IXMLDOMNode
    If XMLFolder(XMLFolder_xl) <> "" And Sheet2Change <> "" Then
        Set oxmldoc = New MSXML2.DOMDocument
        oxmldoc.Load XMLFolder(XMLFolder_xl) & "_rels\workbook.xml.rels"
        For Each oxmlNode In oxmldoc.ChildNodes
            For Each oXMLChildNode In oxmlNode.ChildNodes
                If oXMLChildNode.Attributes.getNamedItem("Id").NodeValue = sSheetId Then
                    GetSheetFileNameFromId = oXMLChildNode.Attributes.getNamedItem("Target").NodeValue
                    Exit Function
                End If
            Next
        Next
    End If
End Function

Private Function GetSheetNameFromId(sId As String) As String
'@AssignedModule clsEditOpenXML
'@INCLUDE CLASS clsEditOpenXML
    Dim oxmldoc As MSXML2.DOMDocument
    Dim oxmlNode As MSXML2.IXMLDOMNode
    Dim oXMLChildNode As MSXML2.IXMLDOMNode
    Dim oXMLChildChildNode As MSXML2.IXMLDOMNode
    If mvxmlfolder(XMLFolder_xl) <> "" Then
        Set oxmldoc = New MSXML2.DOMDocument
        oxmldoc.Load XMLFolder(XMLFolder_xl) & "workbook.xml"
        For Each oxmlNode In oxmldoc.ChildNodes
            For Each oXMLChildNode In oxmlNode.ChildNodes
                If oXMLChildNode.nodename = "sheets" Then
                    For Each oXMLChildChildNode In oXMLChildNode.ChildNodes
                        If oXMLChildChildNode.Attributes.getNamedItem("r:id").NodeValue = "rId" & val(sId) + 1 Then
                            GetSheetNameFromId = oXMLChildChildNode.Attributes.getNamedItem("name").NodeValue
                            Exit Function
                        End If
                    Next
                    Exit Function
                End If
            Next
        Next
    End If
End Function

Public Sub ZipAllFilesInFolder()
'@AssignedModule clsEditOpenXML
'@INCLUDE CLASS clsEditOpenXML
    Dim oShellApp As Object
    Dim sDate As String
    Dim sDefPath As String
    Dim vFileNameZip As Variant
    Dim FSO As Object
    Dim lFileCt As Long
    Set FSO = CreateObject("scripting.filesystemobject")
    sDate = Format(Now, " dd-mmm-yy h-mm-ss")
    vFileNameZip = SourceFile & sDate & ".zip"
    NewZip vFileNameZip
    Set oShellApp = CreateObject("Shell.Application")
    lFileCt = oShellApp.Namespace(FolderName & "Unzipped " & fileName & Application.PathSeparator).Items.count
    oShellApp.Namespace(vFileNameZip).CopyHere oShellApp.Namespace(FolderName & "Unzipped " & fileName & Application.PathSeparator).Items
    On Error Resume Next
    Do Until oShellApp.Namespace(vFileNameZip).Items.count = lFileCt
        Application.Wait (Now + TimeValue("0:00:01"))
    Loop
    DoEvents
    Kill SourceFile
    Name vFileNameZip As SourceFile
    On Error Resume Next
    FSO.DeleteFolder FolderName & "Unzipped " & fileName, True
    On Error GoTo 0
    Set oShellApp = Nothing
End Sub

Public Sub UnzipFile()
'@AssignedModule clsEditOpenXML
'@INCLUDE PROCEDURE FolderExists
'@INCLUDE CLASS clsEditOpenXML
    Dim FSO As Object
    Dim oShellApp As Object
    Set FSO = CreateObject("scripting.filesystemobject")
    XMLFolderRoot = FolderName
    If Right(XMLFolderRoot, 1) <> Application.PathSeparator Then
        XMLFolderRoot = XMLFolderRoot & "\UnZipped " & fileName & Application.PathSeparator
    Else
        XMLFolderRoot = XMLFolderRoot & "UnZipped " & fileName & Application.PathSeparator
    End If
    On Error Resume Next
    FSO.DeleteFolder XMLFolderRoot & "*", True
    Kill XMLFolderRoot & "*.*"
    If FolderExists(XMLFolderRoot) = False Then
        MkDir XMLFolderRoot
    End If
    Set oShellApp = CreateObject("Shell.Application")
    oShellApp.Namespace(XMLFolderRoot).CopyHere oShellApp.Namespace(SourceFile).Items
    On Error Resume Next
    FSO.DeleteFolder Environ("Temp") & "\Temporary Directory*", True
    Set oShellApp = Nothing
    Set FSO = Nothing
    Exit Sub
End Sub

Sub NewZip(sPath)
'@AssignedModule clsEditOpenXML
'@INCLUDE CLASS clsEditOpenXML
    If Len(Dir(sPath)) > 0 Then Kill sPath
    Open sPath For Output As #1
    Print #1, Chr$(80) & Chr$(75) & Chr$(5) & Chr$(6) & String(18, 0)
    Close #1
End Sub

Public Property Get CreateBackup() As Boolean
    CreateBackup = mbCreateBackup
End Property

Public Property Let CreateBackup(ByVal bCreateBackup As Boolean)
    mbCreateBackup = bCreateBackup
End Property

Private Sub Class_Initialize()
    CreateBackup = True
End Sub

Public Property Get SourceFile() As Variant
    SourceFile = mvSourceFile
End Property

Public Property Let SourceFile(ByVal vSourceFile As Variant)
    mvSourceFile = vSourceFile
    If CreateBackup Then
        If Len(Dir(vSourceFile & "(backup)")) > 0 Then
            Kill vSourceFile & "(backup)"
        End If
        FileCopy vSourceFile, vSourceFile & "(backup)"
    End If
    If Not vSourceFile Like "*.zip" Then
        Name vSourceFile As vSourceFile & ".zip"
        mvSourceFile = mvSourceFile & ".zip"
        AddedZip = True
    End If
End Property

Public Property Get FolderName() As Variant
    FolderName = Mid(SourceFile, 1, InStrRev(SourceFile, Application.PathSeparator))
End Property

Public Property Get fileName() As Variant
    If SourceFile <> "" Then
        fileName = Mid(SourceFile, InStrRev(SourceFile, Application.PathSeparator) + 1, Len(SourceFile))
    End If
End Property

Public Property Get XMLFolder(sXMLFolder As XMLFolder) As String
    Select Case sXMLFolder
    Case Is = XMLFolder_root
        XMLFolder = mvXMLFolderRoot
    Case Is = XMLFolder_customUI
        XMLFolder = mvXMLFolderRoot & "customUI" & Application.PathSeparator
    Case Is = XMLFolder_docProps
        XMLFolder = mvXMLFolderRoot & "docProps" & Application.PathSeparator
    Case Is = XMLFolder_rels
        XMLFolder = mvXMLFolderRoot & "_rels" & Application.PathSeparator
    Case Is = XMLFolder_xl
        XMLFolder = mvXMLFolderRoot & "xl" & Application.PathSeparator
    End Select
End Property

Public Property Get Sheet2Change() As String
    Sheet2Change = msSheet2Change
End Property

Public Property Let Sheet2Change(ByVal sSheet2Change As String)
    msSheet2Change = sSheet2Change
    SheetId = GetSheetIdFromSheetName(sSheet2Change)
    If SheetId <> "" Then
        SheetFileName = GetSheetFileNameFromId(SheetId)
    End If
End Property

Public Property Get SheetId() As String
    SheetId = msSheetId
End Property

Public Property Let SheetId(ByVal sSheetId As String)
    msSheetId = sSheetId
End Property

Public Property Get SheetFileName() As String
    SheetFileName = msSheetFileName
End Property

Public Property Let SheetFileName(ByVal sSheetFileName As String)
    msSheetFileName = sSheetFileName
End Property

Private Property Get AddedZip() As Boolean
    AddedZip = mbAddedZip
End Property

Private Property Let AddedZip(ByVal bAddedZip As Boolean)
    mbAddedZip = bAddedZip
End Property

Private Sub Class_Terminate()
    Dim FSO As Object
    If AddedZip Then
        Name SourceFile As Left(SourceFile, Len(SourceFile) - 4)
    End If
    On Error Resume Next
    FSO.DeleteFolder XMLFolderRoot, True
End Sub

Private Property Get XMLFolderRoot() As Variant
    XMLFolderRoot = mvXMLFolderRoot
End Property

Private Property Let XMLFolderRoot(ByVal vXMLFolderRoot As Variant)
    mvXMLFolderRoot = vXMLFolderRoot
End Property


'aListBox	Class


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Class      : aListBox
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 04-05-2023 12:18    Alex
'* Modified   : 21-07-2023 08:28    Alex
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit



Public WithEvents Emitter As EventListenerEmitter

Public WithEvents DoubleClickEvents As MSForms.ListBox

Public WithEvents ExtendedSelectionEvents As MSForms.ListBox
Private ItemsSelected As Variant


Public WithEvents DragSource As MSForms.ListBox
Public WithEvents DragTarget As MSForms.ListBox
Private from_lb_index As Long
Private to_lb_index As Long
Private dragindexes As Collection
Private dragArray
Private isUpdatingSelection As Boolean



Private oListBox As MSForms.ListBox
Private oList
Private oForm As Object
Private previousFilterLength As Long

Private isDoubleClick As Boolean

#If VBA7 Then
    Private Declare PtrSafe Function GetSystemMetrics Lib "user32" (ByVal nIndex As Long) As Long
    Private Declare PtrSafe Function GetKeyState Lib "user32" (ByVal nVirtKey As Long) As Integer
#Else
    Private Declare Function  GetSystemMetrics Lib "user32" (ByVal nIndex As Long) As Long
    Private Declare Function GetKeyState Lib "user32" (ByVal nVirtKey As Long) As Integer
#End If

Private Type POINTAPI
    x               As Long
    y               As Long
End Type

#If VBA7 Then
    
    Private Type Msg
        hwnd            As LongPtr
        message         As Long
        wParam          As LongPtr
        lParam          As LongPtr
        time            As Long
        pt              As POINTAPI
    End Type
    
    #If Win64 Then
    Private Declare PtrSafe Function WindowFromPoint Lib "user32" (ByVal POINT As LongPtr) As LongPtr
    #Else
    Private Declare PtrSafe Function WindowFromPoint Lib "user32" (ByVal xPoint As Long, ByVal yPoint As Long) As LongPtr
    #End If
    
    Private Declare PtrSafe Function GetMessage Lib "user32" Alias "GetMessageA" (lpMsg As Msg, ByVal hwnd As LongPtr, ByVal wMsgFilterMin As Long, ByVal wMsgFilterMax As Long) As Long
    Private Declare PtrSafe Function DispatchMessage Lib "user32" Alias "DispatchMessageA" (lpMsg As Msg) As LongPtr
    Private Declare PtrSafe Function TranslateMessage Lib "user32" (lpMsg As Msg) As Long
    Private Declare PtrSafe Function WindowFromAccessibleObject Lib "oleacc" (ByVal pacc As IAccessible, phwnd As LongPtr) As Long
    Private Declare PtrSafe Function IsWindow Lib "user32" (ByVal hwnd As LongPtr) As Long
    Private Declare PtrSafe Sub DragAcceptFiles Lib "shell32.dll" (ByVal hwnd As LongPtr, ByVal fAccept As Long)
    Private Declare PtrSafe Sub DragFinish Lib "shell32.dll" (ByVal HDROP As LongPtr)
    Private Declare PtrSafe Function DragQueryFile Lib "shell32.dll" Alias "DragQueryFileA" (ByVal HDROP As LongPtr, ByVal UINT As Long, ByVal lpStr As String, ByVal ch As Long) As Long
    Private Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal Length As LongPtr)

#Else
    
    Private Type Msg
        hwnd            As Long
        message         As Long
        wParam          As Long
        lParam          As Long
        time            As Long
        pt              As POINTAPI
    End Type
    
    Private Declare Function WindowFromPoint Lib "user32" (ByVal xPoint As Long, ByVal yPoint As Long) As Long
    Private Declare Function GetMessage Lib "user32" Alias "GetMessageA" (lpMsg As MSG, ByVal hwnd As Long, ByVal wMsgFilterMin As Long, ByVal wMsgFilterMax As Long) As Long
    Private Declare Function DispatchMessage Lib "user32" Alias "DispatchMessageA" (lpMsg As MSG) As Long
    Private Declare Function TranslateMessage Lib "user32" (lpMsg As MSG) As Long
    Private Declare Function WindowFromAccessibleObject Lib "oleacc" (ByVal pacc As IAccessible, phwnd As Long) As Long
    Private Declare Function IsWindow Lib "user32" (ByVal hwnd As Long) As Long
    Private Declare Sub DragAcceptFiles Lib "shell32.dll" (ByVal hwnd As Long, ByVal fAccept As Long)
    Private Declare Sub DragFinish Lib "shell32.dll" (ByVal HDROP As Long)
    Private Declare Function DragQueryFile Lib "shell32.dll" Alias "DragQueryFileA" (ByVal HDROP As Long, ByVal UINT As Long, ByVal lpStr As String, ByVal ch As Long) As Long
    Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal Length As Long)
#End If


Public Function Init(ByRef TargetListBox As MSForms.ListBox) As aListBox
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    Set oListBox = TargetListBox
    Set oForm = oListBox.Parent
    Set Init = Me
End Function

Public Function Parent()
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    Set Parent = oForm
End Function
Sub RememberList()
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    oList = oListBox.List
End Sub



Private Sub Emitter_Click(control As Object)
'@AssignedModule aListBox
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS aListBox
    If control.Name Like "lblHeader-*" Then
        Dim col As Long
        col = Split(control.Name, "-")(1)
        Me.SortOnColumn col - 1
    End If
End Sub
Private Sub Emitter_Keyup(control As Object, KeyCode As MSForms.ReturnInteger, Shift As Integer)
'@AssignedModule aListBox
'@INCLUDE PROCEDURE ArrayAllocated
'@INCLUDE PROCEDURE ArrayFilter2D
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS aListBox
    If Not ArrayAllocated(oList) Then RememberList
    If control.Name = "txtFilter" Then
        If Len(control.text) = 0 Then
            oListBox.List = oList
        ElseIf Len(control.text) > previousFilterLength Then
            oListBox.List = ArrayFilter2D(oListBox.List, control.text, oForm.Controls("cbxFilter").text)
        ElseIf Len(control.text) < previousFilterLength Then
            oListBox.List = ArrayFilter2D(oList, control.text, oForm.Controls("cbxFilter").text)
        End If
        previousFilterLength = Len(control.text)
    End If
        
    If control.Name = "cbxFilter" Then
        oForm.Controls("txtFilter").text = ""
        previousFilterLength = 0
    End If
End Sub


Public Sub ListenToDragDrop(Optional ToLbx As MSForms.ListBox)
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    Set DragSource = oListBox
    If Not ToLbx Is Nothing Then
        Set DragTarget = ToLbx
    Else
        Set DragTarget = oListBox
    End If
    DragTarget.columnCount = DragSource.columnCount
    DragSource.MousePointer = 5
End Sub


Private Sub DragSource_Change()
'@AssignedModule aListBox
'@INCLUDE PROCEDURE ArrayAllocated
'@INCLUDE CLASS aListBox
    Dim AltPressed As Boolean:     AltPressed = CBool(GetKeyState(&H12) And &H8000)
    Dim CtrlPressed As Boolean:    CtrlPressed = CBool(GetKeyState(&H11) And &H8000)
    Dim ShiftPressed As Boolean:   ShiftPressed = CBool(GetKeyState(&HA0) And &HFF80)
    
    If AltPressed Then Exit Sub
    
    If Not isUpdatingSelection _
    And ArrayAllocated(ItemsSelected) _
    And Not CtrlPressed _
    And Not ShiftPressed Then
        isUpdatingSelection = True
        With DragSource
            Dim i As Long
            For i = 0 To .ListCount - 1
                If ItemsSelected(i) <> .Selected(i) Then
                    .Selected(i) = ItemsSelected(i)
                End If
            Next i
        End With
        isUpdatingSelection = False
    End If
End Sub
Private Sub DragSource_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
'@AssignedModule aListBox
'@INCLUDE PROCEDURE ArrayAllocated
'@INCLUDE CLASS aListBox
    Dim AltPressed As Boolean:     AltPressed = CBool(GetKeyState(&H12) And &H8000)
    Dim CtrlPressed As Boolean:    CtrlPressed = CBool(GetKeyState(&H11) And &H8000)
    Dim ShiftPressed As Boolean:   ShiftPressed = CBool(GetKeyState(&HA0) And &HFF80)
    
    If AltPressed Then Exit Sub
    
    If Not CtrlPressed And Not ShiftPressed And ArrayAllocated(ItemsSelected) Then
        Dim index As Long: index = Int(y * 0.85 / DragSource.Font.Size)
        If index > UBound(ItemsSelected) Then Exit Sub
        ItemsSelected(index) = True
        With DragSource
            Dim i As Long
            For i = 0 To .ListCount - 1
                ItemsSelected(i) = .Selected(i)
            Next i
        End With
    End If

End Sub
Private Sub DragSource_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    With DragSource
        ReDim ItemsSelected(0 To .ListCount - 1) As Boolean
        Dim i As Long
        For i = 0 To .ListCount - 1
            ItemsSelected(i) = .Selected(i)
        Next i
    End With
End Sub

Private Sub DragTarget_BeforeDragOver(ByVal Cancel As MSForms.ReturnBoolean, ByVal Data As MSForms.DataObject, ByVal x As Single, ByVal y As Single, ByVal DragState As MSForms.fmDragState, ByVal Effect As MSForms.ReturnEffect, ByVal Shift As Integer)
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    Effect = fmDropEffectMove
    Cancel = True
End Sub
Private Sub DragTarget_BeforeDropOrPaste(ByVal Cancel As MSForms.ReturnBoolean, ByVal Action As MSForms.fmAction, ByVal Data As MSForms.DataObject, ByVal x As Single, ByVal y As Single, ByVal Effect As MSForms.ReturnEffect, ByVal Shift As Integer)
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
'@INCLUDE DECLARATION Action
    With DragTarget
        to_lb_index = Int(y * 0.85 / .Font.Size)
        If to_lb_index >= .ListCount Then to_lb_index = .ListCount
        Cancel = True
        Effect = fmDropEffectMove
        Dim difIndexes As Long
        Dim indexesCounter As Long
        For indexesCounter = dragindexes.count To 1 Step -1
            DragSource.RemoveItem dragindexes(indexesCounter)
            If dragindexes(indexesCounter) < to_lb_index Then to_lb_index = to_lb_index - 1
        Next
        
        For indexesCounter = 1 To dragindexes.count 'To 1 Step -1
            If DragTarget.ListCount = 0 Then
                .AddItem
            Else
                .AddItem , to_lb_index 'Data.GetText, to_lb_index
            End If
            Dim i As Long
           
            Dim cellTxt As String
            For i = 1 To UBound(dragArray, 2)
                cellTxt = IIf( _
                            IsNull(dragArray(indexesCounter, i)), _
                                "", _
                                dragArray(indexesCounter, i))
                DragTarget.List(to_lb_index, i - 1) = cellTxt
            Next
            to_lb_index = to_lb_index + 1
        Next
    End With
    
    ClearSelection
    DoEvents
    oForm.Repaint
End Sub
Private Sub DragSource_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    Dim obj As DataObject
    Dim drageff As Long
    If Button = 1 Then
        Set obj = New DataObject
'        obj.SetText DragSource.text

        from_lb_index = DragSource.ListIndex
        
        Set dragindexes = selectedIndexes  'test
        dragArray = SelectedRowsArray
    
        drageff = obj.StartDrag
        Set obj = Nothing
    End If
End Sub




Public Sub ListenToExtendedSelection()
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    Set ExtendedSelectionEvents = oListBox
End Sub
Private Sub ExtendedSelectionEvents_Change()
'author: Petr Radimersky
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    Dim i As Long
    If CBool(GetKeyState(&HA0) And &HFF80) Then
        With ExtendedSelectionEvents
            For i = 0 To .ListCount - 1
                If ItemsSelected(i) = False And .Selected(i) = True Then
                    ItemsSelected(i) = True
                End If
            Next i
        End With
    End If
End Sub
Private Sub ExtendedSelectionEvents_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    Dim i As Long
    If CBool(GetKeyState(&HA0) And &HFF80) Then
        With ExtendedSelectionEvents
            ReDim ItemsSelected(0 To .ListCount - 1) As Boolean
            For i = 0 To .ListCount - 1
                ItemsSelected(i) = .Selected(i)
            Next i
        End With
    End If
End Sub
Private Sub ExtendedSelectionEvents_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    Dim i As Long
    If CBool(GetKeyState(&HA0) And &HFF80) Then
        With ExtendedSelectionEvents
            For i = 0 To .ListCount - 1
                .Selected(i) = ItemsSelected(i)
            Next i
        End With
    End If
End Sub



Public Sub ListenToDoubleClick()
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    Set DoubleClickEvents = oListBox
End Sub

Private Sub DoubleClickEvents_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    isDoubleClick = True
End Sub

Public Sub DoubleClickEvents_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    If Not isDoubleClick Then Exit Sub
    MsgBox oListBox.List(oListBox.ListIndex, targetColumn(x, y) - 1)
    isDoubleClick = False
End Sub

Public Function targetColumn(x, y)
        ' Calculate the column index based on the X-coordinate
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
        Dim ColumnIndex As Long
        Dim columnWidth As Long
        Dim totalWidth As Long
        Dim totalColumns As Long
        
        totalColumns = oListBox.columnCount
        
        ' Calculate the total width of all columns
        For ColumnIndex = 1 To totalColumns
            columnWidth = Replace(Split(oListBox.columnWidths, ";")(ColumnIndex - 1), " pt", "")
            totalWidth = totalWidth + columnWidth
        Next ColumnIndex
        
        ' Calculate the approximate column index based on the X-coordinate
        Dim clickedX As Long
        clickedX = x
        
        If clickedX > 0 Then
            Dim cumulativeWidth As Long
            Dim lastColumnIndex As Long
            
            For ColumnIndex = 1 To totalColumns
                columnWidth = Replace(Split(oListBox.columnWidths, ";")(ColumnIndex - 1), " pt", "")
                cumulativeWidth = cumulativeWidth + columnWidth
                
                If clickedX < cumulativeWidth Then
                    ' The mouse click is within this column
                    lastColumnIndex = ColumnIndex
                    Exit For
                End If
            Next ColumnIndex
            
            ' Display the clicked column index
            targetColumn = lastColumnIndex
        End If
End Function


Public Sub AutofitColumns(ResizeListbox As Boolean)
'@AssignedModule aListBox
'@INCLUDE PROCEDURE Min
'@INCLUDE CLASS aListBox
'@INCLUDE CLASS aUserform
    oListBox.Font.Name = "consolas" '<---!
    Dim lRowCt As Long
    Dim lColCt As Long
    Dim lLengths()
    Dim mvTable: mvTable = oListBox.List
    ReDim lLengths(UBound(mvTable, 2))
    With oListBox
        For lRowCt = LBound(mvTable, 1) To UBound(mvTable, 1)
            For lColCt = LBound(mvTable, 2) To UBound(mvTable, 2)
                lLengths(lColCt) = Application.Max(4, lLengths(lColCt), Len(mvTable(lRowCt, lColCt)))
            Next
        Next
    End With
    
    Dim lCt As Long
    Dim sWidths As String
    Dim dTotWidth As Double
    Dim lblHidden As MSForms.control
    Set lblHidden = oForm.Controls.Add("Forms.commandbutton.1")
    With lblHidden
        .Caption = "Measure size"
        .Font.Size = oListBox.Font.Size
        .Font.Name = oListBox.Font.Name
        .WordWrap = False
        .AutoSize = True
    End With
    For lCt = LBound(lLengths) To UBound(lLengths)
        lblHidden.Caption = String(lLengths(lCt), "M")
        dTotWidth = dTotWidth + lblHidden.Width
        If Len(sWidths) = 0 Then
            sWidths = CStr(Int(lblHidden.Width))  '+ 12)
        Else
            sWidths = sWidths & ";" & CStr(Int(lblHidden.Width))  '+ 12)
        End If
    Next
   
    'Now set the widths of the columns
    oListBox.columnWidths = sWidths
   
    If Not ResizeListbox Then GoTo TidyUp
    
    'Adjust the dimensions of the listbox itself. You may want to adjust the constants I hard coded here.
   
    'Listbox will always be at least 200 wide
'    oListBox.Width = Application.Min(Application.Max(200, dTotWidth + 12), oListBox.Width)
    oListBox.Width = Application.Max(TotalColumnsWidth, 200)
    aUserform.Init(oForm).ResizeToFitControls marginRight:=10, marginBottom:=10
    'Listbox will always be at least 48 high.
'    oListBox.Height = Application.Min(Application.Max((oListBox.ListCount + 1) * 12, 48), oListBox.Height)
TidyUp:
    oForm.Controls.Remove lblHidden.Name
    On Error GoTo 0
End Sub

Function TotalColumnsWidth()
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    If oListBox.columnWidths = "" Then
        MsgBox "Column widths not set"
        TotalColumnsWidth = oListBox.Width
    End If
    TotalColumnsWidth = Evaluate(Replace(Join(Split(oListBox.columnWidths, ";"), "+"), "pt", "")) + 10
End Function

Sub AddFilter()
'@AssignedModule aListBox
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS aListBox
'@INCLUDE DECLARATION Emitter
    If oListBox.columnWidths = "" Then
        MsgBox "Column widths not set"
        Exit Sub
    End If
    Dim var: var = Split(Replace(oListBox.columnWidths, "pt", ""), ";")
    Dim txt As MSForms.Textbox
    Dim i As Long
    Set txt = oForm.Controls.Add("Forms.Textbox.1")
    txt.Name = "txtFilter"
    txt.Top = oListBox.Top - txt.Height - 2
    txt.Width = 150
    
    Set Emitter = New EventListenerEmitter
    Emitter.AddEventListenerAll oForm
    
    Dim cbx As MSForms.ComboBox
    Set cbx = oForm.Controls.Add("Forms.ComboBox.1")
    cbx.Name = "cbxFilter"
    cbx.Height = txt.Height
    cbx.Width = 50
    cbx.Left = oListBox.Left
    cbx.Top = txt.Top
    For i = -1 To oListBox.columnCount - 1
        cbx.AddItem i
    Next
    cbx.ListIndex = 0
    
    txt.Left = oListBox.Left + cbx.Width + 6
End Sub

Public Sub FilterByColumn(This As String, _
                            Optional ColumnIndexZeroBased As Long = -1, _
                            Optional CaseSensitive As Boolean = False)
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    Dim i               As Long
    Dim N               As Long
    Dim sTemp           As String
    If ColumnIndexZeroBased > oListBox.columnCount - 1 Or ColumnIndexZeroBased < 0 Then
        ColumnIndexZeroBased = -1
    End If
    N = oListBox.ListCount
    If ColumnIndexZeroBased <> -1 Then
        For i = N - 1 To 0 Step -1
            If CaseSensitive = True Then
                sTemp = oListBox.List(i, ColumnIndexZeroBased)
            Else
                This = LCase(This)
                sTemp = LCase(oListBox.List(i, ColumnIndexZeroBased))
            End If
            If InStr(1, sTemp, This) = 0 Then
                oListBox.RemoveItem (i)
            End If
        Next i
    Else
        Dim columnCount As Long
        N = oListBox.ListCount
        For i = N - 1 To 0 Step -1
            For columnCount = 0 To oListBox.columnCount - 1
                If CaseSensitive = True Then
                    sTemp = oListBox.List(i, columnCount)
                Else
                    This = LCase(This)
                    sTemp = LCase(oListBox.List(i, columnCount))
                End If
                If InStr(1, sTemp, This) > 0 Then
                Else
                    If columnCount = oListBox.columnCount - 1 Then
                        oListBox.RemoveItem (i)
                    End If
                End If
            Next columnCount
        Next i
    End If
End Sub


Function LoadCSV(targetFile As String, Clear As Boolean)
'@AssignedModule aListBox
'@INCLUDE PROCEDURE TxtRead
'@INCLUDE CLASS aListBox
    If Clear Then oListBox.Clear
    Dim ArrayOfElements
    Dim s: s = TxtRead(targetFile)
    Dim arr
    arr = Split(s, vbLf)
    Dim iCols, iRows
    iRows = UBound(arr) + 1
    iCols = UBound(Split(arr(0), ",")) + 1
    ReDim ArrayOfElements(1 To iRows, 1 To iCols)
    Dim x, y
    For x = 1 To iRows
        For y = 1 To iCols
            ArrayOfElements(x, y) = Split(arr(x - 1), ",")(y - 1)
        Next
    Next
    oListBox.columnCount = iCols
    oListBox.List = ArrayOfElements
End Function

Sub ToRange(cell As Range)
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    cell.Resize(oListBox.ListCount, oListBox.columnCount) = oListBox.List
End Sub

Sub ClearSelection()
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    On Error Resume Next
    Dim i As Long
    For i = 0 To oListBox.ListCount
        oListBox.Selected(i) = False
    Next i
End Sub


Public Sub AcceptFiles(Optional sExpansion As String = "*.xlsm;*.xlsb;*.xlsx", Optional iDeepSubPath As Integer = 999)
'eg on userform_activate:
'aListBox.Init(ListBox1).AcceptFiles sExpansion:="*.xlsm;*.xlsb;*.xlsx",iDeepSubPath:=999
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
'@INCLUDE CLASS aUserform
    
    'you can use .[_GethWnd] with controls which support it
    Dim ctr As control: Set ctr = oListBox
    Dim lGethWnd As LongPtr: lGethWnd = ctr.[_GethWnd]

    #If VBA7 Then
        Dim hwnd As LongPtr, HDROP As LongPtr
    #Else
        Dim hwnd As Long, HDROP As Long
    #End If

    Const WM_DROPFILES = &H233
    Dim tMsg As Msg, sFileName As String * 1000
    Dim lFilesCount As Long, i As Long
    hwnd = aUserform.Init(oForm).hwnd
    Call DragAcceptFiles(lGethWnd, True)

    Dim sPathFile   As String

    Do While GetMessage(tMsg, 0, 0, 0) And IsWindow(hwnd)
        If tMsg.message = WM_DROPFILES Then
            HDROP = tMsg.wParam
            lFilesCount = DragQueryFile(HDROP, &HFFFFFFFF, 0, 0)
            If lFilesCount Then
                For i = 0 To lFilesCount - 1
                    sPathFile = VBA.Trim$(VBA.Left(sFileName, DragQueryFile(HDROP, i, sFileName, VBA.Len(sFileName))))
                    Call getFilesFromPath(sPathFile, sExpansion, iDeepSubPath)
                Next i
            End If
            Call DragFinish(HDROP)
        End If
        Call TranslateMessage(tMsg)
        Call DispatchMessage(tMsg)
    Loop
End Sub
Private Sub getFilesFromPath(ByVal sPathFile As String, ByVal sExpansion As String, ByVal iDeepSubPath As Integer)
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    Dim sExp        As String
    sExp = sGetExtensionName(sPathFile)
    If sExp = vbNullString Then
        Dim oCol    As Collection
        Set oCol = GetFiles(sPathFile, iDeepSubPath)
        Dim i       As Integer
        Dim iCount  As Integer
        iCount = oCol.count
        Dim sFile   As String
        For i = 1 To iCount
            sFile = oCol.item(i).Path
            sExp = sGetExtensionName(sFile)
            Call filterFiles(sFile, sExpansion, sExp)
        Next i
    Else
        Call filterFiles(sPathFile, sExpansion, sExp)
    End If
End Sub
Private Sub filterFiles(ByVal sPathFile As String, ByVal sExpansion As String, ByVal sExp As String)
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    sExp = "*." & sExp
    If sExpansion = vbNullString Or sExpansion = "*.*" Then
    ElseIf Not likeExp(sExpansion, sExp) Then
        Exit Sub
    End If
    oListBox.AddItem sPathFile
End Sub
Private Function likeExp(ByVal sExpansion As String, ByVal sExp As String) As Boolean
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    Dim arr         As Variant
    arr = VBA.Split(sExpansion, ";")
    Dim i           As Long
    Dim iCount      As Long
    iCount = UBound(arr, 1)
    For i = 0 To iCount
        If sExp Like arr(i) Then
            likeExp = True
            Exit For
        End If
    Next i
End Function
Private Function sGetExtensionName(ByVal sPathFile As String) As String
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    Dim FSO         As Object
    Set FSO = CreateObject("Scripting.FileSystemObject")
    sGetExtensionName = FSO.GetExtensionName(sPathFile)
    Set FSO = Nothing
End Function
Private Function GetFiles(ByVal Path As String, ByVal iDeepSubPath As Integer) As Collection
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    Dim MainFolder  As Object
    Dim iFolder     As Object
    Dim iFile       As Object
    Dim FSO         As Object
    Dim MainColl    As New Collection
    Dim iColl       As Collection
    Dim i           As Long

    Set FSO = CreateObject("Scripting.FileSystemObject")
    Set MainFolder = FSO.GetFolder(Path)
    If MainFolder Is Nothing Then Exit Function

    For Each iFile In MainFolder.Files
        If VBA.InStr(1, iFile.Name, "~") = 0 Then
            MainColl.Add iFile, iFile.Path
        End If
    Next

    If iDeepSubPath > 0 Then
        For Each iFolder In MainFolder.SubFolders
            Set iColl = GetFiles(iFolder.Path, iDeepSubPath - 1)
            For i = 1 To iColl.count
                MainColl.Add iColl(i)
            Next
        Next
    End If
    Set GetFiles = MainColl
End Function

Public Sub HeightToEntries(ByVal NumberOfEntries As Long)
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
'@INCLUDE DECLARATION GetSystemMetrics
    Const SM_CYEDGE = 46&
    With oListBox
        NumberOfEntries = IIf(NumberOfEntries > .ListCount, .ListCount, NumberOfEntries)
        .Height = ((9.75 * NumberOfEntries) _
                + IIf(oListBox.Width < TotalColumnsWidth, 18, 0) _
                + IIf(.SpecialEffect = fmSpecialEffectFlat, 0, GetSystemMetrics(SM_CYEDGE)))
    End With
End Sub

Public Sub LoadVBProjects()
'@AssignedModule aListBox
'@INCLUDE PROCEDURE WorkbookProjectProtected
'@INCLUDE CLASS aListBox
    oListBox.Clear
    oListBox.columnCount = 1
    Dim coll As New Collection
    Dim WB As Workbook
    For Each WB In Workbooks
        If Len(WB.Path) > 0 Then
            If WorkbookProjectProtected(WB) = False Then
                On Error Resume Next
                coll.Add WB.Name, WB.Name
                On Error GoTo 0
            End If
        End If
    Next
    Rem list addins
    Dim vbProj As VBProject
    Dim wbPath As String
    For Each vbProj In Application.VBE.VBProjects
        On Error GoTo ErrorHandler
        wbPath = vbProj.fileName
        If Right(wbPath, 4) = "xlam" Or Right(wbPath, 3) = "xla" Then
            Dim wbName As String
            wbName = Mid(wbPath, InStrRev(wbPath, "\") + 1)
            If WorkbookProjectProtected(Workbooks(wbName)) = False Then
                On Error Resume Next
                coll.Add wbName, wbName
                On Error GoTo 0
            End If
        End If
SKIP:
    Next vbProj

    Dim el As Variant
    For Each el In coll
    oListBox.AddItem el
    Next

    Exit Sub
ErrorHandler:
    If Err.Number = 76 Then GoTo SKIP
End Sub

Public Sub SelectItems(This As Variant, Optional ByIndex As Boolean)
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    Dim i As Long
    Select Case TypeName(This)
    Case Is = "String", "Long", "Integer"
        For i = 0 To oListBox.ListCount - 1
            If oListBox.List(i) = CStr(This) Then
                oListBox.Selected(i) = True
                DoEvents
                If oListBox.multiSelect = fmMultiSelectSingle Then Exit Sub
            End If
        Next
    Case Else
        Dim el As Variant
        If ByIndex Then
            For Each el In This
                oListBox.Selected(el) = True
            Next
        Else
            For Each el In This
                For i = 0 To oListBox.ListCount - 1
                    If oListBox.List(i) = el Then
                        oListBox.Selected(i) = True
                        DoEvents
                    End If
                Next
            Next
        End If
    End Select
End Sub

Public Sub AddHeader(Optional arrHeaders)
'@AssignedModule aListBox
'@INCLUDE PROCEDURE ArrayDimensions
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS aListBox
'@INCLUDE DECLARATION Emitter
    If oListBox.columnWidths = "" Then Exit Sub
    Dim i As Long
    
    If IsMissing(arrHeaders) Then
        ReDim arrHeaders(0 To oListBox.columnCount - 1)
        For i = 1 To oListBox.columnCount
            arrHeaders(i - 1) = i
        Next
    End If
    
    Dim Header As MSForms.Label
    For i = 1 To oListBox.columnCount
        Set Header = oForm.Controls.Add("Forms.Label.1")
        If i = 1 Then
            Header.Left = oListBox.Left
        Else
            Header.Left = oForm.Controls("lblHeader-" & i - 1).Left + oForm.Controls("lblHeader-" & i - 1).Width
        End If
        Header.Name = "lblHeader-" & i
        Header.SpecialEffect = fmSpecialEffectFlat
        Header.BackColor = RGB(200, 200, 200)
        Header.Width = Trim(Replace(Split(oListBox.columnWidths, ";")(i - 1), "pt", ""))
        Header.Height = 12
        Header.Font.Bold = True
        Header.Font.Name = "Segoe UI"
        Header.Top = oListBox.Top - Header.Height - 1
        Header.TextAlign = fmTextAlignCenter
        If ArrayDimensions(arrHeaders) = 1 Then
            Header.Caption = arrHeaders(i - 1)
        Else
            Header.Caption = arrHeaders(0, i)
        End If
    Next

    Set Emitter = New EventListenerEmitter
    Emitter.AddEventListenerAll oForm

'    oListBox.ZOrder (1)
'    Header.ZOrder (0)

End Sub
Sub removeHeaders()
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    Dim ctl As MSForms.control
    For Each ctl In oForm.Controls
        If ctl.Name Like "lblHeader-*" Then oForm.Controls.Remove ctl.Name
    Next
End Sub
Public Function Contains(This As String, _
                Optional ColumnIndexZeroBased As Long = -1, _
                Optional CaseSensitive As Boolean = False) As Boolean
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    Dim i      As Long
    Dim N      As Long
    Dim sTemp  As String
    If ColumnIndexZeroBased > oListBox.columnCount - 1 Or ColumnIndexZeroBased < 0 Then
        ColumnIndexZeroBased = -1
    End If
    N = oListBox.ListCount
    If ColumnIndexZeroBased <> -1 Then
        For i = N - 1 To 0 Step -1
            If CaseSensitive = True Then
                sTemp = oListBox.List(i, ColumnIndexZeroBased)
            Else
                This = LCase(This)
                sTemp = LCase(oListBox.List(i, ColumnIndexZeroBased))
            End If
            If InStr(1, sTemp, This) > 0 Then
                Contains = True
                Exit Function
            End If
        Next i
    Else
        Dim columnCount As Long
        N = oListBox.ListCount
        For i = N - 1 To 0 Step -1
            For columnCount = 0 To oListBox.columnCount - 1
                If CaseSensitive = True Then
                    sTemp = oListBox.List(i, columnCount)
                Else
                    This = LCase(This)
                    sTemp = LCase(oListBox.List(i, columnCount))
                End If
                If InStr(1, sTemp, This) > 0 Then
                    Contains = True
                    Exit Function
                End If
            Next columnCount
        Next i
    End If
End Function

Public Sub SortOnColumn(OnColumn As Long)
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox

    Dim vntData As Variant
    Dim vntTempItem As Variant
    Dim lngOuterIndex As Long
    Dim lngInnerIndex As Long
    Dim lngSubItemIndex As Long
    vntData = oListBox.List

    For lngOuterIndex = LBound(vntData, 1) To UBound(vntData, 1) - 1
        For lngInnerIndex = lngOuterIndex + 1 To UBound(vntData, 1)
            ' Use StrComp with vbTextCompare option to compare strings case-insensitively
            If StrComp(vntData(lngOuterIndex, OnColumn), vntData(lngInnerIndex, OnColumn), vbTextCompare) > 0 Then
                For lngSubItemIndex = 0 To oListBox.columnCount - 1
                    vntTempItem = vntData(lngOuterIndex, lngSubItemIndex)
                    vntData(lngOuterIndex, lngSubItemIndex) = vntData(lngInnerIndex, lngSubItemIndex)
                    vntData(lngInnerIndex, lngSubItemIndex) = vntTempItem
                Next lngSubItemIndex
            End If
        Next lngInnerIndex
    Next lngOuterIndex

    oListBox.Clear
    oListBox.List = vntData
End Sub

'Public Sub SortOnColumn(OnColumn As Long)
'
'    Dim vntData As Variant
'    Dim vntTempItem As Variant
'    Dim lngOuterIndex As Long
'    Dim lngInnerIndex As Long
'    Dim lngSubItemIndex As Long
'    vntData = oListBox.List
'    For lngOuterIndex = LBound(vntData, 1) To UBound(vntData, 1) - 1
'        For lngInnerIndex = lngOuterIndex + 1 To UBound(vntData, 1)
'            If vntData(lngOuterIndex, OnColumn) > vntData(lngInnerIndex, OnColumn) Then
'                For lngSubItemIndex = 0 To oListBox.columnCount - 1
'                    vntTempItem = vntData(lngOuterIndex, lngSubItemIndex)
'                    vntData(lngOuterIndex, lngSubItemIndex) = vntData(lngInnerIndex, lngSubItemIndex)
'                    vntData(lngInnerIndex, lngSubItemIndex) = vntTempItem
'                Next
'            End If
'        Next lngInnerIndex
'    Next lngOuterIndex
'    oListBox.Clear
'    oListBox.List = vntData
'End Sub

Public Function selectedIndexes() As Collection
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    Dim i As Long
    Dim coll As New Collection
    If oListBox.ListCount > 0 Then
        For i = 0 To oListBox.ListCount - 1
            If oListBox.Selected(i) Then coll.Add i
        Next i
    End If
    Set selectedIndexes = coll
End Function

Public Function SelectedValues() As Collection 'single column
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    Dim i As Long
    Dim ListItem As Long
    Dim selectedCollection As Collection
    Set selectedCollection = New Collection
    Dim listboxCount As Long

        If oListBox.ListCount > 0 Then
            For i = 0 To oListBox.ListCount - 1
                If oListBox.Selected(i) Then
                    selectedCollection.Add oListBox.List(i, oListBox.BoundColumn - 1)
                End If
            Next i
        End If

    Set SelectedValues = selectedCollection
End Function


Public Function SelectedRowsArray()
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    Dim x As Long, y As Long
    Dim ListItem As Long
    
    Dim indexColl As New Collection
    Set indexColl = selectedIndexes
    If indexColl.count = 0 Then SelectedRowsArray = Array(): Exit Function
    Dim out() As Variant
    ReDim out(1 To indexColl.count, 1 To oListBox.columnCount)
    For x = 1 To indexColl.count
        For y = 1 To oListBox.columnCount
            out(x, y) = oListBox.List(indexColl(x), y - 1)
        Next
    Next
    SelectedRowsArray = out
End Function

Public Function SelectedRowsText() As String
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    Dim x As Long, y As Long
    Dim ListItem As Long
    Dim out As String
    Dim indexColl As New Collection
    Set indexColl = selectedIndexes
    For x = 1 To indexColl.count
        For y = 0 To oListBox.columnCount - 1
            out = out & IIf(y > 0, "|", "") & oListBox.List(indexColl(x), y)
        Next
        If x < indexColl.count Then out = out & vbNewLine
    Next
    SelectedRowsText = out
End Function


Public Function SelectedCount() As Long
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    Dim i As Long
    Dim ListItem As Long
    Dim selectedCollection As Collection
    Set selectedCollection = New Collection
    Dim listboxCount As Long
    Dim counter As Long

        If oListBox.ListCount > 0 Then
            For i = 0 To oListBox.ListCount - 1
                If oListBox.Selected(i) = True Then
                    counter = counter + 1
                End If
            Next i
        End If
    SelectedCount = counter
End Function

Public Sub DeselectAll()
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    If oListBox.ListCount <> 0 Then
        Dim i As Long
        For i = 0 To oListBox.ListCount - 1
            oListBox.Selected(i) = False
        Next i
    End If
End Sub

Public Sub SelectAll()
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    If oListBox.ListCount <> 0 Then
        Dim i As Long
        For i = 0 To oListBox.ListCount - 1
            oListBox.Selected(i) = True
        Next i
    End If
End Sub

Public Sub SelectLike(This As String) '1D
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    DeselectAll
    If This = "" Then Exit Sub
    Dim i As Long
    For i = 0 To oListBox.ListCount - 1
        If UCase(oListBox.List(i, 1)) Like "*" & UCase(This) & "*" Then
            oListBox.Selected(i) = True
        End If
    Next i
End Sub

Public Sub SortAZ() '1D
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    Dim j As Long
    Dim i As Long
    Dim Temp As Variant
    With oListBox
        For j = 0 To .ListCount - 2
            For i = 0 To .ListCount - 2
                If LCase(.List(i)) > LCase(.List(i + 1)) Then
                    Temp = .List(i)
                    .List(i) = .List(i + 1)
                    .List(i + 1) = Temp
                End If
            Next i
        Next j
    End With
End Sub

Public Sub SortZA() '1D
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    Dim j As Long
    Dim i As Long
    Dim Temp As Variant
    With oListBox
        For j = 0 To .ListCount - 2
            For i = 0 To .ListCount - 2
                If LCase(.List(i)) < LCase(.List(i + 1)) Then
                    Temp = .List(i)
                    .List(i) = .List(i + 1)
                    .List(i + 1) = Temp
                End If
            Next i
        Next j
    End With
End Sub

'Sub ToRangeSelect(cell As Range)
'    cell.RESIZE(lBox.ListCount, oListBox.ColumnCount) = CollectionsToArray2D(SelectedValues)
'End Sub

Public Sub SelectedToRange()
'@AssignedModule aListBox
'@INCLUDE PROCEDURE CollectionsToArray2D
'@INCLUDE PROCEDURE GetInputRange
'@INCLUDE CLASS aCollection
'@INCLUDE CLASS aListBox
   Dim rng As Range
    If GetInputRange(rng, "Range picker", "Select range to output listbox' list") = False Then Exit Sub
    Dim var: var = aCollection.CollectionsToArray2D(SelectedValues)
    rng.Resize(UBound(var, 1), oListBox.columnCount) = var
End Sub

Public Sub RemoveSelected()
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    Dim coll As New Collection: Set coll = selectedIndexes
    If coll.count = 0 Then Exit Sub
    Dim i As Long
    For i = coll.count To 1 Step -1
        oListBox.RemoveItem coll(i)
    Next
End Sub

Public Sub ShowTheseColumns(targetColumns As Variant)
'targetColumns is array of integers, base 1
'@AssignedModule aListBox
'@INCLUDE CLASS aListBox
    Dim RetVal() As Variant
    ReDim RetVal(1 To oListBox.columnCount)
    If oListBox.columnWidths = "" Then Exit Sub     ' AutofitColumns (False)
    Dim i As Long, ii As Long
    For i = 1 To oListBox.columnCount
        For ii = LBound(targetColumns) To UBound(targetColumns)
            If i = targetColumns(ii) Then
                RetVal(i) = Split(Replace(oListBox.columnWidths, "pt", ""), ";")(i - 1)
                GoTo resumeNext
            End If
        Next
        RetVal(i) = 0
resumeNext:
    Next
    oListBox.columnWidths = Join(RetVal, ";")
End Sub

'aUserform	Class


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Class      : aUserform
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 04-05-2023 12:19    Alex
'* Modified   : 30-06-2023 10:01    Alex                modified save/load options/position to use ini
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Option Compare Text

Public WithEvents DockResize As UserForm
Private oForm As Object

Public TrackHeight As New Collection
Public TrackWidth As New Collection
Public TrackTop As New Collection
Public TrackLeft As New Collection

Rem Transparent Declarations
Rem Private Declare PtrSafe Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long) As Long
#If VBA7 Then
    Private Declare PtrSafe Function DrawMenuBar Lib "user32" (ByVal hwnd As Long) As Long
    Private Declare PtrSafe Function SetLayeredWindowAttributes Lib "user32" (ByVal hwnd As Long, ByVal crKey As Long, ByVal bAlpha As Byte, ByVal dwFlags As Long) As Long
#Else
    Private Declare Function DrawMenuBar Lib "user32" (ByVal hWnd As Long) As Long
    Private Declare Function SetLayeredWindowAttributes Lib "user32" (ByVal hWnd As Long, ByVal crKey As Long, ByVal bAlpha As Byte, ByVal dwFlags As Long) As Long
#End If

Private Const GWL_STYLE As Long = (-16)
Private Const GWL_EXSTYLE As Long = (-20)
Private Const WS_CAPTION As Long = &HC00000
Private Const WS_EX_DLGMODALFRAME As Long = &H1

Private Const WS_EX_LAYERED = &H80000
Private Const LWA_COLORKEY = &H1
Private Const LWA_ALPHA = &H2

Private m_sngDownX As Single
Private m_sngDownY As Single

Rem Private Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Rem Private Declare PtrSafe Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long

Rem Parent Declarations
Private Const FORMAT_MESSAGE_ALLOCATE_BUFFER = &H100
Private Const FORMAT_MESSAGE_ARGUMENT_ARRAY = &H2000
Private Const FORMAT_MESSAGE_FROM_HMODULE = &H800
Private Const FORMAT_MESSAGE_FROM_STRING = &H400
Private Const FORMAT_MESSAGE_FROM_SYSTEM = &H1000
Private Const FORMAT_MESSAGE_IGNORE_INSERTS = &H200
Private Const FORMAT_MESSAGE_MAX_WIDTH_MASK = &HFF
Private Const FORMAT_MESSAGE_TEXT_LEN = 160
Private Const MAX_PATH = 260
Private Const GWL_HWNDPARENT As Long = -8
Private Const GW_OWNER = 4

#If VBA7 Then
    Private Declare PtrSafe Function GetWindowText Lib "user32.dll" Alias "GetWindowTextA" (ByVal hwnd As Long, ByVal lpString As String, ByVal cch As Long) As Long
    Private Declare PtrSafe Function GetClassName Lib "user32" Alias "GetClassNameA" (ByVal hwnd As Long, ByVal lpClassName As String, ByVal nMaxCount As Long) As Long
    Private Declare PtrSafe Function GetWindowLong Lib "user32.dll" Alias "GetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long) As Long
#Else
    Private Declare Function GetWindowText Lib "user32.dll" Alias "GetWindowTextA" (ByVal hWnd As Long, ByVal lpString As String, ByVal cch As Long) As Long
    Private Declare Function GetClassName Lib "user32" Alias "GetClassNameA" (ByVal hWnd As Long, ByVal lpClassName As String, ByVal nMaxCount As Long) As Long
    Private Declare Function GetWindowLong Lib "user32.dll" Alias "GetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
#End If

Private VBEditorHWnd As Long
Private ApplicationHWnd As Long
Private ExcelDeskHWnd As Long
Private ActiveWindowHWnd As Long
Private UserFormHWnd As Long
Private WindowsDesktopHWnd As Long
Private Const GA_ROOT As Long = 2
Private Const GA_ROOTOWNER As Long = 3
Private Const GA_PARENT As Long = 1

#If VBA7 Then
    Private Declare PtrSafe Function GetWindow Lib "user32" (ByVal hwnd As Long, ByVal wCmd As Long) As Long
    Private Declare PtrSafe Function FindWindowEx Lib "user32" Alias "FindWindowExA" (ByVal hWnd1 As Long, ByVal hWnd2 As Long, ByVal lpsz1 As String, ByVal lpsz2 As String) As Long
    Private Declare PtrSafe Function GetAncestor Lib "user32.dll" (ByVal hwnd As Long, ByVal gaFlags As Long) As Long
    Private Declare PtrSafe Function GetDesktopWindow Lib "user32" () As Long
    Private Declare PtrSafe Function GetParent Lib "user32.dll" (ByVal hwnd As Long) As Long
    Private Declare PtrSafe Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
#Else
    Private Declare Function GetWindow Lib "user32" (ByVal hWnd As Long, ByVal wCmd As Long) As Long
    Private Declare Function FindWindowEx Lib "user32" Alias "FindWindowExA" (ByVal hWnd1 As Long, ByVal hWnd2 As Long, ByVal lpsz1 As String, ByVal lpsz2 As String) As Long
    Private Declare Function GetAncestor Lib "user32.dll" (ByVal hWnd As Long, ByVal gaFlags As Long) As Long
    Private Declare Function GetDesktopWindow Lib "user32" () As Long
    Private Declare Function GetParent Lib "user32.dll" (ByVal hWnd As Long) As Long
    Private Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
#End If

Private Const C_EXCEL_APP_WINDOWCLASS = "XLMAIN"
Private Const C_EXCEL_DESK_WINDOWCLASS = "XLDESK"
Private Const C_EXCEL_WINDOW_WINDOWCLASS = "EXCEL7"
Private Const USERFORM_WINDOW_CLASS = "ThunderDFrame"
Private Const C_VBA_USERFORM_WINDOWCLASS = "ThunderDFrame"

Rem Window position and more
Private Const SWP_NOMOVE = &H2
Private Const SWP_NOSIZE = &H1
Private Const HWND_TOP = 0
Private Const HWND_BOTTOM = 1
Private Const HWND_TOPMOST = -1
Private Const HWND_NOTOPMOST = -2

#If VBA7 Then
    Private Declare PtrSafe Function SetWindowPos Lib "user32" (ByVal hwnd As LongPtr, ByVal hwndInsertAfter As LongPtr, ByVal x As LongPtr, ByVal y As LongPtr, ByVal cx As LongPtr, ByVal cy As LongPtr, ByVal uFlags As LongPtr) As Long
#Else
    Private Declare Function SetWindowPos Lib "user32" (ByVal hWnd As LongPtr, ByVal hWndInsertAfter As LongPtr, ByVal X As LongPtr, ByVal Y As LongPtr, ByVal cx As LongPtr, ByVal cy As LongPtr, ByVal uFlags As LongPtr) As Long
#End If

Rem ---
#If VBA7 Then
    Private Declare PtrSafe Function SetParent Lib "user32" (ByVal hwndChild As LongPtr, ByVal hWndNewParent As LongPtr) As LongPtr
    Private Declare PtrSafe Function SetForegroundWindow Lib "user32" (ByVal hwnd As LongPtr) As Long
    Private Declare PtrSafe Function FormatMessage Lib "kernel32" Alias "FormatMessageA" (ByVal dwFlags As Long, lpSource As Any, ByVal dwMessageId As Long, ByVal dwLanguageId As Long, ByVal lpBuffer As String, ByVal nSize As Long, Arguments As LongPtr) As Long
#Else
    Private Declare Function SetParent Lib "user32" (ByVal hWndChild As Long, ByVal hWndNewParent As Long) As Long
    Private Declare Function SetForegroundWindow Lib "user32" (ByVal hwnd As Long) As Long
    Private Declare Function FormatMessage Lib "kernel32.dll" Alias "FormatMessageA" (ByVal dwFlags As Long, ByRef lpSource As Any, ByVal dwMessageId As Long, ByVal dwLanguageId As Long, ByVal lpBuffer As String, ByVal nSize As Long, ByRef Arguments As Long) As Long
#End If

Rem Closeby
Private Enum CloseBy
    User = 0
    Code = 1
    WindowsOS = 2
    TaskManager = 3
End Enum


Private Const black As Long = &H80000012
Private Const red As Long = &HFF&

Rem other
#If VBA7 Then
    Private Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    Private Declare PtrSafe Function FindWindowA Lib "user32" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    Private Declare PtrSafe Function GetWindowLongA Lib "user32" (ByVal hwnd As Long, ByVal nIndex As Long) As Long
    Private Declare PtrSafe Function SetWindowLongA Lib "user32" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
#Else
    Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    Private Declare Function FindWindowA Lib "user32" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    Private Declare Function GetWindowLongA Lib "user32" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
    Private Declare Function SetWindowLongA Lib "user32" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
#End If

Rem userform hwnd
#If Win64 Then
    Private Declare PtrSafe Function IUnknown_GetWindow Lib "shlwapi" Alias "#172" (ByVal pIUnk As IUnknown, ByVal hwnd As LongPtr) As Long
#Else
    Private Declare Function IUnknown_GetWindow Lib "shlwapi" Alias "#172" (ByVal pIUnk As IUnknown, ByVal hwnd As Long) As Long
#End If

Rem ___Resizeable___

Public isResizable As Boolean
#If VBA7 Then
    Private Declare PtrSafe Function SetFocus Lib "user32" (ByVal hwnd As Long) As Long
    Private Declare PtrSafe Function ShowWindow Lib "user32" (ByVal hwnd As Long, ByVal nCmdShow As Long) As Long
#Else
    Private Declare Function SetFocus Lib "user32" (ByVal hwnd As Long) As Long
    Private Declare Function ShowWindow Lib "user32" (ByVal hwnd As Long, ByVal nCmdShow As Long) As Long
#End If
Private mdWidth As Double
Private mdHeight As Double
Private Const WS_THICKFRAME As Long = &H40000
Private Const SW_SHOW As Long = 5



#If VBA7 Then
    Private Declare PtrSafe Function getFrequency Lib "kernel32" Alias "QueryPerformanceFrequency" (cyFrequency As Currency) As Long
    Private Declare PtrSafe Function getTickCount Lib "kernel32" Alias "QueryPerformanceCounter" (cyTickCount As Currency) As Long
#Else
    Private Declare Function getFrequency Lib "kernel32" Alias "QueryPerformanceFrequency" (cyFrequency As Currency) As Long
    Private Declare Function getTickCount Lib "kernel32" Alias "QueryPerformanceCounter" (cyTickCount As Currency) As Long
#End If



Rem get hwnd
#If VBA7 Then
    Private Declare PtrSafe Function WindowFromAccessibleObject Lib "oleacc" (ByVal pacc As IAccessible, phwnd As LongPtr) As Long
#Else
    Private Declare Function WindowFromAccessibleObject Lib "oleacc" (ByVal pacc As IAccessible, phwnd As Long) As Long
#End If


'-------------------------------------------


#If VBA7 Then
    Function hwnd() As LongPtr
'@AssignedModule aUserform
'@INCLUDE CLASS aUserform
#Else
    Function hwnd() As Long
#End If
    WindowFromAccessibleObject oForm, hwnd
End Function


Public Sub Transition(ParamArray Elements() As Variant)
Rem By Robert Todaer
'__usage__
'with aUserform
'    .Transition .Effect(Box, "Top", Me.InsideHeight - Box.Height, 1000) _
                , .Effect(box2, "Top", 0, 100) _
                , .Effect(GoButton, "fontsize", 12, 1000) _
                , .Effect(Me, "Top", 20, 2000)
'End with
'@AssignedModule aUserform
'@INCLUDE CLASS aUserform
'@INCLUDE DECLARATION Sleep

    If IsArray(Elements(LBound(Elements, 1))) Then
        Dim Temp As Variant
        Temp = Elements(LBound(Elements, 1))
        Elements = Temp
    End If
    Dim Form As MSForms.UserForm
    Set Form = Elements(LBound(Elements, 1))("form")
    MicroTimer True
    Do
        Dim index As Integer
        For index = LBound(Elements, 1) To UBound(Elements, 1)
            IncRementElement Elements(index), MicroTimer
        Next index
        Sleep 40
        Form.Repaint
    Loop Until AllTransitionsComplete(CVar(Elements))
End Sub

Public Function Effect(obj As Object, Property As String, Destination As Double, MilSecs As Double) As Scripting.Dictionary
'@AssignedModule aUserform
'@INCLUDE CLASS aUserform
    Dim Temp As New Scripting.Dictionary
    Set Temp("obj") = obj
    Temp("property") = Property
    Temp("startValue") = CallByName(obj, Property, VbGet)
    Temp("destination") = Destination
    Temp("travel") = Destination - Temp("startValue")
    Temp("milSec") = MilSecs
    Temp("complete") = False
    On Error GoTo Catch:
    Set Temp("form") = obj.Parent
    Set Effect = Temp
    Exit Function
Catch:
    Set Temp("form") = obj
    Resume Next
End Function

Private Function MicroTimer(Optional StartTime As Boolean = False) As Double
'@AssignedModule aUserform
'@INCLUDE CLASS aUserform
'@INCLUDE DECLARATION getTickCount
    Static dTime As Double
    Dim cyTicks1 As Currency
    Dim cyTicks2 As Currency
    Static cyFrequency As Currency
    MicroTimer = 0
    If cyFrequency = 0 Then getFrequency cyFrequency
    getTickCount cyTicks1
    getTickCount cyTicks2
    If cyTicks2 < cyTicks1 Then cyTicks2 = cyTicks1
    If cyFrequency Then MicroTimer = cyTicks2 / cyFrequency
    If StartTime = True Then
        dTime = MicroTimer
        MicroTimer = 0
    Else
        MicroTimer = (MicroTimer - dTime) * 1000
    End If
End Function

Private Function AllTransitionsComplete(Elements As Variant) As Boolean
    '@INCLUDE TransitionComplete
'@AssignedModule aUserform
'@INCLUDE CLASS aUserform
    Dim el As Object
    Dim index As Integer
    For index = LBound(Elements, 1) To UBound(Elements, 1)
        Set el = Elements(index)
        If Not TransitionComplete(el) Then
            AllTransitionsComplete = False
            Exit Function
        End If
    Next index
    AllTransitionsComplete = True
End Function

Private Function TransitionComplete(ByVal el As Scripting.Dictionary) As Boolean
'@AssignedModule aUserform
'@INCLUDE CLASS aUserform
    If Math.Round(el("destination")) = Math.Round(CallByName(el("obj"), el("property"), VbGet)) Then
        TransitionComplete = True
    End If
End Function

Private Function IncRementElement(ByVal el As Scripting.Dictionary, CurrentTime As Double) As Boolean
    '@INCLUDE TransitionComplete
    '@INCLUDE easeInAndOut
'@AssignedModule aUserform
'@INCLUDE CLASS aUserform
    Dim IncRementValue As Double
    Dim CurrentValue As Double
    If TransitionComplete(el) Then
        Exit Function
    End If
    Dim o As Object
    Dim p As String
    Dim Value As Double
    Dim d As Double
    IncRementValue = easeInAndOut(CurrentTime, el("startValue"), el("travel"), el("milSec"))
    If el("travel") < 0 Then
        If Math.Round(IncRementValue, 4) < el("destination") Then
            CallByName el("obj"), el("property"), VbLet, el("destination")
        Else
            CallByName el("obj"), el("property"), VbLet, IncRementValue
        End If
    Else
        If Math.Round(IncRementValue, 4) > el("destination") Then
            CallByName el("obj"), el("property"), VbLet, el("destination")
        Else
            CallByName el("obj"), el("property"), VbLet, IncRementValue
        End If
    End If
End Function

Private Function easeInAndOut(ByVal t As Double, ByVal b As Double, ByVal c As Double, ByVal d As Double) As Double
'@AssignedModule aUserform
'@INCLUDE CLASS aUserform
    d = d / 2
    t = t / d
    If (t < 1) Then
        easeInAndOut = c / 2 * t * t * t + b
    Else
        t = t - 2
        easeInAndOut = c / 2 * (t * t * t + 2) + b
    End If
End Function

Public Sub Resizable()
'@AssignedModule aUserform
'@INCLUDE CLASS aUserform
'@INCLUDE DECLARATION GWL_STYLE
'@INCLUDE DECLARATION DrawMenuBar
'@INCLUDE DECLARATION FindWindow
'@INCLUDE DECLARATION GetWindowLong
'@INCLUDE DECLARATION SetWindowLong
    Dim hWndForm As Long, iStyle As Long
    If val(Application.Version) < 9 Then
        hWndForm = FindWindow("ThunderXFrame", oForm.Caption)
    Else
        hWndForm = FindWindow("ThunderDFrame", oForm.Caption)
    End If
    iStyle = GetWindowLong(hWndForm, GWL_STYLE)
    iStyle = iStyle Or WS_THICKFRAME
    SetWindowLong hWndForm, GWL_STYLE, iStyle
    ShowWindow hWndForm, SW_SHOW
    DrawMenuBar hWndForm
    SetFocus hWndForm
    
    mdWidth = oForm.Width
    mdHeight = oForm.Height
    
    Set DockResize = oForm
    isResizable = True
End Sub

Public Sub DockResize_Layout()
'@AssignedModule aUserform
'@INCLUDE CLASS aUserform
    DockControls
End Sub

Public Sub DockControls()
'
'from STEPHEN BULLEN's USERFORM RESIZER CLASS
'
' _______IN USERFORM_________________
'
' Private Sub UserForm_Resize()
'     auserform.init(me).DockControls
' End Sub
'
' _______Instructions_______
'
' To specify which control(s) to resize (and how), you set the control's .Tag property at design time to
' indicate that the control's top, left, width and height should be adjusted as the form's size changes.
'
' Use the letters t, l, w and h in any order (or not at all) to state that the property should change as the form
' is resized.  Follow the property by a decimal to indicate that the control should change by a percentage of the
' form's change.
'
' For example:
'   hw           Sets the control's height and width to change with the form (e.g. if there's a single list box on the form)
'   tl           Sets the contol's top and left to change in line with the form (e.g. to keep it in the bottom-right corner)
'   w0.5         Sets the control's width to change by 0.5 that of the form's width change
'   w0.5l0.5     Sets the control's width and position to change by 0.5 that of the form's width change
'@AssignedModule aUserform
'@INCLUDE CLASS aUserform

    Dim dWidthAdj As Double, dHeightAdj As Double, sTag As String
    Dim oCtl As MSForms.control
    If mdWidth = 0 Then mdWidth = oForm.Width
    If mdHeight = 0 Then mdHeight = oForm.Height
    dWidthAdj = oForm.Width - mdWidth
    dHeightAdj = oForm.Height - mdHeight
    For Each oCtl In oForm.Controls
'        If TypeName(oCtl) = "ListView" Then Stop
        With oCtl
            sTag = UCase(.Tag)
            If InStr(1, sTag, "L", vbBinaryCompare) Then
                If .Left + dWidthAdj <= 0 Then oForm.Width = mdWidth
            End If
            If InStr(1, sTag, "W", vbBinaryCompare) Then
                If .Width + dWidthAdj <= 0 Then oForm.Width = mdWidth
            End If
            If InStr(1, sTag, "T", vbBinaryCompare) Then
                If .Top + dHeightAdj <= 0 Then oForm.Height = mdHeight
            End If
            If InStr(1, sTag, "H", vbBinaryCompare) Then
                If .Height + dHeightAdj <= 0 Then oForm.Height = mdHeight
            End If
        End With
    Next
    dWidthAdj = oForm.Width - mdWidth
    dHeightAdj = oForm.Height - mdHeight
    For Each oCtl In oForm.Controls
        With oCtl
            sTag = UCase(.Tag)
            If InStr(1, sTag, "L", vbBinaryCompare) Then .Left = .Left + dWidthAdj * ResizeFactor(sTag, "L")
            If InStr(1, sTag, "T", vbBinaryCompare) Then .Top = .Top + dHeightAdj * ResizeFactor(sTag, "T")
            If InStr(1, sTag, "W", vbBinaryCompare) Then .Width = .Width + dWidthAdj * ResizeFactor(sTag, "W")
            If InStr(1, sTag, "H", vbBinaryCompare) Then .Height = .Height + dHeightAdj * ResizeFactor(sTag, "H")

        End With
    Next
    mdWidth = oForm.Width
    mdHeight = oForm.Height
End Sub

Private Function ResizeFactor(sTag As String, sChange As String)
'@AssignedModule aUserform
'@INCLUDE CLASS aUserform
    Dim i As Integer, d As Double
    i = InStr(1, sTag, sChange, vbBinaryCompare)
    If i > 0 Then
        d = val(Mid$(sTag, i + 1))
        If d = 0 Then d = 1
    End If
    ResizeFactor = d
End Function

Public Function Init(Form As Object) As aUserform
'@AssignedModule aUserform
'@INCLUDE CLASS aUserform
    Set oForm = Form
    Set Init = Me
End Function

Private Sub Class_Initialize()
'do something
'@AssignedModule aUserform
'@INCLUDE CLASS aUserform
End Sub

'Function GetUserformHwnd(Form As Object)
'    GetUserformHwnd = FindWindow(vbNullString, Form.Caption)
'End Function

Public Sub TRANSPARENT(Optional color As Variant)
    '@INCLUDE MakeFormBorderless
'@AssignedModule aUserform
'@INCLUDE CLASS aUserform
'@INCLUDE DECLARATION GWL_EXSTYLE
'@INCLUDE DECLARATION LWA_COLORKEY
'@INCLUDE DECLARATION WS_EX_LAYERED
'@INCLUDE DECLARATION FindWindow
'@INCLUDE DECLARATION GetWindowLong
'@INCLUDE DECLARATION SetLayeredWindowAttributes
'@INCLUDE DECLARATION SetWindowLong
    Dim formhandle As Long
    Dim bytOpacity As Byte
    formhandle = CLng(FindWindow(vbNullString, oForm.Caption))
    If IsMissing(color) Then color = vbWhite
    bytOpacity = 100
    SetWindowLong formhandle, GWL_EXSTYLE, GetWindowLong(formhandle, GWL_EXSTYLE) Or WS_EX_LAYERED
    oForm.BackColor = color
    SetLayeredWindowAttributes formhandle, color, bytOpacity, LWA_COLORKEY
End Sub

Public Sub Borderless()
'@AssignedModule aUserform
'@INCLUDE CLASS aUserform
'@INCLUDE DECLARATION GWL_EXSTYLE
'@INCLUDE DECLARATION GWL_STYLE
'@INCLUDE DECLARATION WS_CAPTION
'@INCLUDE DECLARATION WS_EX_DLGMODALFRAME
'@INCLUDE DECLARATION DrawMenuBar
'@INCLUDE DECLARATION FindWindow
'@INCLUDE DECLARATION GetWindowLong
'@INCLUDE DECLARATION SetWindowLong
    Dim lngWindow As Long
    Dim lFrmHdl As Long
    lFrmHdl = CLng(FindWindow(vbNullString, oForm.Caption))
    lngWindow = GetWindowLong(lFrmHdl, GWL_STYLE)
    lngWindow = lngWindow And (Not WS_CAPTION)
    SetWindowLong lFrmHdl, GWL_STYLE, lngWindow
    lngWindow = GetWindowLong(lFrmHdl, GWL_EXSTYLE)
    lngWindow = lngWindow And Not WS_EX_DLGMODALFRAME
    SetWindowLong lFrmHdl, GWL_EXSTYLE, lngWindow
    DrawMenuBar lFrmHdl
End Sub

Public Sub OnTop()
'@AssignedModule aUserform
'@INCLUDE CLASS aUserform
'@INCLUDE DECLARATION HWND_TOPMOST
'@INCLUDE DECLARATION SWP_NOMOVE
'@INCLUDE DECLARATION SWP_NOSIZE
'@INCLUDE DECLARATION FindWindow
'@INCLUDE DECLARATION SetWindowPos
    Const C_VBA6_USERFORM_CLASSNAME = "ThunderDFrame"
    Dim Ret As Long
    Dim formHWnd As Long
    formHWnd = CLng(FindWindow(C_VBA6_USERFORM_CLASSNAME, oForm.Caption))
    If formHWnd = 0 Then
        Debug.Print Err.LastDllError
    End If
    Ret = SetWindowPos(formHWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE Or SWP_NOSIZE)
    If Ret = 0 Then
        Debug.Print Err.LastDllError
    End If
End Sub

Sub ParentIsVBE()
    '@INCLUDE DisplayErrorText
'@AssignedModule aUserform
'@INCLUDE CLASS aUserform
'@INCLUDE DECLARATION USERFORM_WINDOW_CLASS
'@INCLUDE DECLARATION FindWindow
'@INCLUDE DECLARATION SetForegroundWindow
'@INCLUDE DECLARATION SetParent
    Dim GivenFormCaption As String
        GivenFormCaption = oForm.Caption
    #If VBA7 Then
        Dim VBEWindowPointer As LongPtr
        Dim UserFormWindowPointer As LongPtr
        Dim ReturnOfSetParentAPI As LongPtr
    #Else
        Dim VBEWindowPointer As Long
        Dim UserFormWindowPointer As Long
        Dim ReturnOfSetParentAPI As Long
    #End If
    Dim ErrorNumber As Long
    VBEWindowPointer = Application.VBE.MainWindow.hwnd
    UserFormWindowPointer = FindWindow(lpClassName:=USERFORM_WINDOW_CLASS, lpWindowName:=GivenFormCaption)
    Const ERROR_NUMBER_FOR_SETPARENT_API = 0
    ReturnOfSetParentAPI = SetParent(hwndChild:=UserFormWindowPointer, hWndNewParent:=VBEWindowPointer)
    If ReturnOfSetParentAPI = ERROR_NUMBER_FOR_SETPARENT_API Then
        ErrorNumber = Err.LastDllError
        DisplayErrorText "Error With SetParent", ErrorNumber
    Else
'        Debug.Print GivenFormCaption & " is child of VBE Window."
    End If
    SetForegroundWindow UserFormWindowPointer
    Application.VBE.MainWindow.SetFocus
End Sub

Private Sub DisplayErrorText(Context As String, ErrNum As Long)
    Rem  Displays a standard error message box. For this
    Rem  procedure, ErrNum should be the number returned
    Rem  by the GetLastError API function or the value
    Rem  of Err.LastDllError. It is NOT the number
    Rem  returned by Err.Number.
    '@INCLUDE GetSystemErrorMessageText
'@AssignedModule aUserform
'@INCLUDE CLASS aUserform
    Dim ErrText As String
    ErrText = GetSystemErrorMessageText(ErrNum)
    Debug.Print Context & vbCrLf & _
    "Error Number: " & CStr(ErrNum) & vbCrLf & _
    "Error Text:   " & ErrText, vbOKOnly
End Sub

Private Function GetSystemErrorMessageText(ErrorNumber As Long) As String
    Rem  This function gets the system error message text that corresponds to the error code returned by the
    Rem  GetLastError API function or the Err.LastDllError property. It may be used ONLY for these error codes.
    Rem  These are NOT the error numbers returned by Err.Number (for these errors, use Err.Description to get the description of the message).
    Rem  The error number MUST be the value returned by GetLastError or Err.LastDLLError.
    Rem
    Rem  In general, you should use Err.LastDllError rather than GetLastError because under some circumstances the value of
    Rem  GetLastError will be reset to 0 before the value is returned to VB. Err.LastDllError will always reliably return
    Rem  the last error number raised in a DLL.
'@AssignedModule aUserform
'@INCLUDE CLASS aUserform
'@INCLUDE DECLARATION FORMAT_MESSAGE_FROM_SYSTEM
'@INCLUDE DECLARATION FORMAT_MESSAGE_IGNORE_INSERTS
'@INCLUDE DECLARATION FORMAT_MESSAGE_TEXT_LEN
'@INCLUDE DECLARATION FormatMessage
    Dim ErrorText As String
    Dim ErrorTextLength As Long
    Dim FormatMessageResult As Long
    Dim LanguageID As Long
    LanguageID = 0&
    ErrorText = String$(FORMAT_MESSAGE_TEXT_LEN, " ")
    ErrorTextLength = Len(ErrorText)
    FormatMessageResult = 0&
    #If VBA7 Then
        Dim FormatMessageAPILastArgument As LongPtr
        FormatMessageAPILastArgument = 0
    #Else
        Dim FormatMessageAPILastArgument As Long
        FormatMessageAPILastArgument = 0
    #End If
    FormatMessageResult = FormatMessage( _
    dwFlags:=FORMAT_MESSAGE_FROM_SYSTEM Or FORMAT_MESSAGE_IGNORE_INSERTS, _
    lpSource:=0&, _
    dwMessageId:=ErrorNumber, _
    dwLanguageId:=0&, _
    lpBuffer:=ErrorText, _
    nSize:=ErrorTextLength, _
    Arguments:=FormatMessageAPILastArgument)
    If FormatMessageResult > 0 Then
        ErrorText = TrimToNull(ErrorText)
        GetSystemErrorMessageText = ErrorText
    Else
        GetSystemErrorMessageText = "NO ERROR DESCRIPTION AVAILABLE"
    End If
End Function

Private Function TrimToNull(text As String) As String
    Rem  Returns all the text in Text to the left of the vbNullChar
'@AssignedModule aUserform
'@INCLUDE CLASS aUserform
    Dim NullCharIndex As Integer
    NullCharIndex = InStr(1, text, vbNullChar, vbTextCompare)
    If NullCharIndex > 0 Then
        TrimToNull = Left(text, NullCharIndex - 1)
    Else
        TrimToNull = text
    End If
End Function

Public Sub MinimizeButton()
'@AssignedModule aUserform
'@INCLUDE CLASS aUserform
'@INCLUDE DECLARATION FindWindowA
'@INCLUDE DECLARATION GetWindowLongA
'@INCLUDE DECLARATION SetWindowLongA
    Dim cap     As String:  cap = oForm.Caption
    Dim hwnd    As Long:    hwnd = FindWindowA(vbNullString, cap)
    Dim exLong  As Long:    exLong = GetWindowLongA(hwnd, -16)
    
    If (exLong And &H20000) = 0 Then SetWindowLongA hwnd, -16, exLong Or &H20000
End Sub

Public Sub SaveOptions( _
    Optional includeCheckbox As Boolean = True, _
    Optional includeOptionButton As Boolean = True, _
    Optional includeTextBox As Boolean = True, _
    Optional includeListbox As Boolean = True, _
    Optional includeToggleButton As Boolean = True, _
    Optional includeCombobox As Boolean = True, _
    Optional includeMultipage As Boolean = True)
'@AssignedModule aUserform
'@INCLUDE PROCEDURE FoldersCreate
'@INCLUDE PROCEDURE IniWrite
'@INCLUDE CLASS aCollection
'@INCLUDE CLASS aListBox
'@INCLUDE CLASS aUserform
                
    Dim configFolder As String: configFolder = ThisWorkbook.Path & "\config\"
    FoldersCreate configFolder
    Dim iniFile As String: iniFile = configFolder & "UserformSettings.ini"
    Dim Key, Value
    Dim c As MSForms.control
    For Each c In oForm.Controls
        If TypeName(c) Like "CheckBox" Then
         If Not includeCheckbox Then GoTo SKIP
        ElseIf TypeName(c) Like "OptionButton" Then
            If Not includeOptionButton Then GoTo SKIP
        ElseIf TypeName(c) Like "TextBox" Then
            If Not includeTextBox Then GoTo SKIP
        ElseIf TypeName(c) = "ListBox" Then
            If Not includeListbox Then GoTo SKIP
        ElseIf TypeName(c) Like "ToggleButton" Then
            If Not includeToggleButton Then GoTo SKIP
        ElseIf TypeName(c) Like "ComboBox" Then
            If Not includeCombobox Then GoTo SKIP
        ElseIf TypeName(c) = "MultiPage" Then
            If Not includeMultipage Then GoTo SKIP
        Else
            GoTo SKIP
        End If
        Key = c.Name
        Dim coll As New Collection
        Select Case TypeName(c)
        Case "CheckBox", "OptionButton", "ToggleButton", "ComboBox", "MultiPage"
            IniWrite iniFile, oForm.Name, Key, c.Value
        Case "TextBox"
            IniWrite iniFile, oForm.Name, Key, VBA.Replace(c.Value, vbNewLine, "||")
        Case "ListBox"
            Set coll = aListBox.Init(c).selectedIndexes
            If coll.count > 0 Then
                IniWrite iniFile, oForm.Name, Key, aCollection.Init(coll).ToString(",")
            Else
                IniWrite iniFile, oForm.Name, Key, -1
            End If
        End Select
SKIP:
    Next
   
End Sub

Public Sub LoadOptions(ParamArray ExcludeThese() As Variant)
'ExcludeThese:="ListBox1","TextBox1"     '<--control names
'@AssignedModule aUserform
'@INCLUDE PROCEDURE ArrayAllocated
'@INCLUDE PROCEDURE FileExists
'@INCLUDE PROCEDURE FoldersCreate
'@INCLUDE PROCEDURE TxtOverwrite
'@INCLUDE PROCEDURE ArrayContains
'@INCLUDE PROCEDURE CreateOrSetSheet
'@INCLUDE PROCEDURE IniSectionKeys
'@INCLUDE PROCEDURE IniReadKey
'@INCLUDE CLASS aListBox
'@INCLUDE CLASS aUserform
    Dim configFolder As String: configFolder = ThisWorkbook.Path & "\config\"
    FoldersCreate configFolder
    Dim iniFile As String: iniFile = configFolder & "UserformSettings.ini"
    If Not FileExists(iniFile) Then TxtOverwrite iniFile, ""
    Dim Key, Value
    Dim c As MSForms.control
    Dim keyArray: keyArray = IniSectionKeys(iniFile, oForm.Name)
    If Not ArrayAllocated(keyArray) Then Exit Sub
    For Each Key In keyArray
    On Error Resume Next
        Set c = oForm.Controls(Key)
        Value = IniReadKey(iniFile, oForm.Name, Key)
        If Not TypeName(c) = "Nothing " Then
            If Not ArrayContains(Key, ExcludeThese) Then
                Select Case TypeName(c)
                Case "CheckBox", "OptionButton", "ToggleButton", "ComboBox", "MultiPage"
                    c.Value = Value
                Case "TextBox"
                    c.Value = VBA.Replace(Value, "||", vbNewLine)
                Case "ListBox"
                    If InStr(1, Value, ",") > 0 Then
                        aListBox.Init(c).SelectItems Split(Value, ","), True
                    Else
                        c.Selected(CInt(Value)) = True
                    End If
                End Select
            End If
        End If
    Next

'=== OBSOLETE
'
'    Dim ws As Worksheet
'    Set ws = CreateOrSetSheet(oForm.Name & "_Settings", ThisWorkbook)
'    If ws.Range("A1") = "" Then Exit Sub
'    Dim cell As Range
'    Set cell = ws.Cells(1, 1)
'    Dim c As MSForms.control
'    Dim v
'    On Error Resume Next
'    Do While cell <> ""
'        Set c = oForm.Controls(cell.TEXT)
'        If Not TypeName(c) = "Nothing " Then
'            If Not ArrayContains(cell, ExcludeThese) Then
'                Select Case TypeName(c)
'                Case "TextBox", "CheckBox", "OptionButton", "ToggleButton", "ComboBox"
'                    c.Value = cell.OFFSET(0, 1)
'                Case "ListBox"
'                    If InStr(1, cell.OFFSET(0, 1), ",") > 0 Then
'                        aListBox.Init(c).SelectItems Split(cell.OFFSET(0, 1), ","), True
'                    Else
'                        c.Selected(CInt(cell.OFFSET(0, 1))) = True
'                    End If
'                End Select
'            End If
'        End If
'        Set cell = cell.OFFSET(1, 0)
'    Loop
End Sub

Public Sub SavePosition()
'@AssignedModule aUserform
'@INCLUDE PROCEDURE FoldersCreate
'@INCLUDE PROCEDURE IniWrite
'@INCLUDE CLASS aUserform
    Dim configFolder As String: configFolder = ThisWorkbook.Path & "\config\"
    FoldersCreate configFolder
    Dim iniFile As String: iniFile = configFolder & "UserformSettings.ini"
    IniWrite iniFile, oForm.Name, "StartupTop", oForm.Top
    IniWrite iniFile, oForm.Name, "StartupLeft", oForm.Left
        
'=== OBSOLETE
'    SaveSetting "My Settings Folder", oForm.Name, "Left Position", oForm.Left
'    SaveSetting "My Settings Folder", oForm.Name, "Top Position", oForm.Top
End Sub

Public Sub LoadPosition()
'@AssignedModule aUserform
'@INCLUDE PROCEDURE FileExists
'@INCLUDE PROCEDURE FoldersCreate
'@INCLUDE PROCEDURE TxtOverwrite
'@INCLUDE PROCEDURE IniReadKey
'@INCLUDE CLASS aUserform
    Dim configFolder As String: configFolder = ThisWorkbook.Path & "\config\"
    FoldersCreate configFolder
    Dim iniFile As String: iniFile = configFolder & "UserformSettings.ini"
    If Not FileExists(iniFile) Then TxtOverwrite iniFile, ""
    Dim myLeft, myTop
    myLeft = IniReadKey(iniFile, oForm.Name, "StartupLeft")
    myTop = IniReadKey(iniFile, oForm.Name, "StartupTop")
    If myLeft = "" Or myTop = "" Then
        oForm.startupposition = 1
    Else
        oForm.startupposition = 0
        oForm.Top = myTop
        oForm.Left = myLeft
    End If
    
'Setting         Value   Description
'Manual          0       No initial setting specified.
'CenterOwner     1       Center on the item to which the UserForm belongs.
'CenterScreen    2       Center on the whole screen.
'WindowsDefault  3       Position in upper-left corner of screen.

'=== OBSOLETE
'    If GetSetting("My Settings Folder", oForm.Name, "Left Position") = "" _
'        And GetSetting("My Settings Folder", oForm.Name, "Top Position") = "" Then
'        oForm.startupposition = 1
'    Else
'        oForm.Left = GetSetting("My Settings Folder", oForm.Name, "Left Position")
'        oForm.Top = GetSetting("My Settings Folder", oForm.Name, "Top Position")
'    End If
End Sub

Public Sub ResizeToFitControls(Optional marginRight = 0, Optional marginBottom = 0)
'@AssignedModule aUserform
'@INCLUDE CLASS aUserform
    oForm.Width = 0
    oForm.Height = 0
    Dim ctr As MSForms.control
    Dim myWidth:    myWidth = 0 'oForm.InsideWidth
    Dim myHeight:   myHeight = 0 'oForm.InsideHeight
    For Each ctr In oForm.Controls
        If ctr.Parent.Name = oForm.Name Then
            If ctr.Visible = True Then
                If ctr.Left + ctr.Width > myWidth Then myWidth = ctr.Left + ctr.Width
                If ctr.Top + ctr.Height > myHeight Then myHeight = ctr.Top + ctr.Height
            End If
        End If
    Next
    oForm.Width = myWidth + (oForm.Width - oForm.InsideWidth) + marginRight
    oForm.Height = myHeight + (oForm.Height - oForm.InsideHeight) + marginBottom
End Sub


Public Sub MouseOnControl(Ctrl As Object)
    '@INCLUDE PointsPerPixelX
    '@INCLUDE PointsPerPixelY
'@AssignedModule aUserform
'@INCLUDE CLASS aUserform
'@INCLUDE DECLARATION ClientToScreen
'@INCLUDE DECLARATION FindWindow
'@INCLUDE DECLARATION SetCursorPos
'@INCLUDE DECLARATION Ctrl
'@INCLUDE DECLARATION tCursor
    Dim p As tCursor
    Dim lngHwnd As Long
    lngHwnd = CLng(FindWindow(vbNullString, oForm.Caption))
    p.Left = (Ctrl.Left + (Ctrl.Width \ 2)) / PointsPerPixelX
    p.Top = (Ctrl.Top + (Ctrl.Height \ 2)) / PointsPerPixelY
    ClientToScreen lngHwnd, p
    SetCursorPos p.Left, p.Top
End Sub

Private Function PointsPerPixelX() As Double
'@AssignedModule aUserform
'@INCLUDE CLASS aUserform
'@INCLUDE DECLARATION LOGPIXELSX
'@INCLUDE DECLARATION GetDC
'@INCLUDE DECLARATION GetDeviceCaps
'@INCLUDE DECLARATION ReleaseDC
    Dim hDC As Long
    hDC = GetDC(0)
    PointsPerPixelX = 72 / GetDeviceCaps(hDC, LOGPIXELSX)
    ReleaseDC 0, hDC
End Function

Private Function PointsPerPixelY() As Double
'@AssignedModule aUserform
'@INCLUDE CLASS aUserform
'@INCLUDE DECLARATION LOGPIXELSY
'@INCLUDE DECLARATION GetDC
'@INCLUDE DECLARATION GetDeviceCaps
'@INCLUDE DECLARATION ReleaseDC
    Dim hDC As Long
    hDC = GetDC(0)
    PointsPerPixelY = 72 / GetDeviceCaps(hDC, LOGPIXELSY)
    ReleaseDC 0, hDC
End Function

Private Function WhereIsTheMouseAt() As tCursor
'@AssignedModule aUserform
'@INCLUDE CLASS aUserform
'@INCLUDE DECLARATION GetCursorPos
'@INCLUDE DECLARATION tCursor
    Dim mPos As tCursor
    GetCursorPos mPos
    WhereIsTheMouseAt = mPos
End Function

Private Function convertMouseToForm() As tCursor
'@AssignedModule aUserform
'@INCLUDE CLASS aUserform
'@INCLUDE DECLARATION tCursor
    Dim mPos As tCursor
    mPos = WhereIsTheMouseAt
    mPos.Left = PointsPerPixelY * mPos.Left
    mPos.Top = PointsPerPixelX * mPos.Top
    convertMouseToForm = mPos
End Function

Public Sub ShowAtCursor()
'@AssignedModule aUserform
'@INCLUDE CLASS aUserform
    oForm.Left = convertMouseToForm.Left
    oForm.Top = convertMouseToForm.Top
End Sub

'README	Document

Option Explicit

'aTreeView	Class


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Class      : aTreeView
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 04-05-2023 12:19    Alex
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Private TV As TreeView

Private Enum tvImages
    tvProject = 1
    tvSheet = 2
    tvForm = 3
    tvModule = 4
    tvClass = 5
    tvMacro = 6
    tvText = 7
End Enum

Public Function Init(TargetTreeview) As aTreeView
'@AssignedModule aTreeView
'@INCLUDE CLASS aTreeView
    Set TV = TargetTreeview
    Set Init = Me
End Function

'Sub TVTestVarious()
'    zTest.Show
'    Dim nod As Node
'    Dim tv As TreeView
'    Set tv = zTest.TreeView1
'    TreeviewPopulateFromRange tv, ActiveSheet.Range("A1"), True, False
'    For Each nod In tv.Nodes
'        dp nod.TEXT & vbTab & TreeviewGetLevel(nod)
'    Next
'    dp TreeviewArray(tv)
'    Stop
'    dp TreeviewArrayPaths(tv)
'    Stop
'    TreeviewFilter tv, "*\*\*\*", True
'    dp TreeviewArrayPaths(tv)
'    TreeviewFoldingExpandAll tv
'End Sub

Public Sub RemoveEmpty(ColumnLevel As Long)
'@AssignedModule aTreeView
'@INCLUDE PROCEDURE dp
'@INCLUDE CLASS aTreeView
    Dim i As Long
    Dim nod As Node
    For i = TV.Nodes.count To 1 Step -1
        Set nod = TV.Nodes(i)
        If GetLevel(nod) = ColumnLevel Then
            If nod.Children = 0 Then
                TV.Nodes.Remove nod.index
            End If
        End If
    Next
End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 20-12-2022 07:43    Alex                (TreeviewFilter)

Public Sub FilterTV(txtLike As String, MatchCase As Boolean)
'example
'TreeviewFilter tv, "*\*\*\*", True
'each \ indicates a sublevel
'@AssignedModule aTreeView
'@INCLUDE PROCEDURE ArrayFilterLike
'@INCLUDE CLASS aTreeView

    Dim var
    var = ArrayFilterLike(TreeviewArrayPaths(TV), txtLike, MatchCase)
    Clear
    Dim element
    Dim nod As Node
    On Error Resume Next
    Dim i As Long
    For Each element In var
        For i = 0 To UBound(Split(element, "\"))
            If i = 0 Then
                Set nod = TV.Nodes.Add(, , , Split(element, "\")(i))
            Else
                Set nod = TV.Nodes.Add(nod, tvwChild, , Split(element, "\")(i))
            End If
        Next
    Next
    On Error GoTo 0
End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 19-12-2022 15:09    Alex                (TVColumnsCount)

Public Function columnCount()
'@AssignedModule aTreeView
'@INCLUDE CLASS aTreeView
    Dim output As Long
    Dim counter As Long
    Dim nod As Node
    For Each nod In TV.Nodes
        counter = GetLevel(nod)
        If counter > output Then output = output + 1
    Next
    columnCount = output
End Function

Public Function rowCount()
'@AssignedModule aTreeView
'@INCLUDE CLASS aTreeView
    rowCount = TV.Nodes.count
End Function

'* Modified   : Date and Time       Author              Description
'* Updated    : 19-12-2022 16:33    Alex
'* Updated    : 19-07-2023 10:23    Alex                added base 1 : ReDim output(1 To rowCount, 1 To ColumnCount)

Function ToArray() As Variant
'@LastModified 2307191023
'Modified from https://www.excelforum.com/excel-programming-vba-macros/1102518-transfer-all-nodes-from-a-userform-treeview-into-a-treeview-on-a-worksheet-with-vba.html
'@AssignedModule aTreeView
'@INCLUDE CLASS aTreeView
   Dim nROOT            As Node
   Dim nX               As Node
   Dim iRow             As Integer

   On Error GoTo Catch

   If TV.Nodes.count = 0 Then
      MsgBox "No nodes to export...", vbExclamation, "Nothing to do"
      Stop
   End If

   ' Start at first node
   Set nX = TV.Nodes(1)
   ' Get the first root node
   Set nROOT = nX.Root.FirstSibling
   'Create array placeholder
   Dim output()
   ReDim output(1 To rowCount, 1 To columnCount)
   'Drill down and export
   Do
      TreeviewArrayAppend 0, iRow, nROOT, output, True
      Set nROOT = nROOT.Next
   Loop While Not (nROOT Is Nothing)

    ToArray = output
Finally:
   'Cleanup

   'Exit
   On Error GoTo 0
   Exit Function
Catch:
   MsgBox "ERROR: " & Err.Description, vbExclamation, "Error"
   Resume Finally
End Function

Private Sub TreeviewArrayAppend(ByVal lngLevel As Integer, _
                                ByRef lngRow As Integer, _
                                ByRef N As Node, _
                                ByRef TargetArray As Variant, _
                                ByVal includeChildren As Boolean)
'@AssignedModule aTreeView
'@INCLUDE CLASS aTreeView

      TargetArray(lngRow + 1, lngLevel + 1) = N.text
      lngRow = lngRow + 1
      ' If there are child nodes then call recusively
      lngLevel = lngLevel + 1
      If includeChildren Then
        If N.Children > 0 Then
           Dim nC As Node
           Set nC = N.child
           Do
              TreeviewArrayAppend lngLevel, lngRow, nC, TargetArray, True
              Set nC = nC.Next
           Loop While Not (nC Is Nothing)
        End If
    End If
End Sub
'--------------------------------------------

Public Function TreeviewArrayPaths() As Variant  '1d
'Modified from https://www.excelforum.com/excel-programming-vba-macros/1102518-transfer-all-nodes-from-a-userform-treeview-into-a-treeview-on-a-worksheet-with-vba.html
'@AssignedModule aTreeView
'@INCLUDE CLASS aTreeView
   Dim nROOT            As Node
   Dim nX               As Node
   Dim iRow             As Integer

   On Error GoTo Catch

   If TV.Nodes.count = 0 Then
      MsgBox "No nodes to export...", vbExclamation, "Nothing to do"
      Stop
   End If

   ' Start at first node
   Set nX = TV.Nodes(1)
   ' Get the first root node
   Set nROOT = nX.Root.FirstSibling
   'Create array placeholder
   Dim output()
   ReDim output(rowCount)
   'Drill down and export
   Do
      TreeviewArrayAppendPaths 0, iRow, nROOT, output
      Set nROOT = nROOT.Next
   Loop While Not (nROOT Is Nothing)

    TreeviewArrayPaths = output
Finally:
   'Cleanup

   'Exit
   On Error GoTo 0
   Exit Function
Catch:
   MsgBox "ERROR: " & Err.Description, vbExclamation, "Error"
   Resume Finally
End Function

Public Sub TreeviewArrayAppendPaths(ByVal lngLevel As Integer, _
                     ByRef lngRow As Integer, _
                     ByRef N As Node, _
                     ByRef TargetArray As Variant)
'@AssignedModule aTreeView
'@INCLUDE CLASS aTreeView

    TargetArray(lngRow) = N.fullPath
    lngRow = lngRow + 1
    ' If there are child nodes then call recusively
    lngLevel = lngLevel + 1
    If N.Children > 0 Then
       Dim nC As Node
       Set nC = N.child
       Do
          TreeviewArrayAppendPaths lngLevel, lngRow, nC, TargetArray
          Set nC = nC.Next
       Loop While Not (nC Is Nothing)
    End If
End Sub

Public Sub SelectNextNode()
'@AssignedModule aTreeView
'@INCLUDE CLASS aTreeView
    If Not TV.selectedItem.child Is Nothing Then
        TV.selectedItem.child.Selected = True
    ElseIf Not TV.selectedItem.Next Is Nothing Then
        TV.selectedItem.Next.Selected = True
    Else
        If Not TV.selectedItem.Parent.Next Is Nothing Then
            TV.selectedItem.Parent.Next.Selected = True
        Else
            TV.selectedItem.Parent.Parent.Next.Selected = True
        End If
    End If
End Sub

Public Sub SelectPreviousNode()
'@AssignedModule aTreeView
'@INCLUDE CLASS aTreeView
    If Not TV.selectedItem.Previous Is Nothing Then
        If Not TV.selectedItem.Previous.child Is Nothing Then
            TV.selectedItem.Previous.child.LastSibling.Selected = True
            Do While Not TV.selectedItem.child Is Nothing
                TV.selectedItem.child.LastSibling.Selected = True
            Loop
        Else
            TV.selectedItem.Previous.Selected = True
        End If
    ElseIf Not TV.selectedItem.Parent Is Nothing Then
        TV.selectedItem.Parent.Selected = True
    End If
End Sub

Public Sub SelectNodes(SingleSelect As Boolean, lvl1crit As String, Optional CriteriaByLevel As Variant)
'@AssignedModule aTreeView
'@INCLUDE CLASS aTreeView
    Dim nd As Node
    For Each nd In TV.Nodes
        If nd.text = lvl1crit Then
            nd.Selected = True
            nd.Expanded = True
            If SingleSelect = True Then Exit For
        End If
    Next
    Dim x As Long
    x = nd.index + 1
    Dim crit
    Dim i As Long
    For Each crit In CriteriaByLevel
        For i = x To TV.Nodes.count
            If TV.Nodes.item(i).text = crit Then
                TV.Nodes.item(i).Selected = True
                TV.Nodes.item(i).Expanded = True
                If SingleSelect = True Then Exit For
            End If
        Next
        x = i + 1
    Next
End Sub

Public Sub ApplyStandardStyle()
'@AssignedModule aTreeView
'@INCLUDE CLASS aTreeView
    With TV
        .Sorted = False
        .Appearance = ccFlat
        .LineStyle = tvwRootLines
        .Style = tvwTreelinesPlusMinusPictureText
        .Font.Size = 10
        .indentation = 2
    End With
End Sub

Sub ExpandAll()
'@AssignedModule aTreeView
'@INCLUDE CLASS aTreeView
    Dim i As Long
    For i = 1 To TV.Nodes.count
        TV.Nodes(i).Expanded = True
    Next
End Sub

Sub CollapseAll()
'@AssignedModule aTreeView
'@INCLUDE CLASS aTreeView

    Dim i As Long
    For i = 1 To TV.Nodes.count
        TV.Nodes(i).Expanded = False
    Next
End Sub

Sub Clear()
'@AssignedModule aTreeView
'@INCLUDE CLASS aTreeView
    Dim i As Long
    For i = TV.Nodes.count To 1 Step -1
        TV.Nodes.Remove i
    Next
End Sub
Public Sub ChildrenCheck(Parent As MSComctlLib.Node, check As Boolean)
    ' In userform:
    ' Sub treeview1_NodeCheck(ByVal node As MSComctlLib.Node)
    '     TreeviewNodeCheck node, node.Checked
    ' End Sub
'@AssignedModule aTreeView
'@INCLUDE CLASS aTreeView
    
    Dim child As MSComctlLib.Node
    Parent.Checked = check
    
    ' Recursively check child nodes
    Set child = Parent.child
    While Not child Is Nothing
        ChildrenCheck child, check
        Set child = child.Next
    Wend
End Sub

Public Function GetLevel(ByVal theNode As Node) As Integer
'@AssignedModule aTreeView
'@INCLUDE CLASS aTreeView
    GetLevel = 1
    Do Until theNode.Root = theNode.FirstSibling
        GetLevel = GetLevel + 1
        Set theNode = theNode.Parent
    Loop
End Function

Sub LoadRange( _
                FirstCell As Range, _
                ClearPreviousNodes As Boolean, _
                Expanded As Boolean)
    Rem example use
    Rem    LoadRange me.Treeview1,thisworkbook.sheets("TreeviewHierarchy").range("A1"),true,false
    Rem example of sheet structure
    Rem  |1|2|3
    Rem 1|A| |
    Rem 2| |1|
    Rem 3| | |1.1
    Rem 4| | |1.2
    Rem 5|B| |
    Rem 6| |2|
    Rem 7| | |2.1
    Rem 8| | |2.2
'@AssignedModule aTreeView
'@INCLUDE CLASS aTreeView
    Dim nP As Node
    Dim c As Excel.Range
    On Error Resume Next
    Dim childRange As Range
    Set childRange = FirstCell.CurrentRegion.offset(0, 1)
    Set childRange = childRange.Resize(, childRange.Columns.count - 1)
    Set childRange = childRange.SpecialCells(xlCellTypeConstants)
    With TV
        If ClearPreviousNodes = True Then .Nodes.Clear
        For Each c In FirstCell.Parent.Columns(FirstCell.Column).SpecialCells(xlCellTypeConstants)
            Set nP = .Nodes.Add(, , c.Address, c.Value)
        Next
        For Each c In childRange
            If c.offset(, -1) = "" Then  'c.Value <> vbNullString And c.Address <> FirstCell.Address And
                Set nP = .Nodes(c.offset(, -1).End(xlUp).Address)
                If nP Is Nothing Then
                    MsgBox "ERROR: Parent node " & c.offset(, -1).End(xlUp).Value & " not found...", vbExclamation, "Error"
                    Exit Sub
                End If
                .Nodes.Add nP, tvwChild, c.Address, c.Value
                If Err.Number <> 0 Then
                    MsgBox "ERROR: The node " & c.Value & " is a duplicate. All node descrptions must be unique", vbExclamation, "Error"
                    Exit Sub
                End If
                nP.Expanded = Expanded
            End If
        Next
        With .Nodes(FirstCell.Address)
            .Selected = True
            .EnsureVisible
        End With
    End With
End Sub

Public Sub LoadTreeArray( _
                    arr, _
                    ClearPreviousNodes As Boolean, _
                    Expanded As Boolean)
'@AssignedModule aTreeView
'@INCLUDE PROCEDURE ArrayToRange2D
'@INCLUDE PROCEDURE CreateOrSetSheet
'@INCLUDE CLASS aTreeView
                   
    Application.ScreenUpdating = False
    Application.DisplayAlerts = False
    Dim tmpSheet As Worksheet
    Set tmpSheet = CreateOrSetSheet("TempOps", ThisWorkbook)
    tmpSheet.Cells.Clear
    ArrayToRange2D arr, tmpSheet.Cells(1, 1)
    LoadRange tmpSheet.Cells(1, 1), ClearPreviousNodes, Expanded
    tmpSheet.Delete
    
    Application.ScreenUpdating = True
    Application.DisplayAlerts = True
End Sub

Sub LoadVBProjects()
'@AssignedModule aTreeView
'@INCLUDE PROCEDURE ProceduresOfModule
'@INCLUDE PROCEDURE WorkbookProjectProtected
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aTreeView
    Me.Clear
    Dim nP As Node
    Dim nM As Node
    Dim nS As Node
    Dim x, y, s, p As Variant
    Dim Module As VBComponent
    On Error Resume Next
    Dim element
    For Each x In Array(Workbooks, AddIns)
        For Each y In x
            If Not WorkbookProjectProtected(Workbooks(y.Name)) Then
                If Err.Number = 0 Then
                    Set nP = TV.Nodes.Add(, , , y.Name)
                    For Each element In Array(vbext_ct_Document, vbext_ct_MSForm, vbext_ct_StdModule, vbext_ct_ClassModule)
                        For Each Module In Workbooks(y.Name).VBProject.VBComponents
                            If Module.Type = element Then
                                Set nM = TV.Nodes.Add(nP, tvwChild, , aModule.Init(Module).Name)
                                For Each p In ProceduresOfModule(Module)
                                    Set nS = TV.Nodes.Add(nM, tvwChild, , CStr(p))
                                Next p
                            End If
                        Next Module
                    Next
                End If
            End If
            Err.Clear
        Next y
    Next x
End Sub

Sub ActivateProjectElement()
'@AssignedModule aTreeView
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aTreeView
    Dim Module As VBComponent
    Dim i As Long
    Select Case GetLevel(TV.selectedItem)
    Case Is = 1
    Case Is = 2
        With TV.selectedItem
            On Error Resume Next
            Set Module = Workbooks(.Parent.text).VBProject.VBComponents(.text)
            On Error GoTo 0
            If Module Is Nothing Then Set Module = Workbooks(.Parent.text).VBProject.VBComponents(Workbooks(.Parent.text).Sheets(.text).codeName)
            aModule.Init(Module).Activate
        End With
    Case Is = 3
        With TV.selectedItem
        On Error Resume Next
        Set Module = Workbooks(.Parent.Parent.text).VBProject.VBComponents(.Parent.text)
        On Error GoTo 0
        If Module Is Nothing Then Set Module = _
            Workbooks(.Parent.Parent.text).VBProject.VBComponents(Workbooks(.Parent.Parent.text).Sheets(.Parent.text).codeName)
            aModule.Init(Module).Activate
            For i = 1 To Module.CodeModule.CountOfLines
                If InStr(1, Module.CodeModule.Lines(i, 1), "Sub " & .text) > 0 Or _
                    InStr(1, Module.CodeModule.Lines(i, 1), "Function " & .text) > 0 Then
                    Module.CodeModule.CodePane.SetSelection i, 1, i, 1
                    Exit Sub
                End If
            Next
        End With
    Case Is = 4
        With TV.selectedItem
            Set Module = Workbooks(.Parent.Parent.Parent.text).VBProject.VBComponents(.Parent.Parent.text)
            aModule.Init(Module).Activate
            DoEvents
            For i = 1 To Module.CodeModule.CountOfLines
                If Trim(Module.CodeModule.Lines(i, 1)) = .text Then
                    Module.CodeModule.CodePane.SetSelection i, 1, i, 1
                    Exit Sub
                End If
            Next
        End With
    End Select
End Sub

Public Sub FindCodeEverywhere(F As String)
'@AssignedModule aTreeView
'@INCLUDE PROCEDURE WorkbookProjectProtected
'@INCLUDE CLASS aProcedure
'@INCLUDE CLASS aWorkbook
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aModules
'@INCLUDE CLASS aTreeView
    Dim nP As Node
    Dim nM As Node
    Dim nS As Node
    Dim nF As Node
    Dim x, y, s, p As Variant
    Dim Module As VBComponent
    Dim am As aModule
    Dim AP As aProcedure
    Dim aw As aWorkbook
    Dim i As Long
    On Error Resume Next
    For Each x In Array(Workbooks, AddIns)
        For Each y In x
            If Not WorkbookProjectProtected(Workbooks(y.Name)) Then
                If Err.Number = 0 Then
                    Set aw = aWorkbook.Init(Workbooks(y.Name))
                    If UBound(Filter(Split(aw.Code, vbNewLine), F, True, vbTextCompare)) > -1 Then
                        Set nP = TV.Nodes.Add(, , , y.Name)
                        For Each am In aModules.Init(aw.item).Items
                            If am.Contains(F, False, False, True) Then
                                Set nM = TV.Nodes.Add(nP, tvwChild, , am.Name)
                                For Each AP In am.Procedures
                                    If UBound(Filter(Split(AP.Code_All, vbNewLine), F, True, vbTextCompare)) > -1 Then
                                        Set nS = TV.Nodes.Add(nM, tvwChild, , CStr(AP.Name))
                                        s = Filter(Split(AP.Code_All, vbNewLine), F, True, vbTextCompare)
                                        For i = 0 To UBound(s)
                                            Set nF = TV.Nodes.Add(nS, tvwChild, , Trim(s(i)))
                                        Next i
                                    End If
                                Next AP
                            End If
                        Next am
                    End If
                End If
            End If
            Err.Clear
        Next y
    Next x
End Sub

Sub ImageListLoadProjectIcons(imgList As ImageList)
'@AssignedModule aTreeView
'@INCLUDE CLASS aTreeView
    Dim strPath As String
    strPath = "C:\Users\acer\Dropbox\SOFTWARE\EXCEL\0 Alex\treeviewicons\"
    With imgList.ListImages
        .Add , "Project", LoadPicture(strPath & "Project.jpg")
        .Add , "Sheet", LoadPicture(strPath & "Sheet.jpg")
        .Add , "Form", LoadPicture(strPath & "Form.jpg")
        .Add , "Module", LoadPicture(strPath & "Module.jpg")
        .Add , "Class", LoadPicture(strPath & "Class.jpg")
        .Add , "Macro", LoadPicture(strPath & "Macro.jpg")
        .Add , "Text", LoadPicture(strPath & "Text.jpg")
    End With
    TV.ImageList = imgList
End Sub

Sub TreeviewAssignProjectImages()
    '@INCLUDE ModuleTypeToString
    '@INCLUDE ModuleOfWorksheet
    '@INCLUDE TreeviewGetLevel
'@AssignedModule aTreeView
'@INCLUDE PROCEDURE ModuleTypeToString
'@INCLUDE PROCEDURE ModuleOfWorksheet
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aTreeView
    Dim sModuleName As String
    Dim i As Long
    Dim Module As VBComponent
    Dim TargetWorkbook As Workbook
    For i = 1 To TV.Nodes.count
        Select Case GetLevel(TV.Nodes.item(i))
        Case 1
            If InStr(1, TV.Nodes.item(i).text, ".") = 0 Then GoTo SKIP
            TV.Nodes.item(i).Image = tvImages.tvProject
        Case 2
            Set TargetWorkbook = Workbooks(TV.Nodes.item(i).Parent.text)
            If InStr(1, TargetWorkbook.Name, ".") = 0 Then GoTo SKIP
            sModuleName = TV.Nodes.item(i).text
            Set Module = Nothing
            On Error Resume Next
            Set Module = TargetWorkbook.VBProject.VBComponents(sModuleName)
            On Error GoTo 0
            If Module Is Nothing Then
                Set Module = ModuleOfWorksheet(TargetWorkbook.Worksheets(TV.Nodes.item(i).text))
            End If
            Select Case aModule.Init(Module).TypeToString
            Case "Document"
                TV.Nodes.item(i).Image = tvImages.tvSheet
            Case "UserForm"
                TV.Nodes.item(i).Image = tvImages.tvForm
            Case "Module"
                TV.Nodes.item(i).Image = tvImages.tvModule
            Case "Class"
                TV.Nodes.item(i).Image = tvImages.tvClass
            End Select
        Case 3
            TV.Nodes.item(i).Image = tvImages.tvMacro
        Case 4
            TV.Nodes.item(i).Image = tvImages.tvText
        End Select
SKIP:
    Next i
End Sub



'uCodeFinder	UserForm

'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Userform   : uCodeFinder
'* Created    : 06-10-2022 10:34
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Dim AT As aTreeView

Dim CalledFromModule As VBComponent
Dim CalledFromProcedure As String

Private Sub CommandButton2_Click()
'@AssignedModule uCodeFinder
'@INCLUDE USERFORM uCodeFinder
    ReturnToCaller
End Sub

Private Sub GetInfo_Click()
'@AssignedModule uCodeFinder
'@INCLUDE PROCEDURE PlayTheSound
'@INCLUDE CLASS aUserform
'@INCLUDE USERFORM uCodeFinder
'@INCLUDE USERFORM uAuthor
    With aUserform.Init(Me)
        .Transition .Effect(GetInfo, "Top", GetInfo.Top - 10, 150)
        PlayTheSound ThisWorkbook.Path & "\sound\coin.wav"
        .Transition .Effect(GetInfo, "Top", GetInfo.Top + 10, 150)
    End With
    uAuthor.Show
End Sub

Private Sub TreeView1_BeforeLabelEdit(Cancel As Integer)
'@AssignedModule uCodeFinder
'@INCLUDE USERFORM uCodeFinder
    Cancel = True
End Sub

Private Sub UserForm_Activate()
'@AssignedModule uCodeFinder
'@INCLUDE CLASS aUserform
'@INCLUDE USERFORM uCodeFinder
    With aUserform.Init(Me)
        .Resizable
        .ParentIsVBE
    End With

End Sub

Private Sub UserForm_Initialize()
'@AssignedModule uCodeFinder
'@INCLUDE PROCEDURE ActiveProcedure
'@INCLUDE PROCEDURE ActiveModule
'@INCLUDE CLASS aTreeView
'@INCLUDE USERFORM uCodeFinder
'@INCLUDE DECLARATION AT
'@INCLUDE DECLARATION CalledFromModule
'@INCLUDE DECLARATION CalledFromProcedure
    
    With TreeView1
        .Sorted = True
        .Appearance = ccFlat
        .LineStyle = tvwRootLines
        .Style = tvwTreelinesPlusMinusPictureText
        .Font.Size = 10
        .indentation = 2
    End With
    Set AT = aTreeView.Init(TreeView1)
    With AT
        .ImageListLoadProjectIcons ImageList1
        .CollapseAll
    End With
    Set CalledFromModule = ActiveModule
    CalledFromProcedure = ActiveProcedure

End Sub

Private Sub ReturnToCaller()
'@AssignedModule uCodeFinder
'@INCLUDE CLASS aModule
'@INCLUDE USERFORM uCodeFinder
'@INCLUDE DECLARATION CalledFromModule
'@INCLUDE DECLARATION CalledFromProcedure
    On Error GoTo HELL
    aModule.Init(CalledFromModule).Activate
    Dim i As Long
    For i = 1 To CalledFromModule.CodeModule.CountOfLines
        If InStr(1, CalledFromModule.CodeModule.Lines(i, 1), "Sub " & CalledFromProcedure) > 0 Or _
            InStr(1, CalledFromModule.CodeModule.Lines(i, 1), "Function " & CalledFromProcedure) > 0 Then
            CalledFromModule.CodeModule.CodePane.SetSelection i, 1, i, 1
            Exit Sub
        End If
    Next
HELL:
End Sub

Private Sub CommandButton1_Click()
'@AssignedModule uCodeFinder
'@INCLUDE CLASS aTreeView
'@INCLUDE USERFORM uCodeFinder
'@INCLUDE DECLARATION AT
    Dim tvtop As Long, tvleft As Long

    'TreeView1.Visible = False
    With AT
        .Clear
        .FindCodeEverywhere TextBox1.text
        .TreeviewAssignProjectImages
        .ExpandAll
    End With
    'TreeView1.Visible = True
    TreeView1.Nodes(1).Expanded = True
End Sub

Private Sub TextBox1_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
'@AssignedModule uCodeFinder
'@INCLUDE USERFORM uCodeFinder
    If KeyCode = 13 Then
        CommandButton1_Click
    End If
End Sub

Private Sub TreeView1_Click()
'@AssignedModule uCodeFinder
'@INCLUDE CLASS aTreeView
'@INCLUDE USERFORM uCodeFinder
'@INCLUDE DECLARATION AT
    If TreeView1.Nodes.count > 0 Then AT.ActivateProjectElement
End Sub


'uProjectExplorer	UserForm

'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Userform   : uProjectExplorer
'* Created    : 06-10-2022 10:39
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


Option Explicit


Private Sub GetInfo_Click()
'@AssignedModule uProjectExplorer
'@INCLUDE PROCEDURE PlayTheSound
'@INCLUDE CLASS aUserform
'@INCLUDE USERFORM uProjectExplorer
'@INCLUDE USERFORM uAuthor
    With aUserform.Init(Me)
        .Transition .Effect(GetInfo, "Top", GetInfo.Top - 10, 150)
        PlayTheSound ThisWorkbook.Path & "\sound\coin.wav"
        .Transition .Effect(GetInfo, "Top", GetInfo.Top + 10, 150)
    End With
    uAuthor.Show
End Sub



Private Sub TreeView1_Click()
'@AssignedModule uProjectExplorer
'@INCLUDE CLASS aTreeView
'@INCLUDE USERFORM uProjectExplorer
    aTreeView.Init(TreeView1).ActivateProjectElement
End Sub

Private Sub UserForm_Initialize()
'@AssignedModule uProjectExplorer
'@INCLUDE USERFORM uProjectExplorer
    InitializeProjectExplorer
End Sub

Sub InitializeProjectExplorer()
'@AssignedModule uProjectExplorer
'@INCLUDE PROCEDURE ActiveModule
'@INCLUDE PROCEDURE ActiveCodepaneWorkbook
'@INCLUDE CLASS aUserform
'@INCLUDE CLASS aTreeView
'@INCLUDE USERFORM uProjectExplorer
    Application.VBE.MainWindow.Visible = True
    aUserform.Init(Me).ParentIsVBE
    aTreeView.Init(TreeView1).LoadVBProjects
    With TreeView1
        .Sorted = True
        .Appearance = ccFlat
        .LineStyle = tvwRootLines
        .Style = tvwTreelinesPlusMinusPictureText
        .Font.Size = 10
        .indentation = 2
    End With
    aTreeView.Init(TreeView1).ImageListLoadProjectIcons ImageList1
    Dim TargetWorkbook As Workbook
    If Application.VBE.MainWindow.Visible = False Then
        Set TargetWorkbook = ActiveWorkbook
    Else
        Set TargetWorkbook = ActiveCodepaneWorkbook
    End If
    aTreeView.Init(TreeView1).SelectNodes True, TargetWorkbook.Name, Array(ActiveModule.Name)
End Sub


'uReferences	UserForm




'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Userform   : uReferences
'* Created    : 06-10-2022 10:40
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Private Sub cADD_Click()
'@AssignedModule uReferences
'@INCLUDE USERFORM uReferences
    If ListBox1.ListIndex = -1 Then
        MsgBox "Select target workbook first"
        Exit Sub
    End If
    Dim TargetWorkbook As Workbook
    Set TargetWorkbook = Workbooks(ListBox1.List(ListBox1.ListIndex))
    On Error Resume Next
    TargetWorkbook.VBProject.REFERENCES.AddFromGuid LReferences.List(LReferences.ListIndex, 1), 0, 0

    Call PopulateLRefActive

End Sub

Private Sub cClearFilter_Click()
    '    LReferences.Clear
    '    Call PopulateLReferences
'@AssignedModule uReferences
'@INCLUDE USERFORM uReferences
    tFilterReferences.text = ""
End Sub

Private Sub cRemove_Click()
'@AssignedModule uReferences
'@INCLUDE CLASS aWorkbook
'@INCLUDE USERFORM uReferences
    If ListBox1.ListIndex = -1 Then
        MsgBox "Select target workbook first"
        Exit Sub
    End If
    Dim TargetWorkbook As Workbook
    Set TargetWorkbook = Workbooks(ListBox1.List(ListBox1.ListIndex))
    On Error Resume Next
    aWorkbook.Init(TargetWorkbook).RemoveReferenceByGUID LRefActive.List(LReferences.ListIndex, 2)
    PopulateLRefActive
End Sub

Private Sub GetInfo_Click()
'@AssignedModule uReferences
'@INCLUDE PROCEDURE PlayTheSound
'@INCLUDE CLASS aUserform
'@INCLUDE USERFORM uReferences
'@INCLUDE USERFORM uAuthor
    With aUserform.Init(Me)
        .Transition .Effect(GetInfo, "Top", GetInfo.Top - 10, 150)
        PlayTheSound ThisWorkbook.Path & "\sound\coin.wav"
        .Transition .Effect(GetInfo, "Top", GetInfo.Top + 10, 150)
    End With
    uAuthor.Show
End Sub


Private Sub listbox1_change()
'@AssignedModule uReferences
'@INCLUDE USERFORM uReferences
    Call PopulateLRefActive
End Sub

Private Sub tFilterReferences_Change()
    'Reload list so if you type and delete you'll get the items back
'@AssignedModule uReferences
'@INCLUDE USERFORM uReferences
    LReferences.Clear
    Call PopulateLReferences

    Dim i               As Long
    Dim N               As Long
    Dim str             As String
    Dim sTemp           As String

    'Equals is always case sensitive
    'Remove LCase if you want it to be case sensitive
    str = LCase(tFilterReferences.text)

    N = LReferences.ListCount

    'Work backwards when deleting items
    For i = N - 1 To 0 Step -1
        'Equals is always case sensitive
        'Remove LCase if you want it to be case sensitive
        sTemp = LCase(LReferences.List(i, 0))

        If InStr(sTemp, str) = 0 Then
            LReferences.RemoveItem (i)
            'Exit Sub   'Uncomment to Exit if value found
        End If
    Next i
End Sub

Private Sub UserForm_Activate()
  'MakeUserFormChildOfVBEditor Me.Caption
'@AssignedModule uReferences
'@INCLUDE USERFORM uReferences
End Sub

Private Sub UserForm_Initialize()
'@AssignedModule uReferences
'@INCLUDE PROCEDURE WorkbookProjectProtected
'@INCLUDE CLASS aListBox
'@INCLUDE USERFORM uReferences
    aListBox.Init(ListBox1).LoadVBProjects
    Call PopulateLReferences

'    Dim x, y As Variant
'    On Error Resume Next
'    For Each x In Array(Workbooks, AddIns)
'        For Each y In x
'            If Not WorkbookProjectProtected(Workbooks(y.Name)) Then
'                If Err.Number = 0 Then
'                    ListBox1.AddItem y.Name
'                End If
'            End If
'            Err.Clear
'        Next
'    Next
End Sub

Function PopulateLRefActive()
    '@INCLUDE SortListboxOnColumn
    '@INCLUDE DP
'@AssignedModule uReferences
'@INCLUDE CLASS aListBox
'@INCLUDE USERFORM uReferences
'@INCLUDE DECLARATION GUID
    Dim FromWorkbook As Workbook
    Set FromWorkbook = Workbooks(ListBox1.List(ListBox1.ListIndex))
    Dim i As Long
    i = 0
    LRefActive.Clear
    Dim myRef As Reference
    For Each myRef In FromWorkbook.VBProject.REFERENCES
        LRefActive.AddItem
        LRefActive.List(i, 0) = myRef.IsBroken
        LRefActive.List(i, 1) = IIf(myRef.Description <> "", myRef.Description, myRef.Name)
        LRefActive.List(i, 2) = myRef.GUID
        i = i + 1
    Next myRef
    aListBox.Init(LRefActive).SortOnColumn 1
End Function

Sub PopulateLReferences()
'@AssignedModule uReferences
'@INCLUDE USERFORM uReferences
    Dim i As Long
    i = 0
    Dim rng As Range
    Set rng = ThisWorkbook.Sheets("REFERENCES").Range("A1").CurrentRegion
    Set rng = rng.offset(1).Resize(rng.rows.count - 1)
    Dim cell As Range
    For Each cell In rng.Columns(1).Cells
        LReferences.AddItem
        LReferences.List(i, 0) = cell.text
        LReferences.List(i, 1) = cell.offset(0, 1).text
        LReferences.List(i, 2) = cell.offset(0, 2).text
        LReferences.List(i, 3) = cell.offset(0, 3).text
        i = i + 1
    Next cell

End Sub


'uCodeOnTheFly	UserForm


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* UserForm   : uCodeOnTheFly
'* Purpose    :
'* Copyright  :
'*
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 30-06-2023 11:53    Alex
'* Modified   : 18-07-2023 08:14    Alex                modified from frame method to aMultipage class
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Private CodeOnTheFlyTextbox As MSForms.Textbox

Private Sub GetInfo_Click()
'@AssignedModule uCodeOnTheFly
'@INCLUDE PROCEDURE PlayTheSound
'@INCLUDE CLASS aUserform
'@INCLUDE USERFORM uCodeOnTheFly
'@INCLUDE USERFORM uAuthor
    With aUserform.Init(Me)
        .Transition .Effect(GetInfo, "Top", GetInfo.Top - 10, 150)
        PlayTheSound ThisWorkbook.Path & "\sound\coin.wav"
        .Transition .Effect(GetInfo, "Top", GetInfo.Top + 10, 150)
    End With
    uAuthor.Show
End Sub

Private Sub labelRun_Click()
'@AssignedModule uCodeOnTheFly
'@INCLUDE PROCEDURE ShowUserformCodeOnTheFly
'@INCLUDE PROCEDURE EvaluateQuestion
'@INCLUDE PROCEDURE RunCodeOnTheFly
'@INCLUDE PROCEDURE TextOfControl
'@INCLUDE PROCEDURE appRunOnTime
'@INCLUDE PROCEDURE PlayTheSound
'@INCLUDE CLASS aUserform
'@INCLUDE USERFORM uCodeOnTheFly
'@INCLUDE DECLARATION CodeOnTheFlyTextbox
    PlayTheSound ThisWorkbook.Path & "\sound\magic.wav"
    aUserform.Init(Me).SaveOptions
    Dim Code As String
    Code = TextOfControl(CodeOnTheFlyTextbox)
    If Left(Code, 1) <> "?" Then
        'if pointer width=0 then code=all text, else code=selection
        appRunOnTime Now, "ShowUserformCodeOnTheFly"
        RunCodeOnTheFly Code
    Else
        Dim qAsked As Long
        qAsked = Len(Code) - Len(Replace(Code, "?", ""))
        If qAsked > 1 Then
            MsgBox qAsked & " questions detected. I can only answer one."
            Exit Sub
        End If
        appRunOnTime Now, "ShowUserformCodeOnTheFly"
        appRunOnTime Now, _
                    "RunCodeOnTheFly", _
                    Me.Name & "." & CodeOnTheFlyTextbox.Name & ".text=" & _
                    Me.Name & "." & CodeOnTheFlyTextbox.Name & ".text & vbNewLine & "" & ""  " & Mid(Code, 2)
'        EvaluateQuestion Mid(code, 2)
    End If
End Sub


Private Sub MultiPage1_Change()
'@AssignedModule uCodeOnTheFly
'@INCLUDE USERFORM uCodeOnTheFly
'@INCLUDE DECLARATION CodeOnTheFlyTextbox
    Set CodeOnTheFlyTextbox = Me.Controls("Textbox" & MultiPage1.Value + 1)
End Sub


Private Sub UserForm_Activate()
'@AssignedModule uCodeOnTheFly
'@INCLUDE USERFORM uCodeOnTheFly
    With labelRun
        .BorderStyle = fmBorderStyleNone
        .Picture = LoadPicture(ThisWorkbook.Path & "\img\MagicHat.bmp")
        .MouseIcon = LoadPicture(ThisWorkbook.Path & "\img\wand.ico")
        .MousePointer = fmMousePointerCustom
    End With
End Sub

Private Sub UserForm_Initialize()
'@AssignedModule uCodeOnTheFly
'@INCLUDE CLASS aUserform
'@INCLUDE CLASS aMultiPage
'@INCLUDE USERFORM uCodeOnTheFly
'@INCLUDE DECLARATION MyColors
'@INCLUDE DECLARATION CodeOnTheFlyTextbox
    
    Me.Caption = "if pointer width=0 then code=all text, else code=selection"
    Dim i As Long
    For i = 1 To 9
        With Me.Controls("Textbox" & i)
            .Width = 1500
            .Height = 1500
            .Left = 0
            .Top = 0
            .Font.Size = 10
            .Font.Name = "Consolas"
        End With
    Next
    
    aUserform.Init(Me).MinimizeButton
    
    Me.Height = 200
    Me.Width = 430

    
    aUserform.Init(Me).LoadOptions
    Set CodeOnTheFlyTextbox = Me.Controls("Textbox" & MultiPage1.Value + 1)
    aMultiPage.Init(MultiPage1).BuildMenu createSidebarMinimizers:=False
    Dim ctl As MSForms.control
    For Each ctl In Me.Controls("sidebarleft").Controls
        If ctl.Name = "sidebarLabel" & MultiPage1.selectedItem.Name Then
            ctl.BackColor = MyColors.FormSelectedGreen
        Else
            ctl.BackColor = Me.Controls("sidebarleft").BackColor
        End If
    Next
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
'@AssignedModule uCodeOnTheFly
'@INCLUDE CLASS aUserform
'@INCLUDE USERFORM uCodeOnTheFly
    aUserform.Init(Me).SaveOptions
End Sub


'uSkeleton	UserForm

'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Userform   : uSkeleton
'* Created    : 06-10-2022 10:40
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


Option Explicit


Dim skellyBook As Workbook
Dim skellyModule As VBComponent
Dim skellyProcName

Private Sub exportDeclarationsAndCalls_Click()
'@AssignedModule uSkeleton
'@INCLUDE PROCEDURE ArrayToRange2D
'@INCLUDE PROCEDURE CollectionsToArray2D
'@INCLUDE PROCEDURE getDeclarations
'@INCLUDE CLASS aWorkbook
'@INCLUDE CLASS aCollection
'@INCLUDE USERFORM uSkeleton
'@INCLUDE DECLARATION skellyBook
    setUp
    Dim var As Variant
    Dim collections As New Collection
    Set collections = FindCalls(skellyBook)
    If collections(1).count > 0 Then
        var = aCollection.CollectionsToArray2D(collections)
        ArrayToRange2D var, dataToSheet(skellyBook, "exportCalls", "A2")
        With skellyBook.Sheets("exportCalls").Range("A1:B1")
            .Value = Array("Procedure", "Calls")
            .Font.Bold = True
            .Font.Size = 14
        End With
        With skellyBook.Sheets("exportCalls").Cells
            .WrapText = False
            .Columns.AutoFit
            .WrapText = True
            .Columns.AutoFit
            .VerticalAlignment = xlVAlignCenter
        End With
    End If
    Set collections = aWorkbook.Init(skellyBook).getDeclarations(True, True, True, True, True, True)
    If collections(1).count > 0 Then
        var = aCollection.CollectionsToArray2D(collections)
        ArrayToRange2D var, dataToSheet(skellyBook, "exportDeclarations", "A2")
        With skellyBook.Sheets("exportDeclarations").Range("A1:F1")
            .Value = Array("Component Type", "Component Name", "Declaration Scope", "Declaration Type", "Declaration Keyword", "Declaration Code")
            .Font.Bold = True
            .Font.Size = 14
        End With
        With skellyBook.Sheets("exportDeclarations").Cells
            .WrapText = False
            .Columns.AutoFit
            .WrapText = True
            .Columns.AutoFit
            .VerticalAlignment = xlVAlignCenter
        End With
    End If
End Sub

Function AddProcedureCallsToCollectionSkeleton(skellyBook As Workbook, skellyModule As VBComponent, procName As String) As Collection
    '@INCLUDE ProceduresOfWorkbook
    '@INCLUDE ProcedureCode
'@AssignedModule uSkeleton
'@INCLUDE PROCEDURE ProcedureCode
'@INCLUDE PROCEDURE ProceduresOfWorkbook
'@INCLUDE USERFORM uSkeleton
'@INCLUDE DECLARATION skellyBook
'@INCLUDE DECLARATION skellyModule
    Dim coll As Collection
    Set coll = New Collection
    Dim WorkbookProcedure As Variant
    Dim AllProcs As Collection
    Set AllProcs = ProceduresOfWorkbook(skellyBook)
    Dim procText As String
        procText = ProcedureCode(skellyBook, skellyModule, procName)
    For Each WorkbookProcedure In AllProcs
        If CStr(WorkbookProcedure) <> procName Then
            If InStr(1, procText, CStr(WorkbookProcedure)) Then
                coll.Add CStr(WorkbookProcedure)
            End If
        End If
    Next WorkbookProcedure
    Set AddProcedureCallsToCollectionSkeleton = coll
End Function



Private Sub UserForm_Initialize()
'@AssignedModule uSkeleton
'@INCLUDE USERFORM uSkeleton
    LoadProjects
End Sub
Private Sub GetInfo_Click()
'@AssignedModule uSkeleton
'@INCLUDE PROCEDURE PlayTheSound
'@INCLUDE CLASS aUserform
'@INCLUDE USERFORM uSkeleton
'@INCLUDE USERFORM uAuthor
    With aUserform.Init(Me)
        .Transition .Effect(GetInfo, "Top", GetInfo.Top - 10, 150)
        PlayTheSound ThisWorkbook.Path & "\sound\coin.wav"
        .Transition .Effect(GetInfo, "Top", GetInfo.Top + 10, 150)
    End With
    uAuthor.Show
End Sub

Sub LoadProjects()
    '@INCLUDE WorkbookProjectProtected
'@AssignedModule uSkeleton
'@INCLUDE PROCEDURE WorkbookProjectProtected
'@INCLUDE USERFORM uSkeleton
'@INCLUDE DECLARATION skellyBook
    For Each skellyBook In Workbooks
        If Not WorkbookProjectProtected(skellyBook) Then LProjects.AddItem skellyBook.Name
    Next
    On Error Resume Next
    Dim ad
    For Each ad In AddIns
        If Not WorkbookProjectProtected(Workbooks(ad.Name)) Then
            If Err = 0 Then LProjects.AddItem ad.Name
            Err.Clear
        End If
    Next
End Sub

Private Sub LProjects_Click()
'@AssignedModule uSkeleton
'@INCLUDE USERFORM uSkeleton
    loadComponents
End Sub

Sub loadComponents()
    '@INCLUDE ModuleTypeToString
    '@INCLUDE SortListboxOnColumn
    '@INCLUDE setUp
    '@INCLUDE ReleaseMe
    '@INCLUDE ControlsResizeColumns
'@AssignedModule uSkeleton
'@INCLUDE PROCEDURE ModuleTypeToString
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aListBox
'@INCLUDE USERFORM uSkeleton
'@INCLUDE DECLARATION skellyBook
'@INCLUDE DECLARATION skellyModule
    LComponents.Clear: LProcedures.Clear: TPROCS.text = "": LCalls.Clear: TCalls.text = "": LDeclarations.Clear: TDeclarations.text = "":
    setUp
    For Each skellyModule In skellyBook.VBProject.VBComponents
        LComponents.AddItem
        LComponents.List(LComponents.ListCount - 1, 0) = aModule.Init(skellyModule).TypeToString
        LComponents.List(LComponents.ListCount - 1, 1) = skellyModule.Name
    Next
    ReleaseMe
    aListBox.Init(LComponents).SortOnColumn 0
    ControlsResizeColumns LComponents
End Sub

Private Sub LComponents_Click()
'@AssignedModule uSkeleton
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aListBox
'@INCLUDE USERFORM uSkeleton
'@INCLUDE DECLARATION skellyModule
    LProcedures.Clear: TPROCS.text = "": LCalls.Clear: TCalls.text = "": LDeclarations.Clear: TDeclarations.text = "":
    setUp
    For Each skellyProcName In ProcList(skellyModule)
        LProcedures.AddItem skellyProcName
    Next
    TComps.text = aModule.Init(skellyModule).Code
    aListBox.Init(LProcedures).SortOnColumn 0
End Sub

Private Sub LProcedures_Click()
'@AssignedModule uSkeleton
'@INCLUDE PROCEDURE tmp
'@INCLUDE PROCEDURE ModuleOfProcedure
'@INCLUDE PROCEDURE ProcedureCode
'@INCLUDE PROCEDURE getDeclarations
'@INCLUDE CLASS aWorkbook
'@INCLUDE CLASS aListBox
'@INCLUDE USERFORM uSkeleton
'@INCLUDE DECLARATION skellyBook
'@INCLUDE DECLARATION skellyModule
    LCalls.Clear: TCalls.text = "": LDeclarations.Clear: TDeclarations.text = "":
    setUp
    TPROCS.text = ProcedureCode(skellyBook, skellyModule, CStr(skellyProcName))
    Do While InStr(1, TPROCS.text, "  ") > 0
        TPROCS.text = Replace(TPROCS.text, "  ", " ")
    Loop
    Dim element
    For Each element In AddProcedureCallsToCollectionSkeleton(skellyBook, ModuleOfProcedure(skellyBook, CStr(skellyProcName)), CStr(skellyProcName))
        LCalls.AddItem element
    Next
    aListBox.Init(LCalls).SortOnColumn 1
    'test
    Dim coll As Collection:     Set coll = aWorkbook.Init(skellyBook).getDeclarations(True, True, True, True, True, True)
    Dim keyCol As Collection:   Set keyCol = coll.item(5)
    Dim decCol As Collection:   Set decCol = coll.item(6)
    Dim i As Long
    Dim tmp As String
    For i = 1 To keyCol.count
        'if the DECLARATION keyword exists inside the procedure
        If InStr(1, TPROCS.text, keyCol.item(i)) > 0 Then
            'and if it is not a VARIABLE inside the procedure
            If InStr(1, TPROCS.text, keyCol.item(i) & " As") = 0 Then
                'avoid duplicates
                
                If aListBox.Init(LDeclarations).Contains(keyCol.item(i)) = False Then
                    LDeclarations.AddItem keyCol.item(i)
                End If
            End If
        End If
    Next i
    aListBox.Init(LDeclarations).SortOnColumn 0
    aListBox.Init(LCalls).SortOnColumn 0
    ReleaseMe
End Sub

Private Sub LCalls_Click()
'@AssignedModule uSkeleton
'@INCLUDE PROCEDURE ModuleOfProcedure
'@INCLUDE PROCEDURE ProcedureCode
'@INCLUDE USERFORM uSkeleton
'@INCLUDE DECLARATION skellyBook
'@INCLUDE DECLARATION skellyModule
    setUp
    skellyProcName = LCalls.List(LCalls.ListIndex)
    Set skellyModule = ModuleOfProcedure(skellyBook, CStr(skellyProcName))
    TCalls.text = ProcedureCode(skellyBook, skellyModule, CStr(skellyProcName))
    ReleaseMe
End Sub

Private Sub LDeclarations_Click()
'@AssignedModule uSkeleton
'@INCLUDE PROCEDURE getDeclarations
'@INCLUDE CLASS aWorkbook
'@INCLUDE USERFORM uSkeleton
'@INCLUDE DECLARATION skellyBook
    setUp
    Dim coll As Collection:     Set coll = aWorkbook.Init(skellyBook).getDeclarations(True, True, True, True, True, True)
    Dim keyCol As Collection:   Set keyCol = coll.item(5)
    Dim decCol As Collection:   Set decCol = coll.item(6)
    Dim i As Long
    For i = 1 To keyCol.count
        If keyCol.item(i) = LDeclarations.List(LDeclarations.ListIndex) Then
            TDeclarations.text = decCol.item(i)
        End If
    Next i
End Sub

Sub setUp()
'@AssignedModule uSkeleton
'@INCLUDE USERFORM uSkeleton
'@INCLUDE DECLARATION skellyBook
'@INCLUDE DECLARATION skellyModule
    On Error Resume Next
    Set skellyBook = Workbooks(LProjects.List(LProjects.ListIndex))
    Set skellyModule = skellyBook.VBProject.VBComponents(LComponents.List(LComponents.ListIndex, 1))
    skellyProcName = LProcedures.List(LProcedures.ListIndex)
End Sub

Sub ReleaseMe()
'@AssignedModule uSkeleton
'@INCLUDE USERFORM uSkeleton
'@INCLUDE DECLARATION skellyBook
'@INCLUDE DECLARATION skellyModule
    Set skellyModule = Nothing
    Set skellyBook = Nothing
End Sub

Function FindCalls(skellyBook As Workbook) As Collection
    '@INCLUDE ProceduresOfWorkbook
    '@INCLUDE ModuleOfProcedure
    '@INCLUDE CollectionToArray
    '@INCLUDE AddProcedureCallsToCollectionSkeleton
'@AssignedModule uSkeleton
'@INCLUDE PROCEDURE tmp
'@INCLUDE PROCEDURE ModuleOfProcedure
'@INCLUDE PROCEDURE ProceduresOfWorkbook
'@INCLUDE CLASS aCollection
'@INCLUDE USERFORM uSkeleton
'@INCLUDE DECLARATION skellyBook
    Dim Procedure As Variant
    Dim output As New Collection
    Dim Procedures As New Collection
    Dim calls As New Collection
    Dim element As Variant
    Dim tmp As New Collection
    For Each Procedure In ProceduresOfWorkbook(skellyBook)
        Set tmp = AddProcedureCallsToCollectionSkeleton(skellyBook, ModuleOfProcedure(skellyBook, CStr(Procedure)), CStr(Procedure))
        If tmp.count > 0 Then
            Procedures.Add Procedure
            calls.Add aCollection.Init(tmp).ToString(vbNewLine)
        End If
    Next
    output.Add Procedures
    output.Add calls
    Set FindCalls = output
End Function

Function dataToSheet(Optional skellyBook As Workbook, Optional wsName As String, Optional rngAddress As String, Optional confirmClear As Boolean) As Range
    '@INCLUDE answer
    '@INCLUDE sheetExists
'@AssignedModule uSkeleton
'@INCLUDE USERFORM uSkeleton
'@INCLUDE DECLARATION skellyBook
    If skellyBook Is Nothing Then Set skellyBook = Workbooks.Add
    Dim ws As Worksheet
    If sheetExists(wsName, skellyBook) Then
        If confirmClear = True Then
            Dim answer As Integer
            answer = MsgBox("Sheet " & wsName & " already exists. Cells will be cleared. Proceed?", vbYesNo)
            If answer = vbNo Then Exit Function
        End If
        Set ws = skellyBook.Sheets(wsName)
        ws.Cells.Clear
    Else
        If wsName = "" Then
            Set ws = skellyBook.Sheets(1)
        Else
            Set ws = skellyBook.Sheets.Add
            ws.Name = wsName
        End If
    End If
    If rngAddress <> "" Then
        Set dataToSheet = ws.Range(rngAddress)
    Else
        Set dataToSheet = ws.Range("A1")
    End If
End Function

Function ProcList(skellyModule As VBComponent) As Collection
'@AssignedModule uSkeleton
'@INCLUDE USERFORM uSkeleton
'@INCLUDE DECLARATION skellyModule
    Dim codeMod As CodeModule
    Set codeMod = skellyModule.CodeModule
    Dim coll As Collection
    Set coll = New Collection
    Dim lineNum As Long
    Dim NumLines As Long
    Dim procName As String
    Dim ProcKind As VBIDE.vbext_ProcKind
    lineNum = codeMod.CountOfDeclarationLines + 1
    Do Until lineNum >= codeMod.CountOfLines
        procName = codeMod.ProcOfLine(lineNum, ProcKind)
        coll.Add procName
        lineNum = codeMod.procStartLine(procName, ProcKind) + codeMod.ProcCountLines(procName, ProcKind) + 1
    Loop
    Set ProcList = coll
End Function

Function ControlsResizeColumns(LBox As MSForms.control, Optional ResizeListbox As Boolean)
    '@INCLUDE sheetExists
'@AssignedModule uSkeleton
'@INCLUDE USERFORM uSkeleton
    If LBox.ListCount = 0 Then Exit Function
    Application.ScreenUpdating = False
    Dim ws As Worksheet
    If sheetExists("ListboxColumnWidth", ThisWorkbook) = False Then
        Set ws = ThisWorkbook.Worksheets.Add
        ws.Name = "ListboxColumnwidth"
    Else
        Set ws = ThisWorkbook.Worksheets("ListboxColumnwidth")
        ws.Cells.Clear
    End If
    ws.Cells.Font.Size = 12
    ws.Cells.Font.Name = "Calibri"
    '---Listbox to range-----
    Dim rng As Range
    Set rng = ThisWorkbook.Sheets("ListboxColumnwidth").Range("A1")
    Set rng = rng.Resize(UBound(LBox.List) + 1, LBox.columnCount)
    rng = LBox.List
    '---Get ColumnWidths------
    rng.Columns.AutoFit
    Dim sWidth As String
    Dim vR() As Variant
    Dim N As Integer
    Dim cell As Range
    For Each cell In rng.Resize(1)
        N = N + 1
        ReDim Preserve vR(1 To N)
        vR(N) = cell.EntireColumn.Width
    Next cell
    sWidth = Join(vR, ";")
    'Debug.Print sWidth
    '---assign ColumnWidths----
    With LBox
        .columnWidths = sWidth
        '.RowSource = "A1:A3"
        .BorderStyle = fmBorderStyleSingle
    End With
    'Remove worksheet
    Application.DisplayAlerts = False
    ws.Delete
    Application.DisplayAlerts = True
    Application.ScreenUpdating = True
    '----Resize Listbox--------
    If ResizeListbox = False Then Exit Function
    Dim w As Long
    Dim i As Long
    For i = LBound(vR) To UBound(vR)
        w = w + vR(i)
    Next
    DoEvents
    LBox.Width = w + 10
End Function

Function sheetExists(sheetToFind As String, Optional InWorkbook As Workbook) As Boolean
'@AssignedModule uSkeleton
'@INCLUDE USERFORM uSkeleton
    If InWorkbook Is Nothing Then Set InWorkbook = ThisWorkbook
    On Error Resume Next
    sheetExists = Not InWorkbook.Sheets(sheetToFind) Is Nothing
End Function


'uSnippets	UserForm


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* UserForm   : uSnippets
'* Purpose    :
'* Copyright  :
'*
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 17-08-2023 13:28    Alex
'* Modified   : 17-08-2023 13:28    Alex                added roundabout way to inject directly
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Private SnippetsFolder As String


Private Sub SNIP_Click()
    If Len(LSnippetsPreview.text) = 0 Then Exit Sub
    Dim s As String
    If LSnippetsPreview.SelLength = 0 Then
        s = LSnippetsPreview.text
    Else
        s = LSnippetsPreview.SelText
    End If
    
     IniWrite ThisWorkbook.Path & "config\UserformSettings.ini", Me.Name, "SelStart", LSnippetsPreview.SelStart
     IniWrite ThisWorkbook.Path & "config\UserformSettings.ini", Me.Name, "SelLength", LSnippetsPreview.SelLength
     IniWrite ThisWorkbook.Path & "config\UserformSettings.ini", Me.Name, "Filter", Me.tFilterSnippets.Value
     IniWrite ThisWorkbook.Path & "config\UserformSettings.ini", Me.Name, "File", LSnippets.List(LSnippets.ListIndex)
     
     If ShowInVBE Then
        Application.OnTime Now, "uShow_SnippetsVBE"
     Else
        Application.OnTime Now, "uShow_SnippetsWorkbook"
     End If
     
    aCodeModule.Active.Inject s
'    cResize_Click
End Sub

Private Sub UserForm_Initialize()
'@AssignedModule uSnippets
'@INCLUDE PROCEDURE FoldersCreate
'@INCLUDE CLASS aListBox
'@INCLUDE CLASS aUserform
'@INCLUDE USERFORM uSnippets
'@INCLUDE DECLARATION ShowInVBE
'@INCLUDE DECLARATION SnippetsFolder
    If ShowInVBE = True Then
        Application.VBE.MainWindow.Visible = True
        aUserform.Init(Me).ParentIsVBE
    End If
    SnippetsFolder = LOCAL_LIBRARY_PROCEDURES

    FoldersCreate SnippetsFolder

    If Right(SnippetsFolder, 1) <> "\" Then SnippetsFolder = SnippetsFolder & "\"
    GetFilesUSnippets

    tFilterSnippets.text = IniReadKey(ThisWorkbook.Path & "config\UserformSettings.ini", Me.Name, "Filter")
    Dim fileName As String
    fileName = IniReadKey(ThisWorkbook.Path & "config\UserformSettings.ini", Me.Name, "File")
    Dim i As Long
    For i = LBound(LSnippets.List) To UBound(LSnippets.List)
        If LSnippets.List(i) = fileName Then
            LSnippets.ListIndex = i
            Exit For
        End If
    Next
 
    LSnippetsPreview.SelStart = IniReadKey(ThisWorkbook.Path & "config\UserformSettings.ini", Me.Name, "SelStart", 0)
    LSnippetsPreview.SelLength = IniReadKey(ThisWorkbook.Path & "config\UserformSettings.ini", Me.Name, "SelLength", 0)
    
    Dim myForm As New aUserform
    myForm.Init(Me).Resizable
End Sub

Sub SwitchParent()
'@AssignedModule uSnippets
'@INCLUDE USERFORM uSnippets
    Stop
    
End Sub

Sub GetFilesUSnippets()
'@AssignedModule uSnippets
'@INCLUDE PROCEDURE LoopThroughFiles
'@INCLUDE USERFORM uSnippets
'@INCLUDE DECLARATION SnippetsFolder
    LSnippets.Clear
    Dim Files As Collection: Set Files = LoopThroughFiles(SnippetsFolder, "*.txt")
    Dim File
    For Each File In Files
        LSnippets.AddItem File
    Next
End Sub

Private Sub CommandButton1_Click()
'@AssignedModule uSnippets
'@INCLUDE USERFORM uSnippets
    tFilterSnippets.text = ""
    LSnippets.ListIndex = -1
End Sub

Private Sub cResize_Click()
'@AssignedModule uSnippets
'@INCLUDE USERFORM uSnippets
    If Me.Height < 429 Then
        Me.Height = 429
    Else
        Me.Height = 60
        Me.Width = 100
    End If

    Me.Show
End Sub

Private Sub cSnippetFolder_Click()
'@AssignedModule uSnippets
'@INCLUDE PROCEDURE FollowLink
'@INCLUDE USERFORM uSnippets
'@INCLUDE DECLARATION SnippetsFolder
    FollowLink SnippetsFolder
End Sub

Private Sub GetInfo_Click()
'@AssignedModule uSnippets
'@INCLUDE PROCEDURE PlayTheSound
'@INCLUDE CLASS aUserform
'@INCLUDE USERFORM uSnippets
'@INCLUDE USERFORM uAuthor
    With aUserform.Init(Me)
        .Transition .Effect(GetInfo, "Top", GetInfo.Top - 10, 150)
        PlayTheSound ThisWorkbook.Path & "\sound\coin.wav"
        .Transition .Effect(GetInfo, "Top", GetInfo.Top + 10, 150)
    End With
    uAuthor.Show
End Sub


Private Sub LSnippets_Click()
'@AssignedModule uSnippets
'@INCLUDE PROCEDURE TxtRead
'@INCLUDE USERFORM uSnippets
'@INCLUDE DECLARATION SnippetsFolder
    Dim sPath As String
    sPath = SnippetsFolder & LSnippets.List(LSnippets.ListIndex)
    LSnippetsPreview.text = TxtRead(sPath)
End Sub

Private Sub cCopySnippet_Click()
'@AssignedModule uSnippets
'@INCLUDE PROCEDURE CLIP
'@INCLUDE USERFORM uSnippets
    If Len(LSnippetsPreview.text) = 0 Then Exit Sub
    Dim s As String
    If LSnippetsPreview.SelLength = 0 Then
        s = LSnippetsPreview.text
    Else
        s = LSnippetsPreview.SelText
    End If
    CLIP s
    cResize_Click
    MsgBox "Snipet copied"
End Sub

Private Sub cOverwriteSnippet_Click()
'@AssignedModule uSnippets
'@INCLUDE PROCEDURE TxtOverwrite
'@INCLUDE PROCEDURE InputboxString
'@INCLUDE USERFORM uSnippets
'@INCLUDE DECLARATION SnippetsFolder
    Dim sPath As String
    Dim isNew As Boolean
    Dim wasResized As Boolean
    If LSnippets.ListIndex = -1 Then
        Dim ans As String
        cResize_Click
        ans = InputboxString(, "Select name for new file")
        If Len(ans) = 0 Then GoTo ExitHandler
        sPath = SnippetsFolder & ans & ".txt"
        isNew = True
        wasResized = True
    Else
        sPath = SnippetsFolder & LSnippets.List(LSnippets.ListIndex)
    End If
    TxtOverwrite sPath, LSnippetsPreview.text
    If isNew = True Then
        LSnippets.AddItem ans & ".txt"
        LSnippets.ListIndex = LSnippets.ListCount - 1
    End If
ExitHandler:
    If wasResized = True Then cResize_Click
End Sub

Private Sub cSnippetDelete_Click()
'@AssignedModule uSnippets
'@INCLUDE USERFORM uSnippets
'@INCLUDE DECLARATION SnippetsFolder
    cResize_Click
    Dim Proceed As Long
    Proceed = MsgBox("Delete " & LSnippets.List(LSnippets.ListIndex) & "?", vbYesNo)
    If Proceed = vbNo Then Exit Sub
    Dim sPath As String
    sPath = SnippetsFolder & LSnippets.List(LSnippets.ListIndex)
    Dim FSO As Scripting.FileSystemObject
    Set FSO = New Scripting.FileSystemObject
    FSO.DeleteFile sPath
    LSnippets.RemoveItem LSnippets.ListIndex
    LSnippetsPreview.text = ""
    LSnippets.ListIndex = -1
    cResize_Click
End Sub

Private Sub cSnippetStartNew_Click()
'@AssignedModule uSnippets
'@INCLUDE PROCEDURE FileExists
'@INCLUDE PROCEDURE TxtOverwrite
'@INCLUDE USERFORM uSnippets
'@INCLUDE DECLARATION SnippetsFolder
    Dim NewName As String
    cResize_Click
    NewName = InputBox("New Snippet Name")
    If NewName = "" Then GoTo ExitHandler
    Dim sPath As String
    sPath = SnippetsFolder & NewName & ".txt"
    If FileExists(sPath) Then Exit Sub
    LSnippets.ListIndex = -1
    LSnippetsPreview.text = ""
    TxtOverwrite sPath, ""
    LSnippets.AddItem NewName & ".txt"
    LSnippets.ListIndex = LSnippets.ListCount - 1
    LSnippetsPreview.SetFocus
ExitHandler:
    cResize_Click
End Sub

Private Sub LSnippetsPreview_Enter()
'@AssignedModule uSnippets
'@INCLUDE USERFORM uSnippets
    LSnippetsPreview.SelStart = 0
End Sub

Private Sub tFilterSnippets_Change()
'@AssignedModule uSnippets
'@INCLUDE CLASS aListBox
'@INCLUDE USERFORM uSnippets
    GetFilesUSnippets
    aListBox.Init(LSnippets).FilterByColumn tFilterSnippets.text
End Sub


'EventListenerEmitter	Class

'------------------------
'userform declararations
'------------------------
'   Private WithEvents Emitter As EventListeneRemitter

'------------------------
'in userform_initialise
'------------------------
'   Set Emitter = New EventListeneRemitter
'   Emitter.AddEventListenerAll Me

Rem Author Robert Todar

Option Explicit
Option Compare Text

' Array of all the different event listeners for every userform control and the form itself
Private EventList() As New EventListenerItem

' All the current possible events that can be emitted.
' Note, EmittedEvent is sent for all events!
Public Event EmittedEvent(ByRef control As Object, ByVal EventType As EmittedEvent, ByRef EventParameters As Collection)
Public Event Click(ByRef control As Object)
Public Event DblClick(ByRef control As Object, ByRef Cancel As MSForms.ReturnBoolean)
Public Event KeyUp(ByRef control As Object, ByRef KeyCode As MSForms.ReturnInteger, ByRef Shift As Integer)
Public Event KeyDown(ByRef control As Object, ByRef KeyCode As MSForms.ReturnInteger, ByRef Shift As Integer)
Public Event MouseOver(ByRef control As Object)
Public Event MouseOut(ByRef control As Object)
Public Event MouseMove(ByRef control As Object, ByRef Shift As Integer, ByRef x As Single, ByRef y As Single)
Public Event Focus(ByRef control As Object)
Public Event Blur(ByRef control As Object)
Public Event Change(ByRef control As Object)

' Events to Labels
Public Event LabelMouseOver(ByRef Label As MSForms.Label)
Public Event LabelMouseOut(ByRef Label As MSForms.Label)
Public Event LabelClick(ByRef Label As MSForms.Label)
Public Event LabelDoubleClick(ByRef Label As MSForms.Label, ByRef Cancel As MSForms.ReturnBoolean)
Public Event LabelMouseMove(ByRef Label As MSForms.Label, ByRef Shift As Integer, ByRef x As Single, ByRef y As Single)

' Events to Textboxes
Public Event TextboxFocus(ByRef Textbox As MSForms.Textbox)
Public Event TextboxBlur(ByRef Textbox As MSForms.Textbox)
Public Event TextboxMouseOver(ByRef Textbox As MSForms.Textbox)
Public Event TextboxMouseOut(ByRef Textbox As MSForms.Textbox)
Public Event TextboxClick(ByRef Textbox As MSForms.Textbox)
Public Event TextboxDoubleClick(ByRef Textbox As MSForms.Textbox, ByRef Cancel As MSForms.ReturnBoolean)
Public Event TextboxMouseMove(ByRef Textbox As MSForms.Textbox, ByRef Shift As Integer, ByRef x As Single, ByRef y As Single)

' Events to CommandButtons
Public Event CommandButtonMouseOver(ByRef CommandButton As MSForms.CommandButton)
Public Event CommandButtonMouseOut(ByRef CommandButton As MSForms.CommandButton)
Public Event CommandButtonClick(ByRef CommandButton As MSForms.CommandButton)
Public Event CommandButtonDoubleClick(ByRef CommandButton As MSForms.CommandButton, ByRef Cancel As MSForms.ReturnBoolean)
Public Event CommandButtonMouseMove(ByRef CommandButton As MSForms.CommandButton, ByRef Shift As Integer, ByRef x As Single, ByRef y As Single)

' Events to Images
Public Event ImageMouseDown(ByRef Image As MSForms.Image, ByRef Button As Integer, ByRef Shift As Integer, ByRef x As Single, ByRef y As Single)

' Types of events that can occur
Public Enum EmittedEvent
    Change
    Click
    DoubleClick
    MouseMove
    MouseOut
    MouseOver
    MouseDown
    MouseUp
    KeyUp
    KeyDown
    Focus
    Blur
End Enum

' Called by EventListenerItem class - main entryway of emitting all events
Public Sub EmitEvent(ByRef control As Object, ByVal EventType As EmittedEvent, Optional ByRef EventParameters As Collection)
    ' Event raised for all events. This is a way for the user to collect from a single location.
'@AssignedModule EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
    RaiseEvent EmittedEvent(control, EventType, EventParameters)

    ' Specific events
    Select Case EventType

    Case Click
        RaiseEvent Click(control)

    Case DoubleClick
        RaiseEvent DblClick(control, EventParameters("Cancel"))

    Case KeyUp
        RaiseEvent KeyUp(control, EventParameters("KeyCode"), EventParameters("Shift"))

    Case KeyDown
        RaiseEvent KeyDown(control, EventParameters("KeyCode"), EventParameters("Shift"))

    Case MouseOver
        RaiseEvent MouseOver(control)

    Case MouseOut
        RaiseEvent MouseOut(control)

    Case Focus
        RaiseEvent Focus(control)

    Case Blur
        RaiseEvent Blur(control)

    Case MouseMove
        RaiseEvent MouseMove(control, EventParameters("Shift"), EventParameters("X"), EventParameters("Y"))

    End Select

    ' Call the specific control type events
    Select Case TypeName(control)
    Case "Label"
        EmitLabelEvent control, EventType, EventParameters

    Case "Textbox"
        EmitTextboxEvent control, EventType, EventParameters

    Case "CommandButton"
        EmitCommandButtonEvent control, EventType, EventParameters
    Case "Image"
        EmitCommandButtonEvent control, EventType, EventParameters
        
    End Select
End Sub

' Events for Labels
Private Sub EmitLabelEvent(ByRef Label As MSForms.Label, ByVal EventType As String, ByRef EventParameters As Collection)
'@AssignedModule EventListenerEmitter
'@INCLUDE CLASS EventListenerEmitter
    Select Case EventType
    Case EmittedEvent.Click
        RaiseEvent LabelClick(Label)

    Case EmittedEvent.DoubleClick
        RaiseEvent LabelDoubleClick(Label, EventParameters("Cancel"))

    Case EmittedEvent.MouseOver
        RaiseEvent LabelMouseOver(Label)

    Case EmittedEvent.MouseOut
        RaiseEvent LabelMouseOut(Label)

    Case EmittedEvent.MouseMove
        RaiseEvent MouseMove(Label, EventParameters("Shift"), EventParameters("X"), EventParameters("Y"))
    End Select
End Sub

' Events for Textboxes
Private Sub EmitTextboxEvent(ByRef Textbox As MSForms.Textbox, ByVal EventType As String, ByRef EventParameters As Collection)
'@AssignedModule EventListenerEmitter
'@INCLUDE CLASS EventListenerEmitter
    Select Case EventType
    Case EmittedEvent.Blur
        RaiseEvent TextboxBlur(Textbox)

    Case EmittedEvent.Focus
        RaiseEvent TextboxFocus(Textbox)

    Case EmittedEvent.Click
        RaiseEvent TextboxClick(Textbox)

    Case EmittedEvent.DoubleClick
        RaiseEvent TextboxDoubleClick(Textbox, EventParameters("Cancel"))

    Case EmittedEvent.MouseOver
        RaiseEvent TextboxMouseOver(Textbox)

    Case EmittedEvent.MouseOut
        RaiseEvent TextboxMouseOut(Textbox)

    Case EmittedEvent.MouseMove
        RaiseEvent MouseMove(Textbox, EventParameters("Shift"), EventParameters("X"), EventParameters("Y"))
    End Select
End Sub

' Events for CommandButton
Private Sub EmitCommandButtonEvent(ByRef CommandButton As MSForms.CommandButton, ByVal EventType As String, ByRef EventParameters As Collection)
'@AssignedModule EventListenerEmitter
'@INCLUDE CLASS EventListenerEmitter
    Select Case EventType
    Case EmittedEvent.Click
        RaiseEvent CommandButtonClick(CommandButton)

    Case EmittedEvent.DoubleClick
        RaiseEvent CommandButtonDoubleClick(CommandButton, EventParameters("Cancel"))

    Case EmittedEvent.MouseOver
        RaiseEvent CommandButtonMouseOver(CommandButton)

    Case EmittedEvent.MouseOut
        RaiseEvent CommandButtonMouseOut(CommandButton)

    Case EmittedEvent.MouseMove
        RaiseEvent MouseMove(CommandButton, EventParameters("Shift"), EventParameters("X"), EventParameters("Y"))
    End Select
End Sub

' MUST CALL THIS IF YOU WANT TO programmatically SET CONTROL! OTHERWISE, EVENT'S WILL BE OFF!
Public Sub SetFocusToControl(ByRef control As Object)
    'If the user was to set focus through VBA then this code will fall apart considering
    'it is unaware of that event occurring.
'@AssignedModule EventListenerEmitter
'@INCLUDE CLASS EventListenerEmitter
    If Not control Is Nothing Then
        control.SetFocus
        EmitEvent control, Focus
    End If
End Sub

' ADD EVENT Listeners ON SPECIFIC CONTROLS - ALSO CALLED BY AddEventListenerAll
Public Sub AddEventListener(ByRef control As Object)
    ' Events are stored in a private EventListenerItem array
'@AssignedModule EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
    If IsArrayEmpty(EventList) Then
        ReDim EventList(0 To 0)
    Else
        ReDim Preserve EventList(0 To UBound(EventList) + 1)
    End If

    'CALL AddEventListener IN EventListenerItem. THIS IS KEPT IN
    EventList(UBound(EventList)).AddEventListener control, Me
End Sub

'ADD EVENT Listener TO ALL CONTROLS INCLUDING THE FORM
Public Sub AddEventListenerAll(ByRef Form As Object)
'@AssignedModule EventListenerEmitter
'@INCLUDE CLASS EventListenerEmitter
    AddEventListener Form

    Dim control As MSForms.control
    For Each control In Form.Controls
        AddEventListener control
    Next control
End Sub

Private Function IsArrayEmpty(arr As Variant) As Boolean
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' CPEARSON: http://www.cpearson.com/excel/VBAArrays.htm
    ' This function tests whether the array is empty (unallocated). Returns TRUE or FALSE.
    '
    ' The VBA IsArray function indicates whether a variable is an array, but it does not
    ' distinguish between allocated and unallocated arrays. It will return TRUE for both
    ' allocated and unallocated arrays. This function tests whether the array has actually
    ' been allocated.
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'@AssignedModule EventListenerEmitter
'@INCLUDE CLASS EventListenerEmitter

    Err.Clear
    On Error Resume Next
    If IsArray(arr) = False Then
        ' we weren't passed an array, return True
        IsArrayEmpty = True
    End If

    ' Attempt to get the UBound of the array. If the array is
    ' unallocated, an error will occur.
    Dim UB As Long
    UB = UBound(arr, 1)
    If (Err.Number <> 0) Then
        IsArrayEmpty = True
    Else
        ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        ' On rare occasion, under circumstances I cannot reliably replicate, Err.Number
        ' will be 0 for an unallocated, empty array. On these occasions, LBound is 0 and
        ' UBound is -1. To accommodate the weird behavior, test to see if LB > UB.
        ' If so, the array is not allocated.
        ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        Err.Clear
        Dim LB As Long
        LB = LBound(arr)
        If LB > UB Then
            IsArrayEmpty = True
        Else
            IsArrayEmpty = False
        End If
    End If
End Function


'M_RunCodeOnTheFly	Module

Option Explicit
Function NamelessCodeOnTheFly()
'@AssignedModule M_RunCodeOnTheFly
'@INCLUDE USERFORM uCodeOnTheFly
uCodeOnTheFly.TextBox1.text = uCodeOnTheFly.TextBox1.text & vbNewLine & ThisWorkbook.Path
End Function

Public Sub ShowUserformCodeOnTheFly()
'@AssignedModule M_RunCodeOnTheFly
'@INCLUDE USERFORM uCodeOnTheFly
    uCodeOnTheFly.Show
End Sub
Function EvaluateQuestion(str As String)
'use in immediate window:
'
'   ?EvaluateQuestion("now")
'@AssignedModule M_RunCodeOnTheFly
'@INCLUDE PROCEDURE ClearClipboard
'@INCLUDE PROCEDURE NamelessCodeOnTheFly
'@INCLUDE PROCEDURE RunCodeOnTheFly
'@INCLUDE USERFORM uCodeOnTheFly

    Dim var
    Dim Code As String
'    code = "on error resume next" & vbnewlilne
    Code = Code & "ClearClipboard" & vbNewLine
    Code = Code & "dim var" & vbNewLine
    Code = Code & "var=" & str & vbNewLine
    Code = Code & "clip cstr(var)" & vbNewLine
    Code = Code & "namelesscodeonthefly=cstr(var)" & vbNewLine

'    code = code & "uCodeOnTheFly.Controls(ThisWorkbook.Sheets(""uCodeOnTheFly_Settings"").Range(""D1"").Value).text= _" & vbNewLine
'    code = code & "ThisWorkbook.Sheets(""uCodeOnTheFly_Settings"").columns(1).find( _" & vbNewLine
'    code = code & "ThisWorkbook.Sheets(""uCodeOnTheFly_Settings"").Range(""D1"").Value).offset(0,1).value & vbNewLine & cstr(var)"
'
    RunCodeOnTheFly Code

    EvaluateQuestion = NamelessCodeOnTheFly
End Function

Function EvaluateString(strTextString As String)
'@AssignedModule M_RunCodeOnTheFly
    Application.Volatile
    EvaluateString = Application.Caller.Parent.Evaluate(strTextString)
    Debug.Print strTextString & vbTab & ":" & vbTab & EvaluateString
End Function

Sub RunCodeFromRange()
'@INCLUDE RunCodeOnTheFly
'@AssignedModule M_RunCodeOnTheFly
'@INCLUDE PROCEDURE RunCodeOnTheFly
    If TypeName(Selection) <> "Range" Then Exit Sub
    If Selection.Columns.count <> 1 Then Exit Sub
    Dim Code As String
    If Selection.Cells.count = 1 Then
        Code = Selection.Value
    Else
        Dim var
        var = WorksheetFunction.Transpose(Selection.Value)
        Code = Join(var, vbNewLine)
    End If
    RunCodeOnTheFly Code
End Sub

Sub RunMacroFromSelection()
'@AssignedModule M_RunCodeOnTheFly
'@INCLUDE PROCEDURE ActiveModule
'@INCLUDE PROCEDURE ActiveCodepaneWorkbook
'@INCLUDE PROCEDURE ProcedureExists
'@INCLUDE PROCEDURE RunCodeOnTheFly
'@INCLUDE CLASS aCodeModule
    Dim Code As String
    Code = aCodeModule.Init(ActiveModule).Selection
    If ProcedureExists(ActiveCodepaneWorkbook, Code) Then
        Application.Run Code
    Else
        RunCodeOnTheFly Code
    End If
End Sub

Sub RunMacroFromClipboard()
'@AssignedModule M_RunCodeOnTheFly
'@INCLUDE PROCEDURE ActiveCodepaneWorkbook
'@INCLUDE PROCEDURE ProcedureExists
'@INCLUDE PROCEDURE CLIP
'@INCLUDE PROCEDURE RunCodeOnTheFly
    Dim Code As String
    Code = CLIP
    If ProcedureExists(ActiveCodepaneWorkbook, Code) Then
        Application.Run Code
    Else
        RunCodeOnTheFly Code
    End If
End Sub

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''AUTHOR     Anastasiou Alex
''EMAIL      AnastasiouAlex@gmail.com
''GITHUB     https://github.com/AlexOfRhodes
''YOUTUBE    https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
''VK         https://vk.com/video/playlist/735281600_1
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'* Modified   : Date and Time       Author              Description
'* Updated    : 18-11-2022 18:22    Alex                (RunCodeOnTheFly) Initial Release

Public Sub RunCodeOnTheFly(CodeOnTheFly As String)
    Rem Do not move this procedure !!!
    Rem All lines after this procedure will be deleted and replaced.
'@INCLUDE ProcedureReplace
'@INCLUDE ProcedureLinesLast
'@INCLUDE ModuleOfProcedure
'@INCLUDE appRunOnTime
'@INCLUDE NamelessCodeOnTheFly
'@AssignedModule M_RunCodeOnTheFly
'@INCLUDE PROCEDURE ModuleOfProcedure
'@INCLUDE PROCEDURE ProcedureLinesLast
'@INCLUDE PROCEDURE ProcedureReplace
'@INCLUDE PROCEDURE NamelessCodeOnTheFly
'@INCLUDE PROCEDURE appRunOnTime
'@INCLUDE CLASS aProcedure

    'The following are considered true
    '1. If the CodeOnTheFly you pass as an argument contains multiple macros,
    '   then the first macro is the main one, which calls the subsequent ones
    '2. No declarations (@TODO use a helper module to overcome this) or missing references are needed
    '3. Make sure your manually typed code is able to run, it's up to you

    On Error GoTo ErrorHandler
    CodeOnTheFly = Replace(CodeOnTheFly, "Public", "Private")
    Dim Module As VBComponent
    Set Module = ModuleOfProcedure(ThisWorkbook, "RunCodeOnTheFly")

    Dim subName As String
    Dim SubStart As Long
    SubStart = InStr(1, CodeOnTheFly, "Sub ", vbTextCompare)
    Dim FunctionStart As Long
    FunctionStart = InStr(1, CodeOnTheFly, "Function ", vbTextCompare)
    If SubStart > 0 Or FunctionStart > 0 Then
        If (SubStart > 0 And SubStart < FunctionStart) Or _
        (SubStart > 0 And FunctionStart = 0) Then
            subName = Mid(CodeOnTheFly, SubStart)
            subName = Split(subName, "Sub ", , vbTextCompare)(1)
            subName = Split(subName, "(")(0)
        ElseIf FunctionStart > 0 And FunctionStart < SubStart Or _
        (SubStart = 0 And FunctionStart > 0) Then
            subName = Mid(CodeOnTheFly, FunctionStart)
            subName = Split(subName, "Function ", , vbTextCompare)(1)
            subName = Split(subName, "(")(0)
        Else
            Stop
        End If
    Else
        subName = "NamelessCodeOnTheFly"
        ProcedureReplace Module, "NamelessCodeOnTheFly", _
                            "Function NamelessCodeOnTheFly()" & vbLf & _
                            CodeOnTheFly & vbLf & _
                            "End Function"
    End If

    If subName <> "NamelessCodeOnTheFly" Then
        Dim procEndLine As Long
        procEndLine = aProcedure.Init(ThisWorkbook, Module, "RunCodeOnTheFly").LineIndex(Procedure_Last)
        With Module.CodeModule
            .DeleteLines procEndLine + 1, .CountOfLines - procEndLine
            .InsertLines .CountOfLines + 1, vbNewLine & CodeOnTheFly
        End With
    End If
    appRunOnTime Now + TimeSerial(0, 0, 1), subName
    Exit Sub
ErrorHandler:
    MsgBox "An error occured"
End Sub


'F_Userform_Controls	Module

Option Explicit

Function CreateOrSetFrame(Form As Object, Optional FrameName As String, Optional LTWH As Variant) As MSForms.Frame
'@AssignedModule F_Userform_Controls
    Dim cFrame As MSForms.Frame
    On Error Resume Next
    Set cFrame = Form.Controls(FrameName)
    On Error GoTo 0
    If cFrame Is Nothing Then
        If TypeName(Form) = "VBComponent" Then
            Set cFrame = Form.Designer.Controls.Add("Forms.Frame.1")
        Else
            Set cFrame = Form.Controls.Add("Forms.Frame.1")
        End If
    End If
    If Not IsMissing(FrameName) Then cFrame.Name = FrameName
    If Not IsMissing(LTWH) Then
        cFrame.Left = LTWH(0)
        cFrame.Top = LTWH(1)
        cFrame.Width = LTWH(2)
        cFrame.Height = LTWH(3)
    End If
    Set CreateOrSetFrame = cFrame
End Function

Function AvailableFormOrFrameRow(FormOrFrame As Object, Optional AfterWidth As Long = 0, Optional AfterHeight As Long = 0, Optional AddMargin As Long = 0) As Long
'@LastModified 2307171805
'@AssignedModule F_Userform_Controls
    Dim ctr As MSForms.control
    Dim myHeight
    For Each ctr In FormOrFrame.Controls
        If ctr.Visible = True Then
            If ctr.Left >= AfterWidth And ctr.Top >= AfterHeight Then
                If ctr.Top + ctr.Height > myHeight Then myHeight = ctr.Top + ctr.Height
            End If
        End If
    Next
    AvailableFormOrFrameRow = myHeight + AddMargin '6
End Function

Function AvailableFormOrFrameColumn(FormOrFrame As Object, Optional AfterWidth As Long = 0, Optional AfterHeight As Long = 0, Optional AddMargin As Long = 0) As Long
'@LastModified 2307171805
'@AssignedModule F_Userform_Controls
    Dim ctr As MSForms.control
    Dim myWidth
    For Each ctr In FormOrFrame.Controls
        If ctr.Visible = True Then
            If ctr.Left >= AfterWidth And ctr.Top >= AfterHeight Then
                If ctr.Left + ctr.Width > myWidth Then myWidth = ctr.Left + ctr.Width
            End If
        End If
    Next
    AvailableFormOrFrameColumn = myWidth + AddMargin '6
End Function

Sub AddFormControls(controlID As String, _
                    CountOrArrayOfNames As Variant, _
                    Optional Captions As Variant = 0, _
                    Optional Vertical As Boolean = True, _
                    Optional offset As Long = 0, _
                    Optional Form As Object)
'@AssignedModule F_Userform_Controls
'@INCLUDE PROCEDURE ActiveModule
    If IsNumeric(CountOrArrayOfNames) And IsArray(Captions) Then
        If UBound(Captions) + 1 <> CLng(CountOrArrayOfNames) Then Exit Sub
    End If
    Dim Module As VBComponent
    If Form Is Nothing Then
        Set Module = ActiveModule
        If Module.Type <> vbext_ct_MSForm Then Exit Sub
    End If
    Dim c As MSForms.control
    Dim i As Long
    If IsNumeric(CountOrArrayOfNames) Then
        For i = 1 To CLng(CountOrArrayOfNames)
            If Form Is Nothing Then
                Set c = Module.Designer.Controls.Add(controlID)
            Else
                Set c = Form.Controls.Add(controlID)
            End If
            If Vertical Then
                c.Top = i * c.Height + i * 5 - c.Height
                c.Left = offset
            Else
                c.Top = offset
                c.Left = i * c.Width + i * 5 - c.Width
            End If
            If IsArray(Captions) Then
                c.Caption = Captions(i - 1)
            Else
                On Error Resume Next
                c.Caption = CountOrArrayOfNames(i - 1)
                If c.Caption = "" Then c.Caption = c.Name
                On Error GoTo 0
            End If
        Next
    Else
        For i = 1 To UBound(CountOrArrayOfNames) + 1
            If Form Is Nothing Then
                Set c = Module.Designer.Controls.Add(controlID)
            Else
                Set c = Form.Controls.Add(controlID)
            End If
            If Vertical Then
                c.Top = i * c.Height + i * 5 - c.Height
                c.Left = offset
            Else
                c.Top = offset
                c.Left = i * c.Width + i * 5 - c.Width
            End If
            c.Name = CountOrArrayOfNames(i - 1)
            If IsArray(Captions) Then
                c.Caption = Captions(i - 1)
            Else
                On Error Resume Next
                c.Caption = CountOrArrayOfNames(i - 1)
                If c.Caption = "" Then c.Caption = c.Name
                On Error GoTo 0
            End If
        Next
    End If
End Sub

Sub AddMultipleControls(ControlTypes As Variant, count As Long, Optional Vertical As Boolean = True, Optional Form As Object = Nothing)
'@AssignedModule F_Userform_Controls
'@INCLUDE PROCEDURE ActiveModule
'@INCLUDE PROCEDURE AddFormControls
    Dim i As Long
    For i = 1 To UBound(ControlTypes) + 1
        If Vertical Then
            AddFormControls CStr(ControlTypes(i - 1)), count, , Vertical, i * 60 - 50, Form
        Else
            AddFormControls CStr(ControlTypes(i - 1)), count, , Vertical, i * 20 - 20, Form
        End If
    Next
    Dim c As MSForms.control
    On Error Resume Next
    If Form Is Nothing Then
        For Each c In ActiveModule.Designer.Controls
            If Not TypeName(c) Like "TextBox" Then c.AutoSize = True
        Next
    Else
        For Each c In Form.Controls
            If Not TypeName(c) Like "TextBox" Then c.AutoSize = True
        Next
    End If
End Sub


Public Sub flashControl(ctr As MSForms.control, blinkCount As Integer)
    Rem if blinkCount = odd then the control will become hidden
'@AssignedModule F_Userform_Controls
'@INCLUDE DECLARATION getTickCount
    Dim lngTime As Long
    Dim i As Integer
    If blinkCount Mod 2 <> 0 Then blinkCount = blinkCount + 1
    For i = 1 To blinkCount * 2
        lngTime = getTickCount
        If ctr.Visible = True Then
            ctr.Visible = False
        Else
            ctr.Visible = True
        End If
        DoEvents
        Do While getTickCount - lngTime < 200
        Loop
    Next
End Sub

Public Function TextOfControl(c As control) As Variant
    Rem Text of Textbox, Selection of Combobox, Selected items (2d) of Listbox
'@AssignedModule F_Userform_Controls
'@INCLUDE CLASS aCollection
'@INCLUDE CLASS aListBox
    Dim out As New Collection
    If TypeName(c) = "TextBox" Then
        If c.SelLength = 0 Then
            TextOfControl = c.text
        Else
            TextOfControl = c.SelText
        End If
    ElseIf TypeName(c) = "ComboBox" Then
        If c.Style < 2 Then
            TextOfControl = c.text
        Else
            TextOfControl = ""
        End If
    ElseIf TypeName(c) = "ListBox" Then
        Set out = aListBox.Init(c).SelectedValues
        If out.count > 0 Then
            TextOfControl = aCollection.Init(out).ToArray
        Else
            TextOfControl = ""
        End If
    End If
End Function

'F_Userform	Module


Option Explicit
Option Compare Text

Rem @Subfolder Userforms>Transparent Declarations
Rem Private Declare PtrSafe Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long) As Long
#If VBA7 Then
    Private Declare PtrSafe Function DrawMenuBar Lib "user32" (ByVal hwnd As Long) As Long
    Private Declare PtrSafe Function SetLayeredWindowAttributes Lib "user32" (ByVal hwnd As Long, ByVal crKey As Long, ByVal bAlpha As Byte, ByVal dwFlags As Long) As Long
#Else
    Private Declare Function DrawMenuBar Lib "user32" (ByVal hWnd As Long) As Long
    Private Declare Function SetLayeredWindowAttributes Lib "user32" (ByVal hWnd As Long, ByVal crKey As Long, ByVal bAlpha As Byte, ByVal dwFlags As Long) As Long
#End If

Private Const GWL_STYLE As Long = (-16)
Private Const GWL_EXSTYLE As Long = (-20)
Private Const WS_CAPTION As Long = &HC00000
Private Const WS_EX_DLGMODALFRAME As Long = &H1

Private Const WS_EX_LAYERED = &H80000
Private Const LWA_COLORKEY = &H1
Private Const LWA_ALPHA = &H2

Private m_sngDownX As Single
Private m_sngDownY As Single

Rem Private Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Rem Private Declare PtrSafe Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long

Rem @Subfolder Userforms>Parent Declarations
Public Const FORMAT_MESSAGE_ALLOCATE_BUFFER = &H100
Public Const FORMAT_MESSAGE_ARGUMENT_ARRAY = &H2000
Public Const FORMAT_MESSAGE_FROM_HMODULE = &H800
Public Const FORMAT_MESSAGE_FROM_STRING = &H400
Public Const FORMAT_MESSAGE_FROM_SYSTEM = &H1000
Public Const FORMAT_MESSAGE_IGNORE_INSERTS = &H200
Public Const FORMAT_MESSAGE_MAX_WIDTH_MASK = &HFF
Public Const FORMAT_MESSAGE_TEXT_LEN = 160
Public Const MAX_PATH = 260
Public Const GWL_HWNDPARENT As Long = -8
Public Const GW_OWNER = 4

#If VBA7 Then
    Private Declare PtrSafe Function GetWindowText Lib "user32.dll" Alias "GetWindowTextA" (ByVal hwnd As Long, ByVal lpString As String, ByVal cch As Long) As Long
    Public Declare PtrSafe Function GetClassName Lib "user32" Alias "GetClassNameA" (ByVal hwnd As Long, ByVal lpClassName As String, ByVal nMaxCount As Long) As Long
    Public Declare PtrSafe Function GetWindowLong Lib "user32.dll" Alias "GetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long) As Long
#Else
    Private Declare Function GetWindowText Lib "user32.dll" Alias "GetWindowTextA" (ByVal hWnd As Long, ByVal lpString As String, ByVal cch As Long) As Long
    Public Declare Function GetClassName Lib "user32" Alias "GetClassNameA" (ByVal hWnd As Long, ByVal lpClassName As String, ByVal nMaxCount As Long) As Long
    Public Declare Function GetWindowLong Lib "user32.dll" Alias "GetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
#End If

Public VBEditorHWnd As Long
Public ApplicationHWnd As Long
Public ExcelDeskHWnd As Long
Public ActiveWindowHWnd As Long
Public UserFormHWnd As Long
Public WindowsDesktopHWnd As Long
Public Const GA_ROOT As Long = 2
Public Const GA_ROOTOWNER As Long = 3
Public Const GA_PARENT As Long = 1

#If VBA7 Then
    Private Declare PtrSafe Function GetWindow Lib "user32" (ByVal hwnd As Long, ByVal wCmd As Long) As Long
    Public Declare PtrSafe Function FindWindowEx Lib "user32" Alias "FindWindowExA" (ByVal hWnd1 As Long, ByVal hWnd2 As Long, ByVal lpsz1 As String, ByVal lpsz2 As String) As Long
    Public Declare PtrSafe Function GetAncestor Lib "user32.dll" (ByVal hwnd As Long, ByVal gaFlags As Long) As Long
    Public Declare PtrSafe Function GetDesktopWindow Lib "user32" () As Long
    Public Declare PtrSafe Function GetParent Lib "user32.dll" (ByVal hwnd As Long) As Long
    Public Declare PtrSafe Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
#Else
    Private Declare Function GetWindow Lib "user32" (ByVal hWnd As Long, ByVal wCmd As Long) As Long
    Public Declare Function FindWindowEx Lib "user32" Alias "FindWindowExA" (ByVal hWnd1 As Long, ByVal hWnd2 As Long, ByVal lpsz1 As String, ByVal lpsz2 As String) As Long
    Public Declare Function GetAncestor Lib "user32.dll" (ByVal hWnd As Long, ByVal gaFlags As Long) As Long
    Public Declare Function GetDesktopWindow Lib "user32" () As Long
    Public Declare Function GetParent Lib "user32.dll" (ByVal hWnd As Long) As Long
    Public Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
#End If

Public Const C_EXCEL_APP_WINDOWCLASS = "XLMAIN"
Public Const C_EXCEL_DESK_WINDOWCLASS = "XLDESK"
Public Const C_EXCEL_WINDOW_WINDOWCLASS = "EXCEL7"
Public Const USERFORM_WINDOW_CLASS = "ThunderDFrame"
Public Const C_VBA_USERFORM_WINDOWCLASS = "ThunderDFrame"

Rem Window position and more
Public Const SWP_NOMOVE = &H2
Public Const SWP_NOSIZE = &H1
Public Const HWND_TOP = 0
Public Const HWND_BOTTOM = 1
Public Const HWND_TOPMOST = -1
Public Const HWND_NOTOPMOST = -2

#If VBA7 Then
    Public Declare PtrSafe Function SetWindowPos Lib "user32" (ByVal hwnd As LongPtr, ByVal hwndInsertAfter As LongPtr, ByVal x As LongPtr, ByVal y As LongPtr, ByVal cx As LongPtr, ByVal cy As LongPtr, ByVal uFlags As LongPtr) As Long
#Else
    Public Declare Function SetWindowPos Lib "user32" (ByVal hWnd As LongPtr, ByVal hWndInsertAfter As LongPtr, ByVal X As LongPtr, ByVal Y As LongPtr, ByVal cx As LongPtr, ByVal cy As LongPtr, ByVal uFlags As LongPtr) As Long
#End If

Rem ---
#If VBA7 Then
    Public Declare PtrSafe Function SetParent Lib "user32" (ByVal hwndChild As LongPtr, ByVal hWndNewParent As LongPtr) As LongPtr
    Public Declare PtrSafe Function SetForegroundWindow Lib "user32" (ByVal hwnd As LongPtr) As Long
    Public Declare PtrSafe Function FormatMessage Lib "kernel32" Alias "FormatMessageA" (ByVal dwFlags As Long, lpSource As Any, ByVal dwMessageId As Long, ByVal dwLanguageId As Long, ByVal lpBuffer As String, ByVal nSize As Long, Arguments As LongPtr) As Long
#Else
    Public Declare Function SetParent Lib "user32" (ByVal hWndChild As Long, ByVal hWndNewParent As Long) As Long
    Public Declare Function SetForegroundWindow Lib "user32" (ByVal hwnd As Long) As Long
    Public Declare Function FormatMessage Lib "kernel32.dll" Alias "FormatMessageA" (ByVal dwFlags As Long, ByRef lpSource As Any, ByVal dwMessageId As Long, ByVal dwLanguageId As Long, ByVal lpBuffer As String, ByVal nSize As Long, ByRef Arguments As Long) As Long
#End If

Rem Closeby
Public Enum CloseBy
    User = 0
    Code = 1
    WindowsOS = 2
    TaskManager = 3
End Enum

Rem FlashControl
#If VBA7 Then
    Public Declare PtrSafe Function getTickCount Lib "kernel32" Alias "GetTickCount" () As Long
#Else
    Public Declare Function getTickCount Lib "kernel32" Alias "GetTickCount" () As Long
#End If

Public Const black As Long = &H80000012
Public Const red As Long = &HFF&
Rem ControlID
Public Const ControlIDCheckBox = "Forms.CheckBox.1"
Public Const ControlIDComboBox = "Forms.ComboBox.1"
Public Const ControlIDCommandButton = "Forms.CommandButton.1"
Public Const ControlIDFrame = "Forms.Frame.1"
Public Const ControlIDImage = "Forms.Image.1"
Public Const ControlIDLabel = "Forms.Label.1"
Public Const ControlIDListBox = "Forms.ListBox.1"
Public Const ControlIDMultiPage = "Forms.MultiPage.1"
Public Const ControlIDOptionButton = "Forms.OptionButton.1"
Public Const ControlIDScrollBar = "Forms.ScrollBar.1"
Public Const ControlIDSpinButton = "Forms.SpinButton.1"
Public Const ControlIDTabStrip = "Forms.TabStrip.1"
Public Const ControlIDTextBox = "Forms.TextBox.1"
Public Const ControlIDToggleButton = "Forms.ToggleButton.1"

Rem other
#If VBA7 Then
    Private Declare PtrSafe Function FindWindowA Lib "user32" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    Private Declare PtrSafe Function GetWindowLongA Lib "user32" (ByVal hwnd As Long, ByVal nIndex As Long) As Long
    Private Declare PtrSafe Function SetWindowLongA Lib "user32" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
#Else
    Private Declare Function FindWindowA Lib "user32" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    Private Declare Function GetWindowLongA Lib "user32" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
    Private Declare Function SetWindowLongA Lib "user32" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
#End If

Rem userform hwnd
#If Win64 Then
    Private Declare PtrSafe Function IUnknown_GetWindow Lib "shlwapi" Alias "#172" (ByVal pIUnk As IUnknown, ByVal hwnd As LongPtr) As Long
#Else
    Private Declare Function IUnknown_GetWindow Lib "shlwapi" Alias "#172" (ByVal pIUnk As IUnknown, ByVal hwnd As Long) As Long
#End If


Public Function IsLoaded(formName As String) As Boolean
'@AssignedModule F_Userform
    Dim frm As Object
    For Each frm In VBA.Userforms
        If frm.Name = formName Then
            IsLoaded = True
            Exit Function
        End If
    Next frm
    IsLoaded = False
End Function

Sub UserformPersist(formName As String)
'In userform put:
'
'Private Sub UserForm_Initialize()
'    setUserformLostStateTrue Me.name
'    UserformPersist Me.name
'End Sub
'
'Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
'    setUserformLostStateFalse Me.name
'End Sub

'@AssignedModule F_Userform
'@INCLUDE PROCEDURE UserformLostState
'@INCLUDE PROCEDURE setUserformLostStateTrue
'@INCLUDE PROCEDURE setUserformLostStateFalse
'@INCLUDE PROCEDURE ShowUserform
'@INCLUDE PROCEDURE appRunOnTime

    appRunOnTime Now() + TimeSerial(0, 0, 5), "UserformPersist", formName

    If UserformLostState(formName) Then
        ShowUserform formName
    Else
        On Error Resume Next
        Application.OnTime Now, "UserformPersist", , False
        On Error GoTo 0
    End If
End Sub

Function UserformLostState(formName As String) As Boolean
'@INCLUDE CreateOrSetSheet
'@AssignedModule F_Userform
'@INCLUDE PROCEDURE CreateOrSetSheet
    UserformLostState = CBool(CreateOrSetSheet(formName & "_Settings", ThisWorkbook).Range("Z1").Value)
End Function

Sub setUserformLostStateTrue(formName As String)
'@INCLUDE CreateOrSetSheet
'@AssignedModule F_Userform
'@INCLUDE PROCEDURE CreateOrSetSheet
    CreateOrSetSheet(formName & "_Settings", ThisWorkbook).Range("Z1").Value = True
End Sub

Sub setUserformLostStateFalse(formName As String)
'@INCLUDE CreateOrSetSheet
'@AssignedModule F_Userform
'@INCLUDE PROCEDURE CreateOrSetSheet
    CreateOrSetSheet(formName & "_Settings", ThisWorkbook).Range("Z1").Value = False
End Sub

Rem var
Public Sub ShowUserform(formName As String)
    '@INCLUDE IsLoaded
'@AssignedModule F_Userform
    Dim frm As Object
    If IsLoaded(formName) = True Then
        For Each frm In VBA.Userforms
            If frm.Name = formName Then
                On Error Resume Next
                frm.Show
                Exit Sub
            End If
        Next frm
    Else
        Dim oUserForm As Object
        On Error GoTo Err
        Set oUserForm = Userforms.Add(formName)
        oUserForm.Show '(vbModeless)
        Exit Sub
    End If
Err:
    Select Case Err.Number
    Case 424:
        Debug.Print "The Userform with the name " & formName & " was not found.", vbExclamation, "Load userforn by name"
    Case Else:
        Debug.Print Err.Number & ": " & Err.Description, vbCritical, "Load userforn by name"
    End Select
End Sub


Public Sub Reframe(Form As Object, control As MSForms.control)
'TODO obsolete, replaced with amultipage.init(..).buildmenu
    Dim c As MSForms.control
    For Each c In Form.Controls
        If TypeName(c) = "Frame" Then
            If Not InStr(1, c.Tag, "skip", vbTextCompare) > 0 Then
                If c.Name <> control.Parent.Parent.Name Then c.Visible = False
            End If
        End If
    Next
    Form.Controls(control.Caption).Visible = True
    For Each c In Form.Controls
        If TypeName(c) = "Label" Then
            If Not InStr(1, c.Tag, "skip", vbTextCompare) > 0 Then
                c.BackColor = &H534848
            End If
        End If
    Next
    control.BackColor = &H80B91E
End Sub

'vbArcImports	Module

Option Explicit

Enum MyColors
    FormBackgroundDarkGray = 4208182        ' BACKGROUND DARK GRAY
    FormSidebarMediumGray = 5457992        ' TILE COLORS LIGHTER GRAY
    FormSidebarMouseOverLightGray = &H808080        ' lighter light gray
    FormSelectedGreen = 8435998        ' green tile
End Enum

Public Type tCursor
    Left As Long
    Top As Long
End Type

Public Const LOGPIXELSX = 88
Public Const LOGPIXELSY = 90

#If VBA7 Then
    Public Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
    Private Declare PtrSafe Function InternetGetConnectedState Lib "wininet.dll" (ByRef dwFlags As Long, ByVal dwReserved As Long) As Long
    Public Declare PtrSafe Sub mouse_event Lib "user32" (ByVal dwFlags As Long, ByVal dx As Long, ByVal dy As Long, ByVal cButtons As Long, ByVal dwExtraInfo As Long)
    Public Declare PtrSafe Function GetAsyncKeyState Lib "user32" (ByVal vKey As Long) As Integer
    Public Declare PtrSafe Function ClientToScreen Lib "user32" (ByVal hwnd As Long, lpPoint As tCursor) As Long
    Public Declare PtrSafe Function GetCursorPos Lib "user32" (p As tCursor) As Long
    Public Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    Public Declare PtrSafe Function GetDC Lib "user32" (ByVal hwnd As Long) As Long
    Public Declare PtrSafe Function GetDeviceCaps Lib "gdi32" (ByVal hDC As Long, ByVal nIndex As Long) As Long
    Public Declare PtrSafe Function ReleaseDC Lib "user32" (ByVal hwnd As Long, ByVal hDC As Long) As Long
    Public Declare PtrSafe Function SetCursorPos Lib "user32" (ByVal x As Long, ByVal y As Long) As Long
#Else
    Public Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
    Private Declare Function InternetGetConnectedState Lib "wininet.dll" (ByRef dwFlags As Long, ByVal dwReserved As Long) As Long
    Public Declare Sub mouse_event Lib "user32" (ByVal dwFlags As Long, ByVal dX As Long, ByVal dy As Long, ByVal cbuttons As Long, ByVal dwExtraInfo As Long)
    Public Declare Function GetAsyncKeyState Lib "user32" (ByVal vKey As Long) As Integer
    public Declare Function ClientToScreen Lib "user32" (ByVal hWnd As Long, lpPoint As tCursor) As Long
    public Declare Function GetCursorPos Lib "user32" (p As tCursor) As Long
    Public Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    Public Declare Function GetDC Lib "user32" (ByVal hWnd As Long) As Long
    Public Declare Function GetDeviceCaps Lib "gdi32" (ByVal hdc As Long, ByVal nIndex As Long) As Long
    Public Declare Function ReleaseDC Lib "user32" (ByVal hWnd As Long, ByVal hdc As Long) As Long
    Public Declare Function SetCursorPos Lib "user32" (ByVal X As Long, ByVal Y As Long) As Long
#End If


Rem DspErrMsg Constants and Variables
Global Const Success        As Boolean = True
Global Const Failure        As Boolean = False
Global Const NoError        As Long = 0
Global Const LogError       As Long = 997
Global Const RtnError       As Long = 998
Global Const DspError       As Long = 999
Public bLogOnly             As Boolean
Public bDebug               As Boolean

Rem timer constants
Public Const mblncTimer As Boolean = True
Public mvarTimerName
Public mvarTimerStart


Function RandomStringArray(ByVal rowCount As Long, ByVal columnCount As Long, maxStringLength) As Variant
'@AssignedModule vbArcImports
    Dim resultArray() As Variant
    ReDim resultArray(1 To rowCount, 1 To columnCount)
    
    Dim i As Long, j As Long
    Dim alphabet As String
    alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
    
    ' Seed the random number generator
    Randomize
    
    ' Generate random strings
    For i = 1 To rowCount
        For j = 1 To columnCount
            Dim randomString As String
            randomString = ""
            
            ' Length of each random string (you can adjust as needed)
            Dim stringLength As Long
            stringLength = WorksheetFunction.RandBetween(1, maxStringLength)
            
            Dim k As Long
            For k = 1 To stringLength
                ' Generate a random index to pick a character from the alphabet
                Dim randomIndex As Long
                randomIndex = Int((Len(alphabet) * Rnd) + 1)
                
                ' Append the random character to the string
                randomString = randomString & Mid(alphabet, randomIndex, 1)
            Next k
            
            resultArray(i, j) = randomString
        Next j
    Next i
    
    RandomStringArray = resultArray
End Function


'* Modified   : Date and Time       Author              Description
'* Updated    : 21-07-2023 11:49    Alex                (ArrayFilter2D)

Function ArrayFilter2D(inputArray As Variant, matchString As String, Optional targetColumn As Long = -1) As Variant
'@LastModified 2307211149
'@INCLUDE PROCEDURE ArraySubSet
'@AssignedModule vbArcImports
    Dim numRows As Long, numCols As Long
    numRows = UBound(inputArray, 1)
    numCols = UBound(inputArray, 2)
    
    Dim resultArray() As Variant
    Dim resultIndex As Long
    ReDim resultArray(LBound(inputArray, 1) To numRows, LBound(inputArray, 2) To numCols)
    resultIndex = LBound(resultArray, 1) - 1
    
    Dim i As Long, j As Long
    For i = LBound(resultArray, 1) To numRows
        Dim rowMatches As Boolean
        rowMatches = False
        
        If targetColumn = -1 Then
            ' Match any cell in the row using Like operator (case-insensitive)
            For j = LBound(resultArray, 2) To numCols
                If LCase(inputArray(i, j)) Like "*" & LCase(matchString) & "*" Then
                    rowMatches = True
                    Exit For
                End If
            Next j
        ElseIf targetColumn >= LBound(resultArray, 2) And targetColumn <= numCols Then
            ' Match the specified column using Like operator (case-insensitive)
            If LCase(inputArray(i, targetColumn)) Like "*" & LCase(matchString) & "*" Then
                rowMatches = True
            End If
        End If
        
        ' Copy the matching row to the result array
        If rowMatches Then
            resultIndex = resultIndex + 1
            For j = LBound(resultArray, 2) To numCols
                resultArray(resultIndex, j) = inputArray(i, j)
            Next j
        End If
    Next i
    
    ' Resize the result array to remove any empty rows
    If resultIndex = -1 Then
        ArrayFilter2D = Array()
    Else
        resultArray = ArraySubSet(resultArray, LBound(resultArray, 1), LBound(resultArray, 2), resultIndex, numCols)
        ' Return the filtered array
        ArrayFilter2D = resultArray
    End If
End Function

Sub PrintConditionalFormatting(TargetWorksheet As Worksheet)
'@AssignedModule vbArcImports
'@INCLUDE PROCEDURE ArrayCombine
'@INCLUDE PROCEDURE ArrayToStringTable
'@INCLUDE PROCEDURE dp
    Dim ws As Worksheet
    Dim CFrule As FormatCondition
    Dim output()
    ReDim output(1 To 1, 1 To 4)
    Dim i As Long
    For i = 1 To 4
        output(1, i) = Choose(i, "Sheet", "Formula", "Range", "Fill")
    Next
    Dim arr(1 To 1, 1 To 4)

    For Each CFrule In TargetWorksheet.Cells.FormatConditions
        For i = 1 To 4
        
            arr(1, i) = Choose(i, _
                                TargetWorksheet.Name, _
                                "'" & CFrule.Formula1, _
                                CFrule.AppliesTo.Address, _
                                CFrule.Interior.color)
                                
            
            
        Next
        ArrayCombine output, arr, True
    Next CFrule
    dp ArrayToStringTable(output)
End Sub



Public Function ArraySubSet(vIn As Variant, Optional ByVal iStartRow As Integer = -1, Optional ByVal iStartCol As Integer = -1, Optional ByVal iHeight As Integer = -1, Optional ByVal iWidth As Integer = -1) As Variant
'@LastModified 2307201044
'@AssignedModule vbArcImports
    Dim vReturn As Variant
    Dim iInRowLower As Integer
    Dim iInRowUpper As Integer
    Dim iInColLower As Integer
    Dim iInColUpper As Integer
    Dim iEndRow As Integer
    Dim iEndCol As Integer
    Dim iRow As Integer
    Dim iCol As Integer

    iInRowLower = LBound(vIn, 1)
    iInRowUpper = UBound(vIn, 1)
    iInColLower = LBound(vIn, 2)
    iInColUpper = UBound(vIn, 2)

    If iStartRow = -1 Then
        iStartRow = iInRowLower
    End If
    If iStartCol = -1 Then
        iStartCol = iInColLower
    End If

    If iHeight = -1 Then
        iHeight = iInRowUpper - iStartRow + 1
    End If
    If iWidth = -1 Then
        iWidth = iInColUpper - iStartCol + 1
    End If

    iEndRow = iStartRow + iHeight - IIf(iStartRow = 0, 0, 1)
    iEndCol = iStartCol + iWidth - IIf(iStartCol = 0, 0, 1)

    ReDim vReturn(iStartRow To iEndRow, iStartCol To iEndCol)

    For iRow = iStartRow To iEndRow
        For iCol = iStartCol To iEndCol
            vReturn(iRow, iCol) = vIn(iRow, iCol)
        Next
    Next

    ArraySubSet = vReturn
End Function

Public Function ArrayCombine(ByRef a As Variant, b As Variant, Optional stacked As Boolean = True) As Boolean
    'assumes that A and B are 2-dimensional variant arrays
    'if stacked is true then A is placed on top of B    in this case the number of rows must be the same,
    'otherwise they are placed side by side A|B         in which case the number of columns are the same
    'LBound can be anything but is assumed to be the SAME for A and B (in both dimensions)
'@AssignedModule vbArcImports
    
    'False is returned if a clash, so use: If not arraycombe(a,b,true) then goto errorHandler
  
    Dim LB As Long, m_A As Long, n_A As Long
    Dim m_B As Long, n_B As Long
    Dim M As Long, N As Long
    Dim i As Long, j As Long, k As Long
    Dim c As Variant

    If TypeName(a) = "Range" Then a = a.Value
    If TypeName(b) = "Range" Then b = b.Value

    LB = LBound(a, 1)
    m_A = UBound(a, 1)
    n_A = UBound(a, 2)
    m_B = UBound(b, 1)
    n_B = UBound(b, 2)

    If stacked Then
        M = m_A + m_B + 1 - LB
        N = n_A
        If n_B <> N Then
            ArrayCombine = False
            Exit Function
        End If
    Else
        M = m_A
        If m_B <> M Then
            ArrayCombine = False
            Exit Function
        End If
        N = n_A + n_B + 1 - LB
    End If
    
    ReDim c(LB To M, LB To N)
    For i = LB To M
        For j = LB To N
            If stacked Then
                If i <= m_A Then
                    c(i, j) = a(i, j)
                Else
                    c(i, j) = b(LB + i - m_A - 1, j)
                End If
            Else
                If j <= n_A Then
                    c(i, j) = a(i, j)
                Else
                    c(i, j) = b(i, LB + j - n_A - 1)
                End If
            End If
        Next j
    Next i
    a = c
    
End Function

Public Function ArrayToStringTable(ByVal Hairetu, Optional HyoujiMaxNagasa%, Optional SikiriMoji$ = "|") As String
'https://gist.github.com/YujiFukami/15c922d41ff06c9b12ad450a14131080#file-
'@AssignedModule vbArcImports
'@INCLUDE PROCEDURE ShortenToByteCharacters
    Dim i&, j&, k&, M&, N&
    Dim TateMin&, TateMax&, YokoMin&, YokoMax&
    Dim WithTableHairetu
    Dim NagasaList, MaxNagasaList
    Dim NagasaOnajiList
    Dim OutputList
'    Const SikiriMoji$ = "|"
    Dim Jigen2%
    On Error Resume Next
    Jigen2 = UBound(Hairetu, 2)
'    On Error GoTo 0
    If Jigen2 = 0 Then
        Hairetu = Application.Transpose(Hairetu)
    End If
    TateMin = LBound(Hairetu, 1)
    TateMax = UBound(Hairetu, 1)
    YokoMin = LBound(Hairetu, 2)
    YokoMax = UBound(Hairetu, 2)
    ReDim WithTableHairetu(1 To TateMax - TateMin + 1 + 1, 1 To YokoMax - YokoMin + 1 + 1)
    For i = 1 To TateMax - TateMin + 1
        WithTableHairetu(i + 1, 1) = TateMin + i - 1
        For j = 1 To YokoMax - YokoMin + 1
            WithTableHairetu(1, j + 1) = YokoMin + j - 1
            WithTableHairetu(i + 1, j + 1) = Hairetu(i - 1 + TateMin, j - 1 + YokoMin)
        Next j
    Next i
    N = UBound(WithTableHairetu, 1)
    M = UBound(WithTableHairetu, 2)
    ReDim NagasaList(1 To N, 1 To M)
    ReDim MaxNagasaList(1 To M)
    Dim tmpStr$
    For j = 1 To M
        For i = 1 To N
            If j > 1 And HyoujiMaxNagasa <> 0 Then
                tmpStr = WithTableHairetu(i, j)
                WithTableHairetu(i, j) = ShortenToByteCharacters(tmpStr, HyoujiMaxNagasa)
            End If
            NagasaList(i, j) = LenB(StrConv(WithTableHairetu(i, j), vbFromUnicode))
            MaxNagasaList(j) = WorksheetFunction.Max(MaxNagasaList(j), NagasaList(i, j))
        Next i
    Next j
    ReDim NagasaOnajiList(1 To N, 1 To M)
    Dim TmpMaxNagasa&
    For j = 1 To M
        TmpMaxNagasa = MaxNagasaList(j)
        For i = 1 To N
            NagasaOnajiList(i, j) = WithTableHairetu(i, j) & WorksheetFunction.Rept(" ", TmpMaxNagasa - NagasaList(i, j))
        Next i
    Next j
    ReDim OutputList(1 To N)
    For i = 1 To N
        For j = 1 To M
            If j = 1 Then
                OutputList(i) = NagasaOnajiList(i, j)
            Else
                OutputList(i) = OutputList(i) & SikiriMoji & NagasaOnajiList(i, j)
            End If
        Next j
    Next i
    ArrayToStringTable = Join(OutputList, vbNewLine)
End Function

Public Function isUserform(obj As Object) As Boolean
'@AssignedModule vbArcImports
'@INCLUDE PROCEDURE UserformNames
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aModules
    Dim formNames As New Collection
    Set formNames = aModules.Init(ThisWorkbook).UserformNames
    Dim formName
    For Each formName In formNames
        If formName = obj.Name Then
            isUserform = True
            Exit For
        End If
    Next
End Function
Function IsFileFolderURL(Path) As String
'@AssignedModule vbArcImports
'@INCLUDE PROCEDURE FileExists
'@INCLUDE PROCEDURE FolderExists
'@INCLUDE PROCEDURE URLExists
    Dim RetVal As String
    RetVal = "I"
    If (RetVal = "I") And FileExists(Path) Then RetVal = "F"
    If (RetVal = "I") And FolderExists(Path) Then RetVal = "D"
    If (RetVal = "I") And URLExists(Path) Then RetVal = "U"
    ' I => Invalid | F => File | D => Directory | U => Valid Url
    IsFileFolderURL = RetVal
End Function

Public Function PadRight(ByVal str As String, ByVal Length As Long, Optional Character As String = " ", Optional RemoveExcess As Boolean)
'@AssignedModule vbArcImports
    If Len(str) < Length Then
        PadRight = str & String$(Length - Len(str), Character)
    ElseIf RemoveExcess = True Then
        PadRight = Left$(str, Length)
    Else
        PadRight = str
    End If
End Function

Public Function PadLeft(ByVal str As String, ByVal Length As Long, Optional Character As String = " ", Optional RemoveExcess As Boolean)
'@AssignedModule vbArcImports
    If Len(str) < Length Then
        PadLeft = String$(Length - Len(str), Character) + str
    ElseIf RemoveExcess = True Then
        PadLeft = Right$(str, Length)
    Else
        PadLeft = str
    End If
End Function

Public Function aSwitch(CheckThis, ParamArray OptionPairs() As Variant)
'@LastModified 2307171814
'@AssignedModule vbArcImports
    Dim i As Long
    For i = LBound(OptionPairs) To UBound(OptionPairs) Step 2
        If UCase(CheckThis) = UCase(OptionPairs(i)) Then
            aSwitch = OptionPairs(i + 1)
            Exit Function
        End If
    Next
End Function

Public Sub ArraySort(vArray As Variant, inLow As Long, inHi As Long)
'@BlogPosted
'@AssignedModule vbArcImports
    Dim Pivot   As Variant
    Dim tmpSwap As Variant
    Dim tmpLow  As Long
    Dim tmpHi   As Long
    tmpLow = inLow
    tmpHi = inHi
    Pivot = vArray((inLow + inHi) \ 2)
    While (tmpLow <= tmpHi)
        While (vArray(tmpLow) < Pivot And tmpLow < inHi)
            tmpLow = tmpLow + 1
        Wend
        While (Pivot < vArray(tmpHi) And tmpHi > inLow)
            tmpHi = tmpHi - 1
        Wend
        If (tmpLow <= tmpHi) Then
            tmpSwap = vArray(tmpLow)
            vArray(tmpLow) = vArray(tmpHi)
            vArray(tmpHi) = tmpSwap
            tmpLow = tmpLow + 1
            tmpHi = tmpHi - 1
        End If
    Wend
    If (inLow < tmpHi) Then ArraySort vArray, inLow, tmpHi
    If (tmpLow < inHi) Then ArraySort vArray, tmpLow, inHi
End Sub
Sub appRunOnTime(timeToRun, macroToRun As String, Optional arg1, Optional arg2, Optional arg3, Optional arg4, Optional arg5)
'@LastModified 2305250729
'@AssignedModule vbArcImports

    If TypeName(arg5) <> "Error" Then
        Application.OnTime timeToRun, "'" & macroToRun & """" & arg1 & """ ,""" & arg2 & """ ,""" & arg3 & """ ,""" & arg4 & """ ,""" & arg5 & " '"
    ElseIf TypeName(arg4) <> "Error" Then
        Application.OnTime timeToRun, "'" & macroToRun & """" & arg1 & """ ,""" & arg2 & """ ,""" & arg3 & """ ,""" & arg4 & " '"
    ElseIf TypeName(arg3) <> "Error" Then
        Application.OnTime timeToRun, "'" & macroToRun & """" & arg1 & """ ,""" & arg2 & """ ,""" & arg3 & " '"
    ElseIf TypeName(arg2) <> "Error" Then
        Application.OnTime timeToRun, "'" & macroToRun & """" & arg1 & """ ,""" & arg2 & " '"
    ElseIf TypeName(arg1) <> "Error" Then
        Application.OnTime timeToRun, "'" & macroToRun & """" & arg1 & """ '"
    Else
        Application.OnTime timeToRun, macroToRun
    End If
End Sub

Sub appRun(ProcedureName As String, Optional TargetWorkbook As Workbook, Optional arg1, Optional arg2, Optional arg3, Optional arg4, Optional arg5, Optional arg6, Optional arg7, Optional arg8, Optional arg9, Optional arg10)
'@LastModified 2305250729
'@INCLUDE PROCEDURE ActiveCodepaneWorkbook
'@AssignedModule vbArcImports
    If TypeName(TargetWorkbook) = "Nothing" Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim WorkbookName As String
    WorkbookName = "'" & TargetWorkbook.Name & "'!"

    If TypeName(arg10) <> "Error" Then
        Application.Run WorkbookName & ProcedureName, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10
    ElseIf TypeName(arg9) <> "Error" Then
        Application.Run WorkbookName & ProcedureName, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9
    ElseIf TypeName(arg8) <> "Error" Then
        Application.Run WorkbookName & ProcedureName, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8
    ElseIf TypeName(arg7) <> "Error" Then
        Application.Run WorkbookName & ProcedureName, arg1, arg2, arg3, arg4, arg5, arg6, arg7
    ElseIf TypeName(arg6) <> "Error" Then
        Application.Run WorkbookName & ProcedureName, arg1, arg2, arg3, arg4, arg5, arg6
    ElseIf TypeName(arg5) <> "Error" Then
        Application.Run WorkbookName & ProcedureName, arg1, arg2, arg3, arg4, arg5
    ElseIf TypeName(arg4) <> "Error" Then
        Application.Run WorkbookName & ProcedureName, arg1, arg2, arg3, arg4
    ElseIf TypeName(arg3) <> "Error" Then
        Application.Run WorkbookName & ProcedureName, arg1, arg2, arg3
    ElseIf TypeName(arg2) <> "Error" Then
        Application.Run WorkbookName & ProcedureName, arg1, arg2
    ElseIf TypeName(arg1) <> "Error" Then
        Application.Run WorkbookName & ProcedureName, arg1
    Else: Application.Run WorkbookName & ProcedureName
    End If
End Sub

Function InputboxString(Optional sTitle As String = "Select String", Optional sPrompt As String = "Select String", Optional DefaultValue = "") As String
'@LastModified 2305250732
'@AssignedModule vbArcImports
    Dim stringVariable As String
    stringVariable = Application.InputBox( _
    Title:=sTitle, _
    Prompt:=sPrompt, _
    Type:=2, _
    Default:=DefaultValue)
    InputboxString = CStr(stringVariable)
End Function

Function LoopThroughFiles(Folder, criteria) As Collection
'@AssignedModule vbArcImports
    If Right(Folder, 1) <> "\" Then Folder = Folder & "\"
    Dim out As Collection: Set out = New Collection
    Dim strFile As String
    strFile = Dir(Folder & criteria)
    Do While Len(strFile) > 0
        out.Add strFile
        strFile = Dir
    Loop
    Set LoopThroughFiles = out
End Function


Function ModuleOfWorksheet(TargetSheet As Worksheet) As VBComponent
'@LastModified 2305231030
'@AssignedModule vbArcImports
    Set ModuleOfWorksheet = TargetSheet.Parent.VBProject.VBComponents(TargetSheet.codeName)
End Function

Rem This displays a message box formatted
'based on what the Err object contains and if we want to put our project in debug mode.
'It returns the button the user clicks: vbAbort, vbCancel, vbIgnore, vbRetry

Public Function DspErrMsg(ByVal sRoutineName As String, _
    Optional ByVal sAddText As String = "") As VbMsgBoxResult
'@AssignedModule vbArcImports
'@INCLUDE DECLARATION bDebug
'@INCLUDE DECLARATION bLogOnly
    If bLogOnly Then
        Debug.Print Now(), ThisWorkbook.Name & "!" & sRoutineName, Err.Description, sAddText
    Else
        DspErrMsg = MsgBox( _
        Prompt:="Error#" & Err.Number & vbLf & Err.Description & vbLf & sAddText, _
        Buttons:=IIf(bDebug, vbAbortRetryIgnore, vbCritical) + _
        IIf(Err.Number < 1, 0, vbMsgBoxHelpButton), _
        Title:=sRoutineName, _
        HelpFile:=Err.HelpFile, _
        Context:=Err.HelpContext)
    End If
End Function

Public Function StartTimer(TimerName)
'@AssignedModule vbArcImports
'@INCLUDE DECLARATION mblncTimer
    On Error GoTo ERR_HANDLER
    If mblncTimer Then
        mvarTimerName = TimerName
        mvarTimerStart = Timer
    End If
    On Error Resume Next
    Exit Function
ERR_HANDLER:
    MsgBox Err.Number & " " & Err.Description, vbCritical, "StartTimer()"
End Function

Public Function EndTimer()
'@AssignedModule vbArcImports
'@INCLUDE PROCEDURE FoldersCreate
'@INCLUDE PROCEDURE TxtAppend
'@INCLUDE DECLARATION mblncTimer
    On Error GoTo ERR_HANDLER
    Dim strFile As String
    Dim strContent As String
    If mblncTimer Then
        Dim strPath As String
        strPath = Environ$("USERPROFILE") & "\Documents\vbArc\Timers\"
        FoldersCreate strPath
        strFile = strPath & mvarTimerName & ".txt"
        Rem strFile = ThisWorkbook.path & "\" _
        & Left(ThisWorkbook.Name, InStr(1, ThisWorkbook.Name, ".") - 1) _
        & "TimerLog.txt"
        If Len(Dir(strFile)) = 0 Then
            strContent = _
            "Timestamp" & vbTab & vbTab & vbTab & vbTab & _
            "ElapsedTime" & vbTab & vbTab & _
            "TimerName"
            TxtAppend strFile, strContent
        End If
        strContent = Now() & vbTab & vbTab & _
        Format(Timer - mvarTimerStart, "0.00") & vbTab & vbTab & vbTab & _
        mvarTimerName
        TxtAppend strFile, strContent
    End If
    On Error Resume Next
    Exit Function
ERR_HANDLER:
    MsgBox Err.Number & " " & Err.Description, vbCritical, "EndTimer()"
End Function



Function GetInputRange(ByRef rInput As Excel.Range, _
                    sPrompt As String, _
                    sTitle As String, _
                    Optional ByVal sDefault As String, _
                    Optional ByVal bActivate As Boolean, _
                    Optional x, _
                    Optional y) As Boolean
'@AssignedModule vbArcImports

'assigns range to variable passed
'GetInputRange(rng, "Range picker", "Select range to output listbox' list") = False Then Exit Sub
    Dim bGotRng As Boolean
    Dim bEvents As Boolean
    Dim nAttempt As Long
    Dim sAddr As String
    Dim vReturn
    On Error Resume Next
    If Len(sDefault) = 0 Then
        If TypeName(Application.Selection) = "Range" Then
            sDefault = "=" & Application.Selection.Address
            If Len(sDefault) > 240 Then
                sDefault = "=" & Application.ActiveCell.Address
            End If
        ElseIf TypeName(Application.ActiveSheet) = "Chart" Then
            sDefault = " first select a Worksheet"
        Else
            sDefault = " Select Cell(s) or type address"
        End If
    End If
    Set rInput = Nothing
    For nAttempt = 1 To 3
        vReturn = False
        vReturn = Application.InputBox(sPrompt, sTitle, sDefault, x, y, Type:=0)
        If False = vReturn Or Len(vReturn) = 0 Then
            Exit For
        Else
            sAddr = vReturn
            If Left$(sAddr, 1) = "=" Then sAddr = Mid$(sAddr, 2, 256)
            If Left$(sAddr, 1) = Chr(34) Then sAddr = Mid$(sAddr, 2, 255)
            If Right$(sAddr, 1) = Chr(34) Then sAddr = Left$(sAddr, Len(sAddr) - 1)
            Set rInput = Application.Range(sAddr)
            If rInput Is Nothing Then
                sAddr = Application.ConvertFormula(sAddr, xlR1C1, xlA1)
                Set rInput = Application.Range(sAddr)
                bGotRng = Not rInput Is Nothing
            Else
                bGotRng = True
            End If
        End If
        If bGotRng Then
            If bActivate Then
                On Error GoTo ErrH
                bEvents = Application.EnableEvents
                Application.EnableEvents = False
                If Not Application.ActiveWorkbook Is rInput.Parent.Parent Then
                    rInput.Parent.Parent.Activate
                End If
                If Not Application.ActiveSheet Is rInput.Parent Then
                    rInput.Parent.Activate
                End If
                rInput.Select
            End If
            Exit For
        ElseIf nAttempt < 3 Then
            If MsgBox("Invalid reference, do you want to try again ?", _
                vbOKCancel, sTitle) <> vbOK Then
                Exit For
            End If
        End If
    Next
cleanup:
    On Error Resume Next
    If bEvents Then
        Application.EnableEvents = True
    End If
    GetInputRange = bGotRng
    Exit Function
ErrH:
    Set rInput = Nothing
    bGotRng = False
    Resume cleanup
End Function
Public Function ArrayContains( _
    ByVal value1 As Variant, _
    ByVal array1 As Variant, _
    Optional CaseSensitive As Boolean) _
    As Boolean
   '@Description: This function checks if a value is in an array
    '@Author: Anthony Mancini
    '@Version: 1.0.0
    '@License: MIT
    '@Param: value1 is the value that will be checked if its in the array
    '@Param: array1 is the array
    '@Returns: Returns boolean True if the value is in the array, and false otherwise
    '@Example: =IsInArray("hello", {"one", 2, "hello"}) -> True
    '@Example: =IsInArray("hello", {1, "two", "three"}) -> False
'@AssignedModule vbArcImports
    Dim individualElement As Variant
    If CaseSensitive = True Then value1 = UCase(value1)
    For Each individualElement In array1
        If CaseSensitive = True Then individualElement = UCase(individualElement)
        If individualElement = value1 Then
            ArrayContains = True
            Exit Function
        End If
    Next
    ArrayContains = False
End Function
Function OutlookCheck() As Boolean
'@LastModified 2305220937
'@AssignedModule vbArcImports
    Dim xOLApp As Object
    Set xOLApp = CreateObject("Outlook.Application")
    If Not xOLApp Is Nothing Then
        OutlookCheck = True
        Set xOLApp = Nothing
        Exit Function
    End If
    OutlookCheck = False
End Function

Public Function GetInternetConnectedState() As Boolean
'@LastModified 2305220934
'@INCLUDE DECLARATION InternetGetConnectedState
'@AssignedModule vbArcImports
    GetInternetConnectedState = InternetGetConnectedState(0&, 0&)
End Function
Function PickExcelFile()
'@AssignedModule vbArcImports
    Dim strFile As String
    Dim fd As Office.FileDialog
    Set fd = Application.FileDialog(msoFileDialogFilePicker)
    With fd
        .Filters.Clear
        .Filters.Add "Excel Files", "*.xl*", 1
        .Title = "Choose an Excel file"
        .AllowMultiSelect = False
        .InitialFileName = Environ("USERprofile") & "\Desktop\"
        If .Show = True Then
            strFile = .SelectedItems(1)
            PickExcelFile = strFile
        End If
    End With
End Function
Function PickFolder() As String
'@AssignedModule vbArcImports
    With Application.FileDialog(msoFileDialogFolderPicker)
        .InitialFileName = Environ("USERprofile") & "\Desktop\"
        If .Show = -1 Then
            PickFolder = .SelectedItems(1) & "\"
        Else
            Exit Function
        End If
    End With
End Function
Public Function SelectFolder(Optional initFolder As String) As String
'@AssignedModule vbArcImports
'@INCLUDE PROCEDURE FolderExists
    With Application.FileDialog(msoFileDialogFolderPicker)
        .AllowMultiSelect = False
        .Title = "Select a folder"
        If FolderExists(initFolder) Then .InitialFileName = initFolder
        .Show
        If .SelectedItems.count > 0 Then
            SelectFolder = .SelectedItems.item(1)
        Else
        End If
    End With
End Function
Public Function RoundUp(dblNumToRound As Long, lMultiple As Long) As Double
'@AssignedModule vbArcImports
    Dim asDec   As Variant
    Dim Rounded As Variant

    asDec = CDec(dblNumToRound) / lMultiple
    Rounded = Int(asDec)

    If Rounded <> asDec Then
       Rounded = Rounded + 1
    End If
    RoundUp = Rounded * lMultiple
End Function
Function StringIndentationNormalize(ByVal txt As String, Optional indentation As Long = 4)
'@AssignedModule vbArcImports
'@INCLUDE PROCEDURE RoundUp
    Dim str As Variant
    str = Split(txt, vbNewLine)
    Dim sLine As String
    Dim tmpLine As String
    Dim i As Long
    Dim iSpaces As Long
    Dim tmpSpaes As Long
    For i = LBound(str) To UBound(str)
        sLine = str(i)
        iSpaces = Len(sLine) - Len(LTrim(sLine))
        If iSpaces > 0 Then
            str(i) = Space(RoundUp(iSpaces, indentation)) & Trim(sLine)
        End If
    Next
    If InStr(1, txt, vbNewLine) > 0 Then
        StringIndentationNormalize = Join(str, vbNewLine)
    Else
        StringIndentationNormalize = str
    End If
End Function

Function Parser_Tab(ByVal s As String) As String
'@LastModified 2305220859
    'https://sites.google.com/site/e90e50/random-topics/tool-for-parsing-formulas-in-excel
'@AssignedModule vbArcImports
    Dim SS As String, ch As String
    Dim t As Long, z As Long, x As Long

    SS = String(10000, " ")

    t = 1
    z = 1
    For x = 1 To Len(s)
        ch = Mid(s, x, 1)
        If ch = vbCr And x > 1 Then

            If Mid(s, x - 1, 1) = "(" Then
                z = z + 1
            Else
                If Mid(s, x + 1, 1) = ")" Then
                    z = z - 1
                End If
            End If

            Mid(SS, t, z + 1) = ch & Application.Rept(vbTab, z)

            t = t + z
        Else
            Mid(SS, t, 1) = ch
            t = t + 1
        End If
    Next
    s = Left(SS, t - 1)
    Parser_Tab = s

End Function
Function Array_Const_Wrap(ByRef sArraY As String, DelR As String) As String
'@LastModified 2305220900
    'https://sites.google.com/site/e90e50/random-topics/tool-for-parsing-formulas-in-excel
'@AssignedModule vbArcImports
    Dim v
    If Len(sArraY) > 1 Then
        v = Split(Mid(sArraY, 2, Len(sArraY) - 2), DelR)
        Array_Const_Wrap = "{" & vbCr & Join(v, DelR & vbCr) & vbCr & "}"
    End If
End Function
Function DataFilePartFolder(fileNameWithExtension, Optional IncludeSlash As Boolean) As String
'@AssignedModule vbArcImports
    DataFilePartFolder = Left(fileNameWithExtension, InStrRev(fileNameWithExtension, "\") - 1 - IncludeSlash)
End Function

Public Function DataFilePicker(Optional fileType As Variant, Optional multiSelect As Boolean) As Variant
'@AssignedModule vbArcImports
    Dim blArray As Boolean
    Dim i As Long
    Dim strErrMsg As String, strTitle As String
    Dim varItem As Variant
    If Not IsMissing(fileType) Then
        blArray = IsArray(fileType)
        If Not blArray Then strErrMsg = "Please pass an array in the first parameter of this function!"
    End If
    If strErrMsg = vbNullString Then
        If multiSelect Then strTitle = "Choose one or more files" Else strTitle = "Choose file"
        With Application.FileDialog(msoFileDialogFilePicker)
            .InitialFileName = Environ("USERprofile") & "\Desktop\"
            .AllowMultiSelect = multiSelect
            .Filters.Clear
            If blArray Then .Filters.Add "File type", Replace("*." & Join(fileType, ", *."), "..", ".")
            .Title = strTitle
            If .Show <> 0 Then
                ReDim arrResults(1 To .SelectedItems.count) As Variant
                If blArray Then
                    For Each varItem In .SelectedItems
                        i = i + 1
                        arrResults(i) = varItem
                    Next varItem
                Else
                    arrResults(1) = .SelectedItems(1)
                End If
                DataFilePicker = arrResults
            End If
        End With
    Else
        MsgBox strErrMsg, vbCritical, "Error!"
    End If
End Function

Function DataFilePartExtension(str As String)
'@AssignedModule vbArcImports
    DataFilePartExtension = Mid(str, InStrRev(str, ".") + 1)
End Function

Function DataFilePartName(fileNameWithExtension As String, Optional IncludeExtension As Boolean) As String
'@AssignedModule vbArcImports
    If InStr(1, fileNameWithExtension, "\") > 0 Then
        DataFilePartName = Right(fileNameWithExtension, Len(fileNameWithExtension) - InStrRev(fileNameWithExtension, "\"))
    ElseIf InStr(1, fileNameWithExtension, "/") > 0 Then
        DataFilePartName = Right(fileNameWithExtension, Len(fileNameWithExtension) - InStrRev(fileNameWithExtension, "/"))
    Else
        DataFilePartName = fileNameWithExtension
    End If
    If IncludeExtension = False Then DataFilePartName = Left(DataFilePartName, InStr(1, DataFilePartName, ".") - 1)
End Function

Public Function ArrayToString(SourceArray As Variant, Optional Delimiter As String = ",") As String
    '@INCLUDE ArrayDimensionLength
'@AssignedModule vbArcImports
'@INCLUDE PROCEDURE ArrayDimensionLength
    Dim Temp As String
    Select Case ArrayDimensionLength(SourceArray)
    Case 1
        '* @TODO Created: 21-12-2022 19:34 Author: Anastasiou Alex
        '* @TODO find where i put the flattenArray

        Temp = Join(SourceArray, Delimiter)
    Case 2
        Dim rowIndex As Long
        Dim ColIndex As Long
        For rowIndex = LBound(SourceArray, 1) To UBound(SourceArray, 1)
            For ColIndex = LBound(SourceArray, 2) To UBound(SourceArray, 2)
                Temp = Temp & SourceArray(rowIndex, ColIndex)
                If ColIndex <> UBound(SourceArray, 2) Then Temp = Temp & Delimiter
            Next ColIndex
            If rowIndex <> UBound(SourceArray, 1) Then Temp = Temp & vbNewLine
        Next rowIndex
    End Select
    ArrayToString = Temp
End Function
Public Function InputBoxRange(Optional sTitle As String, Optional sPrompt As String) As Range
'@AssignedModule vbArcImports
    On Error Resume Next
    Set InputBoxRange = Application.InputBox(Title:=sTitle, Prompt:=sPrompt, Type:=8, _
    Default:=IIf(TypeName(Selection) = "Range", Selection.Address, ""))
End Function
Function CreateOrSetSheet(SheetName As String, TargetWorkbook As Workbook) As Worksheet
'@BlogPosted
'@INCLUDE PROCEDURE WorksheetExists
'@AssignedModule vbArcImports
    Dim NewSheet As Worksheet
    If WorksheetExists(SheetName, TargetWorkbook) = True Then
        Set CreateOrSetSheet = TargetWorkbook.Sheets(SheetName)
    Else
        Set CreateOrSetSheet = TargetWorkbook.Sheets.Add
        CreateOrSetSheet.Name = SheetName
    End If
End Function
Function Parser_Formula( _
                        ByVal s As String, _
                        sListSeparator As String, _
                        sRowSeparator As String) As String
'@LastModified 2305220859
'https://sites.google.com/site/e90e50/random-topics/tool-for-parsing-formulas-in-excel
'@AssignedModule vbArcImports
    Const CW As String = "[^=\-+*/();:,.$<>^]"
    Dim M As Object, RE As Object, SM As Object, SB As Object
    Dim v As Variant, t As String

    Set RE = CreateObject("vbscript.regexp")
    RE.IgnoreCase = True
    RE.Global = True

    v = Array( _
        "(""[^""]*""|'[^']*')", _
        "(\{[^}]+})", _
        "(\" & sListSeparator & ")", _
        "(" & CW & "+(?:\." & CW & "+)*\()", _
        "(\))", _
        "(^=|\()", _
        "(.)")

    RE.pattern = Join(v, "|")
    If RE.test(s) Then
        Set M = RE.Execute(s)
        s = ""
        For Each SM In M
            Set SB = SM.SubMatches
            If Len(SB(0) & SB(6)) Then
                t = SB(0) & SB(6)
            ElseIf Len(SB(1)) Then
                t = Array_Const_Wrap(SB(1), sRowSeparator) & vbCr
            ElseIf Len(SB(2) & SB(5)) Then
                t = SB(2) & SB(5) & vbCr
            ElseIf Len(SB(3)) Then
                t = vbCr & SB(3) & vbCr
            ElseIf Len(SB(4)) Then
                t = vbCr & SB(4)
            End If
            s = s & t
        Next
    End If

    RE.pattern = "\r{2,}"
    s = RE.Replace(s, vbCr)

    If Left(s, 1) = vbCr Then s = Mid(s, 1 + Len(vbCr))
    If Right(s, 1) = vbCr Then s = Left(s, Len(s) - Len(vbCr))
    Parser_Formula = s
End Function
Function StringFormatFunctionNested( _
                                   str As String, _
                                   Optional sListSeparator As String = ",", _
                                   Optional sRowSeparator As String = ",") As String
'@AssignedModule vbArcImports
'@INCLUDE PROCEDURE StringIndentationNormalize
'@INCLUDE PROCEDURE ArrayRemoveEmptyElements
    Dim txt As String
    txt = _
        Join( _
            ArrayRemoveEmptyElements( _
                Split( _
                    Parser_Tab( _
                        Parser_Formula( _
                            str, _
                            sListSeparator, _
                            sRowSeparator _
                        ) _
                    ), _
                    vbCr _
                ) _
            ), _
            " _" & vbNewLine _
        )
    StringFormatFunctionNested = StringIndentationNormalize(txt)
End Function
Function IncreaseAllNumbersInString(str As String)
'@AssignedModule vbArcImports
    Dim output As String
    Dim counter As Long
    counter = Len(str)
    Dim i As Long
    For i = 1 To Len(str)
        counter = i
        If IsNumeric(Mid(str, i, 1)) Then
            Do
                output = output & Mid(str, counter, 1)
                counter = counter + 1
            Loop While IsNumeric(Mid(str, counter, 1))
            i = counter - 1
            IncreaseAllNumbersInString = IncreaseAllNumbersInString & val(output + 1)
        Else
            output = output & Mid(str, i, 1)
            IncreaseAllNumbersInString = IncreaseAllNumbersInString & output
        End If
        output = ""
    Next
End Function
Function ArrayRotate(inputArray, Optional ShiftByNum = 1) As Variant
'ShiftByNum = Positive number
    Rem @TODO - Rotate right
    Rem rotates array left (first element to end of array)
    '@INCLUDE Len2
'@AssignedModule vbArcImports
'@INCLUDE PROCEDURE Len2
    Dim UB As Long: UB = UBound(inputArray)
    Dim LB As Long: LB = LBound(inputArray)
    Dim dif As Long: dif = 1 - LB
    Dim NewArray() As Variant
    Dim element As Variant
    Dim counter As Long
    Dim fromStart As Long: fromStart = LB
    For counter = LB To UB
        ReDim Preserve NewArray(1 To counter + dif)
        If counter + ShiftByNum <= UB Then
            NewArray(UBound(NewArray)) = inputArray(counter + ShiftByNum)
        ElseIf UBound(NewArray) <= Len2(inputArray) Then
            NewArray(UBound(NewArray)) = inputArray(fromStart)
            fromStart = fromStart + 1
        End If
    Next
    ArrayRotate = NewArray
End Function
Public Function SortSelectionArray(ByVal TempArray As Variant) As Variant
'@AssignedModule vbArcImports
    Dim MaxVal As Variant
    Dim MaxIndex As Integer
    Dim i As Integer, j As Integer
    For i = UBound(TempArray) To 0 Step -1
        MaxVal = TempArray(i)
        MaxIndex = i
        For j = 0 To i
            If TempArray(j) > MaxVal Then
                MaxVal = TempArray(j)
                MaxIndex = j
            End If
        Next j
        If MaxIndex < i Then
            TempArray(MaxIndex) = TempArray(i)
            TempArray(i) = MaxVal
        End If
    Next i
    SortSelectionArray = TempArray
End Function
 Public Function RegExpReplace( _
                              text As String, _
                              pattern As String, _
                              text_replace As String, _
                              Optional instance_num As Integer = 0, _
                              Optional match_case As Boolean = True) As String
'@AssignedModule vbArcImports
    Dim text_result, text_find As String
    Dim matches_index, pos_start As Integer
    
    On Error GoTo ErrHandle
    text_result = text
    Dim REGEX As RegExp
    Set REGEX = CreateObject("VBScript.RegExp")
      
    REGEX.pattern = pattern
    REGEX.Global = True
    REGEX.MultiLine = True
    
    If True = match_case Then
      REGEX.IgnoreCase = False
    Else
      REGEX.IgnoreCase = True
    End If
    Dim matches As Object
    Set matches = REGEX.Execute(text)
    
    If 0 < matches.count Then
      If (0 = instance_num) Then
        text_result = REGEX.Replace(text, text_replace)
      Else
        If instance_num <= matches.count Then
          pos_start = 1
          For matches_index = 0 To instance_num - 2
            pos_start = InStr(pos_start, text, matches.item(matches_index), vbBinaryCompare) + Len(matches.item(matches_index))
          Next matches_index
    
          text_find = matches.item(instance_num - 1)
          text_result = Left(text, pos_start - 1) & Replace(text, text_find, text_replace, pos_start, 1, vbBinaryCompare)
    
        End If
      End If
    End If
    
    RegExpReplace = text_result
    Exit Function
    
ErrHandle:
    RegExpReplace = CVErr(xlErrValue)
End Function

Function InStrExact( _
                   Start As Long, _
                   sourceText As String, _
                   WordToFind As String, _
                   Optional CaseSensitive As Boolean = False, _
                   Optional AllowAccentedCharacters As Boolean = False) As Long
'@BlogPosted
'@AssignedModule vbArcImports
    Dim x As Long, Str1 As String, str2 As String, pattern As String
    Const UpperAccentsOnly As String = ""
    Const UpperAndLowerAccents As String = ""
    If CaseSensitive Then
        Str1 = sourceText
        str2 = WordToFind
        pattern = "[!A-Za-z0-9]"
        If AllowAccentedCharacters Then pattern = Replace(pattern, "!", "!" & UpperAndLowerAccents)
    Else
        Str1 = UCase(sourceText)
        str2 = UCase(WordToFind)
        pattern = "[!A-Z0-9]"
        If AllowAccentedCharacters Then pattern = Replace(pattern, "!", "!" & UpperAccentsOnly)
    End If
    For x = Start To Len(Str1) - Len(str2) + 1
        If Mid(" " & Str1 & " ", x, Len(str2) + 2) Like pattern & str2 & pattern _
            And Not Mid(Str1, x) Like str2 & "'[" & Mid(pattern, 3) & "*" Then
            InStrExact = x
            Exit Function
        End If
    Next
End Function
Function ArrayFilterLike(inputArray As Variant, MatchThis As String, MatchCase As Boolean)
'@AssignedModule vbArcImports
    Dim OutputArray As Variant
    ReDim OutputArray(1 To 1)
    Dim counter As Long
    counter = 0
    Dim element
    Dim doesMatch As Boolean
    For Each element In inputArray
        doesMatch = IIf(MatchCase, _
                    element Like MatchThis, _
                    UCase(element) Like UCase(MatchThis))
        If doesMatch Then
            counter = counter + 1
            ReDim Preserve OutputArray(1 To counter)
            OutputArray(UBound(OutputArray)) = element
        End If
    Next
    ArrayFilterLike = OutputArray
End Function


Function StringCommentsRemove(ByVal txt As String, RemoveRem As Boolean) As String
'@BlogPosted
'modified from Jacob Hilderbrand's code, found at
'http://www.vbaexpress.com/kb/getarticle.php?kb_id=266
'@AssignedModule vbArcImports
'@INCLUDE PROCEDURE ArrayRemoveEmptyElements
    Dim var As Variant
    ReDim var(0)
    Dim str
        str = Split(txt, vbNewLine)
'        str = ArrayRemoveEmptyElements(str)
    Dim N               As Long
    Dim i               As Long
    Dim j               As Long
    Dim k               As Long
    Dim L               As Long
    Dim lineText        As String
    Dim QUOTES          As Long
    Dim Q               As Long
    Dim StartPos        As Long

    For j = LBound(str) To UBound(str)
        lineText = LTrim(str(j))
        If RemoveRem Then If lineText Like "Rem *" Then GoTo SKIP
        StartPos = 1
Retry:
        N = InStr(StartPos, lineText, "'")
        Q = InStr(StartPos, lineText, """")
        QUOTES = 0
        If Q < N Then
            For L = 1 To N
                If Mid(lineText, L, 1) = """" Then
                    QUOTES = QUOTES + 1
                End If
            Next L
        End If
        If QUOTES = Application.WorksheetFunction.Odd(QUOTES) Then
            StartPos = N + 1
            GoTo Retry:
        Else
            Select Case N
                Case Is = 0
'                    If Len(lineText) > 0 Then
                        var(UBound(var)) = str(j)
                        If j < UBound(str) Then ReDim Preserve var(UBound(var) + 1)
'                    End If
                Case Is = 1
                    '
                Case Is > 1
                    var(UBound(var)) = Left(str(j), N - 1)
                    If j < UBound(str) Then ReDim Preserve var(UBound(var) + 1)
            End Select
        End If
SKIP:
    Next j
'    var = ArrayRemoveEmptyElements(var)
    StringCommentsRemove = Join(var, vbNewLine)
End Function

Public Function IsLineNumberAble( _
                                ByVal str As String) As Boolean
'@AssignedModule vbArcImports
    Dim test As String
    test = Trim(str)
    If Len(test) = 0 Then Exit Function
    If Right(test, 1) = ":" Then Exit Function
    If IsNumeric(Left(test, 1)) Then Exit Function
    If test Like "'*" Then Exit Function
    If test Like "Rem*" Then Exit Function
    If test Like "Dim*" Then Exit Function
    If test Like "Sub*" Then Exit Function
    If test Like "Public*" Then Exit Function
    If test Like "Private*" Then Exit Function
    If test Like "Function*" Then Exit Function
    If test Like "End Sub*" Then Exit Function
    If test Like "End Function*" Then Exit Function
    If test Like "Debug*" Then Exit Function
    IsLineNumberAble = True
End Function
Public Function NumberOfArrayDimensions(arr As Variant) As Byte
'@AssignedModule vbArcImports
    Dim Ndx As Byte
    Dim Res As Long
    On Error Resume Next
    Do
        Ndx = Ndx + 1
        Res = UBound(arr, Ndx)
    Loop Until Err.Number <> 0
    NumberOfArrayDimensions = Ndx - 1
End Function
Function LargestLength(Optional MyObj As Variant) As Long
'@LastModified 2305220815
'@INCLUDE DECLARATION Selection
'@INCLUDE PROCEDURE dp
'@AssignedModule vbArcImports
    LargestLength = 0
    Dim element As Variant
    If IsMissing(MyObj) Then
        If TypeName(Selection) = "Range" Then
            Set MyObj = Selection
        Else
            Exit Function
        End If
    End If
    Select Case TypeName(MyObj)
    Case Is = "String"
        LargestLength = Len(MyObj)

    Case "Variant", "Variant()", "String()", "Collection"
        For Each element In MyObj
            Select Case TypeName(element)
                Case Is = "String", "Integer", "Date"
                    If Len(CStr(element)) > LargestLength Then LargestLength = Len(CStr(element))
                Case Else
                    If element.Width > LargestLength Then LargestLength = element.Width
                End Select
        Next element

    Case Else
    End Select
End Function
Function StringFormatAlignRowsElements(txt As String, AlignAtString As String, SearchFromLeft As Boolean, Optional AlignAtColumn As Long)
'@LastModified 2303171105
'@AssignedModule vbArcImports
    Dim TextLines: TextLines = Split(txt, vbNewLine)
    Dim elementOriginalColumn  As Long
    Dim rightMostColumn        As Long
    Dim lineText               As String
    Dim numberOfSpacesToInsert As Long
    Dim i                      As Long
    
    If AlignAtColumn = 0 Then
        For i = LBound(TextLines) To UBound(TextLines)
            lineText = TextLines(i)
            If SearchFromLeft Then
                elementOriginalColumn = InStr(lineText, AlignAtString)
            Else
                elementOriginalColumn = InStrRev(lineText, AlignAtString)
            End If
            If elementOriginalColumn > rightMostColumn Then rightMostColumn = elementOriginalColumn
        Next
        AlignAtColumn = rightMostColumn
    End If
    
    For i = LBound(TextLines) To UBound(TextLines)
        lineText = TextLines(i)
        If SearchFromLeft Then
            elementOriginalColumn = InStr(lineText, AlignAtString)
        Else
            elementOriginalColumn = InStrRev(lineText, AlignAtString)
        End If
        
        If elementOriginalColumn > 0 Then
            numberOfSpacesToInsert = AlignAtColumn - elementOriginalColumn + IIf(AlignAtString = ":", 1, 0)
            If numberOfSpacesToInsert > 0 Then
                If AlignAtString = ":" Then
                    TextLines(i) = Left(TextLines(i), elementOriginalColumn) & _
                                    Space(numberOfSpacesToInsert) & _
                                    Trim(Mid(TextLines(i), elementOriginalColumn + 1))
                Else
                    TextLines(i) = Left(TextLines(i), elementOriginalColumn - 1) & _
                                    Space(numberOfSpacesToInsert) & _
                                    Mid(TextLines(i), elementOriginalColumn)
                End If
            End If
        End If
    Next

    StringFormatAlignRowsElements = Join(TextLines, vbNewLine)

End Function

Public Function Combine2Array(ByVal arr1 As Variant, ByVal arr2 As Variant) As Variant
    '@INCLUDE NumberOfArrayDimensions
'@AssignedModule vbArcImports
'@INCLUDE PROCEDURE NumberOfArrayDimensions
    Dim LowRowArr1 As Long
    Dim HighRowArr1 As Long
    Dim LowColumnArr1 As Long
    Dim HighColumnArr1 As Long
    Dim NumOfRowsArr1 As Long
    Dim NumOfColumnsArr1 As Long
    Dim LowRowArr2 As Long
    Dim HighRowArr2 As Long
    Dim LowColumnArr2 As Long
    Dim HighColumnArr2 As Long
    Dim NumOfRowsArr2 As Long
    Dim NumOfColumnsArr2 As Long
    Dim output As Variant
    Dim OutputRow As Long
    Dim OutputColumn As Long
    Dim RowIdx As Long
    Dim ColIdx As Long
    If (IsArray(arr1) = False) Or (IsArray(arr2) = False) Then
        Combine2Array = Null
        MsgBox "Both need to be array"
        Exit Function
    End If
    If (NumberOfArrayDimensions(arr1) <> 2) Or (NumberOfArrayDimensions(arr2) <> 2) Then
        Combine2Array = Null
        MsgBox "Both need to be 2D array"
        Exit Function
    End If
    LowRowArr1 = LBound(arr1, 1)
    HighRowArr1 = UBound(arr1, 1)
    LowColumnArr1 = LBound(arr1, 2)
    HighColumnArr1 = UBound(arr1, 2)
    NumOfRowsArr1 = HighRowArr1 - LowRowArr1 + 1
    NumOfColumnsArr1 = HighColumnArr1 - LowColumnArr1 + 1
    LowRowArr2 = LBound(arr2, 1)
    HighRowArr2 = UBound(arr2, 1)
    LowColumnArr2 = LBound(arr2, 2)
    HighColumnArr2 = UBound(arr2, 2)
    NumOfRowsArr2 = HighRowArr2 - LowRowArr2 + 1
    NumOfColumnsArr2 = HighColumnArr2 - LowColumnArr2 + 1
    If NumOfColumnsArr1 <> NumOfColumnsArr2 Then
        Combine2Array = Null
        MsgBox "Both array must have same number of column"
        Exit Function
    End If
    ReDim output(0 To NumOfRowsArr1 + NumOfRowsArr2 - 1, 0 To NumOfColumnsArr1 - 1)
    For RowIdx = LowRowArr1 To HighRowArr1
        OutputColumn = 0
        For ColIdx = LowColumnArr1 To HighColumnArr1
            output(OutputRow, OutputColumn) = arr1(RowIdx, ColIdx)
            OutputColumn = OutputColumn + 1
        Next ColIdx
        OutputRow = OutputRow + 1
    Next RowIdx
    For RowIdx = LowRowArr2 To HighRowArr2
        OutputColumn = 0
        For ColIdx = LowColumnArr2 To HighColumnArr2
            output(OutputRow, OutputColumn) = arr2(RowIdx, ColIdx)
            OutputColumn = OutputColumn + 1
        Next ColIdx
        OutputRow = OutputRow + 1
    Next RowIdx
    Combine2Array = output
End Function

Public Function IndentationCount(str) As Long
'@AssignedModule vbArcImports
    IndentationCount = Len(str) - Len(LTrim(str))
End Function

Function WorkbookProjectProtected(ByVal TargetWorkbook As Workbook) As Boolean
'@BlogPosted
'@AssignedModule vbArcImports
        WorkbookProjectProtected = (TargetWorkbook.VBProject.Protection = 1)
End Function

Function CountOfCharacters(SearchHere As String, FindThis As String)
'@AssignedModule vbArcImports
    CountOfCharacters = (Len(SearchHere) - Len(Replace(SearchHere, FindThis, ""))) / Len(FindThis)
End Function

Function IsCommentLine(ByVal str As String) As Boolean
'@LastModified 2305220757
'@AssignedModule vbArcImports
    str = Trim(str)
    If str Like "'*" Then IsCommentLine = True
    If str Like "Rem *" Then IsCommentLine = True
End Function

Function CommentsMoveToOwnLine(ByVal txt As String) As String
'@BlogPosted
'@INCLUDE PROCEDURE CommentsTrim
'@AssignedModule vbArcImports

    Dim var As Variant
    ReDim var(0)
    Dim str As Variant
        str = Split(txt, vbNewLine)
    
    Dim N               As Long
    Dim i               As Long
    Dim j               As Long
    Dim k               As Long
    Dim L               As Long
    Dim lineText        As String
    Dim QUOTES          As Long
    Dim Q               As Long
    Dim StartPos        As Long
    
    For j = LBound(str) To UBound(str)
        lineText = Trim(str(j))
        StartPos = 1
Retry:
        N = InStr(StartPos, lineText, "'")
        Q = InStr(StartPos, lineText, """")
        QUOTES = 0
        If Q < N Then
            For L = 1 To N
                If Mid(lineText, L, 1) = """" Then
                    QUOTES = QUOTES + 1
                End If
            Next L
        End If
        If QUOTES = Application.WorksheetFunction.Odd(QUOTES) Then
            StartPos = N + 1
            GoTo Retry:
        Else
            Select Case N
                Case Is = 0
                    var(UBound(var)) = str(j)
                    ReDim Preserve var(UBound(var) + 1)
                Case Is = 1
                    var(UBound(var)) = CommentsTrim(Array(str(j)))
                    ReDim Preserve var(UBound(var) + 1)
                Case Is > 1
                    var(UBound(var)) = Space(Len(str(j)) - Len(LTrim(str(j)))) & Mid(lineText, N)
                    ReDim Preserve var(UBound(var) + 1)
                    var(UBound(var)) = Space(Len(str(j)) - Len(LTrim(str(j)))) & Left(lineText, N - 1)
                    ReDim Preserve var(UBound(var) + 1)
            End Select
        End If
    Next j

     CommentsMoveToOwnLine = Join(var, vbNewLine)
     CommentsMoveToOwnLine = Left(CommentsMoveToOwnLine, Len(CommentsMoveToOwnLine) - Len(vbNewLine))
End Function
Public Function IsBlockEnd(strline As String) As Boolean
'@BlogPosted
'@AssignedModule vbArcImports
    strline = Replace(strline, Chr(13), "")
    Dim bOK As Boolean
    Dim nPos As Integer
    Dim strTemp As String
    nPos = InStr(1, strline, " ") - 1
    If nPos < 0 Then nPos = Len(strline)
    strTemp = Left$(strline, nPos)
    Select Case strTemp
    Case "Next", "Loop", "Wend", "Case", "Else", "#Else", "Else:", "#Else:", "ElseIf", "#ElseIf", "#End"
        bOK = True
    Case "End"
        bOK = (Len(strline) > 3)
    End Select
    IsBlockEnd = bOK
End Function

Function TxtAppend(sFile As String, sText As String)
'@BlogPosted
'@AssignedModule vbArcImports
    On Error GoTo ERR_HANDLER
    Dim iFileNumber           As Integer
    iFileNumber = FreeFile
    Open sFile For Append As #iFileNumber
    Print #iFileNumber, sText
    Close #iFileNumber
Exit_Err_Handler:
    Exit Function
ERR_HANDLER:
    MsgBox "The following error has occurred" & vbCrLf & vbCrLf & _
    "Error Number: " & Err.Number & vbCrLf & _
    "Error Source: Txt_Append" & vbCrLf & _
    "Error Description: " & Err.Description & _
    Switch(Erl = 0, "", Erl <> 0, vbCrLf & "Line No: " & Erl) _
    , vbOKOnly + vbCritical, "An Error has Occurred!"
    GoTo Exit_Err_Handler
End Function

Function CommentsTrim(ByVal txt As String) As String
'@LastModified 2305220838
'@BlogPosted
'@INCLUDE PROCEDURE ArrayRemoveEmptyElements
'@AssignedModule vbArcImports
'@INCLUDE PROCEDURE tmp
    Dim var As Variant
    ReDim var(0)
    Dim str As Variant
        str = Split(txt, vbNewLine)
    Dim j As Long
    Dim dif As Long
    Dim lineText As String
    Dim tmp As String
    For j = LBound(str) To UBound(str)
        lineText = Trim(str(j))
        If Left(lineText, 2) = "' " Then
            tmp = Mid(lineText, 2)
            dif = Len(tmp) - Len(LTrim(tmp))
            var(UBound(var)) = Space(dif) & "'" & LTrim(tmp)
            ReDim Preserve var(UBound(var) + 1)
        Else
            var(UBound(var)) = str(j)
            ReDim Preserve var(UBound(var) + 1)
        End If
    Next
    var = ArrayRemoveEmptyElements(var)
    CommentsTrim = Join(var, vbNewLine)
End Function
Public Function ArrayRemoveEmptyElements(varArray As Variant) As Variant
'@LastModified 2305220838
'@BlogPosted
'@AssignedModule vbArcImports
    Dim TempArray() As Variant
    Dim OldIndex As Integer
    Dim NewIndex As Integer
    If UBound(varArray) = -1 Then Exit Function
    ReDim TempArray(LBound(varArray) To UBound(varArray))
    For OldIndex = LBound(varArray) To UBound(varArray)
        If Not Trim(varArray(OldIndex) & " ") = "" Then
            TempArray(NewIndex) = varArray(OldIndex)
            NewIndex = NewIndex + 1
        End If
    Next OldIndex
    ReDim Preserve TempArray(LBound(varArray) To NewIndex - 1)
    ArrayRemoveEmptyElements = TempArray
    varArray = TempArray
End Function


Function ArrayTrim(ByVal arr As Variant)
'@BlogPosted
'@AssignedModule vbArcImports
        Dim i As Long
        For i = LBound(arr) To UBound(arr)
            arr(i) = Trim(arr(i))
        Next
        ArrayTrim = arr
End Function


Public Function IsBlockStart(strline As String) As Boolean
'@BlogPosted
'@AssignedModule vbArcImports
    strline = Replace(strline, Chr(13), "")
    Dim bOK As Boolean
    Dim nPos As Integer
    Dim strTemp As String
    nPos = InStr(1, strline, " ") - 1
    If nPos < 0 Then nPos = Len(strline)
    strTemp = Left$(strline, nPos)
    Select Case strTemp
    Case "With", "For", "Do", "While", "Select", "Case", "Else", "Else:", "#Else", "#Else:", "Sub", "Function", "Property", "Enum", "Type"
        bOK = True
    Case "If", "#If", "ElseIf", "#ElseIf"
        bOK = (Right(strline, 4) = "Then" Or Right(strline, 1) = "_")
    Case "Private", "Public", "Friend"
        nPos = InStr(1, strline, " Static ")
        If nPos Then
            nPos = InStr(nPos + 7, strline, " ")
        Else
            nPos = InStr(Len(strTemp) + 1, strline, " ")
        End If
        On Error GoTo SKIP
        Select Case Mid$(strline, nPos + 1, InStr(nPos + 1, strline, " ") - nPos - 1)
        Case "Sub", "Function", "Property", "Enum", "Type"
            bOK = True
        End Select
SKIP:
        On Error GoTo 0
    End Select
    IsBlockStart = bOK
End Function


Public Sub dp(var As Variant)
'@LastModified 2305220815
'@BlogPosted
'@INCLUDE DECLARATION i
'@INCLUDE PROCEDURE PrintXML
'@INCLUDE PROCEDURE printRange
'@INCLUDE PROCEDURE printArray
'@INCLUDE PROCEDURE printCollection
'@INCLUDE PROCEDURE printDictionary
'@AssignedModule vbArcImports
    Dim element     As Variant
    Dim i As Long
'    Debug.Print TypeName(var)
    Select Case TypeName(var)
    Case Is = "String", "Long", "Integer", "Double", "Boolean"
        Debug.Print var
    Case Is = "Variant()", "String()", "Long()", "Integer()"
        printArray var
    Case Is = "Collection"
        printCollection var
    Case Is = "Dictionary"
        printDictionary var
    Case Is = "Range"
        printRange var
    Case Is = "Date"
        Debug.Print var
    Case Is = "IXMLDOMElement"
        PrintXML var
    Case Else
    End Select
End Sub

Sub PrintXML(var)
'@BlogPosted
'@AssignedModule vbArcImports
    Debug.Print var.xml
End Sub
'Sub PrintXML(NodeList)
''   Parse all levels recursively
'    Dim obj
'    On Error Resume Next
'    Set obj = NodeList.ChildNodes
'    If Err.Number = 0 Then
'
'    Else
'        Err.clear
'        Set obj = NodeList.NodeList
'        If Err.Number <> 0 Then: Err.clear: Exit Sub
'    End If
'    On Error GoTo 0
'    Dim child
'    For Each child In obj
'        If Not Left(child.nodename, 1) = "#" Then Debug.Print child.nodename & ":" & child.TEXT
'        If child.ChildNodes.Length > 0 Then PrintXML child.ChildNodes
'    Next
'End Sub

Public Sub PrintLinesContaining(F)
'@AssignedModule vbArcImports
'@INCLUDE PROCEDURE ProcedureCode
'@INCLUDE PROCEDURE ProceduresOfModule
'@INCLUDE PROCEDURE collectionToString
'@INCLUDE PROCEDURE WorkbookProjectProtected
'@INCLUDE PROCEDURE dp
'@INCLUDE CLASS aWorkbook
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aCollection
    Dim i As Long
    Const ModuleString = vbNewLine & "    M|"
    Const Procedurestring = "" & vbTab & "P" & "|" & "---" & "| "
    Const FoundString = "" & vbTab & "t" & "|" & vbTab & " |" & "---" & "| "
    Dim x, y, s, p As Variant
    Dim Module As VBComponent
    On Error Resume Next
    Dim out As New Collection
    For Each x In Array(Workbooks, AddIns)
        For Each y In x
            If Not WorkbookProjectProtected(Workbooks(y.Name)) Then
                If Err.Number = 0 Then
                    If UBound(Filter(Split(aWorkbook.Init(Workbooks(y.Name)).Code, vbNewLine), F, True, vbTextCompare)) > -1 Then

                        out.Add ""
                        out.Add String(50, "-")
                        out.Add "| " & y.Name
                        out.Add String(50, "-")

                        For Each Module In Workbooks(y.Name).VBProject.VBComponents
                            If UBound(Filter(Split(aModule.Init(Module).Code, vbNewLine), F, True, vbTextCompare)) > -1 Then
                                out.Add ModuleString & Module.Name
                                If Module.CodeModule.CountOfDeclarationLines > 0 Then
                                    s = Filter(Split(Module.CodeModule.Lines(1, Module.CodeModule.CountOfDeclarationLines), vbNewLine), F, True, vbTextCompare)
                                    out.Add FoundString & Trim(s(i))
                                End If
                                For Each p In ProceduresOfModule(Module)
                                    If UBound(Filter(Split(ProcedureCode(Workbooks(y.Name), Module, CStr(p)), vbNewLine), F, True, vbTextCompare)) > -1 Then
                                        out.Add Procedurestring & CStr(p)
                                        s = Filter(Split(ProcedureCode(Workbooks(y.Name), Module, CStr(p)), vbNewLine), F, True, vbTextCompare)
                                        For i = 0 To UBound(s)
                                            out.Add FoundString & Trim(s(i))
                                        Next i
                                    End If
                                Next p
                            End If
                        Next Module
                    End If
                End If
            End If
            Err.Clear
        Next y
    Next x
    dp aCollection.Init(out).ToString(vbNewLine) 'collectionToString(out, vbNewLine)
End Sub

Public Sub printRange(var As Variant)
'@BlogPosted
'@INCLUDE PROCEDURE Combine2Array
'@INCLUDE PROCEDURE dp
'@AssignedModule vbArcImports
    If var.Areas.count = 1 Then
        dp var.Value
    Else
        Dim out As Variant
        Dim Temp As Variant
        Dim i As Long
        For i = 1 To var.Areas.count
            Temp = var.Areas(i).Value
            If IsEmpty(out) Then
                out = Temp
            Else
                out = Combine2Array(out, Temp)
            End If
        Next
        dp out
    End If
End Sub

Private Sub printArray(var As Variant)
'@BlogPosted
'@INCLUDE PROCEDURE DPH
'@INCLUDE PROCEDURE ArrayDimensions
'@AssignedModule vbArcImports
'@INCLUDE PROCEDURE dp
    Dim element
    If ArrayDimensions(var) = 1 Then
'        Debug.Print Join(var, vbNewLine)
        For Each element In var
            dp element
        Next
    ElseIf ArrayDimensions(var) > 1 Then
        DPH var
    End If
End Sub

Private Sub printCollection(var As Variant)
'@BlogPosted
'@INCLUDE PROCEDURE dp
'@AssignedModule vbArcImports
    Dim elem        As Variant
    For Each elem In var
        dp elem
    Next elem
End Sub

Private Sub printDictionary(var As Variant)
'@BlogPosted
'@INCLUDE PROCEDURE dp
'@AssignedModule vbArcImports


'@TODO detect error cause I met when printing a dic from JSON related modules

    Dim i As Long: Dim iCount As Long
    Dim arrKeys
    Dim sKey        As String
    Dim varItem
    
    Dim Key As Variant
    For Each Key In var.Keys
        dp var(Key)
        
    Next Key
    
'    Stop
    
'    With var
'        iCount = .Count
'        arrKeys = .Keys
'        iCount = UBound(arrKeys, 1)
'        For i = 0 To iCount
'            sKey = arrKeys(i)
'            Debug.Print "Key " & sKey
'            Debug.Print String(20, "-")
'            If IsObject(.item(sKey)) Then
'                dp (.item(sKey))
'            Else
'                Debug.Print "Key " & sKey & " : "
'                dp .item(sKey)
'            End If
'        Next i
'    End With
End Sub

Private Sub DPH(ByVal Hairetu, Optional HyoujiMaxNagasa%, Optional HairetuName$)
'@BlogPosted
'https://gist.github.com/YujiFukami/15c922d41ff06c9b12ad450a14131080#file-
'@INCLUDE PROCEDURE DebugPrintHairetu
'@AssignedModule vbArcImports
    Call DebugPrintHairetu(Hairetu, HyoujiMaxNagasa, HairetuName)
End Sub

Public Function ArrayDimensions(ByVal vArray As Variant) As Long
'@BlogPosted
'@AssignedModule vbArcImports
    Dim dimnum      As Long
    Dim ErrorCheck As Long
    On Error GoTo FinalDimension
    For dimnum = 1 To 60000
        ErrorCheck = LBound(vArray, dimnum)
    Next
FinalDimension:
    ArrayDimensions = dimnum - 1
End Function

Private Sub DebugPrintHairetu(ByVal Hairetu, Optional HyoujiMaxNagasa%, Optional HairetuName$)
'@BlogPosted
'https://gist.github.com/YujiFukami/15c922d41ff06c9b12ad450a14131080#file-
'@INCLUDE PROCEDURE ShortenToByteCharacters
'@AssignedModule vbArcImports


    Dim i&, j&, k&, M&, N&
    Dim TateMin&, TateMax&, YokoMin&, YokoMax&
    Dim WithTableHairetu
    Dim NagasaList, MaxNagasaList
    Dim NagasaOnajiList
    Dim OutputList
    Const SikiriMoji$ = "|"
    Dim Jigen2%
    On Error Resume Next
    Jigen2 = UBound(Hairetu, 2)
'    On Error GoTo 0

    If Jigen2 = 0 Then
        Hairetu = Application.Transpose(Hairetu)
    End If
    TateMin = LBound(Hairetu, 1)
    TateMax = UBound(Hairetu, 1)
    YokoMin = LBound(Hairetu, 2)
    YokoMax = UBound(Hairetu, 2)
    ReDim WithTableHairetu(1 To TateMax - TateMin + 1 + 1, 1 To YokoMax - YokoMin + 1 + 1)
    For i = 1 To TateMax - TateMin + 1
        WithTableHairetu(i + 1, 1) = TateMin + i - 1
        For j = 1 To YokoMax - YokoMin + 1
            WithTableHairetu(1, j + 1) = YokoMin + j - 1
            WithTableHairetu(i + 1, j + 1) = Hairetu(i - 1 + TateMin, j - 1 + YokoMin)
        Next j
    Next i
    N = UBound(WithTableHairetu, 1)
    M = UBound(WithTableHairetu, 2)
    ReDim NagasaList(1 To N, 1 To M)
    ReDim MaxNagasaList(1 To M)
    Dim tmpStr$
    For j = 1 To M
        For i = 1 To N
            If j > 1 And HyoujiMaxNagasa <> 0 Then
                tmpStr = WithTableHairetu(i, j)
                WithTableHairetu(i, j) = ShortenToByteCharacters(tmpStr, HyoujiMaxNagasa)
            End If
            NagasaList(i, j) = LenB(StrConv(WithTableHairetu(i, j), vbFromUnicode))
            MaxNagasaList(j) = WorksheetFunction.Max(MaxNagasaList(j), NagasaList(i, j))
        Next i
    Next j
    ReDim NagasaOnajiList(1 To N, 1 To M)
    Dim TmpMaxNagasa&
    For j = 1 To M
        TmpMaxNagasa = MaxNagasaList(j)
        For i = 1 To N
            NagasaOnajiList(i, j) = WithTableHairetu(i, j) & WorksheetFunction.Rept(" ", TmpMaxNagasa - NagasaList(i, j))
        Next i
    Next j
    ReDim OutputList(1 To N)
    For i = 1 To N
        For j = 1 To M
            If j = 1 Then
                OutputList(i) = NagasaOnajiList(i, j)
            Else
                OutputList(i) = OutputList(i) & SikiriMoji & NagasaOnajiList(i, j)
            End If
        Next j
    Next i
    Debug.Print HairetuName
    For i = 1 To N
        Debug.Print OutputList(i)
    Next i
End Sub


Public Function ShortenToByteCharacters(Mojiretu$, ByteNum%)
'@BlogPosted
'https://gist.github.com/YujiFukami/15c922d41ff06c9b12ad450a14131080#file-
'@INCLUDE PROCEDURE CalculateByteCharacters
'@INCLUDE PROCEDURE TextDecomposition
'@AssignedModule vbArcImports
    Dim OriginByte%
    Dim output
    OriginByte = LenB(StrConv(Mojiretu, vbFromUnicode))
    If OriginByte <= ByteNum Then
        output = Mojiretu
    Else
        Dim RuikeiByteList, BunkaiMojiretu
        RuikeiByteList = CalculateByteCharacters(Mojiretu)
        BunkaiMojiretu = TextDecomposition(Mojiretu)
        Dim AddMoji$
        AddMoji = "."
        Dim i&, N&
        N = Len(Mojiretu)
        For i = 1 To N
            If RuikeiByteList(i) < ByteNum Then
                output = output & BunkaiMojiretu(i)
            ElseIf RuikeiByteList(i) = ByteNum Then
                If LenB(StrConv(BunkaiMojiretu(i), vbFromUnicode)) = 1 Then
                    output = output & AddMoji
                Else
                    output = output & AddMoji & AddMoji
                End If
                Exit For
            ElseIf RuikeiByteList(i) > ByteNum Then
                output = output & AddMoji
                Exit For
            End If
        Next i
    End If
    ShortenToByteCharacters = output
End Function

Private Function CalculateByteCharacters(Mojiretu$)
'@BlogPosted
'https://gist.github.com/YujiFukami/15c922d41ff06c9b12ad450a14131080#file-
'@AssignedModule vbArcImports
    Dim MojiKosu%
    MojiKosu = Len(Mojiretu)
    Dim output
    ReDim output(1 To MojiKosu)
    Dim i&
    Dim TmpMoji$
    For i = 1 To MojiKosu
        TmpMoji = Mid(Mojiretu, i, 1)
        If i = 1 Then
            output(i) = LenB(StrConv(TmpMoji, vbFromUnicode))
        Else
            output(i) = LenB(StrConv(TmpMoji, vbFromUnicode)) + output(i - 1)
        End If
    Next i
    CalculateByteCharacters = output
End Function

Private Function TextDecomposition(Mojiretu$)
'@BlogPosted
'https://gist.github.com/YujiFukami/15c922d41ff06c9b12ad450a14131080#file-
'@AssignedModule vbArcImports
    Dim i&, N&
    Dim output
    N = Len(Mojiretu)
    ReDim output(1 To N)
    For i = 1 To N
        output(i) = Mid(Mojiretu, i, 1)
    Next i
    TextDecomposition = output
End Function

Function DpHeader( _
                 str As Variant, _
                 Optional lvl As Integer = 1, _
                 Optional Character As String = "'", _
                 Optional Top As Boolean, _
                 Optional Bottom As Boolean) As String
'@BlogPosted
'@INCLUDE PROCEDURE LargestLength
'@AssignedModule vbArcImports
    If lvl < 1 Then lvl = 1
    If Character = "" Then Character = "'"
    Dim indentation As Integer
    indentation = (lvl * 4) - 4 + 1
    Dim quote As String: quote = "'"
    Dim s As String
    Dim element As Variant
    If Top = True Then s = vbNewLine & quote & String(indentation + LargestLength(str), Character) & vbNewLine
    If TypeName(str) <> "String" Then
        For Each element In str
            s = s & quote & Character & Space(indentation) & element & vbNewLine
        Next
    Else
        s = s & quote & String(indentation, Character) & str
    End If
    If Bottom = True Then s = s & quote & String(indentation + LargestLength(str), Character)
    DpHeader = s
End Function


Sub FindCode(s As String)
'@LastModified 2305231016
'@INCLUDE CLASS aTreeView
'@INCLUDE USERFORM uCodeFinder
'@AssignedModule vbArcImports
    Load uCodeFinder
    uCodeFinder.Show
    With aTreeView.Init(uCodeFinder.TreeView1)
        .FindCodeEverywhere s
        .TreeviewAssignProjectImages
        .ExpandAll
    End With
    uCodeFinder.TextBox1.text = s
'    uCodeFinder.Show
End Sub




'aDesigner	Class


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Class      : aDesigner
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 04-05-2023 12:18    Alex
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


Option Explicit

Private oModule As VBComponent

Function Active() As aDesigner
'@AssignedModule aDesigner
'@INCLUDE CLASS aDesigner
    Set Active = Me
    Class_Initialize
End Function

Private Sub Class_Initialize()
'@AssignedModule aDesigner
'@INCLUDE PROCEDURE ActiveModule
'@INCLUDE CLASS aDesigner
    Set oModule = ActiveModule
    If oModule.Type <> vbext_ct_MSForm Then End
End Sub

Private Sub Class_Terminate()
'exit
'@AssignedModule aDesigner
'@INCLUDE CLASS aDesigner
End Sub

Function SelectedControl() As MSForms.control
'@AssignedModule aDesigner
'@INCLUDE CLASS aDesigner
    Dim col As New Collection
    Set col = SelectedControls
    If col.count = 1 Then
        Set SelectedControl = col(1)
    End If
End Function

Function SelectedControls() As Collection
'@AssignedModule aDesigner
'@INCLUDE CLASS aCollection
'@INCLUDE CLASS aDesigner
    Dim ctl    As control
    Dim out As New Collection
    For Each ctl In oModule.Designer.Selected
        out.Add ctl
    Next ctl
    
    Dim ac As New aCollection
    Set out = ac.Init(out).Reverse.Items
    Set SelectedControls = out
End Function

Function SelectedFrameOrMultipageControl() As MSForms.control
'@AssignedModule aDesigner
'@INCLUDE CLASS aDesigner
    Dim col As New Collection
    Set col = SelectedFrameOrMultipageControls
    If col.count = 1 Then
        Set SelectedFrameOrMultipageControl = col(1)
    End If
End Function


Function SelectedFrameOrMultipageControls() As Collection
'@AssignedModule aDesigner
'@INCLUDE CLASS aCollection
'@INCLUDE CLASS aDesigner
    Dim ctl       As MSForms.control
    Dim subctl    As MSForms.control
    Dim out As New Collection
    For Each ctl In SelectedControls
        If InStr("FrameMultiPage", TypeName(ctl)) > 0 Then
            For Each subctl In ctl.Controls
                If InStr("FrameMultiPage", TypeName(subctl)) = 0 And subctl.InSelection Then
                    out.Add subctl
                End If
            Next
        End If
    Next ctl
    Dim ac As New aCollection
    Set out = ac.Init(out).Reverse.Items
    Set SelectedFrameOrMultipageControls = out
End Function

'Function RealActiveControl(oForm As Variant) As MSForms.control
''Jaafar Tribak
'
'    Dim oControl As MSForms.control
'
'    On Error Resume Next
'    Set oControl = oForm.ActiveControl
'    Do
'        Set oControl = CallByName(oControl, "ActiveControl", VbGet)
'    Loop Until TypeName(oControl) <> "Frame"
'    Set RealActiveControl = oControl
'End Function

Sub RemoveCaption()
'@AssignedModule aDesigner
'@INCLUDE CLASS aDesigner
    Dim c As MSForms.control
    For Each c In SelectedControls
        c.Caption = ""
    Next
End Sub

Sub SetHandCursor()
'@AssignedModule aDesigner
'@INCLUDE CLASS aDesigner
    Dim ctr As MSForms.control, ctr2 As MSForms.control
    For Each ctr In SelectedControls
        AssignHandCursor ctr
    Next
End Sub

Sub SetHandCursorToSubControls()
'@AssignedModule aDesigner
'@INCLUDE CLASS aDesigner
    Dim ctr As MSForms.control, ctr2 As MSForms.control
    For Each ctr In SelectedFrameOrMultipageControls
        AssignHandCursor ctr
    Next
End Sub

Private Sub AssignHandCursor(control As MSForms.control)
'@AssignedModule aDesigner
'@INCLUDE CLASS aDesigner
    On Error GoTo Catch
    With control
        .MouseIcon = LoadPicture(ThisWorkbook.Path & "\img\Hand Cursor Pointer.ico")
        .MousePointer = fmMousePointerCustom
    End With
Catch:
End Sub

Sub SwitchNames()
'@AssignedModule aDesigner
'@INCLUDE CLASS aDesigner
    If SelectedControls.count <> 2 Then Exit Sub

    Dim ctrls As Collection
    Set ctrls = SelectedControls
    If ctrls.count <> 2 Then Exit Sub
    Dim tmp1 As String
    tmp1 = ctrls(1).Name
    Dim tmp2 As String
    tmp2 = ctrls(2).Name
    ctrls(1).Name = "tmp1"
    ctrls(2).Name = "tmp2"
    ctrls(1).Name = tmp2
    ctrls(2).Name = tmp1
End Sub

Sub SwitchPositions()
'@AssignedModule aDesigner
'@INCLUDE CLASS aDesigner
    If SelectedControls.count <> 2 Then
        MsgBox "Select exactly 2 controls to swirtch their position"
        Exit Sub
    End If
    Dim ctrls As Collection
    Set ctrls = SelectedControls
    If ctrls.count <> 2 Then Exit Sub
    Dim left1 As Long, left2 As Long
    Dim top1 As Long, top2 As Long
    left1 = ctrls(1).Left
    top1 = ctrls(1).Top
    left2 = ctrls(2).Left
    top2 = ctrls(2).Top
    ctrls(1).Left = left2
    ctrls(1).Top = top2
    ctrls(2).Left = left1
    ctrls(2).Top = top1
End Sub


Sub ReplaceCommandButtonWithLabel()
'@AssignedModule aDesigner
'@INCLUDE PROCEDURE tmp
'@INCLUDE CLASS aDesigner
    Dim ctr As MSForms.control, ctr2 As MSForms.control
    Dim lbl As MSForms.Label
    Dim ctrName As String
    Dim col As New Collection: Set col = SelectedControls
    For Each ctr In col
        Set lbl = oModule.Designer.Controls.Add("Forms.label.1")
        ctrName = ctr.Name
        ctr.Name = "tmp" & ctr.Name
        With lbl
            .Name = ctrName
            .Caption = ctr.Caption
            .Tag = ctr.Tag
            .Top = ctr.Top
            .Left = ctr.Left
            .Width = ctr.Width
            .Height = ctr.Height
            .BackColor = ctr.BackColor
            .ForeColor = ctr.ForeColor
            .Font.Size = ctr.Font.Size
            .Font.Name = ctr.Font.Name
        End With
        AssignHandCursor lbl
        oModule.Designer.Controls.Remove ctr.Name
    Next
End Sub

Sub CenterLabelCaption()
'@AssignedModule aDesigner
'@INCLUDE CLASS aDesigner
    Dim lbl As MSForms.Label
    Set lbl = SelectedControl
    lbl.Font.Size = IIf(lbl.SpecialEffect = fmSpecialEffectFlat, 18 / 22, 16 / 22) * lbl.Height
    lbl.TextAlign = fmTextAlignCenter
End Sub

Sub EditObjectProperties(ParamArray Args() As Variant)
    Rem EditObjectProperties "left",0,"top",0
'@AssignedModule aDesigner
'@INCLUDE CLASS aDesigner
    Dim obj As control: Set obj = SelectedControl
    If obj Is Nothing Or SelectedControls.count <> 1 Then Exit Sub
    If Not WorksheetFunction.IsEven(UBound(Args)) Then Exit Sub
    Dim i As Long: i = 0
    Do While i < UBound(Args)
        CallByName obj, Args(i), VbLet, _
                    IIf(IsNumeric(Args(i + 1)), _
                    CLng(Args(i + 1)), _
                    Args(i + 1))
        i = i + 2
    Loop
End Sub

Sub EditObjectsProperty(objProperty As String, ParamArray Args() As Variant)
'@AssignedModule aDesigner
'@INCLUDE PROCEDURE Toast
'@INCLUDE CLASS aDesigner
    Dim obj As New Collection: Set obj = SelectedControls
    If obj.count <> UBound(Args) + 1 Then
        Toast "selected controls count <> arguements count"
        Exit Sub
    End If
    Dim ArgItem
    Dim i As Long
    i = obj.count
    Dim element As Variant
    For Each element In obj
        CallByName element, objProperty, VbLet, _
                    IIf(IsNumeric(Args(i - 1)), _
                    CLng(Args(i - 1)), _
                    Args(i - 1))
        i = i - 1
    Next
End Sub

Sub RenameControlAndCode()
'@AssignedModule aDesigner
'@INCLUDE PROCEDURE InputboxString
'@INCLUDE CLASS aDesigner
    Dim ctr As MSForms.control: Set ctr = SelectedControl
    If ctr Is Nothing Then Exit Sub
    Dim OldName As String: OldName = ctr.Name
    Dim NewName As String: NewName = InputboxString
    If NewName = "" Then Exit Sub
    ctr.Name = NewName
    Dim CountOfLines As Long: CountOfLines = oModule.CodeModule.CountOfLines
    If CountOfLines = 0 Then Exit Sub
    Dim strline As String
    Dim i As Long
    For i = 1 To CountOfLines
        strline = oModule.CodeModule.Lines(i, 1)
        If InStr(1, strline, " " & OldName & "_") > 0 Then
            oModule.CodeModule.ReplaceLine (i), Replace(strline, OldName, NewName)
        End If
    Next
End Sub

Sub SortControlsHorizontally()
'@AssignedModule aDesigner
'@INCLUDE CLASS aDesigner
    SortControls False
End Sub

Sub SortControlsVertivally()
'@AssignedModule aDesigner
'@INCLUDE CLASS aDesigner
    SortControls True
End Sub

Private Sub SortControls(Optional SortVertically As Boolean = True)
    Rem call from immediate window while looking at userform
'@AssignedModule aDesigner
'@INCLUDE CLASS aCollection
'@INCLUDE CLASS aDesigner
    Dim ctr As MSForms.control
    Dim coll As New Collection
    Dim lastTop As Long
    Dim lastLeft As Long
    Dim element As Variant
    For Each element In SelectedControls
        coll.Add element.Name
    Next
    Set coll = aCollection.Init(coll).Sort.Items
    lastTop = 2000
    For Each element In coll
        If oModule.Designer.Controls(element).Top < lastTop Then lastTop = oModule.Designer.Controls(element).Top
        If oModule.Designer.Controls(element).Left < lastLeft Then lastLeft = oModule.Designer.Controls(element).Left
    Next
    For Each element In coll
        If SortVertically = True Then
            lastTop = lastTop + oModule.Designer.Controls(element).Height + 6
        Else
            lastLeft = lastLeft + oModule.Designer.Controls(element).Width + 6
        End If
        oModule.Designer.Controls(element).Top = lastTop
        oModule.Designer.Controls(element).Left = lastLeft
    Next
End Sub

Public Sub CopyControlProperties()
'@AssignedModule aDesigner
'@INCLUDE PROCEDURE Min
'@INCLUDE PROCEDURE CreateOrSetSheet
'@INCLUDE CLASS aDesigner
    If SelectedControls.count <> 1 Then Exit Sub
    Dim ctr As control: Set ctr = SelectedControl
    Dim ws As Worksheet: Set ws = CreateOrSetSheet("CopyControlProperties", ThisWorkbook)
    Dim PropertiesArray As Variant
    PropertiesArray = Array("Accelerator", "Alignment", "AutoSize", "AutoTab", "BackColor", "BackStyle", "BorderColor", "BorderStyle", "BoundColumn", _
    "Caption", "Children", "columnCount", "ColumnHeads", "ColumnWidths", "ControlSource", "ControlTipText", "Cycle", "DrawBuffer", "Enabled", "EnterKeyBehavior", "Expanded", _
    "FirstSibling", "FontBold", "FontSize", "ForeColor", "FullPath", "GroupName", "Height", "HelpContextID", "KeepScrollBarsVisible", "LargeChange", "LastSibling", "LineStyle", "ListRows", "Locked", _
    "Max", "MaxLength", "Min", "MouseIcon", "MousePointer", "MultiLine", "MultiSelect", "Next", "Nodes", "Orientation", _
    "Parent", "PasswordChar", "PathSeparator", "Picture", "PictureAlignment", "PictureSizeMode", "PictureTiling", "Previous", "RightToLeft", "Root", "RowSource", _
    "ScrollBars", "ScrollHeight", "ScrollLeft", "ScrollTop", "ScrollWidth", "Selected", "SelectedItem", "ShowModal", "SmallChange", "Sorted", "SpecialEffect", "StartUpPosition", _
    "Style", "Tag", "Text", "TextColumn", "TripleState", "WhatsThisHelp", "Width", "Zoom")
    If ws.Range("A1") = "" Then ws.Range("A1").Resize(UBound(PropertiesArray) + 1) = WorksheetFunction.Transpose(PropertiesArray)
    Dim PropertiesRange As Range: Set PropertiesRange = ws.Range("A1").CurrentRegion.Resize(, 1)
    Dim Property As Range
    On Error Resume Next
    For Each Property In PropertiesRange
        Property.offset(0, 1) = CallByName(ctr, Property.Value, VbGet)
    Next
End Sub

Public Sub PasteControlProperties()
'@AssignedModule aDesigner
'@INCLUDE PROCEDURE Toast
'@INCLUDE CLASS aDesigner
    Dim control As MSForms.control
    Dim Controls As Collection: Set Controls = SelectedControls
    If Controls.count = 0 Then Exit Sub
    Dim ws As Worksheet: Set ws = ThisWorkbook.Sheets("CopyControlProperties")
    If ws.Columns(2).SpecialCells(xlCellTypeConstants).count = 0 Then
        Toast "You haven't saved properties before"
        Exit Sub
    End If
    Dim PropertiesRange As Range: Set PropertiesRange = ws.Range("A1").CurrentRegion.Resize(, 1)
    Dim Property As Range
    On Error Resume Next
    For Each control In Controls
        For Each Property In PropertiesRange
            CallByName control, Property.Value, VbLet, Property.offset(0, 1).Value
        Next
    Next
End Sub



Public Sub CopySubControlProperties()
'@AssignedModule aDesigner
'@INCLUDE PROCEDURE Min
'@INCLUDE PROCEDURE CreateOrSetSheet
'@INCLUDE CLASS aDesigner
    If SelectedFrameOrMultipageControls.count <> 1 Then Exit Sub
    Dim ctr As control: Set ctr = SelectedFrameOrMultipageControl
    Dim ws As Worksheet: Set ws = CreateOrSetSheet("CopyControlProperties", ThisWorkbook)
    Dim PropertiesArray As Variant
    PropertiesArray = Array("Accelerator", "Alignment", "AutoSize", "AutoTab", "BackColor", "BackStyle", "BorderColor", "BorderStyle", "BoundColumn", _
    "Caption", "Children", "columnCount", "ColumnHeads", "ColumnWidths", "ControlSource", "ControlTipText", "Cycle", "DrawBuffer", "Enabled", "EnterKeyBehavior", "Expanded", _
    "FirstSibling", "FontBold", "FontSize", "ForeColor", "FullPath", "GroupName", "Height", "HelpContextID", "KeepScrollBarsVisible", "LargeChange", "LastSibling", "LineStyle", "ListRows", "Locked", _
    "Max", "MaxLength", "Min", "MouseIcon", "MousePointer", "MultiLine", "MultiSelect", "Next", "Nodes", "Orientation", _
    "Parent", "PasswordChar", "PathSeparator", "Picture", "PictureAlignment", "PictureSizeMode", "PictureTiling", "Previous", "RightToLeft", "Root", "RowSource", _
    "ScrollBars", "ScrollHeight", "ScrollLeft", "ScrollTop", "ScrollWidth", "Selected", "SelectedItem", "ShowModal", "SmallChange", "Sorted", "SpecialEffect", "StartUpPosition", _
    "Style", "Tag", "Text", "TextColumn", "TripleState", "WhatsThisHelp", "Width", "Zoom")
    If ws.Range("A1") = "" Then ws.Range("A1").Resize(UBound(PropertiesArray) + 1) = WorksheetFunction.Transpose(PropertiesArray)
    Dim PropertiesRange As Range: Set PropertiesRange = ws.Range("A1").CurrentRegion.Resize(, 1)
    Dim Property As Range
    On Error Resume Next
    For Each Property In PropertiesRange
        Property.offset(0, 1) = CallByName(ctr, Property.Value, VbGet)
    Next
End Sub

Public Sub PasteSubControlProperties()
'@AssignedModule aDesigner
'@INCLUDE PROCEDURE Toast
'@INCLUDE CLASS aDesigner
    Dim control As MSForms.control
    Dim Controls As Collection: Set Controls = SelectedControls
    If Controls.count = 0 Then Exit Sub
    Dim ws As Worksheet: Set ws = ThisWorkbook.Sheets("CopyControlProperties")
    If ws.Columns(2).SpecialCells(xlCellTypeConstants).count = 0 Then
        Toast "You haven't saved properties before"
        Exit Sub
    End If
    Dim PropertiesRange As Range: Set PropertiesRange = ws.Range("A1").CurrentRegion.Resize(, 1)
    Dim Property As Range
    On Error Resume Next
    For Each control In Controls
        For Each Property In PropertiesRange
            CallByName control, Property.Value, VbLet, Property.offset(0, 1).Value
        Next
    Next
End Sub


Public Sub addFrameFormCode()
'@AssignedModule aDesigner
'@INCLUDE PROCEDURE CLIP
'@INCLUDE PROCEDURE Toast
'@INCLUDE PROCEDURE Reframe
'@INCLUDE PROCEDURE dp
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aDesigner
'@INCLUDE DECLARATION Emitter
    Dim s As String
    s = s & vbNewLine & "Private WithEvents Emitter As EventListeneRemitter"
    s = s & vbNewLine & ""

    s = s & vbNewLine & "Private Sub Emitter_LabelMouseOut(Label As MSForms.Label)"
    s = s & vbNewLine & "    If InStr(1, Label.Tag, " & """" & "reframe" & """" & ", vbTextCompare) > 0 Then"
    s = s & vbNewLine & "        If Label.BackColor <> &H80B91E Then Label.BackColor = &H534848"
    s = s & vbNewLine & "    End If"
    s = s & vbNewLine & "End Sub"
    s = s & vbNewLine & ""
    s = s & vbNewLine & "Private Sub Emitter_LabelMouseOver(Label As MSForms.Label)"
    s = s & vbNewLine & "    If InStr(1, Label.Tag, " & """" & "reframe" & """" & ", vbTextCompare) > 0 Then"
    s = s & vbNewLine & "        If Label.BackColor <> &H80B91E Then Label.BackColor = &H808080"
    s = s & vbNewLine & "    End If"
    s = s & vbNewLine & "End Sub"
    s = s & vbNewLine & ""
    s = s & vbNewLine & "Sub Emitter_LabelClick(ByRef Label As MSForms.Label)"
    s = s & vbNewLine & "    If InStr(1, Label.Tag, " & """" & "reframe" & """" & ", vbTextCompare) > 0 Then Reframe Me, Label"
    s = s & vbNewLine & "End Sub"
    s = s & vbNewLine & ""

    s = s & vbNewLine & "Private Sub UserForm_Initialize()"
    s = s & vbNewLine & "    startFrameForm Me"
    s = s & vbNewLine & "End Sub"
    If InStr(1, aModule.Init(oModule).Code, oModule.Name & "_Initialize") Then
        Toast "Threre is already _Initialize_ code in this form. Code will be put in cilpboard and immediate window."
        dp s
        CLIP s
    Else
        oModule.CodeModule.AddFromString s
    End If
End Sub


Public Sub CreateFrameMenu()
'@AssignedModule aDesigner
'@INCLUDE PROCEDURE ActiveModule
'@INCLUDE CLASS aDesigner
'@INCLUDE DECLARATION MyColors
    Select Case SelectedControls.count
    Case Is = 0
        ActiveModule.Designer.BackColor = MyColors.FormBackgroundDarkGray
        addFrameSidebar ActiveModule
        addFrameFormCode
    Case Is = 1
        addFrameSidebar SelectedControl
    End Select
End Sub

Private Sub addFrameSidebar(Form As Object, Optional dockRight As Boolean)
    '@INCLUDE askFormMenuElements
    '@INCLUDE UnderlineFrameName
    '@INCLUDE CreateOrSetFrame
'@AssignedModule aDesigner
'@INCLUDE PROCEDURE CreateOrSetFrame
'@INCLUDE CLASS aDesigner
'@INCLUDE DECLARATION ControlIDLabel
    Dim F As MSForms.control
    Dim L As MSForms.control
    Set F = CreateOrSetFrame(Form, "SideBar" & Form.Name)
    F.Tag = "skip"
    F.BackColor = 5457992
    F.ForeColor = vbWhite
    F.BorderStyle = 1
    F.BorderStyle = 0
    F.Width = 80
    If TypeName(Form) = "VBComponent" Then
        F.Height = 800
    Else
        F.Height = Form.Height
    End If
    dockRight = IIf(TypeName(Form) = "VBComponent", False, True)
    If dockRight = True Then
        F.Left = Form.Width - F.Width
    Else
        F.Left = 0
    End If
    UnderlineFrameName Form, F
    If TypeName(Form) = "VBComponent" Then
        Set L = Form.Designer.Controls.Add(ControlIDLabel, "Anchor" & Form.Name)
    Else
        Set L = Form.Controls.Add(ControlIDLabel, "Anchor" & Form.Name)
    End If
    L.Visible = False
    L.Left = IIf(TypeName(Form) = "VBComponent", F.Left + F.Width + 9, 1)
    L.Top = 12
    L.Width = 1
    L.BackColor = vbWhite
    L.Visible = False
    askFormMenuElements Form
End Sub

Private Sub askFormMenuElements(Form As Object)
    '@INCLUDE InputboxString
    '@INCLUDE addFrameMenu
'@AssignedModule aDesigner
'@INCLUDE PROCEDURE InputboxString
'@INCLUDE CLASS aDesigner
    Dim FormElements As String
    FormElements = InputboxString("Form Menus", "Type comma delimited menu names")
    If FormElements = "" Then Exit Sub
    Dim var
    var = Split(FormElements, ",")
    Dim i As Long
    For i = LBound(var) To UBound(var)
        var(i) = Trim(var(i))
    Next
    Dim coll As New Collection
    Dim element
    On Error Resume Next
    For Each element In var
        If Not IsNumeric(Left(element, 1)) _
            And InStr(1, element, " ") = 0 Then
            coll.Add CStr(element), CStr(element)
        End If
    Next
    On Error GoTo 0
    For Each element In coll
        addFrameMenu Form, CStr(element)
    Next
End Sub

Private Sub addFrameMenu(Form As Object, FrameCaptionNoSpace As String)
    '@INCLUDE Reframe
    '@INCLUDE UnderlineFrameName
    '@INCLUDE CreateOrSetFrame
    '@INCLUDE AvailableFormOrFrameRow
    '@INCLUDE AvailableFormOrFrameColumn
'@AssignedModule aDesigner
'@INCLUDE PROCEDURE CreateOrSetFrame
'@INCLUDE PROCEDURE AvailableFormOrFrameRow
'@INCLUDE PROCEDURE AvailableFormOrFrameColumn
'@INCLUDE PROCEDURE Reframe
'@INCLUDE CLASS aDesigner
'@INCLUDE DECLARATION ControlIDFrame
'@INCLUDE DECLARATION ControlIDLabel
    Dim F As MSForms.control
    Dim L As MSForms.control
    Dim Module As VBComponent
    If TypeName(Form) = "VBComponent" Then
        Set Module = Form
        Set F = Module.Designer.Controls.Add(ControlIDFrame, FrameCaptionNoSpace)
    Else
        Set Module = ThisWorkbook.VBProject.VBComponents(Form.Parent.Name)
        Set F = CreateOrSetFrame(Module.Designer.Controls(Form.Name), FrameCaptionNoSpace)
    End If
    F.Tag = "anchor" & Form.Name
    F.Caption = FrameCaptionNoSpace
    F.ForeColor = vbWhite
    F.Visible = False
    If TypeName(Form) = "VBComponent" Then
        F.Left = AvailableFormOrFrameColumn(Form.Designer)
    Else
        F.Left = 0
    End If
    F.Visible = True
    F.BorderStyle = 1
    F.BorderStyle = 0
    F.Top = 12
    F.Width = 100
    UnderlineFrameName Form, F
    If TypeName(Form) = "VBComponent" Then
        Set L = Module.Designer.Controls("SideBar" & Form.Name).Controls.Add(ControlIDLabel)
    Else
        Set L = Module.Designer.Controls("SideBar" & Form.Name).Add(ControlIDLabel)
    End If
    L.Caption = FrameCaptionNoSpace
    L.ForeColor = vbWhite
    L.Visible = False
    L.Top = AvailableFormOrFrameRow(Module.Designer.Controls("SideBar" & Form.Name))
    L.Left = L.Left + 3
    L.Visible = True
    L.Tag = "reframe"
    L.Width = F.Width
End Sub

Private Sub AddControlsToFrame(isSubFrame As Boolean)
    '@INCLUDE SelectedControl
    '@INCLUDE SelectedControls
    '@INCLUDE SelectedFrameControl
    '@INCLUDE ActiveModule
    '@INCLUDE InputboxString
'@AssignedModule aDesigner
'@INCLUDE PROCEDURE ActiveModule
'@INCLUDE PROCEDURE InputboxString
'@INCLUDE CLASS aDesigner
'@INCLUDE DECLARATION ControlIDCommandButton
    If ActiveModule.Type <> vbext_ct_MSForm Then Exit Sub
    Dim ad As New aDesigner
    If ad.SelectedControls.count <> 1 Then Exit Sub
    If TypeName(ad.SelectedControl) <> "Frame" Then Exit Sub
    Dim Module As VBComponent
    Dim TargetFrame As MSForms.control
    If isSubFrame = False Then
        Set TargetFrame = ad.SelectedControl
        Set Module = ActiveModule
    Else
        Set TargetFrame = ad.SelectedFrameOrMultipageControl
        Set Module = ThisWorkbook.VBProject.VBComponents(TargetFrame.Parent.Parent.Name)
    End If
    Dim ControlNames As String
    ControlNames = InputboxString("Form Menus", "Type comma delimited menu names")
    If ControlNames = "" Then Exit Sub
    Dim var
    var = Split(ControlNames, ",")
    Dim i As Long
    For i = LBound(var) To UBound(var)
        var(i) = Trim(var(i))
    Next
    Dim coll As New Collection
    Dim element
    On Error Resume Next
    For Each element In var
        If Not IsNumeric(Left(element, 1)) _
            And InStr(1, element, " ") = 0 Then
            coll.Add CStr(element), CStr(element)
        End If
    Next
    On Error GoTo 0
    Dim L As MSForms.control
    For Each element In coll
        Set L = Module.Designer.Controls(TargetFrame.Name).Controls.Add(ControlIDCommandButton, element)
        L.Top = 7 + ((TargetFrame.Controls.count - 1) * L.Height)
        L.BackColor = vbWhite
    Next
End Sub

Private Sub UnderlineFrameName(Form As Object, F As MSForms.control)
'@AssignedModule aDesigner
'@INCLUDE CLASS aDesigner
'@INCLUDE DECLARATION ControlIDLabel
    Dim Module As VBComponent
    If TypeName(Form) = "VBComponent" Then
        Set Module = Form
    Else
        Set Module = ThisWorkbook.VBProject.VBComponents(Form.Parent.Name)
    End If
    Dim L As MSForms.Label
    Set L = Module.Designer.Controls(F.Name).Controls.Add(ControlIDLabel)
    L.Top = 6
    L.Height = 1
    L.Width = 100
    L.BackColor = vbWhite
    L.Tag = "skip"
End Sub


'F_Bookmarks	Module


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Module     : F_Bookmarks
'* Purpose    : per workbook vbe bookmarks
'* Copyright  :
'*
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 19-07-2023 10:08    Alex                per workbook vbe bookmarks
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Public Sub BmSave1(): SaveBookmark 1: End Sub
Public Sub BmSave2(): SaveBookmark 2: End Sub
Public Sub BmSave3(): SaveBookmark 3: End Sub
Public Sub BmSave4(): SaveBookmark 4: End Sub
Public Sub BmSave5(): SaveBookmark 5: End Sub
Public Sub BmSave6(): SaveBookmark 6: End Sub
Public Sub BmSave7(): SaveBookmark 7: End Sub
Public Sub BmSave8(): SaveBookmark 8: End Sub
Public Sub BmSave9(): SaveBookmark 9: End Sub
Public Sub BmSave10(): SaveBookmark 10: End Sub
Public Sub BmSave11(): SaveBookmark 11: End Sub
Public Sub BmSave12(): SaveBookmark 12: End Sub
Public Sub BmSave13(): SaveBookmark 13: End Sub
Public Sub BmSave14(): SaveBookmark 14: End Sub
Public Sub BmSave15(): SaveBookmark 15: End Sub
Public Sub BmSave16(): SaveBookmark 16: End Sub
Public Sub BmSave17(): SaveBookmark 17: End Sub
Public Sub BmSave18(): SaveBookmark 18: End Sub
Public Sub BmSave19(): SaveBookmark 19: End Sub
Public Sub BmSave20(): SaveBookmark 20: End Sub

Public Sub bmload1(): LoadBookmark 1: End Sub
Public Sub bmload2(): LoadBookmark 2: End Sub
Public Sub bmload3(): LoadBookmark 3: End Sub
Public Sub bmload4(): LoadBookmark 4: End Sub
Public Sub bmload5(): LoadBookmark 5: End Sub
Public Sub bmload6(): LoadBookmark 6: End Sub
Public Sub bmload7(): LoadBookmark 7: End Sub
Public Sub bmload8(): LoadBookmark 8: End Sub
Public Sub bmload9(): LoadBookmark 9: End Sub
Public Sub bmload10(): LoadBookmark 10: End Sub
Public Sub bmload11(): LoadBookmark 11: End Sub
Public Sub bmload12(): LoadBookmark 12: End Sub
Public Sub bmload13(): LoadBookmark 13: End Sub
Public Sub bmload14(): LoadBookmark 14: End Sub
Public Sub bmload15(): LoadBookmark 15: End Sub
Public Sub bmload16(): LoadBookmark 16: End Sub
Public Sub bmload17(): LoadBookmark 17: End Sub
Public Sub bmload18(): LoadBookmark 18: End Sub
Public Sub bmload19(): LoadBookmark 19: End Sub
Public Sub bmload20(): LoadBookmark 20: End Sub


Sub SaveBookmark(index As Long)
    Dim delim As String: delim = " | "
    Dim TargetWorkbook As Workbook: Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim Module As VBComponent:  Set Module = ActiveModule
    Dim Procedure As String: Procedure = ActiveProcedure: If Procedure = "" Then Procedure = "N/A"
    Dim BookmarkLine As String
    BookmarkLine = TargetWorkbook.Name & delim & _
                   Module.Name & delim & _
                   Procedure & delim & _
                   Module.CodeModule.Lines(aCodeModule.Init(Module).RowFirst, 1)
    IniWrite BookmarkFile, TargetWorkbook.Name, CStr(index), BookmarkLine
End Sub

Function BookmarkFile() As String
     BookmarkFile = ThisWorkbook.Path & "config\bookmarks.ini"
End Function
Sub ListBookmarks()
    dp IniReadSection(BookmarkFile, ActiveCodepaneWorkbook.Name)
    '* @TODO Created: 17-08-2023 08:42 Author: Anastasiou Alex
    '* @TODO show on userform - use uCodeFinder? add '@BOOKMARK comment instead?
End Sub
Sub RemoveBookmark(index As Long)
    IniWrite BookmarkFile, ActiveCodepaneWorkbook.Name, CStr(index), vbNullString
End Sub
Sub ResetBookmarks()
    Dim index As Long
    For index = 1 To 20
        RemoveBookmark index
    Next
End Sub
Sub LoadBookmark(index As Long)
    Dim BookmarkLine As String: BookmarkLine = IniReadKey(BookmarkFile, ActiveCodepaneWorkbook.Name, CStr(index))
    If BookmarkLine = vbNullString Then Exit Sub
Retry:
    Dim delim As String:                delim = " | "
    Dim var:                            var = Split(BookmarkLine, delim)
    Dim targetworkbookname As String:   targetworkbookname = var(0)
    Dim ComponentName As String:        ComponentName = var(1)
    Dim Procedure As String:            Procedure = var(2)
                                        BookmarkLine = var(3)

    Dim WB As Workbook
    Dim Module As VBComponent
    On Error Resume Next
        Set WB = Workbooks(targetworkbookname)
        Set Module = WB.VBProject.VBComponents(ComponentName)
        If Module Is Nothing Then Set Module = ModuleOfProcedure(WB, Procedure)
    On Error GoTo 0
    If Module Is Nothing Then Exit Sub
    aModule.Init(Module).Activate
    Module.CodeModule.CodePane.SetSelection 1, 1, 1, 1
    Dim ProcFirstline As Long
    If Procedure = "N/A" Then Exit Sub
    If Not ProcedureExists(WB, Procedure) Then
        Debug.Print "Procedure " & Procedure & " not found in workbook " & targetworkbookname
        Exit Sub
    End If
    Dim AP As New aProcedure: AP.Init WB, Module, Procedure
    ProcFirstline = AP.LineIndex(Procedure_First)
    Module.CodeModule.CodePane.SetSelection ProcFirstline, 1, ProcFirstline, 1
    If BookmarkLine <> "" Then
        If AP.Contains(BookmarkLine, False, False, False) Then
            Dim i As Long
            For i = ProcFirstline To AP.LineIndex(Procedure_Last)
                If InStr(1, Module.CodeModule.Lines(i, 1), BookmarkLine, vbTextCompare) > 0 Then
                    Module.CodeModule.CodePane.SetSelection i, 1, i, 10000
                    Exit Sub
                End If
            Next
        End If
    End If
End Sub


'F_Settings_INI	Module


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Module     : F_Settings_INI
'* Purpose    :
'* Copyright  :
'*
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 30-06-2023 14:11    Alex
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

'____API METHOD______

#If VBA7 Then
    Public Declare PtrSafe Function GetPrivateProfileString Lib "kernel32" Alias "GetPrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As Any, ByVal lpDefault As String, ByVal lpReturnedString As String, ByVal nSize As Long, ByVal lpFileName As String) As Long
    Public Declare PtrSafe Function WritePrivateProfileString Lib "kernel32" Alias "WritePrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As Any, ByVal lpString As Any, ByVal lpFileName As String) As Long
    Public Declare PtrSafe Function GetPrivateProfileSection Lib "kernel32" Alias "GetPrivateProfileSectionA" (ByVal lpAppName As String, ByVal lpReturnedString As String, ByVal nSize As Long, ByVal lpFileName As String) As Long
#Else
    public declare Function GetPrivateProfileString Lib "kernel32" Alias "GetPrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As Any, ByVal lpDefault As String, ByVal lpReturnedString As String, ByVal nSize As Long, ByVal lpFileName As String) As Long
    public declare Function WritePrivateProfileString Lib "kernel32" Alias "WritePrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As Any, ByVal lpString As Any, ByVal lpFileName As String) As Long
    public declare Function GetPrivateProfileSection Lib "kernel32" Alias "GetPrivateProfileSectionA" (ByVal lpAppName As String, ByVal lpReturnedString As String, ByVal nSize As Long, ByVal lpFileName As String) As Long
#End If


Sub TestINI()
'@AssignedModule F_Settings_INI
'@INCLUDE PROCEDURE FollowLink
'@INCLUDE PROCEDURE dp
'@INCLUDE PROCEDURE IniSections
'@INCLUDE PROCEDURE IniReadSection
'@INCLUDE PROCEDURE IniSectionKeys
'@INCLUDE PROCEDURE IniReadKey
'@INCLUDE PROCEDURE IniWrite

    Dim filepath As String: filepath = ThisWorkbook.Path & "\test.INI"
    FollowLink ThisWorkbook.Path
    
    IniWrite filepath, "Settings1", "KeyName1", "Value1"
    IniWrite filepath, "Settings1", "KeyName2", "2"
    IniWrite filepath, "Settings1", "KeyName3", "3"     'SEE THE FILE
    Stop
    IniWrite filepath, "Settings1", "KeyName1", "Updated Value" 'SEE THE FILE
    Stop
    
    Dim i  As Long
    For i = 1 To 5
        IniWrite filepath, "Settings" & i, "KeyName" & i, i
    Next
    'SEE THE FILE
    Stop
    dp String(20, "~") & " Printing sections of " & filepath
    dp IniSections(filepath)
    Stop
    dp String(20, "~") & " Printing keys of section Settings1"
    dp IniSectionKeys(filepath, "Settings1")
    Stop
    dp String(20, "~") & " Printing all lines of section Settings1"
    dp IniReadSection(filepath, "Settings1")
    Stop
    dp String(20, "~") & " Printing value of Section: Settings1, Keyname: Keyname1"
    dp IniReadKey(filepath, "Settings1", "KeyName1")
    
End Sub

Public Function IniSections(iniFile As String) As Variant
'@INCLUDE PROCEDURE TxtRead
'@AssignedModule F_Settings_INI

'---sample file content---
'[settings1]
'    string1 = aaa
'    string2 = bbb
'[settings2]
'    string1 = ccc
'    string2 = ddd
'-------------------------
    IniSections = Split(Replace(Replace(Join(Filter(Split(Replace(TxtRead(iniFile), vbLf, vbNewLine), vbNewLine), "[", True), vbNewLine), "[", ""), "]", ""), vbNewLine)
'------Result------------------
'Array("settings1","settings2")
End Function

Public Function IniReadSection(fileName As String, Section As String) As Variant
'@INCLUDE DECLARATION GetPrivateProfileSection
'@INCLUDE PROCEDURE ArrayRemoveEmptyElements
'@AssignedModule F_Settings_INI
    Dim RetVal As String * 255
    Dim v As Long:      v = GetPrivateProfileSection(Section, RetVal, 255, fileName)
    Dim s As String:    s = Left(RetVal, v + 0)
    Dim VL As Variant:  VL = Split(s, Chr$(0))
    VL = ArrayRemoveEmptyElements(VL)
    IniReadSection = VL
'-----result for reading "settings1"-----
'Array("string1=aaa","string2=bbb")
End Function

Public Function IniSectionKeys(fileName As String, Section As String) As Variant
'@AssignedModule F_Settings_INI
'@INCLUDE PROCEDURE IniReadSection
'@INCLUDE PROCEDURE IniSectionExists
    Dim arr() As Variant
    If Not IniSectionExists(fileName, Section) Then
        IniSectionKeys = arr
        Exit Function
    End If
    arr = IniReadSection(fileName, Section)
    Dim out As Variant
    ReDim out(UBound(arr))
    Dim i As Long
    For i = LBound(arr) To UBound(arr)
        out(i) = Trim(Split(arr(i), "=")(0))
    Next i
    IniSectionKeys = out
'-----result for reading "settings1"-----
'string1
'string2
End Function

Public Function IniReadKey(IniFileName As String, ByVal Sect As String, ByVal Keyname As String, Optional ByVal Default As Variant) 'As String
'@INCLUDE DECLARATION GetPrivateProfileString
'@AssignedModule F_Settings_INI
    Dim Worked As Long
    Dim RetStr As String * 128
    Dim StrSize As Long
    Dim iNoOfCharInIni As Long: iNoOfCharInIni = 0
    Dim sIniString As String: sIniString = ""
    If Sect = "" Or Keyname = "" Then
        MsgBox "Section Or Key To Read Not Specified !!!", vbExclamation, "INI"
    Else
        Dim sProfileString As String: sProfileString = ""
        RetStr = Space(128)
        StrSize = Len(RetStr)
        Worked = GetPrivateProfileString(Sect, Keyname, "", RetStr, StrSize, IniFileName)
        If Worked Then
            iNoOfCharInIni = Worked
            sIniString = Left$(RetStr, Worked)
        End If
    End If
    
    If sIniString <> vbNullString Then
        IniReadKey = sIniString
    ElseIf sIniString = vbNullString And Not IsMissing(Default) Then
        IniReadKey = Default
    End If
'---- result for reading "settings1", "string1" ----
'aaa
End Function

Public Sub IniWrite(IniFileName As String, ByVal Sect As String, ByVal Keyname As String, ByVal Wstr As String)
'@INCLUDE DECLARATION WritePrivateProfileString
'@AssignedModule F_Settings_INI

'This macro also creates the file & section & key if they doesn't exist

    Dim Worked As Long
    Dim iNoOfCharInIni As Long

    iNoOfCharInIni = 0
    Dim sIniString As String: sIniString = ""
    If Sect = "" Or Keyname = "" Then
        MsgBox "Section Or Key To Write Not Specified !!!", vbExclamation, "INI"
    Else
        Worked = WritePrivateProfileString(Sect, Keyname, Wstr, IniFileName)
        If Worked Then
            iNoOfCharInIni = Worked
            sIniString = Wstr
        End If
    End If
    
'---- result for writing "settings1", "string1", "newval" ----
'[settings1]
'    string1 = newval
'    string2 = bbb
'[settings2]
'    string1 = ccc
'    string2 = ddd

'---- result for writing "settings1", "string3", "newkey" ----
'[settings1]
'    string1 = newval
'    string2 = bbb
'    string3 = newkey
'[settings2]
'    string1 = ccc
'    string2 = ddd
End Sub






'___NO API METHOD______
'
Public Sub TestReadKey()
    Debug.Print "INI File: " & ThisWorkbook.Path & "\MyIniFile.ini" & vbCrLf & _
           "Section: SETTINGS" & vbCrLf & _
           "Section Exist: " & IniSectionExists(ThisWorkbook.Path & "\MyIniFile.ini", "SETTINGS") & vbCrLf & _
           "Key: License" & vbCrLf & _
           "Key Exist: " & IniKeyExists(ThisWorkbook.Path & "\MyIniFile.ini", "SETTINGS", "License") & vbCrLf & _
           "Key Value: " & Ini_ReadKeyVal(ThisWorkbook.Path & "\MyIniFile.ini", "SETTINGS", "License")
    'You can validate the value by checking the bSectionExists and bKeyExists variable to ensure they were actually found in the ini file
'@AssignedModule F_Settings_INI
'@INCLUDE PROCEDURE IniSectionExists
'@INCLUDE PROCEDURE IniKeyExists
End Sub

Public Function IniSectionExists(iniFile As String, Section As String) As Boolean
    'Alex
'@AssignedModule F_Settings_INI
'@INCLUDE PROCEDURE TxtRead
    IniSectionExists = InStr(1, TxtRead(iniFile), "[" & Section & "]") > 0
End Function

Public Function IniKeyExists(iniFile As String, Section As String, Key As String) As Boolean
    'Alex
'@AssignedModule F_Settings_INI
    IniKeyExists = (Ini_ReadKeyVal(iniFile, Section, Key) <> "")
End Function

Public Sub TestWriteKey()
'@AssignedModule F_Settings_INI
    If Ini_WriteKeyVal(ThisWorkbook.Path & "\MyIniFile.ini", "SETTINGS", "License", "JBXR-HHTY-LKIP-HJNB-GGGT") = True Then
        MsgBox "The key was written"
    Else
        MsgBox "An error occurred!"
    End If
End Sub

'---------------------------------------------------------------------------------------
' Procedure : Ini_ReadKeyVal
' Author    : Daniel Pineault, CARDA Consultants Inc.
' Website   : http://www.cardaconsultants.com
' Purpose   : Read an Ini file's Key
' Copyright : The following may be altered and reused as you wish so long as the
'             copyright notice is left unchanged (including Author, Website and
'             Copyright).  It may not be sold/resold or reposted on other sites (links
'             back to this site are allowed).
' Req'd Refs: Uses Late Binding, so none required
'             No APIs either! 100% VBA
'
' Input Variables:
' ~~~~~~~~~~~~~~~~
' sIniFile  : Full path and filename of the ini file to read
' sSection  : Ini Section to search for the Key to read the Key from
' sKey      : Name of the Key to read the value of
'
' Usage:
' ~~~~~~
' ? Ini_Read(Application.CurrentProject.Path & "\MyIniFile.ini", "LINKED TABLES", "Path")
'
' Revision History:
' Rev       Date(yyyy/mm/dd)        Description
' **************************************************************************************
' 1         2012-08-09              Initial Release
'---------------------------------------------------------------------------------------
Public Function Ini_ReadKeyVal(ByVal sIniFile As String, _
                        ByVal sSection As String, _
                        ByVal sKey As String) As String
'@AssignedModule F_Settings_INI
'@INCLUDE PROCEDURE FileExists
'@INCLUDE PROCEDURE TxtRead
'@INCLUDE PROCEDURE ArrayTrim
    On Error GoTo Error_Handler
    Dim bSectionExists         As Boolean
    Dim bKeyExists             As Boolean
    Dim sIniFileContent       As String
    Dim aIniLines()           As String
    Dim sLine                 As String
    Dim i                     As Long

    sIniFileContent = ""
    bSectionExists = False
    bKeyExists = False

    'Validate that the file actually exists
    If FileExists(sIniFile) = False Then
        MsgBox "The specified ini file: " & vbCrLf & vbCrLf & _
               sIniFile & vbCrLf & vbCrLf & _
               "could not be found.", vbCritical + vbOKOnly, "File not found"
        GoTo Error_Handler_Exit
    End If

    sIniFileContent = TxtRead(sIniFile)    'Read the file into memory
    aIniLines = Split(sIniFileContent, vbLf)
    For i = 0 To UBound(aIniLines)
        sLine = Trim(aIniLines(i))
        sLine = VBA.Replace(sLine, vbTab, vbNullString)
        If InStr(1, sLine, "=") > 0 Then sLine = Join(ArrayTrim(Split(sLine, "=")), "=") '<- Alex added this
        If bSectionExists = True And Left(sLine, 1) = "[" And Right(sLine, 1) = "]" Then
            Exit For    'Start of a new section
        End If
        If sLine = "[" & sSection & "]" Then
            bSectionExists = True
        End If
        If bSectionExists = True Then
            If sLine Like sKey & "=*" Then
                bKeyExists = True
                Ini_ReadKeyVal = Mid(sLine, InStr(sLine, "=") + 1)
            End If
        End If
    Next i

Error_Handler_Exit:
    On Error Resume Next
    Exit Function

Error_Handler:
    'Err.Number = 75 'File does not exist, Permission issues to write is denied,
    MsgBox "The following error has occurred" & vbCrLf & vbCrLf & _
           "Error Number: " & Err.Number & vbCrLf & _
           "Error Source: Ini_ReadKeyVal" & vbCrLf & _
           "Error Description: " & Err.Description & _
           Switch(Erl = 0, "", Erl <> 0, vbCrLf & "Line No: " & Erl) _
           , vbOKOnly + vbCritical, "An Error has Occurred!"
    Resume Error_Handler_Exit
End Function

'---------------------------------------------------------------------------------------
' Procedure : Ini_WriteKeyVal
' Author    : Daniel Pineault, CARDA Consultants Inc.
' Website   : http://www.cardaconsultants.com
' Purpose   : Writes a Key value to the specified Ini file's Section
'               If the file does not exist, it will be created
'               If the Section does not exist, it will be appended to the existing content
'               If the Key does not exist, it will be appended to the existing Section content
' Copyright : The following may be altered and reused as you wish so long as the
'             copyright notice is left unchanged (including Author, Website and
'             Copyright).  It may not be sold/resold or reposted on other sites (links
'             back to this site are allowed).
' Req'd Refs: Uses Late Binding, so none required
'             No APIs either! 100% VBA
'
' Input Variables:
' ~~~~~~~~~~~~~~~~
' sIniFile  : Full path and filename of the ini file to edit
' sSection  : Ini Section to search for the Key to edit
' sKey      : Name of the Key to edit
' sValue    : Value to associate to the Key
'
' Usage:
' ~~~~~~
' Call Ini_WriteKeyVal(Application.CurrentProject.Path & "\MyIniFile.ini", "LINKED TABLES", "Paths", "D:\")
'
' Revision History:
' Rev       Date(yyyy/mm/dd)        Description
' **************************************************************************************
' 1         2012-08-09              Initial Release
' 2         2020-01-27              Fix to address issue flagged by users
'---------------------------------------------------------------------------------------
Public Function Ini_WriteKeyVal(ByVal sIniFile As String, _
                         ByVal sSection As String, _
                         ByVal sKey As String, _
                         ByVal sValue As String) As Boolean
'@AssignedModule F_Settings_INI
'@INCLUDE PROCEDURE FileExists
'@INCLUDE PROCEDURE TxtOverwrite
'@INCLUDE PROCEDURE TxtRead
    On Error GoTo Error_Handler
    Dim bSectionExists         As Boolean
    Dim bKeyExists             As Boolean
    Dim sIniFileContent       As String
    Dim aIniLines()           As String
    Dim sLine                 As String
    Dim sNewLine              As String
    Dim i                     As Long
    Dim bFileExist            As Boolean
    Dim bInSection            As Boolean
    Dim bKeyAdded             As Boolean

    sIniFileContent = ""
    bSectionExists = False
    bKeyExists = False

    'Validate that the file actually exists
    If FileExists(sIniFile) = False Then
        GoTo SectionDoesNotExist
    End If
    bFileExist = True

    sIniFileContent = TxtRead(sIniFile)    'Read the file into memory
    aIniLines = Split(sIniFileContent, vbLf)    'Break the content into individual lines
    sIniFileContent = ""    'Reset it
    For i = 0 To UBound(aIniLines)    'Loop through each line
        sNewLine = ""
        sLine = Trim(aIniLines(i))
        If sLine = "[" & sSection & "]" Then
            bSectionExists = True
            bInSection = True
        End If
        If bInSection = True Then
            If sLine <> "[" & sSection & "]" Then
                If Left(sLine, 1) = "[" And Right(sLine, 1) = "]" Then
                    'Our section exists, but the key wasn't found, so append it
                    sNewLine = sKey & "=" & sValue
                    i = i - 1
                    bInSection = False    ' we're switching section
                    bKeyAdded = True
                End If
            End If
            If Len(sLine) > Len(sKey) Then
                If Left(sLine, Len(sKey) + 1) = sKey & "=" Then
                    sNewLine = sKey & "=" & sValue
                    bKeyExists = True
                    bKeyAdded = True
                End If
            End If
        End If
        If Len(sIniFileContent) > 0 Then sIniFileContent = sIniFileContent & vbCrLf
        If sNewLine = "" Then
            sIniFileContent = sIniFileContent & sLine
        Else
            sIniFileContent = sIniFileContent & sNewLine
        End If
    Next i

SectionDoesNotExist:
    'if not found, add it to the end
    If bSectionExists = False Then
        If Len(sIniFileContent) > 0 Then sIniFileContent = sIniFileContent & vbCrLf
        sIniFileContent = sIniFileContent & "[" & sSection & "]"
    End If
    If bKeyAdded = False Then
        sIniFileContent = sIniFileContent & vbCrLf & sKey & "=" & sValue
    End If

    'Write to the ini file the new content
    Call TxtOverwrite(sIniFile, sIniFileContent)
    Ini_WriteKeyVal = True

Error_Handler_Exit:
    On Error Resume Next
    Exit Function

Error_Handler:
    MsgBox "The following error has occurred" & vbCrLf & vbCrLf & _
           "Error Number: " & Err.Number & vbCrLf & _
           "Error Source: Ini_WriteKeyVal" & vbCrLf & _
           "Error Description: " & Err.Description & _
           Switch(Erl = 0, "", Erl <> 0, vbCrLf & "Line No: " & Erl) _
           , vbOKOnly + vbCritical, "An Error has Occurred!"
    Resume Error_Handler_Exit
End Function

'_____________________________________________________________


'aComboBox	Class


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Class      : aComboBox
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 27-06-2023 12:35    Alex                figured how to get the hwnd
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Public oComboBox As ComboBox

Rem resize combobox List Portion
#If VBA7 Then
    Private Declare PtrSafe Function GetDeviceCaps Lib "gdi32" (ByVal hDC As LongPtr, ByVal nIndex As Long) As Long
    Private Declare PtrSafe Function CreateCompatibleDC Lib "gdi32" (ByVal hDC As LongPtr) As LongPtr
    Private Declare PtrSafe Function DeleteDC Lib "gdi32" (ByVal hDC As LongPtr) As Long
    Private Declare PtrSafe Function DrawText Lib "user32" Alias "DrawTextW" (ByVal hDC As LongPtr, ByVal lpStr As LongPtr, ByVal nCount As Long, lpRect As RECT, ByVal wFormat As Long) As Long
    Private Declare PtrSafe Function SetMapMode Lib "gdi32" (ByVal hDC As LongPtr, ByVal nMapMode As Long) As Long
    Private Declare PtrSafe Function GetTextExtentPoint32 Lib "gdi32" Alias "GetTextExtentPoint32W" (ByVal hDC As LongPtr, ByVal lpsz As LongPtr, ByVal cbString As Long, lpSize As ComboboxListSize) As Long
    Private Declare PtrSafe Function SelectObject Lib "gdi32" (ByVal hDC As LongPtr, ByVal hObject As LongPtr) As LongPtr
    Private Declare PtrSafe Function DeleteObject Lib "gdi32" (ByVal hObject As LongPtr) As Long
    Private Declare PtrSafe Function GetSystemMetrics Lib "user32" (ByVal nIndex As Long) As Long
#Else
    Private Enum LongPtr
        [_]
    End Enum
    Private Declare Function GetDeviceCaps Lib "gdi32" (ByVal hDC As LongPtr, ByVal nIndex As Long) As Long
    Private Declare Function CreateCompatibleDC Lib "gdi32" (ByVal hDC As LongPtr) As LongPtr
    Private Declare Function DeleteDC Lib "gdi32" (ByVal hDC As LongPtr) As Long
    Private Declare Function DrawText Lib "user32" Alias "DrawTextW" (ByVal hDC As LongPtr, ByVal lpStr As LongPtr, ByVal nCount As Long, lpRect As RECT, ByVal wFormat As Long) As Long
    Private Declare Function SetMapMode Lib "gdi32" (ByVal hDC As LongPtr, ByVal nMapMode As Long) As Long
    Private Declare Function GetTextExtentPoint32 Lib "gdi32" Alias "GetTextExtentPoint32W" (ByVal hDC As LongPtr, ByVal lpsz As LongPtr, ByVal cbString As Long, lpSize As ComboboxListSize) As Long
    Private Declare Function SelectObject Lib "gdi32" (ByVal hDC As LongPtr, ByVal hObject As LongPtr) As LongPtr
    Private Declare Function DeleteObject Lib "gdi32" (ByVal hObject As LongPtr) As Long
    Private Declare Function GetSystemMetrics Lib "user32" (ByVal nIndex As Long) As Long
#End If

#If Win64 Then
    Private Const NULL_PTR = 0^
#Else
    Private Const NULL_PTR = 0&
#End If

Private Type ComboboxListSize
    cx As Long
    cy As Long
End Type

Private Type RECT
    Left As Long
    Top As Long
    Right As Long
    Bottom As Long
End Type

Public Function Init(cbx As ComboBox) As aComboBox
'@AssignedModule aComboBox
'@INCLUDE CLASS aComboBox
    Set oComboBox = cbx
    Set Init = Me
End Function

Public Function AutoSizeDropDown(Optional ByVal JumpToWidestEntry As Boolean = False) As Long
'@AssignedModule aComboBox
'@INCLUDE CLASS aComboBox
'@INCLUDE DECLARATION GetSystemMetrics

    Const MM_TEXT = 1&
    Const SM_CXVSCROLL = 2&
 
    Static bDropDownState As Boolean
    Dim hMemDc As LongPtr
    Dim hPrevFont As LongPtr
    Dim IFont As stdole.IFont
    Dim lPrevMPMode As Long
    Dim lIndex As Long
    Dim lMaxWidth As Long
    Dim lMaxIndex As Long
    Dim sItemText As String
    Dim sWidestText As String
    Dim tSize As ComboboxListSize

    hMemDc = CreateCompatibleDC(NULL_PTR)
    If hMemDc Then
        lPrevMPMode = SetMapMode(hMemDc, MM_TEXT)
        Set IFont = oComboBox.Font
        hPrevFont = SelectObject(hMemDc, IFont.hFont)
        With oComboBox
            For lIndex = 0& To .ListCount - 1&
                sItemText = .List(lIndex)
                Call GetTextExtentPoint32(hMemDc, StrPtr(sItemText), Len(sItemText), tSize)
                If lMaxWidth < tSize.cx Then
                    lMaxWidth = tSize.cx
                    sWidestText = sItemText
                    lMaxIndex = lIndex
                End If
            Next lIndex
            'Debug.Print lMaxIndex, sWidestText
            AutoSizeDropDown = lMaxIndex
            lMaxWidth = PXtoPT(hMemDc, lMaxWidth + 2.5 * GetSystemMetrics(SM_CXVSCROLL), False)
            Call SetMapMode(hMemDc, lPrevMPMode)
            Call SelectObject(hMemDc, hPrevFont)
            Call DeleteDC(hMemDc)
            .ListWidth = lMaxWidth
            If JumpToWidestEntry Then
                If bDropDownState = False Then
                    .ListIndex = lMaxIndex
                End If
            End If
            bDropDownState = Not bDropDownState
        End With
    End If

End Function

Private Function ScreenDPI(ByVal bVert As Boolean, ByVal hDC As LongPtr) As Long
'@AssignedModule aComboBox
'@INCLUDE CLASS aComboBox
'@INCLUDE DECLARATION LOGPIXELSX
'@INCLUDE DECLARATION LOGPIXELSY
'@INCLUDE DECLARATION GetDeviceCaps
    Const LOGPIXELSX As Long = 88&
    Const LOGPIXELSY As Long = 90&
    Static lDPI(1&) As Long

    If lDPI(0&) = 0& Then
        lDPI(0&) = GetDeviceCaps(hDC, LOGPIXELSX)
        lDPI(1&) = GetDeviceCaps(hDC, LOGPIXELSY)
    End If
    ScreenDPI = lDPI(Abs(bVert))
End Function

Private Function PXtoPT(ByVal hDC As LongPtr, ByVal Pixels As Single, ByVal bVert As Boolean) As Single
'@AssignedModule aComboBox
'@INCLUDE CLASS aComboBox
    Const POINTSPERINCH As Long = 72&
    PXtoPT = (Pixels / (ScreenDPI(bVert, hDC) / POINTSPERINCH))
End Function



Public Sub LoadVBProjects()
'@AssignedModule aComboBox
'@INCLUDE PROCEDURE WorkbookProjectProtected
'@INCLUDE CLASS aComboBox
    Dim coll As New Collection
    Dim WB As Workbook
    For Each WB In Workbooks
        If Len(WB.Path) > 0 Then
            If WorkbookProjectProtected(WB) = False Then
                On Error Resume Next
                coll.Add WB.Name, WB.Name
                On Error GoTo 0
            End If
        End If
    Next
    Rem list addins
    Dim vbProj As VBProject
    Dim wbPath As String
    For Each vbProj In Application.VBE.VBProjects
        On Error GoTo ErrorHandler
        wbPath = vbProj.fileName
        If Right(wbPath, 4) = "xlam" Or Right(wbPath, 3) = "xla" Then
            Dim wbName As String
            wbName = Mid(wbPath, InStrRev(wbPath, "\") + 1)
            If WorkbookProjectProtected(Workbooks(wbName)) = False Then
                On Error Resume Next
                coll.Add wbName, wbName
                On Error GoTo 0
            End If
        End If
SKIP:
    Next vbProj

    Dim el As Variant
    For Each el In coll
        oComboBox.AddItem el
    Next

    Exit Sub
ErrorHandler:
    If Err.Number = 76 Then GoTo SKIP
End Sub


'z_ListView	UserForm

Option Explicit



Private Sub Label2_Click()
'@AssignedModule z_ListView
'@INCLUDE USERFORM z_ListView
    
End Sub

Private Sub UserForm_Initialize()
'@AssignedModule z_ListView
'@INCLUDE CLASS aListView
'@INCLUDE USERFORM z_ListView
    Dim i As Long
    For i = 1 To 4
        ListView1.ListItems.Add , , "Test" & i
    Next
    With ListView1
        .FullRowSelect = True
        .LabelEdit = lvwManual
        .View = lvwReport
        .ColumnHeaders.Add , , "Filepath"
        .multiSelect = False    '@TODO multi drag drop
    End With
    
    With aListView.Init(ListView1)
        .AutofitColumns
        .EnableDropFilesFolders True, False, False, "*"
        .EnableDragSort
    End With
    
    
End Sub


'aListView	Class


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Class      : aListView
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 29-06-2023 13:45    Alex
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Public WithEvents EventDragSort As ListView
Public WithEvents EventDropFiles As ListView
Public WithEvents aListViewEvent As ListView

#If VBA7 Then
    Private Declare PtrSafe Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long
    Private Declare PtrSafe Function SendMessageLong Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
    Private Declare PtrSafe Function GetDC Lib "user32" (ByVal hwnd As Long) As Long
    Private Declare PtrSafe Function GetDeviceCaps Lib "gdi32" (ByVal hDC As Long, ByVal nIndex As Long) As Long
    Private Declare PtrSafe Function ReleaseDC Lib "user32" (ByVal hwnd As Long, ByVal hDC As Long) As Long
    
    Private Declare PtrSafe Sub mouse_event Lib "user32" (ByVal dwFlags As Long, ByVal dx As Long, ByVal dy As Long, ByVal cButtons As Long, ByVal dwExtraInfo As Long)
    Private Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
#Else
    Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long
    Private Declare Function SendMessageLong Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
    private Declare Function GetDC Lib "user32" (ByVal hWnd As Long) As Long
    private Declare Function GetDeviceCaps Lib "gdi32" (ByVal hDC As Long, ByVal nIndex As Long) As Long
    private Declare Function ReleaseDC Lib "user32" (ByVal hWnd As Long, ByVal hDC As Long) As Long
    
    Private Declare Sub mouse_event Lib "user32" (ByVal dwFlags As Long, ByVal dx As Long, ByVal dy As Long, ByVal cButtons As Long, ByVal dwExtraInfo As Long)
    Private Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
#End If

Private Const MOUSEEVENTF_LEFTDOWN = &H2
Private Const MOUSEEVENTF_LEFTUP = &H4

'Windows API Constants
Private Const LOGPIXELSX = 88
Private Const LOGPIXELSY = 90

Private Const LVM_FIRST = &H1000
Private Const LVM_SETCOLUMNWIDTH = (LVM_FIRST + 30)
 
Private Const LVSCW_AUTOSIZE = -1
Private Const LVSCW_AUTOSIZE_USEHEADER = -2
 
Private Const LVM_GETNEXTITEM = (LVM_FIRST + 12)
Private Const LVNI_SELECTED = &H2
Private Const LVM_GETSELECTEDCOUNT = (LVM_FIRST + 50)

Public oListView As ListView

Private option_DD_LogFiles As Boolean
Private option_DD_LogFolders As Boolean
Private option_DD_IncludeSubfolders As Boolean
Private option_DD_CommaSeparatedFilters As String


Public LstItmObj As ListItem
Public swapNeeded As Boolean 'swap mode

Private Type POINTAPI
    x As Long
    y As Long
End Type
Private Type LVHITTESTINFO
    pt As POINTAPI
    Flags As Long
    iItem As Long
    iSubItem  As Long
End Type

Private Const LVM_HITTEST As Long = &H418
Private Const LVM_SUBITEMHITTEST As Long = &H1039
Private Const LVHT_ONITEM As Long = &H2

Public Function Value()
'@AssignedModule aListView
'@INCLUDE CLASS aListView
    Dim headCount As Long: headCount = oListView.ColumnHeaders.count
    Dim rowCount As Long: rowCount = oListView.ListItems.count
    
    Dim arr()
    ReDim arr(1 To rowCount, 1 To headCount)
    Dim x As Long
    Dim y As Long
    For y = 1 To oListView.ColumnHeaders.count
        arr(1, y) = oListView.ColumnHeaders(y)
    Next
    If oListView.ListItems.count > 0 Then
        For x = 1 To oListView.ListItems.count
            For y = 1 To headCount
                If y = 1 Then
                    arr(x, y) = oListView.ListItems(x)
                Else
                    arr(x, y) = oListView.ListItems(x).ListSubItems(y - 1)
                End If
            Next
        Next
        Value = arr
    Else
        Value = Array()
    End If
End Function

Public Function RowArray(targetRow As Long)
'@AssignedModule aListView
'@INCLUDE CLASS aListView
    Dim headCount As Long: headCount = oListView.ColumnHeaders.count
    Dim arr
    ReDim arr(1 To headCount)
    Dim i As Long
    For i = 1 To headCount
        If i = 1 Then
            arr(i) = oListView.ListItems(targetRow)
        Else
            arr(i) = oListView.ListItems(targetRow).ListSubItems(i - 1)
        End If
    Next
    RowArray = arr
End Function

Public Function SelectionArray()
'@AssignedModule aListView
'@INCLUDE CLASS aListView
    Dim item As MSComctlLib.ListItem
    Dim targetRow As Long
    Dim arr()
    Dim i As Long, counter As Long
    Dim headCount As Long: headCount = oListView.ColumnHeaders.count
    If oListView.multiSelect = False Then
        targetRow = oListView.selectedItem.index
        arr = RowArray(targetRow)
    Else
        ReDim arr(1 To 1, 1 To headCount)
        For Each item In oListView.ListItems
            If item.Selected Then
                targetRow = item.index
                counter = counter + 1
                ReDim Preserve arr(1 To counter, 1 To headCount)
                For i = 1 To headCount
                    If i = 1 Then
                        arr(counter, i) = oListView.ListItems(targetRow)
                    Else
                        arr(counter, i) = oListView.ListItems(targetRow).ListSubItems(i - 1)
                    End If
                Next
                
            End If
        Next
    End If
    SelectionArray = arr
End Function

Public Function ClickedColumn(x, y)
    'call from userform ListView1_MouseDown event and such
'@AssignedModule aListView
'@INCLUDE CLASS aListView
'@INCLUDE DECLARATION SendMessage
    ClickedColumn = -1
    
    Dim hitTestInfo As LVHITTESTINFO
    hitTestInfo.pt.x = x
    hitTestInfo.pt.y = y
    SendMessage oListView.hwnd, LVM_SUBITEMHITTEST, 0, hitTestInfo
    
    If hitTestInfo.Flags = 4 Then
        Dim ColumnIndex As Long
        ColumnIndex = hitTestInfo.iSubItem
        ClickedColumn = ColumnIndex
    End If

End Function

Sub DeselectAll()
'@AssignedModule aListView
'@INCLUDE CLASS aListView
'@INCLUDE DECLARATION SendMessage
    Dim sThisItem As Long, lLvHwnd As Long, lSelectedItems As Long, lItemIndex As Long

    On Error GoTo ErrFailed

    With oListView
        lLvHwnd = .hwnd
        lSelectedItems = SendMessage(lLvHwnd, LVM_GETSELECTEDCOUNT, 0, ByVal 0&)
        lItemIndex = -1
        For sThisItem = 1 To lSelectedItems
            lItemIndex = SendMessage(lLvHwnd, LVM_GETNEXTITEM, lItemIndex, ByVal LVNI_SELECTED)
            .ListItems(lItemIndex + 1).Selected = False
        Next
    End With
    Exit Sub

ErrFailed:
    Debug.Print Err.Description
    Debug.Assert False
End Sub

Public Sub EnableDragSort()
'@AssignedModule aListView
'@INCLUDE CLASS aListView
    Set EventDragSort = oListView
    swapNeeded = False
End Sub

Private Sub EventDragSort_OLEStartDrag(Data As MSComctlLib.DataObject, AllowedEffects As Long)
'@AssignedModule aListView
'@INCLUDE CLASS aListView
    Set LstItmObj = EventDragSort.selectedItem
End Sub

'when drop occurs we make mouseclick to select next item and then set swap mode on
Private Sub EventDragSort_OLEDragDrop(Data As MSComctlLib.DataObject, Effect As Long, Button As Integer, Shift As Integer, x As Single, y As Single)
    'that click will occur only after end of this Sub, that's why we can't make rows swaping here
'@AssignedModule aListView
'@INCLUDE CLASS aListView
    Call SingleClick
    swapNeeded = True
End Sub

'this Sub starts after OLEDragDrop ends so new row is already selected and old row is already saved to LstItmObj so here we just need to swap those two rows
Private Sub eventdragsort_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As stdole.OLE_XPOS_PIXELS, ByVal y As stdole.OLE_YPOS_PIXELS)
'@AssignedModule aListView
'@INCLUDE CLASS aListView
'@INCLUDE DECLARATION Sleep
    If LstItmObj Is Nothing Then Exit Sub
    If (swapNeeded) Then
        Sleep 30
        Dim insertedList As ListItem
        Dim SelectedIndex As Integer
        Dim newListSubItemObj As ListSubItem

        SelectedIndex = EventDragSort.selectedItem.index
        EventDragSort.ListItems.Remove LstItmObj.index

        Set insertedList = EventDragSort.ListItems.Add(SelectedIndex, LstItmObj.Key, LstItmObj.text, LstItmObj.Icon, LstItmObj.SmallIcon)
        For Each newListSubItemObj In LstItmObj.ListSubItems
                insertedList.ListSubItems.Add newListSubItemObj.index, newListSubItemObj.Key, newListSubItemObj.text, newListSubItemObj.ReportIcon, newListSubItemObj.TooltipText
        Next newListSubItemObj 'swap mode off again
        swapNeeded = False
        Set EventDragSort.selectedItem = EventDragSort.ListItems.item(SelectedIndex)
    End If
End Sub

Private Sub SingleClick()
'@AssignedModule aListView
'@INCLUDE CLASS aListView
'@INCLUDE DECLARATION mouse_event
  mouse_event MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0
  mouse_event MOUSEEVENTF_LEFTUP, 0, 0, 0, 0
End Sub

Public Sub EnableDropFilesFolders(LogFiles As Boolean, LogFolders As Boolean, IncludeSubFolders As Boolean, Optional CommaSeparatedFilters As String = "*")
'@AssignedModule aListView
'@INCLUDE CLASS aListView
    option_DD_LogFiles = LogFiles
    option_DD_LogFolders = LogFolders
    option_DD_IncludeSubfolders = IncludeSubFolders
    option_DD_CommaSeparatedFilters = CommaSeparatedFilters
    oListView.OLEDragMode = ccOLEDragAutomatic ' ccOLEDragManual
    oListView.OLEDropMode = ccOLEDropManual
    Set EventDropFiles = oListView
End Sub

Private Sub EventDropFiles_OLEDragDrop(Data As MSComctlLib.DataObject, Effect As Long, Button As Integer, Shift As Integer, x As Single, y As Single)
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'The Format numbers used in the OLE DragDrop data structure, are:
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'Text = 1 (vbCFText)
    'Bitmap = 2 (vbCFBitmap)
    'Metafile = 3
    'Emetafile = 14
    'DIB = 8
    'Palette = 9
    'Files = 15 (vbCFFiles)
    'RTF = -16639
'@AssignedModule aListView
'@INCLUDE CLASS aListView
    
    Select Case True
    Case Data.GetFormat(15) 'Format 15 is an array of names from WinExplorer
        If Not option_DD_LogFiles And Not option_DD_LogFiles Then Exit Sub
        Dim FileFullPath As String
        Dim fileItem As Long
        For fileItem = 1 To Data.Files.count
            FileFullPath = Data.Files(fileItem)
            DD_AddToListview FileFullPath
        Next fileItem
    Case Else
    End Select
End Sub

Private Sub DD_AddToListview(FileFullPath As String)
'@AssignedModule aListView
'@INCLUDE PROCEDURE IsFileFolderURL
'@INCLUDE CLASS aListView
    Dim objFSO As Scripting.FileSystemObject
    Dim objTopFolder As Scripting.Folder
    Set objFSO = CreateObject("Scripting.FileSystemObject")
    Dim fileName As String
    Dim var As Variant, element As Variant
        var = Split(option_DD_CommaSeparatedFilters, ",")
    If option_DD_LogFiles = True Then
        If LCase(IsFileFolderURL(FileFullPath)) = "f" Then
            fileName = Mid(FileFullPath, InStrRev(FileFullPath, "\") + 1)
            On Error Resume Next
            If Left(fileName, 1) <> "~" And (var(0) = "*" Or var(0) = "") Then GoTo PASS
            For Each element In var
                If InStr(1, FileFullPath, element, vbTextCompare) > 0 And Left(fileName, 1) <> "~" Then
PASS:

'where:
'Constant    Value   Description
'lvwText     0       (Default) Matches the string with a ListItem object's Text property.
'lvwSubitem  1       Matches the string with any string in a ListItem object's SubItems property.
'lvwTag      2       Matches the string with any ListItem object's Tag property.

'match:
'The settings for match are:
'Constant        Value   Description
'lvwWholeWord    0       (Default) An integer or constant specifying that a match will occur if the item's Text property begins with the whole word being searched. Ignored if the criteria is not text.
'lvwPartial      1       An integer or constant specifying that a match will occur if the item's Text property begins with the string being searched. Ignored if the criteria is not text.

'                    For full match:
'                        Dim itm As MSComctlLib.listItem
'                        Set itm = oListView.FindItem(sz:="subitemtext", where:=lvwSubItem, index:=2, fPartial:=lvwPartial)
'                    for partial search use this:
                    'Set itm = oListView.FindItem(sz:="partial", where:=lvwSubItem, index:=2, fPartial:lvwPartial)
                    
                    If Not oListView.FindItem(sz:=FileFullPath, where:=0, fPartial:=lvwWhole) Then
                        oListView.ListItems.Add , , FileFullPath
                    End If
                End If
            Next
        Else        'if drag dropped folder
            Set objTopFolder = objFSO.GetFolder(FileFullPath)
            DD_AddToListview objTopFolder.Path
        End If
    End If

    If option_DD_LogFolders = True Then
        If UCase(IsFileFolderURL(FileFullPath)) = "D" Then
            Set objTopFolder = objFSO.GetFolder(FileFullPath)
            If Not oListView.FindItem(sz:=objTopFolder.Path & "\", where:=0, fPartial:=lvwWhole) Then
                oListView.ListItems.Add , , objTopFolder.Path
            End If
            DD_AddToListview objTopFolder.Path
        End If
    End If
    Set objFSO = Nothing
    Set objTopFolder = Nothing
End Sub

Sub AutofitColumns()
'@AssignedModule aListView
'@INCLUDE CLASS aListView
    Dim counter As Long
    For counter = 1 To oListView.ColumnHeaders.count
        Call SendMessageLong(oListView.hwnd, LVM_SETCOLUMNWIDTH, counter - 1, LVSCW_AUTOSIZE_USEHEADER)
    Next
End Sub

Public Function Init(LV As ListView) As aListView
'REFERENCE: Microsoft Windows Common Controls 6.0 (SP6)
'@AssignedModule aListView
'@INCLUDE CLASS aListView

    Set oListView = LV
    Set Init = Me

End Function
'Public Function Parent()
'
'End Function
Public Sub Clear()
'@AssignedModule aListView
'@INCLUDE CLASS aListView
    oListView.ListItems.Clear
    oListView.ColumnHeaders.Clear
End Sub

Public Sub InitializeFromArray(inputArray As Variant)
'@AssignedModule aListView
'@INCLUDE CLASS aListView
    Clear
    Dim vListItem As ListItem
    Dim vChildItem As ListSubItem
    Dim vHeader As Variant
    Dim iRows As Long, iColumns As Long
    For iColumns = LBound(inputArray, 2) To UBound(inputArray, 2)
        Set vHeader = oListView.ColumnHeaders.Add(, , inputArray(LBound(inputArray, 1), iColumns))
    Next
    For iRows = LBound(inputArray, 1) + 1 To UBound(inputArray, 1)
        Set vListItem = oListView.ListItems.Add(, , inputArray(iRows, 1))
        For iColumns = LBound(inputArray, 2) + 1 To UBound(inputArray, 2)
            Set vChildItem = vListItem.ListSubItems.Add(, , inputArray(iRows, iColumns))
        Next
    Next
    oListView.View = lvwReport
End Sub

Public Sub AppendArray(inputArray As Variant)
'@AssignedModule aListView
'@INCLUDE PROCEDURE ArrayDimensions
'@INCLUDE CLASS aListView
    If ArrayDimensions(inputArray) <> 2 Then Exit Sub
    If UBound(inputArray, 2) + IIf(LBound(inputArray, 2) = 0, 1, 0) <> oListView.ColumnHeaders.count Then Exit Sub
    Dim vListItem As ListItem
    Dim vChildItem As ListSubItem
    Dim iRows As Long, iColumns As Long
    For iRows = LBound(inputArray, 1) To UBound(inputArray, 1)
        Set vListItem = oListView.ListItems.Add(, , inputArray(iRows, 1))
        For iColumns = LBound(inputArray, 2) + 1 To UBound(inputArray, 2)
            Set vChildItem = vListItem.ListSubItems.Add(, , inputArray(iRows, iColumns))
        Next
    Next
'    oListView.View = lvwReport
End Sub

Public Sub EventListener()
'@AssignedModule aListView
'@INCLUDE CLASS aListView
    Set aListViewEvent = oListView
End Sub

'Private Sub aListViewEvent_Click()
'    MsgBox "Clicked the listview"
'End Sub

Private Sub aListViewEvent_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, _
                                    ByVal x As stdole.OLE_XPOS_PIXELS, ByVal y As stdole.OLE_YPOS_PIXELS)
'@AssignedModule aListView
'@INCLUDE CLASS aListView
'@INCLUDE DECLARATION LOGPIXELSX
'@INCLUDE DECLARATION LOGPIXELSY
'@INCLUDE DECLARATION GetDC
'@INCLUDE DECLARATION GetDeviceCaps
'@INCLUDE DECLARATION ReleaseDC

   'https://markdagosta.wordpress.com/2010/08/08/listview-hittest-right-click/
   Dim item As MSComctlLib.ListItem
   Dim lngXPixelsPerInch As Long, lngYPixelsPerInch As Long
   Dim lngDeviceHandle As Long
   'Only capture the standard right-clicks; otherwise get out.
   If (Button <> xlSecondaryButton) Or (Shift <> 0) Then Exit Sub
  'We must determine the Pixels per Inch for the display device.
   lngDeviceHandle = GetDC(0)
   lngXPixelsPerInch = GetDeviceCaps(lngDeviceHandle, LOGPIXELSX)
   lngYPixelsPerInch = GetDeviceCaps(lngDeviceHandle, LOGPIXELSY)
   ReleaseDC 0, lngDeviceHandle
  'Convert the event's x and y arguments from Pixels to Twips
  Set item = oListView.hitTest(x * 1440 / lngXPixelsPerInch, y * 1440 / lngYPixelsPerInch)
   MsgBox "List ID #" & item.index & ": " & item.text & " has been right-clicked!"

   
End Sub

Public Sub RowsFormatOddEven()
'@AssignedModule aListView
'@INCLUDE CLASS aListView
    Dim i As Long, y As Long
    For i = 1 To oListView.ListItems.count
        If i Mod 2 Then
            oListView.ListItems(i).ForeColor = vbBlue
            For y = 1 To oListView.ColumnHeaders.count - 1
                oListView.ListItems(i).ListSubItems(y).ForeColor = vbBlue
            Next
        Else
            oListView.ListItems(i).ForeColor = vbRed
            For y = 1 To oListView.ColumnHeaders.count - 1
                oListView.ListItems(i).ListSubItems(y).ForeColor = vbRed
            Next
        End If
    Next
    oListView.Refresh
End Sub



'uAuthor	UserForm



'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Userform   : uAuthor
'* Created    : 06-10-2022 10:34
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* DONATE     : http://paypal.me/alexofrhodes
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Const AUTHOR_EMAIL = "anastasioualex@gmail.com"

#If VBA7 Then
    Private Declare PtrSafe Function InternetGetConnectedState Lib "wininet.dll" (ByRef dwFlags As Long, ByVal dwReserved As Long) As Long
    Private Declare PtrSafe Function GetSystemMetrics Lib "user32" (ByVal nIndex As Long) As Long
    
    Private Declare PtrSafe Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
    Private Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    Private Declare PtrSafe Function FindWindowA Lib "user32" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    Private Declare PtrSafe Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long) As Long
    Private Declare PtrSafe Function DrawMenuBar Lib "user32" (ByVal hwnd As Long) As Long
    Private Declare PtrSafe Function SetLayeredWindowAttributes Lib "user32" (ByVal hwnd As Long, ByVal crKey As Long, ByVal bAlpha As Byte, ByVal dwFlags As Long) As Long
#Else
    Private Declare Function InternetGetConnectedState Lib "wininet.dll" (ByRef dwflags As Long, ByVal dwReserved As Long) As Long
    Private Declare Function GetSystemMetrics Lib "user32" (ByVal nIndex As Long) As Long
    
    
    Private Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
    Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    Private Declare Function FindWindowA Lib "user32" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    Private Declare Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
    Private Declare Function DrawMenuBar Lib "user32" (ByVal hWnd As Long) As Long
    Private Declare Function SetLayeredWindowAttributes Lib "user32" (ByVal hWnd As Long, ByVal crKey As Long, ByVal bAlpha As Byte, ByVal dwFlags As Long) As Long
#End If


Private Const GWL_STYLE As Long = (-16)
Private Const GWL_EXSTYLE As Long = (-20)
Private Const WS_CAPTION As Long = &HC00000
Private Const WS_EX_DLGMODALFRAME As Long = &H1
Private Const WS_EX_LAYERED = &H80000
Private Const LWA_COLORKEY = &H1
Private Const LWA_ALPHA = &H2
Private m_sngDownX As Single
Private m_sngDownY As Single

Public Function GetInternetConnectedState() As Boolean
'@AssignedModule uAuthor
'@INCLUDE USERFORM uAuthor
'@INCLUDE DECLARATION InternetGetConnectedState
    GetInternetConnectedState = InternetGetConnectedState(0&, 0&)
End Function

Private Sub MakeFormTransparent(frm As Object, Optional color As Variant)
'@AssignedModule uAuthor
'@INCLUDE USERFORM uAuthor
'@INCLUDE DECLARATION GWL_EXSTYLE
'@INCLUDE DECLARATION LWA_COLORKEY
'@INCLUDE DECLARATION WS_EX_LAYERED
'@INCLUDE DECLARATION FindWindow
'@INCLUDE DECLARATION GetWindowLong
'@INCLUDE DECLARATION SetLayeredWindowAttributes
'@INCLUDE DECLARATION SetWindowLong
    Dim formhandle As Long
    Dim bytOpacity As Byte
    formhandle = CLng(FindWindow(vbNullString, frm.Caption))
    If IsMissing(color) Then color = vbWhite
    bytOpacity = 100
    SetWindowLong formhandle, GWL_EXSTYLE, GetWindowLong(formhandle, GWL_EXSTYLE) Or WS_EX_LAYERED
    frm.BackColor = color
    SetLayeredWindowAttributes formhandle, color, bytOpacity, LWA_COLORKEY
End Sub

Private Sub MakeFormBorderless(frm As Object)
'@AssignedModule uAuthor
'@INCLUDE USERFORM uAuthor
'@INCLUDE DECLARATION GWL_EXSTYLE
'@INCLUDE DECLARATION GWL_STYLE
'@INCLUDE DECLARATION WS_CAPTION
'@INCLUDE DECLARATION WS_EX_DLGMODALFRAME
'@INCLUDE DECLARATION DrawMenuBar
'@INCLUDE DECLARATION FindWindow
'@INCLUDE DECLARATION GetWindowLong
'@INCLUDE DECLARATION SetWindowLong
    Dim lngWindow As Long
    Dim lFrmHdl As Long
    lFrmHdl = CLng(FindWindow(vbNullString, frm.Caption))
    lngWindow = GetWindowLong(lFrmHdl, GWL_STYLE)
    lngWindow = lngWindow And (Not WS_CAPTION)
    SetWindowLong lFrmHdl, GWL_STYLE, lngWindow
    lngWindow = GetWindowLong(lFrmHdl, GWL_EXSTYLE)
    lngWindow = lngWindow And Not WS_EX_DLGMODALFRAME
    SetWindowLong lFrmHdl, GWL_EXSTYLE, lngWindow
    DrawMenuBar lFrmHdl
End Sub

Private Sub LVK_Click()
'@AssignedModule uAuthor
'@INCLUDE PROCEDURE FollowLink
'@INCLUDE USERFORM uAuthor
    FollowLink ("https://vk.com/video/playlist/735281600_1")
End Sub

Private Sub LExit_Click()
'@AssignedModule uAuthor
'@INCLUDE USERFORM uAuthor
    Unload Me
End Sub

Private Sub LBLOG_Click()
'@AssignedModule uAuthor
'@INCLUDE PROCEDURE FollowLink
'@INCLUDE USERFORM uAuthor
    FollowLink ("https://alexofrhodes.github.io")
End Sub

Private Sub LGitHub_Click()
'@AssignedModule uAuthor
'@INCLUDE PROCEDURE FollowLink
'@INCLUDE USERFORM uAuthor
    FollowLink ("https://github.com/alexofrhodes")
End Sub

Private Sub LYouTube_Click()
'@AssignedModule uAuthor
'@INCLUDE PROCEDURE FollowLink
'@INCLUDE USERFORM uAuthor
    FollowLink ("https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg")
End Sub

Private Sub LBuyMeACoffee_Click()
'@AssignedModule uAuthor
'@INCLUDE PROCEDURE FollowLink
'@INCLUDE USERFORM uAuthor
    FollowLink "http://paypal.me/alexofrhodes"
End Sub

Private Function CLIP(Optional StoreText As String) As String
'@AssignedModule uAuthor
'@INCLUDE USERFORM uAuthor
    Dim x As Variant
    x = StoreText
    With CreateObject("htmlfile")
        With .parentWindow.clipboardData
            Select Case True
            Case Len(StoreText)
                .SetData "text", x
            Case Else
                CLIP = .GetData("text")
            End Select
        End With
    End With
End Function

Private Sub LEmail_Click()
'@AssignedModule uAuthor
'@INCLUDE PROCEDURE CLIP
'@INCLUDE PROCEDURE OutlookCheck
'@INCLUDE PROCEDURE GetInternetConnectedState
'@INCLUDE USERFORM uAuthor
'@INCLUDE DECLARATION AUTHOR_EMAIL
    If GetInternetConnectedState = False Then
        MsgBox "Seems Internet is not available"
        Exit Sub
    End If
    If OutlookCheck = True Then
        MailDev
    Else
        Dim out As String
        out = AUTHOR_EMAIL
        CLIP out
        MsgBox ("Seems Outlook is not available" & Chr(10) & _
        "DEV's email address " & vbNewLine & out & vbNewLine & "copied to clipboard")
    End If
End Sub

Function OutlookCheck() As Boolean
'@AssignedModule uAuthor
'@INCLUDE USERFORM uAuthor
    Dim xOLApp As Object
    Set xOLApp = CreateObject("Outlook.Application")
    If Not xOLApp Is Nothing Then
        OutlookCheck = True
        Set xOLApp = Nothing
        Exit Function
    End If
    OutlookCheck = False
End Function


Sub MailDev()
'@AssignedModule uAuthor
'@INCLUDE USERFORM uAuthor
'@INCLUDE DECLARATION AUTHOR_EMAIL
    Dim OutApp As Object
    Dim OutMail As Object
    Dim strBody As String
    Set OutApp = CreateObject("Outlook.Application")
    Set OutMail = OutApp.CreateItem(0)
    On Error Resume Next
    With OutMail
        .to = AUTHOR_EMAIL
        .cc = vbNullString
        .BCC = vbNullString
        .Subject = "Feedback or request - " & ThisWorkbook.Name
        .body = strBody
        .display
    End With
    On Error GoTo 0
    Set OutMail = Nothing
    Set OutApp = Nothing
End Sub

Private Sub UserForm_Initialize()
'@AssignedModule uAuthor
'@INCLUDE USERFORM uAuthor
'@INCLUDE DECLARATION GetSystemMetrics

    Dim screenWidth As Long
    Dim screenHeight As Long
    
    screenWidth = GetSystemMetrics(0)  ' SM_CXSCREEN
    screenHeight = GetSystemMetrics(1)  ' SM_CYSCREEN
    
    Me.Width = screenWidth
    Me.Height = screenHeight
    
    Frame1.Left = Me.Width / 2 - Image1.Width
    Frame1.Top = Me.Height / 2 - Image1.Height
        MakeFormBorderless Me
'    MakeFormTransparent Me, vbYellow
End Sub




'z_TreeView	UserForm

Option Explicit

Private AT As aTreeView
Private Sub Label1_Click()
'@AssignedModule z_TreeView
'@INCLUDE PROCEDURE dp
'@INCLUDE CLASS aTreeView
'@INCLUDE USERFORM z_TreeView
'@INCLUDE DECLARATION AT
    dp AT.ToArray
End Sub

Private Sub Label2_Click()
'@AssignedModule z_TreeView
'@INCLUDE CLASS aTreeView
'@INCLUDE USERFORM z_TreeView
'@INCLUDE DECLARATION AT
    AT.LoadRange ThisWorkbook.Sheets("TV_Data").Range("A1"), True, True
End Sub

Private Sub Label3_Click()
'@AssignedModule z_TreeView
'@INCLUDE PROCEDURE dp
'@INCLUDE CLASS aTreeView
'@INCLUDE USERFORM z_TreeView
'@INCLUDE DECLARATION AT
    dp AT.TreeviewArrayPaths
End Sub

Private Sub Label4_Click()
'@AssignedModule z_TreeView
'@INCLUDE CLASS aTreeView
'@INCLUDE USERFORM z_TreeView
'@INCLUDE DECLARATION AT
    AT.LoadVBProjects
End Sub

Private Sub Label5_Click()
'@AssignedModule z_TreeView
'@INCLUDE CLASS aTreeView
'@INCLUDE USERFORM z_TreeView
'@INCLUDE DECLARATION AT
    AT.Clear
End Sub

Private Sub TreeView1_NodeCheck(ByVal Node As MSComctlLib.Node)
'@AssignedModule z_TreeView
'@INCLUDE CLASS aTreeView
'@INCLUDE USERFORM z_TreeView
'@INCLUDE DECLARATION AT
    AT.ChildrenCheck Node, Node.Checked
End Sub

Private Sub UserForm_Initialize()
'@AssignedModule z_TreeView
'@INCLUDE CLASS aTreeView
'@INCLUDE USERFORM z_TreeView
'@INCLUDE DECLARATION AT
    Set AT = New aTreeView
    AT.Init TreeView1
    TreeView1.CheckBoxes = True
End Sub


'z_ListBox	UserForm

Option Explicit

Private al As aListBox

Sub LoadSample()
'@AssignedModule z_ListBox
'@INCLUDE USERFORM z_ListBox
    With ListBox1
        .columnCount = 10
        Dim x As Long, y As Long
        Dim var(1 To 10, 1 To 10)
        For x = 1 To 10
            For y = 1 To 10
                var(x, y) = x * y
            Next
        Next
        .List = var
        .multiSelect = fmMultiSelectSingle
        
    End With
End Sub
Private Sub Label10_Click()
'@AssignedModule z_ListBox
'@INCLUDE PROCEDURE RandomStringArray
'@INCLUDE CLASS aListBox
'@INCLUDE USERFORM z_ListBox
'@INCLUDE DECLARATION al
    al.removeHeaders
    With ListBox1
        .columnCount = 10
        .Clear
        .List = RandomStringArray(10, 10, 5)
    End With
End Sub


Private Sub CheckBox2_Click()
'@AssignedModule z_ListBox
'@INCLUDE CLASS aListBox
'@INCLUDE USERFORM z_ListBox
    If CheckBox2.Value = True Then
        ListBox1.multiSelect = fmMultiSelectExtended
    Else
        ListBox1.multiSelect = fmMultiSelectSingle
    End If
End Sub



Private Sub Label11_Click()
'    dp al.SelectedRowsText
'@AssignedModule z_ListBox
'@INCLUDE PROCEDURE dp
'@INCLUDE CLASS aListBox
'@INCLUDE USERFORM z_ListBox
'@INCLUDE DECLARATION al
    dp al.SelectedRowsArray
End Sub



Private Sub Label12_Click()
'@AssignedModule z_ListBox
'@INCLUDE CLASS aListBox
'@INCLUDE USERFORM z_ListBox
'@INCLUDE DECLARATION al
    al.ListenToDoubleClick
End Sub

Private Sub Label13_Click()
'@AssignedModule z_ListBox
'@INCLUDE CLASS aListBox
'@INCLUDE USERFORM z_ListBox
'@INCLUDE DECLARATION al
    al.ListenToExtendedSelection
End Sub

Private Sub Label14_Click()
'@AssignedModule z_ListBox
'@INCLUDE CLASS aListBox
'@INCLUDE USERFORM z_ListBox
'@INCLUDE DECLARATION al
    al.ListenToDragDrop ListBox2
End Sub

Private Sub Label15_Click()
'@AssignedModule z_ListBox
'@INCLUDE CLASS aListBox
'@INCLUDE USERFORM z_ListBox
'@INCLUDE DECLARATION al
    Dim arr
    arr = Split(TextBox1.Value, ",")
    al.ShowTheseColumns arr
End Sub

Private Sub Label2_Click()
'@AssignedModule z_ListBox
'@INCLUDE CLASS aListBox
'@INCLUDE CLASS aUserform
'@INCLUDE USERFORM z_ListBox
'@INCLUDE DECLARATION al
    al.AutofitColumns True
    aUserform.Init(Me).ResizeToFitControls 10, 10
End Sub

Private Sub Label3_Click()
'@AssignedModule z_ListBox
'@INCLUDE CLASS aListBox
'@INCLUDE USERFORM z_ListBox
'@INCLUDE DECLARATION al
    Me.Caption = "Add files to Listbox by Drag and Drop"
    al.AcceptFiles sExpansion:="*", iDeepSubPath:=999
End Sub

Private Sub Label4_Click()
'@AssignedModule z_ListBox
'@INCLUDE CLASS aListBox
'@INCLUDE USERFORM z_ListBox
'@INCLUDE DECLARATION al
    al.AddFilter
End Sub

Private Sub Label5_Click()
'@AssignedModule z_ListBox
'@INCLUDE USERFORM z_ListBox
    LoadSample
End Sub

Private Sub Label6_Click()
'@AssignedModule z_ListBox
'@INCLUDE CLASS aListBox
'@INCLUDE USERFORM z_ListBox
'@INCLUDE DECLARATION al
    al.RememberList
End Sub

Private Sub Label7_Click()
'@AssignedModule z_ListBox
'@INCLUDE CLASS aListBox
'@INCLUDE USERFORM z_ListBox
'@INCLUDE DECLARATION al
    Dim i As Long: i = InputBox("How many rows to display?")
    If i >= 1 And i <= ListBox1.ListCount Then al.HeightToEntries i
End Sub

Private Sub Label8_Click()
'@AssignedModule z_ListBox
'@INCLUDE CLASS aListBox
'@INCLUDE USERFORM z_ListBox
'@INCLUDE DECLARATION al
    al.AddHeader
    Me.Caption = "Click on header to sort A to Z"
End Sub

Private Sub UserForm_Initialize()
'@AssignedModule z_ListBox
'@INCLUDE CLASS aListBox
'@INCLUDE USERFORM z_ListBox
'@INCLUDE DECLARATION al
    Set al = New aListBox
    al.Init ListBox1
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
'@AssignedModule z_ListBox
'@INCLUDE CLASS aListBox
'@INCLUDE USERFORM z_ListBox
'@INCLUDE DECLARATION al
    Set al = Nothing
End Sub


'aFrame	Class

'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Class      : aFrame
'* Purpose    :
'* Copyright  :
'*
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 05-07-2023 07:26    Alex
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Private oFrame As MSForms.Frame

Public Function Init(TargetFrame As Object) As aFrame
'@AssignedModule aFrame
'@INCLUDE CLASS aFrame
    Set oFrame = TargetFrame
    Set Init = Me
End Function

Public Sub ResizeToFitControls(Optional marginRight = 0, Optional marginBottom = 0)
'@AssignedModule aFrame
'@INCLUDE CLASS aFrame
    oFrame.Width = 0
    oFrame.Height = 0
    Dim ctr As MSForms.control
    Dim myWidth:    myWidth = 0
    Dim myHeight:   myHeight = 0
    For Each ctr In oFrame.Controls
        If ctr.Parent.Name = oFrame.Name Then
            If ctr.Visible = True Then
                If ctr.Left + ctr.Width > myWidth Then myWidth = ctr.Left + ctr.Width
                If ctr.Top + ctr.Height > myHeight Then myHeight = ctr.Top + ctr.Height
            End If
        End If
    Next
    oFrame.Width = myWidth + (oFrame.Width - oFrame.InsideWidth) + marginRight
    oFrame.Height = myHeight + (oFrame.Height - oFrame.InsideHeight) + marginBottom
End Sub

Public Sub AddThemeControls()
'@AssignedModule aFrame
'@INCLUDE PROCEDURE aSwitch
'@INCLUDE CLASS aFrame
'@INCLUDE CLASS aColorScheme
'@INCLUDE DECLARATION Ctrl
    Dim Ctrl As MSForms.control
    Dim i As Long
    For i = 1 To 19
        Set Ctrl = oFrame.Controls.Add("Forms.Label.1")
        Ctrl.Visible = False
        Ctrl.Top = i * Ctrl.Height
        Ctrl.Left = 12
        Ctrl.Height = 20
        Ctrl.Width = 120
        Ctrl.Font.Size = 9
        Ctrl.Font.Name = "Consolas"
        Ctrl.WordWrap = False
        Ctrl.Caption = aSwitch(i, 1, "ThemeBlackAndBlueDark", 2, "ThemeBlackAndBrownDark", 3, "ThemeBlackAndGrayDark", 4, "ThemeBlackAndGreenDark", 5, "ThemeBlackAndOrangeDark", 6, "ThemeBlackAndPinkDark", 7, "ThemeBlackAndPurpleDark", 8, "ThemeBlackAndRedDark", 9, "ThemeBlackAndYellowDark", 10, "ThemeBlueAndGreenLight", 11, "ThemeWhiteAndBlueLight", 12, "ThemeWhiteAndBrownLight", 13, "ThemeWhiteAndGrayLight", 14, "ThemeWhiteAndGreenLight", 15, "ThemeWhiteAndOrangeLight", 16, "ThemeWhiteAndPinkLight", 17, "ThemeWhiteAndPurpleLight", 18, "ThemeWhiteAndRedLight", 19, "ThemeWhiteAndYellowLight")
        Ctrl.Visible = True
    Next
'
'    On Error Resume Next
'        For Each ctrl In oframe.parent.Controls
'            ctrl.Font.Name = "Consolas"
'            ctrl.Font.Size = 9
'            ctrl.Font.Bold = True
'        Next
'    On Error GoTo 0
    
    aColorScheme.Init oFrame.Parent
End Sub


'z_ColorSchemes	UserForm

Option Explicit

Private Sub UserForm_Initialize()
'    aColorScheme.Init(Me.Frame1).ThemeBlackAndGreenDark
'    aColorScheme.Init(Me).ThemeBlackAndGreenDark
'@AssignedModule z_ColorSchemes
'@INCLUDE CLASS aFrame
'@INCLUDE CLASS aColorScheme
'@INCLUDE USERFORM z_ColorSchemes
'@INCLUDE DECLARATION Ctrl
    aFrame.Init(fColorSchemes).AddThemeControls
    
    
    Dim Ctrl As MSForms.control
    On Error Resume Next
        For Each Ctrl In Me.Controls
            Ctrl.Font.Name = "Consolas"
            Ctrl.Font.Size = 9
            Ctrl.Font.Bold = True
        Next
    On Error GoTo 0
    
End Sub

'aColorScheme	Class


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Class      : aColorScheme
'* Purpose    :
'* Copyright  :
'*
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 05-07-2023 12:04    Alex
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Private myTarget As Object
Public WithEvents Emitter As EventListenerEmitter

Public NormalBackColor, NormalForeColor, HoverBackColor, HoverForeColor, SelectedColor
Public DefaultNormalBackColor, DefaultNormalForeColor

Dim cWhite As Long
Dim cWhiteHover As Long
Dim cBlueLight As Long
Dim cBlueLightHover As Long
Dim cGreenLight As Long
Dim cGreenLightHover As Long
Dim cPurpleLight As Long
Dim cPurpleLightHover As Long
Dim cYellowLight As Long
Dim cYellowLightHover As Long
Dim cRedLight As Long
Dim cRedLightHover As Long
Dim cOrangeLight As Long
Dim cOrangeLightHover As Long
Dim cGrayLight As Long
Dim cGrayLightHover As Long
Dim cBrownLight As Long
Dim cBrownLightHover As Long
Dim cPinkLight As Long
Dim cPinkLightHover As Long

Dim cBlack As Long
Dim cBlackHover As Long
Dim cBlueDark As Long
Dim cBlueDarkHover As Long
Dim cGreenDark As Long
Dim cGreenDarkHover As Long
Dim cPurpleDark As Long
Dim cPurpleDarkHover As Long
Dim cYellowDark As Long
Dim cYellowDarkHover As Long
Dim cRedDark As Long
Dim cRedDarkHover As Long
Dim cOrangeDark As Long
Dim cOrangeDarkHover As Long
Dim cGrayDark As Long
Dim cGrayDarkHover As Long
Dim cBrownDark As Long
Dim cBrownDarkHover As Long
Dim cPinkDark As Long
Dim cPinkDarkHover As Long

Sub AssignColors()
    ' Light Themes
'@AssignedModule aColorScheme
'@INCLUDE CLASS aColorScheme
'@INCLUDE DECLARATION red
    cWhite = RGB(255, 255, 255)
    cWhiteHover = RGB(230, 230, 230)
    cBlueLight = RGB(20, 61, 89) ' Darker blue color
    cBlueLightHover = RGB(61, 129, 168)
    cGreenLight = RGB(33, 138, 33) ' Darker green color
    cGreenLightHover = RGB(78, 160, 78)
    cPurpleLight = RGB(85, 47, 113) ' Darker purple color
    cPurpleLightHover = RGB(130, 84, 151)
    cYellowLight = RGB(153, 123, 0) ' Darker yellow color
    cYellowLightHover = RGB(193, 156, 0)
    cRedLight = RGB(169, 0, 0) ' Darker red color
    cRedLightHover = RGB(204, 0, 0)
    cOrangeLight = RGB(201, 87, 0) ' Darker orange color
    cOrangeLightHover = RGB(234, 113, 0)
    cGrayLight = RGB(51, 51, 51) ' Darker gray color
    cGrayLightHover = RGB(85, 85, 85)
    cBrownLight = RGB(102, 34, 34) ' Darker brown color
    cBrownLightHover = RGB(128, 42, 42)
    cPinkLight = RGB(163, 67, 111) ' Darker pink color
    cPinkLightHover = RGB(207, 112, 145)
    
    ' Dark Themes
    cBlack = RGB(0, 0, 0)
    cBlackHover = RGB(64, 64, 64)
    cBlueDark = RGB(0, 0, 139)
    cBlueDarkHover = RGB(0, 0, 205)
    cGreenDark = RGB(0, 100, 0)
    cGreenDarkHover = RGB(0, 128, 0)
    cPurpleDark = RGB(128, 0, 128)
    cPurpleDarkHover = RGB(139, 0, 139)
    cYellowDark = RGB(128, 128, 0)
    cYellowDarkHover = RGB(184, 134, 11)
    cRedDark = RGB(139, 0, 0)
    cRedDarkHover = RGB(178, 34, 34)
    cOrangeDark = RGB(255, 140, 0)
    cOrangeDarkHover = RGB(255, 69, 0)
    cGrayDark = RGB(105, 105, 105)
    cGrayDarkHover = RGB(128, 128, 128)
    cBrownDark = RGB(139, 69, 19)
    cBrownDarkHover = RGB(160, 82, 45)
    cPinkDark = RGB(255, 105, 180)
    cPinkDarkHover = RGB(255, 20, 147)
End Sub

Sub ThemeWhiteAndBlueLight()
'@AssignedModule aColorScheme
'@INCLUDE CLASS aColorScheme
    Call color(cWhite, cBlueLight, cWhiteHover, cBlueLightHover)
End Sub

Sub ThemeWhiteAndGreenLight()
'@AssignedModule aColorScheme
'@INCLUDE CLASS aColorScheme
    Call color(cWhite, cGreenLight, cWhiteHover, cGreenLightHover)
End Sub

Sub ThemeWhiteAndPurpleLight()
'@AssignedModule aColorScheme
'@INCLUDE CLASS aColorScheme
    Call color(cWhite, cPurpleLight, cWhiteHover, cPurpleLightHover)
End Sub

Sub ThemeWhiteAndYellowLight()
'@AssignedModule aColorScheme
'@INCLUDE CLASS aColorScheme
    Call color(cWhite, cYellowLight, cWhiteHover, cYellowLightHover)
End Sub

Sub ThemeWhiteAndRedLight()
'@AssignedModule aColorScheme
'@INCLUDE CLASS aColorScheme
    Call color(cWhite, cRedLight, cWhiteHover, cRedLightHover)
End Sub

Sub ThemeWhiteAndOrangeLight()
'@AssignedModule aColorScheme
'@INCLUDE CLASS aColorScheme
    Call color(cWhite, cOrangeLight, cWhiteHover, cOrangeLightHover)
End Sub

Sub ThemeWhiteAndGrayLight()
'@AssignedModule aColorScheme
'@INCLUDE CLASS aColorScheme
    Call color(cWhite, cGrayLight, cWhiteHover, cGrayLightHover)
End Sub

Sub ThemeWhiteAndBrownLight()
'@AssignedModule aColorScheme
'@INCLUDE CLASS aColorScheme
    Call color(cWhite, cBrownLight, cWhiteHover, cBrownLightHover)
End Sub

Sub ThemeWhiteAndPinkLight()
'@AssignedModule aColorScheme
'@INCLUDE CLASS aColorScheme
    Call color(cWhite, cPinkLight, cWhiteHover, cPinkLightHover)
End Sub

Sub ThemeBlueAndGreenLight()
'@AssignedModule aColorScheme
'@INCLUDE CLASS aColorScheme
    Call color(cBlueLight, cGreenLight, cBlueLightHover, cGreenLightHover)
End Sub

Sub ThemeBlackAndBlueDark()
'@AssignedModule aColorScheme
'@INCLUDE CLASS aColorScheme
    Call color(cBlack, cBlueDark, cBlackHover, cBlueDarkHover)
End Sub

Sub ThemeBlackAndGreenDark()
'@AssignedModule aColorScheme
'@INCLUDE CLASS aColorScheme
    Call color(cBlack, cGreenDark, cBlackHover, cGreenDarkHover)
End Sub

Sub ThemeBlackAndPurpleDark()
'@AssignedModule aColorScheme
'@INCLUDE CLASS aColorScheme
    Call color(cBlack, cPurpleDark, cBlackHover, cPurpleDarkHover)
End Sub

Sub ThemeBlackAndYellowDark()
'@AssignedModule aColorScheme
'@INCLUDE CLASS aColorScheme
    Call color(cBlack, cYellowDark, cBlackHover, cYellowDarkHover)
End Sub

Sub ThemeBlackAndRedDark()
'@AssignedModule aColorScheme
'@INCLUDE CLASS aColorScheme
    Call color(cBlack, cRedDark, cBlackHover, cRedDarkHover)
End Sub

Sub ThemeBlackAndOrangeDark()
'@AssignedModule aColorScheme
'@INCLUDE CLASS aColorScheme
    Call color(cBlack, cOrangeDark, cBlackHover, cOrangeDarkHover)
End Sub

Sub ThemeBlackAndGrayDark()
'@AssignedModule aColorScheme
'@INCLUDE CLASS aColorScheme
    Call color(cBlack, cGrayDark, cBlackHover, cGrayDarkHover)
End Sub

Sub ThemeBlackAndBrownDark()
'@AssignedModule aColorScheme
'@INCLUDE CLASS aColorScheme
    Call color(cBlack, cBrownDark, cBlackHover, cBrownDarkHover)
End Sub

Sub ThemeBlackAndPinkDark()
'@AssignedModule aColorScheme
'@INCLUDE CLASS aColorScheme
    Call color(cBlack, cPinkDark, cBlackHover, cPinkDarkHover)
End Sub


Public Sub color( _
                NormalBackColorValue, _
                NormalForeColorValue, _
                HoverBackColorValue, _
                HoverForeColorValue, _
                Optional SelectedColorValue)
'@AssignedModule aColorScheme
'@INCLUDE CLASS aColorScheme
        
    NormalBackColor = NormalBackColorValue
    NormalForeColor = NormalForeColorValue
    HoverBackColor = HoverBackColorValue
    HoverForeColor = HoverForeColorValue
    SelectedColor = SelectedColorValue
    
    ApplyColorToParent myTarget
End Sub

Private Sub ApplyColorToParent(obj As Object)
'@AssignedModule aColorScheme
'@INCLUDE CLASS aMultiPage
'@INCLUDE CLASS aColorScheme
'@INCLUDE DECLARATION Ctrl
    On Error Resume Next
    obj.BackColor = NormalBackColor
    obj.ForeColor = NormalForeColor
    On Error GoTo 0
    Dim Ctrl As MSForms.control
    For Each Ctrl In obj.Controls
        Select Case TypeName(Ctrl)
            Case "CommandButton", "Label", "CheckBox", "OptionButton"
                Ctrl.BackColor = NormalBackColor
                Ctrl.ForeColor = NormalForeColor
            Case "Frame"
                Ctrl.BackColor = NormalBackColor
                Ctrl.ForeColor = NormalForeColor
                ApplyColorToParent Ctrl
            Case "MultiPage"
                Dim i As Long
                With aMultiPage.Init(Ctrl)
                    For i = 0 To Ctrl.Pages.count - 1
                        .SetBackColor i, CLng(NormalBackColor)
                    Next
                End With
            Case Else
    
        End Select
    Next
End Sub

Private Sub SetEmitter()
'@AssignedModule aColorScheme
'@INCLUDE PROCEDURE isUserform
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS aColorScheme
'@INCLUDE DECLARATION Emitter
    Set Emitter = Nothing
    Set Emitter = New EventListenerEmitter
    Select Case TypeName(myTarget)
        Case "CommandButton", "Label", "OptionButton", "CheckBox" '@TODO add controls to emitter class, this isn't working for all
            Emitter.AddEventListener myTarget
        Case "MultiPage", "Frame"
            Emitter.AddEventListenerAll myTarget
        Case Else
            If isUserform(myTarget) Then
                Emitter.AddEventListenerAll myTarget
            End If
    End Select

End Sub

Private Sub resetColors()
'@AssignedModule aColorScheme
'@INCLUDE CLASS aColorScheme
    NormalBackColor = 0
    NormalForeColor = 0
    HoverBackColor = 0
    HoverForeColor = 0
    SelectedColor = 0
End Sub

Public Function Init(FormFrameOrControl As Object) As aColorScheme
'@AssignedModule aColorScheme
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS aColorScheme
    resetColors
    Set myTarget = FormFrameOrControl
    AssignColors
    SetEmitter
    Set Init = Me
End Function

Private Sub Emitter_Click(control As Object)
'@AssignedModule aColorScheme
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS aColorScheme
    If control.Caption Like "Theme*" Then
        CallByName Me, control.Caption, VbMethod
    End If
End Sub

Private Sub Emitter_MouseOut(control As Object)
'@AssignedModule aColorScheme
'@INCLUDE PROCEDURE isUserform
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS aColorScheme
    If NormalBackColor + NormalForeColor + HoverBackColor + HoverForeColor = 0 Then Exit Sub
    If isUserform(control) Then Exit Sub
    Select Case TypeName(control)
    Case "MultiPage", "Frame": Exit Sub
    End Select
    control.BackColor = NormalBackColor
    control.ForeColor = NormalForeColor
End Sub

Private Sub Emitter_MouseOver(control As Object)
'@AssignedModule aColorScheme
'@INCLUDE PROCEDURE isUserform
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS aColorScheme
    If NormalBackColor + NormalForeColor + HoverBackColor + HoverForeColor = 0 Then Exit Sub
    If isUserform(control) Then Exit Sub
    Select Case TypeName(control)
    Case "MultiPage", "Frame": Exit Sub
    End Select
    control.BackColor = HoverBackColor
    control.ForeColor = HoverForeColor
End Sub


'CVBECommandHandler	Class

Public WithEvents EvtHandler As VBIDE.CommandBarEvents

Public Sub EvtHandler_Click(ByVal CommandBarControl As Object, _
                            Handled As Boolean, CancelDefault As Boolean)
'@AssignedModule CVBECommandHandler
'@INCLUDE CLASS CVBECommandHandler
    On Error Resume Next
    Application.Run CommandBarControl.OnAction
    Handled = True
    CancelDefault = True
End Sub



'M_CommandBars	Module

Option Explicit

''''''''''''''''''''''''''''''''''''''''''''''''''''''
''DEVELOPER  Anastasiou Alex
''EMAIL      AnastasiouAlex@gmail.com
''GITHUB     https://github.com/AlexOfRhodes
''YOUTUBE    https://bit.ly/3aLZU9M
''VK         https://vk.com/video/playlist/735281600_1
''''''''''''''''''''''''''''''''''''''''''''''''''''''

Public Const rBUILD_ON_OPEN = "I3"
Public Const rC_TAG = "I4"
Public Const rMENU_TYPE = "I5"
Public Const rBAR_LOCATION = "I6"

Public MenuLevel, NextLevel, Caption, Divider, FaceId
Public MenuSheet As Worksheet
Public BarRow As Integer
Public MenuType As Long
Public Action As String

Public Const WorksheetMenu = 1
Public Const VbeMenu = 2
Public Const RightClickMenu = 3

Public BarLocation As String

Public C_TAG As String

Public MenuEvent        As CVBECommandHandler
Public EventHandlers    As New Collection
Public CmdBarItem       As CommandBarControl
Public TargetCommandbar 'As CommandBar
Public TargetControl    As CommandBarControl
Public MainMenu         As CommandBarControl
Public MenuItem         As CommandBarControl
Public Ctrl             As Office.CommandBarControl



Public Sub CreateAllBars()
'@AssignedModule M_CommandBars
'@INCLUDE PROCEDURE CommandBarBuilder
'@INCLUDE CLASS CVBECommandHandler
'@INCLUDE DECLARATION rBUILD_ON_OPEN
    Dim ws As Worksheet
    For Each ws In ThisWorkbook.Worksheets
        If UCase(Left(ws.Name, 4)) = "BAR_" Then
            If ws.Range(rBUILD_ON_OPEN) = True Then CommandBarBuilder ws
        End If
    Next
End Sub

Public Sub DeleteAllBars()
'@AssignedModule M_CommandBars
'@INCLUDE PROCEDURE DeleteControlsAndHandlers
'@INCLUDE CLASS CVBECommandHandler
    Dim ws As Worksheet
    For Each ws In ThisWorkbook.Worksheets
        If UCase(Left(ws.Name, 4)) = "BAR_" Then DeleteControlsAndHandlers ws
    Next
End Sub

Public Sub RestoreBars()
'@AssignedModule M_CommandBars
'@INCLUDE PROCEDURE CreateAllBars
'@INCLUDE CLASS CVBECommandHandler
    Application.OnTime Now, "CreateAllBars"
End Sub

Public Sub ListBars()
'@AssignedModule M_CommandBars
'@INCLUDE PROCEDURE ListWorksheetBars
'@INCLUDE PROCEDURE ListVBEBars
'@INCLUDE CLASS CVBECommandHandler
    ListWorksheetBars
    ListVBEBars
End Sub

Public Sub NewBar()
'@AssignedModule M_CommandBars
'@INCLUDE PROCEDURE lastBar
'@INCLUDE CLASS CVBECommandHandler
    Dim wsMain As Worksheet
    Set wsMain = ActiveSheet
    Dim wsCopy As Worksheet
    wsMain.Copy After:=ThisWorkbook.Sheets(ThisWorkbook.Sheets.count)
    Set wsCopy = ThisWorkbook.Sheets(ThisWorkbook.Sheets.count)
    wsCopy.Name = "BAR_" & lastBar + 1
    On Error Resume Next
    wsCopy.Range("A1").ListObject.DataBodyRange.Delete
    On Error GoTo 0
    wsCopy.Range("I5:I6").ClearContents
    wsCopy.Range("I3") = False
End Sub

Private Function lastBar() As Long
'@AssignedModule M_CommandBars
'@INCLUDE CLASS CVBECommandHandler
    Dim counter As Long
    Dim ws As Worksheet
    For Each ws In ThisWorkbook.Worksheets
        If UCase(Left(ws.Name, 4)) = "BAR_" Then counter = counter + 1
    Next
    lastBar = counter
End Function

'The names for each of the top-level CommandBars in the VBE
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Name                       Description
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Menu Bar                   The normalVBE menu bar
'Standard                   The normal VBE toolbar
'Edit                       The VBE edit toolbar, containing useful code-editing tools
'Debug                      The VBE debug toolbar, containing typical debugging tools
'UserForm                   The VBE UserForm toolbar, containing useful form-editing tools
'MSForms                    The popup menu for a UserForm (shown when you right-click the UserForm background)
'MSForms Control            The popup menu for a normal control on a UserForm
'MSForms Control Group      The popup menu that appears when you right-click a group of controls on a UserForm
'MSForms MPC                The popup menu for theMulti-Page control
'MSForms Palette            The popup menu that appears when you right-click a tool in the Control Toolbox
'MSForms Toolbox            The popup menu that appears when you right-click one of the tabs at the top of the Control Toolbox
'MSForms DragDrop           The popup menu that appears when you use the right mouse button to drag a control between tabs in the Control Toolbox, or onto a UserForm
'Code Window                The popup menu for a code window
'Code Window (Break)        The popup menu for a code window, when in Break (debug) mode
'Watch Window               The popup menu for the Watch window
'Immediate Window           The popup menu for the Immediate window
'Locals Window              The popup menu for the Locals window
'Project Window             The popup menu for the Project Explorer
'Project Window (Break)     The popup menu for the Project Explorer, when in Break mode
'Object Browser             The popup menu for the Object Browser
'Property Browser           The popup menu for the Properties window
'Docked Window              The popup menu that appears when you right-click the title bar of a docked window

Public Function BarExists(findBarName As String) As Boolean
'@AssignedModule M_CommandBars
'@INCLUDE CLASS CVBECommandHandler
    Dim bar As CommandBar
    For Each bar In Application.CommandBars
        If UCase(bar.Name) = UCase(findBarName) Then
            BarExists = True
            Exit Function
        End If
    Next bar
    For Each bar In Application.VBE.CommandBars
        If UCase(bar.Name) = UCase(findBarName) Then
            BarExists = True
            Exit Function
        End If
    Next bar
End Function

Public Sub BuildBarFromShape()
'@AssignedModule M_CommandBars
'@INCLUDE PROCEDURE CommandBarBuilder
'@INCLUDE CLASS CVBECommandHandler
    CommandBarBuilder ActiveSheet
End Sub

Public Sub DeleteBarFromShape()
'@AssignedModule M_CommandBars
'@INCLUDE PROCEDURE DeleteControlsAndHandlers
'@INCLUDE CLASS CVBECommandHandler
    DeleteControlsAndHandlers ActiveSheet
End Sub

Private Sub CommandBarBuilder(ws As Worksheet)
'@AssignedModule M_CommandBars
'@INCLUDE PROCEDURE SetCMDbar
'@INCLUDE PROCEDURE CreateMainMenu
'@INCLUDE PROCEDURE CreatePopup
'@INCLUDE PROCEDURE CreateButton
'@INCLUDE PROCEDURE DirectButton
'@INCLUDE PROCEDURE DeleteControlsAndHandlers
'@INCLUDE PROCEDURE markControlType
'@INCLUDE PROCEDURE SetVariables
'@INCLUDE PROCEDURE ReSetVariables
'@INCLUDE CLASS CVBECommandHandler
'@INCLUDE DECLARATION VbeMenu
'@INCLUDE DECLARATION BarLocation
'@INCLUDE DECLARATION BarRow
'@INCLUDE DECLARATION C_TAG
'@INCLUDE DECLARATION MenuSheet
'@INCLUDE DECLARATION MenuType
'@INCLUDE DECLARATION TargetControl
    DeleteControlsAndHandlers ws
    SetCMDbar ws
    Set MenuSheet = ws
    BarRow = 2
'    If MenuType = VbeMenu Then
'        If BarLocation = "Menu Bar" Then
'            Set TargetControl = TargetCommandbar.Controls.Add(Type:=msoControlPopup, Temporary:=True)
'        End If
'        If Not TargetControl Is Nothing Then
'            TargetControl.Caption = C_TAG
'            TargetControl.Tag = C_TAG
'        End If
'    End If
    Do Until IsEmpty(MenuSheet.Cells(BarRow, 1))
        With MenuSheet
            SetVariables
        End With
        Select Case MenuLevel
        '@TODO add in the table "Main Menu|Tools" etc
        'and in the following functions create main menu / target... by splitting
        'to get commandbars.controls.add
        'or commandbars.controls(...).add
            Case 1
                If NextLevel > MenuLevel Then
                    CreateMainMenu
                Else
                    DirectButton
                End If
            Case 2
                If NextLevel > MenuLevel Then
                    CreatePopup
                Else
                    DirectButton
                End If
            Case 3
                CreateButton
        End Select
        BarRow = BarRow + 1
        ReSetVariables
    Loop
    markControlType ws
    Debug.Print "Bar created"
End Sub

Private Function SetCMDbar(ws As Worksheet) As Boolean
'@AssignedModule M_CommandBars
'@INCLUDE CLASS CVBECommandHandler
'@INCLUDE DECLARATION rBAR_LOCATION
'@INCLUDE DECLARATION rC_TAG
'@INCLUDE DECLARATION RightClickMenu
'@INCLUDE DECLARATION rMENU_TYPE
'@INCLUDE DECLARATION VbeMenu
'@INCLUDE DECLARATION WorksheetMenu
'@INCLUDE DECLARATION BarLocation
'@INCLUDE DECLARATION C_TAG
'@INCLUDE DECLARATION MenuType
    C_TAG = ws.Range(rC_TAG)
    Select Case LCase(ws.Range(rMENU_TYPE))
        Case Is = LCase("WorksheetMenu")
            MenuType = WorksheetMenu
        Case Is = LCase("vbeMenu")
            MenuType = VbeMenu
        Case Is = LCase("RightClickMenu")
            MenuType = RightClickMenu
        Case Else
    End Select
    If ws.Range(rBAR_LOCATION) <> "" Then
        BarLocation = ws.Range(rBAR_LOCATION)
    Else
        BarLocation = 0
    End If
    If MenuType = VbeMenu Then
        Select Case BarLocation
            'case sensitive
            Case Is = "Menu Bar", "Code Window", "Project Window", "Debug", "Userform", _
                      "MSForms", "MSForms Control", "MSForms Control Group", "MSForms MPC", _
                      "MSForms Palette", "MSForms Toolbox", "MSForms DragDrop", "Code Window (Break)", _
                      "Watch Window", "Immediate Window", "Locals Window", "Project Window (Break)", _
                      "Object Browser", "Property Browser", "Docked Window", _
                      "View", "Insert", "Format", "Add-Ins", "Window"
                Set TargetCommandbar = Application.VBE.CommandBars(BarLocation)
                SetCMDbar = True
            Case Else
                Set TargetCommandbar = Application.VBE.CommandBars.Add(C_TAG, Position:=msoBarTop, Temporary:=True)
                TargetCommandbar.Visible = True
        End Select
    ElseIf MenuType = WorksheetMenu Then
        Select Case ws.Range(rBAR_LOCATION)
            Case Is = "Worksheet Menu Bar", "Cell", "Column", "Row"
                Set TargetCommandbar = Application.CommandBars(BarLocation)
                SetCMDbar = True
            Case Else
        End Select
    Else
    End If
End Function


Private Sub CreateMainMenu()
'@AssignedModule M_CommandBars
'@INCLUDE CLASS CVBECommandHandler
'@INCLUDE DECLARATION RightClickMenu
'@INCLUDE DECLARATION VbeMenu
'@INCLUDE DECLARATION WorksheetMenu
'@INCLUDE DECLARATION Action
'@INCLUDE DECLARATION C_TAG
'@INCLUDE DECLARATION MainMenu
'@INCLUDE DECLARATION MenuType
    If MenuType = VbeMenu Then
        Set MainMenu = TargetCommandbar.Controls.Add(Type:=msoControlPopup)
    ElseIf MenuType = WorksheetMenu Then
        Set MainMenu = TargetCommandbar.Controls.Add(Type:=msoControlPopup, Temporary:=True)
    ElseIf MenuType = RightClickMenu Then
'        Set TargetCommandbar = CommandBars.Add(C_TAG, msoBarPopup, , True)
'        Set MainMenu = TargetCommandbar.Controls.Add(Type:=msoControlPopup)
        On Error Resume Next
        CommandBars.Add C_TAG, msoBarPopup, , True
        On Error GoTo 0
        Set MainMenu = CommandBars(C_TAG).Controls.Add(Type:=msoControlPopup)
        'Exit Sub
    End If
    With MainMenu
        .Caption = Caption
        .BeginGroup = Divider
        If FaceId <> "" And Action <> "" Then .FaceId = FaceId
        .Tag = C_TAG
    End With
End Sub

Private Sub CreatePopup()
'@AssignedModule M_CommandBars
'@INCLUDE CLASS CVBECommandHandler
'@INCLUDE DECLARATION RightClickMenu
'@INCLUDE DECLARATION Action
'@INCLUDE DECLARATION C_TAG
'@INCLUDE DECLARATION MainMenu
'@INCLUDE DECLARATION MenuItem
'@INCLUDE DECLARATION MenuType
    If MenuType = RightClickMenu Then
'        Set MenuItem = TargetCommandbar.Controls.Add(Type:=msoControlPopup)
        Set MenuItem = MainMenu.Controls.Add(Type:=msoControlPopup)
        
    Else
        Set MenuItem = MainMenu.Controls.Add(Type:=msoControlPopup)
    End If
    With MenuItem
        .Caption = Caption
        .BeginGroup = Divider
        If FaceId <> "" And Action <> "" Then .FaceId = FaceId
        .Tag = C_TAG
    End With
End Sub

Private Sub CreateButton()
'@AssignedModule M_CommandBars
'@INCLUDE CLASS CVBECommandHandler
'@INCLUDE DECLARATION VbeMenu
'@INCLUDE DECLARATION Action
'@INCLUDE DECLARATION C_TAG
'@INCLUDE DECLARATION CmdBarItem
'@INCLUDE DECLARATION EventHandlers
'@INCLUDE DECLARATION MenuEvent
'@INCLUDE DECLARATION MenuItem
'@INCLUDE DECLARATION MenuType
    If MenuType = VbeMenu Then
        Set MenuEvent = New CVBECommandHandler
    End If
    Set CmdBarItem = MenuItem.Controls.Add
    With CmdBarItem
        .Caption = Caption
        .BeginGroup = Divider
        .OnAction = Action
        If FaceId <> "" Then .FaceId = FaceId
        .Tag = C_TAG
    End With
    If MenuType = VbeMenu Then
        Set MenuEvent.EvtHandler = Application.VBE.Events.CommandBarEvents(CmdBarItem)
        On Error Resume Next
        EventHandlers.Add MenuEvent, CmdBarItem.Caption
        On Error GoTo 0
    End If
End Sub

Private Sub DirectButton()
'@AssignedModule M_CommandBars
'@INCLUDE CLASS CVBECommandHandler
'@INCLUDE DECLARATION RightClickMenu
'@INCLUDE DECLARATION VbeMenu
'@INCLUDE DECLARATION Action
'@INCLUDE DECLARATION C_TAG
'@INCLUDE DECLARATION CmdBarItem
'@INCLUDE DECLARATION EventHandlers
'@INCLUDE DECLARATION MainMenu
'@INCLUDE DECLARATION MenuEvent
'@INCLUDE DECLARATION MenuType
    Dim CmdBarItem As CommandBarControl
    If MenuType = VbeMenu Then
        Set MenuEvent = New CVBECommandHandler
    End If
    Select Case MenuLevel
        Case Is = 1
            Set CmdBarItem = TargetCommandbar.Controls.Add
        Case Is = 2
'            If MenuType = RightClickMenu Then
'                Set CmdBarItem = TargetCommandbar.Controls.Add
'            Else
                Set CmdBarItem = MainMenu.Controls.Add
'            End If
    End Select
    With CmdBarItem
        .Style = msoButtonIconAndCaption
        .Caption = Caption
        .BeginGroup = Divider
        .OnAction = Action
        If FaceId <> "" Then .FaceId = FaceId
        .Tag = C_TAG
    End With
    If MenuType = VbeMenu Then
        Set MenuEvent.EvtHandler = Application.VBE.Events.CommandBarEvents(CmdBarItem)
        EventHandlers.Add MenuEvent
    End If
End Sub

Private Sub DeleteControlsAndHandlers(ws As Worksheet)
'@AssignedModule M_CommandBars
'@INCLUDE PROCEDURE BarExists
'@INCLUDE PROCEDURE DeleteHandlersFor
'@INCLUDE CLASS CVBECommandHandler
'@INCLUDE DECLARATION rC_TAG
'@INCLUDE DECLARATION RightClickMenu
'@INCLUDE DECLARATION rMENU_TYPE
'@INCLUDE DECLARATION VbeMenu
'@INCLUDE DECLARATION WorksheetMenu
'@INCLUDE DECLARATION Ctrl
'@INCLUDE DECLARATION MenuType
    If ws.Range(rC_TAG).text = vbNullString Then Exit Sub
    Select Case LCase(ws.Range(rMENU_TYPE))
        Case "vbemenu"
            MenuType = VbeMenu
        Case "worksheetmenu"
            MenuType = WorksheetMenu
        Case "rightclickmenu"
            MenuType = RightClickMenu
    End Select
    If MenuType = VbeMenu Then
        If BarExists(ws.Range(rC_TAG)) Then
            Application.VBE.CommandBars(ws.Range(rC_TAG).text).Delete
            Set Ctrl = Application.VBE.CommandBars.FindControl(Tag:=ws.Range(rC_TAG).text)
        End If
    ElseIf MenuType = WorksheetMenu Then
        Set Ctrl = Application.CommandBars.FindControl(Tag:=ws.Range(rC_TAG).text)
    ElseIf MenuType = RightClickMenu Then
        If BarExists(ws.Range(rC_TAG).text) Then
            CommandBars(ws.Range(rC_TAG).text).Delete
        End If
        Exit Sub
    End If
    On Error Resume Next
    Do
        Ctrl.Delete
        If MenuType = VbeMenu Then
            Set Ctrl = Application.VBE.CommandBars.FindControl(Tag:=ws.Range(rC_TAG).text)
        Else
            Set Ctrl = Application.CommandBars.FindControl(Tag:=ws.Range(rC_TAG).text)
        End If
    Loop While Not Ctrl Is Nothing
    On Error GoTo 0
    DeleteHandlersFor ws
End Sub

Private Sub DeleteHandlersFor(ws As Worksheet)
'@AssignedModule M_CommandBars
'@INCLUDE PROCEDURE markControlType
'@INCLUDE CLASS CVBECommandHandler
'@INCLUDE DECLARATION EventHandlers
    On Error Resume Next
    markControlType ws
    Dim cell As Range
    Set cell = ws.Cells(2, 6)
    Do Until IsEmpty(cell)
        If cell.text = "Button" Then
            EventHandlers.Remove cell.offset(0, -3).text
        End If
        Set cell = cell.offset(1)
    Loop
End Sub

Private Sub markControlType(ws As Worksheet)
'@AssignedModule M_CommandBars
'@INCLUDE CLASS CVBECommandHandler
    ws.Columns("F").ClearContents
    Dim idx As Long: idx = 0
    Dim Description() As Variant
    Dim cell As Range
    Set cell = ws.Cells(2, 1)
    Do Until IsEmpty(cell)
        idx = idx + 1
        ReDim Preserve Description(1 To idx)
        Description(idx) = IIf(cell.offset(1) > cell, "PopUp", "Button")
        Set cell = cell.offset(1)
    Loop
    ws.Range("F2").Resize(UBound(Description)) = WorksheetFunction.Transpose(Description)
End Sub

Private Sub SetVariables()
'@AssignedModule M_CommandBars
'@INCLUDE CLASS CVBECommandHandler
'@INCLUDE DECLARATION Action
'@INCLUDE DECLARATION BarRow
'@INCLUDE DECLARATION MenuSheet
    With MenuSheet
        MenuLevel = .Cells(BarRow, 1)
        Caption = .Cells(BarRow, 2)
        Action = .Cells(BarRow, 3)
        Divider = .Cells(BarRow, 4)
        FaceId = .Cells(BarRow, 5)
        NextLevel = .Cells(BarRow + 1, 1)
    End With
End Sub

Private Sub ReSetVariables()
'@AssignedModule M_CommandBars
'@INCLUDE CLASS CVBECommandHandler
'@INCLUDE DECLARATION Action
    MenuLevel = ""
    Caption = ""
    Action = ""
    Divider = ""
    FaceId = ""
    NextLevel = ""
End Sub


Private Sub ListWorksheetBars()
'@AssignedModule M_CommandBars
'@INCLUDE CLASS CVBECommandHandler
    Dim oCB As CommandBar
    Dim oWK As Worksheet
    Set oWK = ThisWorkbook.Sheets("ListSheetBars")
    oWK.Cells.Clear
    Dim arr As Variant
    arr = Array("Type", "Index", "Name", "Built-in", "Visible")
    Dim iCol As Integer
    iCol = UBound(arr) + 1
    oWK.Range("a1").Resize(1, iCol) = arr
    oWK.Range("a1").Resize(1, iCol).Cells.Font.Bold = True
    Dim i As Long
    i = 2
    Dim cbVar(300, 4) As Variant
    For Each oCB In Excel.Application.CommandBars
        cbVar(i - 2, 0) = Choose(oCB.Type + 1, "Toolbar", "Menu", "PopUp")
        cbVar(i - 2, 1) = oCB.index
        cbVar(i - 2, 2) = oCB.Name
        cbVar(i - 2, 3) = oCB.BuiltIn
        cbVar(i - 2, 4) = oCB.Visible
        i = i + 1
    Next
    oWK.Cells(2, 1).Resize(UBound(cbVar, 1) + 1, UBound(cbVar, 2) + 1) = cbVar
    oWK.Columns.AutoFit
End Sub

Private Sub ListVBEBars()
'@AssignedModule M_CommandBars
'@INCLUDE CLASS CVBECommandHandler
    Dim oCB As CommandBar
    Dim oWK As Worksheet
    Set oWK = ThisWorkbook.Sheets("ListVBEBars")
    oWK.Cells.Clear
    Dim arr As Variant
    arr = Array("Type", "Index", "Name", "Built-in", "Visible")
    Dim iCol As Integer
    iCol = UBound(arr) + 1
    oWK.Range("a1").Resize(1, iCol) = arr
    oWK.Range("a1").Resize(1, iCol).Cells.Font.Bold = True
    Dim i As Long
    i = 2
    Dim cbVar(300, 4) As Variant
    For Each oCB In Application.VBE.CommandBars
        cbVar(i - 2, 0) = Choose(oCB.Type + 1, "Toolbar", "Menu", "PopUp")
        cbVar(i - 2, 1) = oCB.index
        cbVar(i - 2, 2) = oCB.Name
        cbVar(i - 2, 3) = oCB.BuiltIn
        cbVar(i - 2, 4) = oCB.Visible
        i = i + 1
    Next
    oWK.Cells(2, 1).Resize(UBound(cbVar, 1) + 1, UBound(cbVar, 2) + 1) = cbVar
    oWK.Columns.AutoFit
End Sub

Private Sub exampleOfControls()
'@AssignedModule M_CommandBars
'@INCLUDE CLASS CVBECommandHandler
    Dim cbc As CommandBarControl
    Dim cbb As CommandBarButton
    Dim cbcm As CommandBarComboBox
    Dim cbp As CommandBarPopup
    With Application.VBE.CommandBars("CodeArchive")
        Set cbc = .Controls.Add(ID:=3, Temporary:=True)
        Set cbb = .Controls.Add(Temporary:=True)
        cbb.Caption = "A new command"
        cbb.Style = msoButtonCaption
        cbb.OnAction = "NewCommand_OnAction"
        Set cbcm = .Controls.Add(Type:=msoControlComboBox, Temporary:=True)
        cbcm.Caption = "Combo:"
        cbcm.AddItem "list entry 1"
        cbcm.AddItem "list entry 2"
        cbcm.OnAction = "NewCommand_OnAction"
        cbcm.Style = msoComboLabel
        Set cbc = .Controls.Add(Type:=msoControlDropdown, Temporary:=True)
        cbc.Caption = "Dropdown:"
        cbc.AddItem "list entry 1"
        cbc.AddItem "list entry 2"
        cbc.OnAction = "MenuDropdown_OnAction"
        Set cbp = .Controls.Add(Type:=msoControlPopup, Temporary:=True)
        cbp.Caption = "new sub menu"
        Set cbb = cbp.Controls.Add
        cbb.Caption = "sub entry 1"
        Set cbb = cbp.Controls.Add
        cbb.Caption = "sub entry 2"
    End With
End Sub

Private Sub ImageFromEmbedded()
'@AssignedModule M_CommandBars
'@INCLUDE CLASS CVBECommandHandler
    Dim p As Excel.Picture
    Dim Btn As Office.CommandBarButton
    Set Btn = Application.CommandBars.FindControl(ID:=30007) _
        .Controls.Add(Type:=msoControlButton, Temporary:=True)
    Set p = Worksheets("Sheet1").Pictures("ThePict")
    p.CopyPicture xlScreen, xlBitmap
    With Btn
        .Caption = "Click Me"
        .Style = msoButtonIconAndCaption
        .PasteFace
    End With
End Sub

Private Sub ImageFromExternalFile()
'@AssignedModule M_CommandBars
'@INCLUDE CLASS CVBECommandHandler
    Dim Btn As Office.CommandBarButton
    Set Btn = Application.CommandBars.FindControl(ID:=30007) _
        .Controls.Add(Type:=msoControlButton, Temporary:=True)
    With Btn
        .Caption = "Click Me"
        .Style = msoButtonIconAndCaption
        .Picture = LoadPicture("C:\TestPic.bmp")
    End With
End Sub

Private Sub ResetCBAR()
'@AssignedModule M_CommandBars
'@INCLUDE CLASS CVBECommandHandler
    Excel.Application.CommandBars("Cell").Reset
End Sub

Public Function IsLoaded(formName As String) As Boolean
'@AssignedModule M_CommandBars
'@INCLUDE CLASS CVBECommandHandler
    Dim frm As Object
    For Each frm In VBA.Userforms
        If frm.Name = formName Then
            IsLoaded = True
            Exit Function
        End If
    Next frm
    IsLoaded = False
End Function

Sub openUValiationDropdown()
'@AssignedModule M_CommandBars
    Dim lngValType As Long
    On Error Resume Next
    lngValType = ActiveCell.Validation.Type
    On Error GoTo 0
    Select Case lngValType
        Case Is = 3
            uValidationDropdown.Show
        Case Else
            If IsLoaded("uValidationDropdown") Then
                On Error Resume Next
                Unload uValidationDropdown
                On Error GoTo 0
            End If
    End Select
End Sub

Sub TestProcedure()
    MsgBox "ok"
End Sub

'''''NOTES'''''''
'''''''''''''''''

'-----------
'Use combobox
'-----------
''call a sub through class events handler
''the sub to contain the following
'With Application.VBE.ActiveCodePane
'  Text = Application.VBE.CommandBars(mcToolBar).Controls(mcInsertList).Text
'  .GetSelection StartLine, StartColumn, EndLine, EndColumn
'  .CodeModule.InsertLines StartLine, Text
'  .SetSelection StartLine, 1, StartLine, 1
'End With



'uValidationDropdown	UserForm



Option Explicit
'Private Sub CommandButton1_Click()
'    If Me.Height > 224 Then
'        Me.Height = 175
'        CommandButton1.Caption = "V"
'    Else
'        Me.Height = 225
'        CommandButton1.Caption = ""
'    End If
'End Sub

Private Sub GetInfo_Click()
'@AssignedModule uValidationDropdown
'@INCLUDE PROCEDURE PlayTheSound
'@INCLUDE CLASS aUserform
'@INCLUDE USERFORM uAuthor
'@INCLUDE USERFORM uValidationDropdown
    With aUserform.Init(Me)
        .Transition .Effect(GetInfo, "Top", GetInfo.Top - 10, 150)
        PlayTheSound ThisWorkbook.Path & "\sound\coin.wav"
        .Transition .Effect(GetInfo, "Top", GetInfo.Top + 10, 150)
    End With
    uAuthor.Show
End Sub


Private Sub ListBox1_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
'@AssignedModule uValidationDropdown
'@INCLUDE USERFORM uValidationDropdown
    Dim lngValType As Long
    On Error Resume Next
    lngValType = ActiveCell.Validation.Type
    On Error GoTo 0
    If lngValType = 3 Then updateData
End Sub

Private Sub ListBox1_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    '    If KeyCode = 13 Then
    '        updateData
    '    End If
    '    UVDRefreshList
'@AssignedModule uValidationDropdown
'@INCLUDE USERFORM uValidationDropdown
End Sub

Private Sub TextBox1_Change()
'@AssignedModule uValidationDropdown
'@INCLUDE USERFORM uValidationDropdown
    UVDRefreshList
End Sub

Private Sub TextBox1_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
'@AssignedModule uValidationDropdown
'@INCLUDE USERFORM uValidationDropdown
    If KeyCode = 13 Then
        updateData
    End If
End Sub

Private Sub TextBox1_KeyUp(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
'@AssignedModule uValidationDropdown
'@INCLUDE USERFORM uValidationDropdown
    Select Case KeyCode
    Case 27        'ESC
        Unload Me
    End Select
End Sub

Private Sub UserForm_Activate()
'@AssignedModule uValidationDropdown
'@INCLUDE USERFORM uValidationDropdown
    UVDRefreshList
End Sub

Sub updateData()
    '@INCLUDE UVDRefreshList
'@AssignedModule uValidationDropdown
'@INCLUDE USERFORM uValidationDropdown
    ActiveCell.Value = Me.ListBox1.Value
    If Me.oClose.Value = True Then
        Me.TextBox1.Value = ""
        Unload Me
    ElseIf Me.oDown.Value = True Then
        ActiveCell.offset(1, 0).Select
        If Me.TextBox1.Value <> "" Then
            Me.TextBox1.Value = ""
        Else
            UVDRefreshList
        End If
        If Me.ListBox1.ListCount = 0 Then Unload Me
    ElseIf Me.oRight.Value = True Then
        ActiveCell.offset(0, 1).Select
        If Me.TextBox1.Value <> "" Then
            Me.TextBox1.Value = ""
        Else
            UVDRefreshList
        End If
        If Me.ListBox1.ListCount = 0 Then Unload Me
    ElseIf Me.oNone.Value = True Then
        Me.TextBox1.Value = ""
    End If
End Sub

Sub UVDRefreshList()
    '@INCLUDE ValidRange
    '@INCLUDE isValidation
'@AssignedModule uValidationDropdown
'@INCLUDE CLASS aListBox
'@INCLUDE USERFORM uValidationDropdown
    Me.ListBox1.Clear
    Dim rng As Range
    Dim cell As Range
    If isValidation(ActiveCell) = False Then Exit Sub
    If ValidRange(ActiveCell.Validation.Formula1) = True Then
        Set rng = Range(Replace(ActiveCell.Validation.Formula1, "=", ""))
        For Each cell In rng
            If Me.TextBox1.Value = "" Then
                Me.ListBox1.AddItem cell.Value
            Else
                If InStr(1, cell.Value, Me.TextBox1.Value, vbTextCompare) > 0 Then
                    Me.ListBox1.AddItem cell.Value
                End If
            End If
        Next
    ElseIf InStr(1, ActiveCell.Validation.Formula1, ",") > 0 Then
        Dim var
        var = Split(ActiveCell.Validation.Formula1, ",")
        Dim element
        For Each element In var
            Me.ListBox1.AddItem element
        Next
    Else
        Unload Me
    End If

     aListBox.Init(ListBox1).FilterByColumn TextBox1.text

    On Error Resume Next
    Me.ListBox1.ListIndex = 0
    On Error GoTo 0

End Sub

Function ValidRange(str As String) As Boolean
'@AssignedModule uValidationDropdown
'@INCLUDE USERFORM uValidationDropdown
    Dim rng As Range
    On Error Resume Next
    Set rng = Range(Replace(str, "=", ""))
    On Error GoTo 0
    If rng Is Nothing Then
        ValidRange = False
    Else
        ValidRange = True
    End If
End Function

Function isValidation(rng As Range) As Boolean
'@AssignedModule uValidationDropdown
'@INCLUDE USERFORM uValidationDropdown
    Dim dvtype As Integer
    On Error Resume Next
    dvtype = rng.Validation.Type
    On Error GoTo 0
    If dvtype = 3 Then
        isValidation = True
    Else
        isValidation = False
    End If
End Function

Private Sub UserForm_Initialize()
    '@INCLUDE LoadUserformOptions
'@AssignedModule uValidationDropdown
'@INCLUDE CLASS aUserform
'@INCLUDE USERFORM uValidationDropdown
    aUserform.Init(Me).LoadOptions
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    '@INCLUDE SaveUserformOptions
'@AssignedModule uValidationDropdown
'@INCLUDE CLASS aUserform
'@INCLUDE USERFORM uValidationDropdown
    aUserform.Init(Me).SaveOptions , , False, False
End Sub


'z_uRadialMenu	Module

Option Explicit
Sub RadialMenuCommand_Unload()
'@INCLUDE USERFORM z_RadialMenu
'@AssignedModule z_uRadialMenu
    Unload z_RadialMenu
End Sub
Public Sub RefreshRadialMenuImages()
'@INCLUDE PROCEDURE FileExists
'@INCLUDE PROCEDURE IniReadKey
'@INCLUDE USERFORM z_RadialMenu
'@AssignedModule z_uRadialMenu
    Dim picForMenuExpanded As String
    picForMenuExpanded = IniReadKey(ThisWorkbook.Path & "\config\radialmenu.ini", "Settings", "picForMenuExpanded")
    If picForMenuExpanded = "" Then picForMenuExpanded = "WhiteCircle"
    picForMenuExpanded = ThisWorkbook.Path & "\img\" & picForMenuExpanded & ".jpg"
    Dim picForMenuCollapsed As String
    picForMenuCollapsed = IniReadKey(ThisWorkbook.Path & "\config\radialmenu.ini", "Settings", "picForMenuCollapsed")
    If picForMenuCollapsed = "" Then picForMenuCollapsed = "PurpleCircle"
    picForMenuCollapsed = ThisWorkbook.Path & "\img\" & picForMenuCollapsed & ".jpg"
    Dim picForItemsDefault As String
    picForItemsDefault = IniReadKey(ThisWorkbook.Path & "\config\radialmenu.ini", "Settings", "picForItemsDefault")
    If picForItemsDefault = "" Then picForItemsDefault = "BlackCircle"
    picForItemsDefault = ThisWorkbook.Path & "\img\" & picForItemsDefault & ".jpg"
    If Not FileExists(picForMenuCollapsed) Or Not FileExists(picForMenuExpanded) Or Not FileExists(picForItemsDefault) Then
        MsgBox "Could not fild image files"
        Stop
    End If
    Dim control As MSForms.control
    For Each control In z_RadialMenu.Controls
        If control.Name = "iMain" Then
            If control.Tag = "collapsed" Then
                control.Picture = LoadPicture(picForMenuCollapsed)
                If InStr(1, picForMenuCollapsed, "White", vbTextCompare) > 0 Then
                    control.ForeColor = vbBlack
                ElseIf InStr(1, picForMenuCollapsed, "Black", vbTextCompare) > 0 Then
                    control.ForeColor = vbWhite
                End If
            Else
                control.Picture = LoadPicture(picForMenuExpanded)
                If InStr(1, picForMenuExpanded, "White", vbTextCompare) > 0 Then
                    control.ForeColor = vbBlack
                ElseIf InStr(1, picForMenuExpanded, "Black", vbTextCompare) > 0 Then
                    control.ForeColor = vbWhite
                End If
            End If
        ElseIf control.Tag <> "custom" Then
            control.Picture = LoadPicture(picForItemsDefault)
            If InStr(1, picForItemsDefault, "White", vbTextCompare) > 0 Then
                control.ForeColor = vbBlack
            ElseIf InStr(1, picForItemsDefault, "Black", vbTextCompare) > 0 Then
                control.ForeColor = vbWhite
            End If
        End If
        If InStr(1, picForMenuCollapsed, "White", vbTextCompare) Then control.ForeColor = vbWhite
    Next
    z_RadialMenu.Repaint
End Sub
Sub setRadialMenuTheme(picForMenuCollapsed As String, picForMenuExpanded As String, picForItemsDefault As String)
'@INCLUDE PROCEDURE IniWrite
'@INCLUDE PROCEDURE RefreshRadialMenuImages
'@AssignedModule z_uRadialMenu
    IniWrite ThisWorkbook.Path & "\config\radialmenu.ini", "Settings", "picForMenuExpanded", picForMenuExpanded
    IniWrite ThisWorkbook.Path & "\config\radialmenu.ini", "Settings", "picForMenuCollapsed", picForMenuCollapsed
    IniWrite ThisWorkbook.Path & "\config\radialmenu.ini", "Settings", "picForItemsDefault", picForItemsDefault
    RefreshRadialMenuImages
End Sub
Sub SwitchThemeHexagon()
'@INCLUDE PROCEDURE setRadialMenuTheme
'@AssignedModule z_uRadialMenu
    setRadialMenuTheme "HexagonBlack", "HexagonWhite", "HexagonBlack"
End Sub
Sub SwitchThemeCircle()
'@INCLUDE PROCEDURE setRadialMenuTheme
'@AssignedModule z_uRadialMenu
    setRadialMenuTheme "PurpleCircle", "WhiteCircle", "BlackCircle"
End Sub


'M_Objects	Module

Option Explicit

'https://www.mrexcel.com/board/threads/get-list-of-all-properties-and-methods-for-an-object-with-vba-code-alone.1122930/
Private Type GUID
    Data1 As Long
    Data2 As Integer
    Data3 As Integer
    Data4(0 To 7) As Byte
End Type

Private Type TTYPEDESC
    #If Win64 Then
        pTypeDesc As LongLong
    #Else
        pTypeDesc As Long
    #End If
    vt            As Integer
End Type

Private Type TPARAMDESC
    #If Win64 Then
        pPARAMDESCEX  As LongLong
    #Else
        pPARAMDESCEX  As Long
    #End If
    wParamFlags       As Integer
End Type

Private Type TELEMDESC
    tdesc  As TTYPEDESC
    pdesc  As TPARAMDESC
End Type

Type TYPEATTR
        aGUID As GUID
        LCID As Long
        dwReserved As Long
        memidConstructor As Long
        memidDestructor As Long
        #If Win64 Then
            lpstrSchema As LongLong
        #Else
            lpstrSchema As Long
        #End If
        cbSizeInstance As Integer
        typekind As Long
        cFuncs As Integer
        cVars As Integer
        cImplTypes As Integer
        cbSizeVft As Integer
        cbAlignment As Integer
        wTypeFlags As Integer
        wMajorVerNum As Integer
        wMinorVerNum As Integer
        tdescAlias As Long
        idldescType As Long
End Type

Type FUNCDESC
    memid As Long
    #If Win64 Then
        lReserved1 As LongLong
        lprgelemdescParam As LongLong
    #Else
        lReserved1 As Long
        lprgelemdescParam As Long
    #End If
    funckind As Long
    INVOKEKIND As Long
    CallConv As Long
    cParams As Integer
    cParamsOpt As Integer
    oVft As Integer
    cReserved2 As Integer
    elemdescFunc As TELEMDESC
    wFuncFlags As Integer
End Type

#If VBA7 Then
    Private Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal Length As LongPtr)
    Private Declare PtrSafe Function DispCallFunc Lib "oleAut32.dll" (ByVal pvInstance As LongPtr, ByVal offsetinVft As LongPtr, ByVal CallConv As Long, ByVal retTYP As Integer, ByVal paCNT As Long, ByRef paTypes As Integer, ByRef paValues As LongPtr, ByRef retVAR As Variant) As Long
    Private Declare PtrSafe Sub SetLastError Lib "kernel32.dll" (ByVal dwErrCode As Long)
#Else
    Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal Length As Long)
    Private Declare Function DispCallFunc Lib "oleAut32.dll" (ByVal pvInstance As Long, ByVal offsetinVft As Long, ByVal CallConv As Long, ByVal retTYP As Integer, ByVal paCNT As Long, ByRef paTypes As Integer, ByRef paValues As Long, ByRef retVAR As Variant) As Long
    Private Declare Sub SetLastError Lib "kernel32.dll" (ByVal dwErrCode As Long)
#End If

Function GetObjectFunctions(ByVal TheObject As Object, Optional ByVal FuncType As VbCallType) As Collection
'@AssignedModule M_Objects
'@INCLUDE DECLARATION CopyMemory

    Dim tTYPEATTR As TYPEATTR
    Dim tFUNCDESC As FUNCDESC

    Dim aGUID(0 To 11) As Long, lFuncsCount As Long

    #If Win64 Then
        Const vTblOffsetFac_32_64 = 2
        Dim aTYPEATTR() As LongLong, aFUNCDESC() As LongLong, farPtr As LongLong
    #Else
        Const vTblOffsetFac_32_64 = 1
        Dim aTYPEATTR() As Long, aFUNCDESC() As Long, farPtr As Long
    #End If

    Dim ITypeInfo As IUnknown
    Dim IDispatch As IUnknown
    Dim sName As String, oCol As New Collection

    Const CC_STDCALL As Long = 4
    Const IUNK_QueryInterface As Long = 0
    Const IDSP_GetTypeInfo As Long = 16 * vTblOffsetFac_32_64
    Const ITYP_GetTypeAttr As Long = 12 * vTblOffsetFac_32_64
    Const ITYP_GetFuncDesc As Long = 20 * vTblOffsetFac_32_64
    Const ITYP_GetDocument As Long = 48 * vTblOffsetFac_32_64

    Const ITYP_ReleaseTypeAttr As Long = 76 * vTblOffsetFac_32_64
    Const ITYP_ReleaseFuncDesc As Long = 80 * vTblOffsetFac_32_64

    aGUID(0) = &H20400: aGUID(2) = &HC0&: aGUID(3) = &H46000000
    CallFunction_COM ObjPtr(TheObject), IUNK_QueryInterface, vbLong, CC_STDCALL, VarPtr(aGUID(0)), VarPtr(IDispatch)
    If IDispatch Is Nothing Then MsgBox "error":   Exit Function

    CallFunction_COM ObjPtr(IDispatch), IDSP_GetTypeInfo, vbLong, CC_STDCALL, 0&, 0&, VarPtr(ITypeInfo)
    If ITypeInfo Is Nothing Then MsgBox "error": Exit Function

    CallFunction_COM ObjPtr(ITypeInfo), ITYP_GetTypeAttr, vbLong, CC_STDCALL, VarPtr(farPtr)
    If farPtr = 0& Then MsgBox "error": Exit Function

    CopyMemory ByVal VarPtr(tTYPEATTR), ByVal farPtr, LenB(tTYPEATTR)
    ReDim aTYPEATTR(LenB(tTYPEATTR))
    CopyMemory ByVal VarPtr(aTYPEATTR(0)), tTYPEATTR, UBound(aTYPEATTR)
    CallFunction_COM ObjPtr(ITypeInfo), ITYP_ReleaseTypeAttr, vbEmpty, CC_STDCALL, farPtr

    For lFuncsCount = 0 To tTYPEATTR.cFuncs - 1
        Call CallFunction_COM(ObjPtr(ITypeInfo), ITYP_GetFuncDesc, vbLong, CC_STDCALL, lFuncsCount, VarPtr(farPtr))
        If farPtr = 0 Then MsgBox "error": Exit For
        CopyMemory ByVal VarPtr(tFUNCDESC), ByVal farPtr, LenB(tFUNCDESC)
        ReDim aFUNCDESC(LenB(tFUNCDESC))
        CopyMemory ByVal VarPtr(aFUNCDESC(0)), tFUNCDESC, UBound(aFUNCDESC)
        Call CallFunction_COM(ObjPtr(ITypeInfo), ITYP_ReleaseFuncDesc, vbEmpty, CC_STDCALL, farPtr)
         Call CallFunction_COM(ObjPtr(ITypeInfo), ITYP_GetDocument, vbLong, CC_STDCALL, aFUNCDESC(0), VarPtr(sName), 0, 0, 0)
        Call CallFunction_COM(ObjPtr(ITypeInfo), ITYP_GetDocument, vbLong, CC_STDCALL, aFUNCDESC(0), VarPtr(sName), 0, 0, 0)

        With tFUNCDESC
            If FuncType Then
                If .INVOKEKIND = FuncType Then
                    'Debug.Print sName & vbTab & Switch(.INVOKEKIND = 1, "VbMethod", .INVOKEKIND = 2, "VbGet", .INVOKEKIND = 4, "VbLet", .INVOKEKIND = 8, "VbSet")
                    oCol.Add sName & vbTab & Switch(.INVOKEKIND = 1, "VbMethod", .INVOKEKIND = 2, "VbGet", .INVOKEKIND = 4, "VbLet", .INVOKEKIND = 8, "VbSet")
                End If
            Else
                'Debug.Print sName & vbTab & Switch(.INVOKEKIND = 1, "VbMethod", .INVOKEKIND = 2, "VbGet", .INVOKEKIND = 4, "VbLet", .INVOKEKIND = 8, "VbSet")
                oCol.Add sName & vbTab & Switch(.INVOKEKIND = 1, "VbMethod", .INVOKEKIND = 2, "VbGet", .INVOKEKIND = 4, "VbLet", .INVOKEKIND = 8, "VbSet")
            End If
        End With
        sName = vbNullString
    Next

    Set GetObjectFunctions = oCol

End Function

#If Win64 Then
    Private Function CallFunction_COM(ByVal InterfacePointer As LongLong, ByVal VTableOffset As Long, ByVal FunctionReturnType As Long, ByVal CallConvention As Long, ParamArray FunctionParameters() As Variant) As Variant
'@AssignedModule M_Objects
'@INCLUDE DECLARATION DispCallFunc
'@INCLUDE DECLARATION SetLastError

    Dim vParamPtr() As LongLong
#Else
    Private Function CallFunction_COM(ByVal InterfacePointer As Long, ByVal VTableOffset As Long, ByVal FunctionReturnType As Long, ByVal CallConvention As Long, ParamArray FunctionParameters() As Variant) As Variant

    Dim vParamPtr() As Long
#End If

    If InterfacePointer = 0& Or VTableOffset < 0& Then Exit Function
    If Not (FunctionReturnType And &HFFFF0000) = 0& Then Exit Function

    Dim pIndex As Long, pCount As Long
    Dim vParamType() As Integer
    Dim vRtn As Variant, vParams() As Variant

    vParams() = FunctionParameters()
    pCount = Abs(UBound(vParams) - LBound(vParams) + 1&)
    If pCount = 0& Then
        ReDim vParamPtr(0 To 0)
        ReDim vParamType(0 To 0)
    Else
        ReDim vParamPtr(0 To pCount - 1&)
        ReDim vParamType(0 To pCount - 1&)
        For pIndex = 0& To pCount - 1&
            vParamPtr(pIndex) = VarPtr(vParams(pIndex))
            vParamType(pIndex) = VarType(vParams(pIndex))
        Next
    End If

    pIndex = DispCallFunc(InterfacePointer, VTableOffset, CallConvention, FunctionReturnType, pCount, _
    vParamType(0), vParamPtr(0), vRtn)
    If pIndex = 0& Then
        CallFunction_COM = vRtn
    Else
        SetLastError pIndex
    End If

End Function

    'Example:
    ' List all Methods and Properties of the excel application Object.
Public Sub ObjectPropertiesList(oObject As Object)
'@AssignedModule M_Objects
'@INCLUDE PROCEDURE GetObjectFunctions
    Application.ScreenUpdating = False
    Dim oFuncCol As New Collection, i As Long, sObjName As String ',oObject As Object

'    Set oObject = Application '<=== Choose here target object as required.
    Set oFuncCol = GetObjectFunctions(TheObject:=oObject, FuncType:=0)
    Dim ws As Worksheet
    Set ws = Workbooks.Add().Sheets(1)
    ws.Cells.CurrentRegion.offset(1).ClearContents
    For i = 1 To oFuncCol.count
        ws.Range("A" & i + 1) = Split(oFuncCol.item(i), vbTab)(0)
        ws.Range("B" & i + 1) = Split(oFuncCol.item(i), vbTab)(1)
    Next
    ws.Range("D2") = oFuncCol.count
    ws.Cells(1).Resize(, 2).EntireColumn.AutoFit

    ws.Range("A2").CurrentRegion.Resize(, 1).Sort Key1:=ws.Range("A2"), _
                                                  Order1:=xlAscending, _
                                                  Header:=xlNo

    Application.ScreenUpdating = True

    On Error Resume Next
        sObjName = oObject.Name
        If Len(sObjName) Then
            MsgBox "(" & oFuncCol.count & ")  functions found for:" & vbCrLf & vbCrLf & sObjName
        End If
    On Error GoTo 0
End Sub




'BAR_VbeCodeWindow	Document

Public Sub Worksheet_BeforeRightClick(ByVal Target As Range, Cancel As Boolean)
'@AssignedModule Sheet34
'@INCLUDE PROCEDURE BarExists
    If Selection.Cells.count > 1 Then Exit Sub
    If BarExists("testtag") Then
        CommandBars("testtag").ShowPopup
        Cancel = True
    End If
End Sub

Private Sub Worksheet_Change(ByVal Target As Range)
'@AssignedModule Sheet34
'@INCLUDE DECLARATION rBAR_LOCATION
'@INCLUDE DECLARATION rMENU_TYPE
Application.EnableEvents = False

    If Replace(Target.Address, "$", "") = rMENU_TYPE Then
        Range(rBAR_LOCATION).ClearContents
    End If
    Application.EnableEvents = True
End Sub

Public Sub Worksheet_SelectionChange(ByVal Target As Range)
'@AssignedModule Sheet34
'@INCLUDE PROCEDURE openUValiationDropdown
On Error GoTo EH
    If Selection.Cells.count > 1 And Cells(Selection.row, 1) <> "" Then Exit Sub
    Calculate
    openUValiationDropdown
EH:
End Sub



'BAR_Designer	Document

Public Sub Worksheet_BeforeRightClick(ByVal Target As Range, Cancel As Boolean)
'@AssignedModule Sheet36
'@INCLUDE PROCEDURE BarExists
    If Selection.Cells.count > 1 Then Exit Sub
    If BarExists("testtag") Then
        CommandBars("testtag").ShowPopup
        Cancel = True
    End If
End Sub

Private Sub Worksheet_Change(ByVal Target As Range)
'@AssignedModule Sheet36
'@INCLUDE DECLARATION rBAR_LOCATION
'@INCLUDE DECLARATION rMENU_TYPE
Application.EnableEvents = False

    If Replace(Target.Address, "$", "") = rMENU_TYPE Then
        Range(rBAR_LOCATION).ClearContents
    End If
    Application.EnableEvents = True
End Sub

Public Sub Worksheet_SelectionChange(ByVal Target As Range)
'@AssignedModule Sheet36
'@INCLUDE PROCEDURE openUValiationDropdown
On Error GoTo EH
    If Selection.Cells.count > 1 And Cells(Selection.row, 1) <> "" Then Exit Sub
    Calculate
    openUValiationDropdown
EH:
End Sub



'BAR_Control	Document

Public Sub Worksheet_BeforeRightClick(ByVal Target As Range, Cancel As Boolean)
'@AssignedModule Sheet37
'@INCLUDE PROCEDURE BarExists
    If Selection.Cells.count > 1 Then Exit Sub
    If BarExists("testtag") Then
        CommandBars("testtag").ShowPopup
        Cancel = True
    End If
End Sub

Private Sub Worksheet_Change(ByVal Target As Range)
'@AssignedModule Sheet37
'@INCLUDE DECLARATION rBAR_LOCATION
'@INCLUDE DECLARATION rMENU_TYPE
Application.EnableEvents = False

    If Replace(Target.Address, "$", "") = rMENU_TYPE Then
        Range(rBAR_LOCATION).ClearContents
    End If
    Application.EnableEvents = True
End Sub

Public Sub Worksheet_SelectionChange(ByVal Target As Range)
'@AssignedModule Sheet37
'@INCLUDE PROCEDURE openUValiationDropdown
On Error GoTo EH
    If Selection.Cells.count > 1 And Cells(Selection.row, 1) <> "" Then Exit Sub
    Calculate
    openUValiationDropdown
EH:
End Sub



'Declarations_Table	Document

Option Explicit


'M_Sound	Module

Option Explicit

#If VBA7 Then
    Public Declare PtrSafe Function sndPlaySound32 Lib "winmm.dll" Alias "sndPlaySoundA" (ByVal lpszSoundName As String, ByVal uFlags As Long) As Long
#Else
    Public Declare Function sndPlaySound32 Lib "winmm.dll" Alias "sndPlaySoundA" (ByVal lpszSoundName As String, ByVal uFlags As Long) As Long
#End If

Public Const SND_SYNC = &H0         ' (Default) Play the sound synchronously. Code execution pauses until sound is complete.
Public Const SND_ASYNC = &H1        ' Play the sound asynchronously. Code execution does not wait for sound to complete.
Public Const SND_NODEFAULT = &H2    ' If the specified sound is not found, do not play the default sound (no sound is played).
Public Const SND_MEMORY = &H4       ' lpszSoundName is a memory file of the sound. Not used in VBA/VB6.
Public Const SND_LOOP = &H8         ' Continue playing sound in a loop until the next call to sndPlaySound.
Public Const SND_NOSTOP = &H10      ' Do not stop playing the current sound before playing the specified sound.

Sub PlayTheSound(ByVal WhatSound As String, Optional Flags As Long = SND_ASYNC)
'http://www.cpearson.com/excel/PlaySound.aspx
'@AssignedModule M_Sound
'@INCLUDE DECLARATION SND_ASYNC
'@INCLUDE DECLARATION sndPlaySound32
        If Dir(WhatSound, vbNormal) = "" Then
        ' WhatSound is not a file. Get the file named by
        ' WhatSound from the Windows\Media directory.
        WhatSound = Environ("SystemRoot") & "\Media\" & WhatSound
        If InStr(1, WhatSound, ".") = 0 Then
            ' if WhatSound does not have a .wav extension,add one.
            WhatSound = WhatSound & ".wav"
        End If
        If Dir(WhatSound, vbNormal) = vbNullString Then
            ' Can't find the file. Do a simple Beep.
            Beep
            Exit Sub
        End If
    Else
        ' WhatSound is a file. Use it.
    End If
    ' Finally, play the sound.
    sndPlaySound32 WhatSound, Flags
End Sub

Sub ListWavFiles()
'@AssignedModule M_Sound
    Dim N As Long
    Dim FSO As Object
    Dim FF As Object
    Dim F As Object
    Set FSO = CreateObject("Scripting.FileSystemObject")
    Set FF = FSO.GetFolder(Environ("SystemRoot") & "\Media")
    For Each F In FF.Files
        N = N + 1
        Cells(N, 1) = F.Name
        Cells(N, 2) = F.Path
    Next F
    ActiveSheet.Columns(1).AutoFit
End Sub

'References	Document

Option Explicit

'uCalendar	UserForm



Option Explicit

Public gDate As New clsDate

Public Function Datepicker(Optional DateInput As Object) As String
'@AssignedModule uCalendar
'@INCLUDE CLASS clsDate
'@INCLUDE USERFORM uCalendar
'@INCLUDE DECLARATION gDate
    Dim str As String
    If VBA.TypeName(DateInput) = "Textbox" Or VBA.TypeName(DateInput) = "Range" Then str = DateInput.Value
    If VBA.TypeName(DateInput) = "CommandButton" Or VBA.TypeName(DateInput) = "Label" Then str = DateInput.Caption

    'If DatepInput <> "" Then <--- replaced with next line
    If str <> "" Then

        Dim curDate As String
        With uCalendar
            .txtYearName = Year(DateInput)
            .txtMonthNumber = Format(DateInput, "mm")

        End With

        With gDate
            .createDates txtYearName, txtMonthNumber
            .SelectDate .dFrame.Controls("lblDate" & Day(DateInput))
        End With
    Else

        With uCalendar
            .lblSelectedDate = Day(Date)
            .lblSelectedMonth = Format(Date, "mmmm")
            .lblSelectedYear = Year(Date)
            curDate = Day(Date) & "." & .txtMonthNumber Mod 12 & "." & .txtYearName
            .lblSelectedDateName = Format(curDate, "dddd")
            .txtSelectedDate = Format(curDate, "dd.mm.yyyy")
            .txtMonthNumber = Format(Date, "mm")
        End With

        With gDate.lblDateBack

        End With

    End If

    Me.Show

    Datepicker = Me.txtSelectedDate.Value

    If VBA.TypeName(DateInput) = "TextBox" Or VBA.TypeName(DateInput) = "Range" Then
        DateInput.Value = Me.txtSelectedDate.Value
    ElseIf VBA.TypeName(DateInput) = "CommandButton" Or VBA.TypeName(DateInput) = "Label" Then
        DateInput.Caption = Me.txtSelectedDate.Value
    Else
        'Datepicker = Me.txtSelectedDate.Value <--- put this before If to return the value anyway
    End If

End Function

Private Sub frameDate_Click()
'@AssignedModule uCalendar
'@INCLUDE USERFORM uCalendar
    frameMonth.Visible = False
    frameYear.Visible = False
End Sub

Private Sub lblChoose_Click()
'@AssignedModule uCalendar
'@INCLUDE USERFORM uCalendar
    Unload Me
End Sub

Private Sub lblChoose_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
'@AssignedModule uCalendar
'@INCLUDE CLASS clsDate
'@INCLUDE USERFORM uCalendar
'@INCLUDE DECLARATION gDate
    gDate.dFrame.Controls("lblDateBack").Visible = False
    gDate.dayMouseOut

End Sub

Private Sub lblClose_Click()
'@AssignedModule uCalendar
'@INCLUDE USERFORM uCalendar
    txtSelectedDate = ""
    Unload Me

End Sub

Private Sub lblMonthName_Click()
'@AssignedModule uCalendar
'@INCLUDE CLASS clsDate
'@INCLUDE USERFORM uCalendar
'@INCLUDE DECLARATION gDate
    frameYear.Visible = False
    With frameMonth
        .Visible = True
        .Left = lblMonthName.Left
        .Top = lblMonthName.Top + 20

    End With
    gDate.createMonth txtMonthNumber
End Sub

Private Sub lblNextMonth_Click()
'@AssignedModule uCalendar
'@INCLUDE PROCEDURE getMonth
'@INCLUDE CLASS clsDate
'@INCLUDE USERFORM uCalendar
'@INCLUDE DECLARATION gDate
    With txtMonthNumber
        .text = .text + 1
        lblMonthName = getMonth(.text)

        If lblMonthName = "JANUARY" Then
            txtYearName = txtYearName + 1
        End If
        '        gDate.createDates txtYearName, .Text

    End With
End Sub

Private Sub lblPreviewMonth_Click()
'@AssignedModule uCalendar
'@INCLUDE PROCEDURE getMonth
'@INCLUDE CLASS clsDate
'@INCLUDE USERFORM uCalendar
'@INCLUDE DECLARATION gDate
    With txtMonthNumber
        .text = .text - 1

        lblMonthName = getMonth(.text)
        If lblMonthName.Caption = "DECEMBER" Then
            txtYearName = txtYearName - 1
        End If
        '       gDate.createDates txtYearName, .Text
    End With
End Sub

Private Sub lblRightBar_Click()
'@AssignedModule uCalendar
'@INCLUDE USERFORM uCalendar

End Sub

Private Sub lblRightBar_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
'@AssignedModule uCalendar
'@INCLUDE PROCEDURE moverForm
'@INCLUDE USERFORM uCalendar
    moverForm Me, Me, Button
End Sub

Private Sub lblToday_Click()
'@AssignedModule uCalendar
'@INCLUDE PROCEDURE getMonth
'@INCLUDE CLASS clsDate
'@INCLUDE USERFORM uCalendar
'@INCLUDE DECLARATION gDate
    lblMonthName = getMonth(Format(Date, "mm"))
    txtYearName = Format(Date, "yyyy")
    txtMonthNumber = Format(Date, "m")
    gDate.createDates Format(Date, "yyyy"), Format(Date, "mm")
End Sub

Private Sub txtMonthNumber_Change()
'@AssignedModule uCalendar
'@INCLUDE PROCEDURE getMonth
'@INCLUDE CLASS clsDate
'@INCLUDE USERFORM uCalendar
'@INCLUDE DECLARATION gDate
    lblMonthName = getMonth(txtMonthNumber)
    gDate.createDates txtYearName, txtMonthNumber
End Sub

Private Sub txtSelectedYear_Change()
'@AssignedModule uCalendar
'@INCLUDE USERFORM uCalendar

End Sub

Private Sub txtYearName_Change()
'@AssignedModule uCalendar
'@INCLUDE CLASS clsDate
'@INCLUDE USERFORM uCalendar
'@INCLUDE DECLARATION gDate
    If Len(txtYearName.text) = 4 Then
        gDate.createDates txtYearName, txtMonthNumber
    End If
End Sub

Private Sub txtYearName_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
'@AssignedModule uCalendar
'@INCLUDE CLASS clsDate
'@INCLUDE USERFORM uCalendar
'@INCLUDE DECLARATION gDate
    frameMonth.Visible = False
    With frameYear
        .Left = txtYearName.Left
        .Top = txtYearName.Top + 20
        .Visible = True
    End With
    gDate.createYear txtYearName
End Sub

Private Sub UserForm_Activate()
'@AssignedModule uCalendar
'@INCLUDE USERFORM uCalendar
    lblToday_Click
End Sub

Private Sub UserForm_Click()
'@AssignedModule uCalendar
'@INCLUDE USERFORM uCalendar
    Me.frameMonth.Visible = False
    Me.frameYear.Visible = False
End Sub

Private Sub UserForm_Initialize()
'@AssignedModule uCalendar
'@INCLUDE PROCEDURE HideTitleBarAndBorder
'@INCLUDE PROCEDURE removeTudo
'@INCLUDE USERFORM uCalendar
    Dim sMonth As Integer
    SelectedDay = ""
    removeTudo Me
    HideTitleBarAndBorder Me

    With Me
        .Height = 308
        .Width = 480
    End With

    IconDesign lblPreviewMonth, "&HE26C"
    IconDesign lblNextMonth, "&HE26B"

End Sub

Private Sub IconDesign(Ctrl As control, IconCode As String)
'@AssignedModule uCalendar
'@INCLUDE USERFORM uCalendar
'@INCLUDE DECLARATION Ctrl
    With Ctrl
        .Font.Name = "Segoe MDL2 Assets"
        .Caption = ChrW(IconCode)
        .Font.Size = 12
        .ForeColor = RGB(191, 191, 191)
        .TextAlign = fmTextAlignLeft
        .BorderStyle = fmBorderStyleNone
        .BackStyle = fmBackStyleTransparent
    End With
End Sub

Private Sub UserForm_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
    '    moverForm Me, Me, Button
'@AssignedModule uCalendar
'@INCLUDE PROCEDURE moverForm
'@INCLUDE USERFORM uCalendar
End Sub


'clsDate	Class

Option Explicit
Public WithEvents dForm As MSForms.UserForm
Public WithEvents dFrame As MSForms.Frame
Public WithEvents mFrame As MSForms.Frame
Public WithEvents yFrame As MSForms.Frame
Public WithEvents lblDate As MSForms.Label
Public WithEvents lblMonth As MSForms.Label
Public WithEvents lblYear As MSForms.Label
Public WithEvents lblTodayBack As MSForms.Label
Public WithEvents lblSelectedDateBack As MSForms.Label
Public WithEvents lblDateBack As MSForms.Label
Public WithEvents lblMonthBack As MSForms.Label
Public WithEvents lblYearBack As MSForms.Label

Public colDate As New Collection
Public aDate As New clsDate
Public colMonth As New Collection
Public aMonth As New clsDate
Public colYear As New Collection
Public aYear As New clsDate

Public Sub createDates(cYear As Integer, cMonth As Integer)
'@AssignedModule clsDate
'@INCLUDE CLASS clsDate
'@INCLUDE USERFORM uCalendar
    Dim lLeft As Integer, lTop As Integer
    Dim fDate As Integer
    Set dForm = uCalendar
    Set dFrame = dForm.frameDate
    PassiveDay = "": SelectedDay = ""
    '  MsgBox cYear & "-" & cMonth
    '************************************
    '***********//frame date start//*****
    With dFrame
        .Clear
    End With
    '***********//frame date start//*****
    '************************************
    Dim dt As Date
    If cMonth Mod 12 = 0 Then cMonth = 12 Else cMonth = cMonth Mod 12
    dt = DateSerial(cYear, cMonth, 1)
    Dim firstDate As Long
    firstDate = Weekday(dt, 2)
    Dim ilk As Date
    ilk = DateSerial(Year(dt), Month(dt), 1 - (firstDate - 1))

    lLeft = 6: lTop = 6
    Dim gunsayi As String
    Dim i As Long
    For i = ilk To ilk + 41
        gunsayi = Format(Day(i), "#0")

        Set lblDate = dFrame.Controls.Add("Forms.Label.1", "lblDate" & gunsayi)
        With lblDate
'            Debug.Print lblDate.Name
            .Left = lLeft
            .Top = lTop
            .Width = 32
            .Font.Name = "MontSerrat Medium"
            .Font.Size = 9
            .ForeColor = &H48372C
            .TextAlign = fmTextAlignCenter
            .BackStyle = fmBackStyleTransparent
            .Caption = gunsayi
            .Tag = i

            If CInt(Year(CDate(i))) = CInt(Year(CDate(dt))) And CInt(Month(CDate(i))) = CInt(Month(CDate(dt))) Then
                .Enabled = True
            Else
                .Enabled = False
            End If

            If Weekday(i, 2) = 7 Or Weekday(i, 2) = 6 Then
                .ForeColor = &H2144FF
            End If

            If i = Date And .Enabled = True Then

                Set lblTodayBack = dFrame.Controls.Add("Forms.Label.1", "lblTodayBack")
                With lblTodayBack
                    .Height = 1.2
                    .Width = 22
                    .Top = lblDate.Top + 16
                    .Left = lblDate.Left + 5
                    .BackColor = &H2144FF
                    .ZOrder (1)
                End With
            End If

            Set aDate = New clsDate
            Set aDate.lblDate = lblDate
            Set aDate.dFrame = dFrame
            Set aDate.dForm = dForm
            colDate.Add aDate

        End With

        If lLeft <= 238 Then
            lLeft = lLeft + 44

        Else
            lLeft = 6
            lTop = lTop + 30
        End If

    Next i
    Set lblSelectedDateBack = dFrame.Controls.Add("Forms.Label.1", "lblSelectedDateBack")
    With lblSelectedDateBack
        .Height = 26
        .Width = 30
        .Picture = dForm.lblSelectedDateBack.Picture

        .Visible = False
        .ZOrder (1)
    End With

    Set lblDateBack = dFrame.Controls.Add("Forms.Label.1", "lblDateBack")
    With lblDateBack
        .Height = 26
        .Width = 30
        .Picture = dForm.lblDateBack.Picture
        .Visible = False
        .ZOrder (1)

    End With

End Sub

Public Sub createMonth(snMonth As Integer)
'@AssignedModule clsDate
'@INCLUDE PROCEDURE getMonth
'@INCLUDE CLASS clsDate
'@INCLUDE USERFORM uCalendar
    Dim lTop As Integer, i As Integer
    Dim fDate As Integer

    Set dForm = uCalendar
    Set mFrame = dForm.frameMonth

    With mFrame
        .Clear
    End With

    lTop = 4
    For i = 1 To 12
        Set lblMonth = mFrame.Controls.Add("Forms.Label.1", "lblMonth" & i)
        With lblMonth
            .Left = 0
            .Top = lTop
            .Width = 90
            .Height = 14
            .Font.Name = "MontSerrat Medium"
            .Font.Size = 9

            If i = snMonth Then
                .ForeColor = vbWhite
                PassiveMonth = lblMonth.Name
            Else
                .ForeColor = vbGrayText
            End If

            .TextAlign = fmTextAlignCenter
            .BackStyle = fmBackStyleTransparent
            .Caption = getMonth(i)
            .Tag = i
        End With
        lTop = lTop + 18

        Set aMonth = New clsDate
        Set aMonth.lblMonth = lblMonth
        Set aMonth.mFrame = mFrame
        Set aMonth.dForm = dForm
        colMonth.Add aMonth

    Next i
    Set lblMonth = Nothing

    Set lblMonthBack = mFrame.Controls.Add("Forms.Label.1", "lblMonthBack")
    With lblMonthBack
        .Left = 0
        .Top = (snMonth - 1) * 18
        .Width = 90
        .BackColor = &H2144FF
        .TextAlign = fmTextAlignCenter
        .BorderStyle = fmBorderStyleNone
        .ZOrder (1)
    End With

End Sub

Public Sub createYear(snYear As Integer)
'@AssignedModule clsDate
'@INCLUDE CLASS clsDate
'@INCLUDE USERFORM uCalendar
    Dim lTop As Integer, i As Integer

    Set dForm = uCalendar
    Set yFrame = dForm.frameYear

    With yFrame
        .Clear
    End With

    lTop = 4
    For i = 1 To 12
        Set lblYear = yFrame.Controls.Add("Forms.Label.1", "lblYear" & i)
        With lblYear
            .Left = 0
            .Top = lTop
            .Width = 90
            .Height = 14
            .Font.Name = "MontSerrat Medium"
            .Font.Size = 9
            .ForeColor = vbGrayText
            .Caption = Format(Date, "yyyy") + i - 4

            If .Caption = snYear Then
                .ForeColor = vbWhite
                PassiveYear = lblYear.Name
            Else
                .ForeColor = vbGrayText
            End If

            .TextAlign = fmTextAlignCenter
            .BackStyle = fmBackStyleTransparent

            .Tag = i
        End With
        lTop = lTop + 18

        Set aYear = New clsDate
        Set aYear.lblYear = lblYear
        Set aYear.yFrame = yFrame
        Set aYear.dForm = dForm
        colYear.Add aYear

    Next i

    Set lblYearBack = yFrame.Controls.Add("Forms.Label.1", "lblYearBack")
    With lblYearBack
        .Left = 0
        .Top = yFrame.Controls(PassiveYear).Top - 4
        .Width = 90
        .BackColor = &H2144FF
        .TextAlign = fmTextAlignCenter
        .BorderStyle = fmBorderStyleNone
        .ZOrder (1)
    End With

End Sub

Private Sub dForm_Click()
'@AssignedModule clsDate
'@INCLUDE CLASS clsDate
    framevisibleFalse
End Sub

Private Sub dFrame_Click()
'@AssignedModule clsDate
'@INCLUDE CLASS clsDate
    framevisibleFalse
End Sub

Sub framevisibleFalse()
'@AssignedModule clsDate
'@INCLUDE CLASS clsDate
'@INCLUDE USERFORM uCalendar
    uCalendar.frameMonth.Visible = False
    uCalendar.frameYear.Visible = False
End Sub

Private Sub lblDate_Click()
'@AssignedModule clsDate
'@INCLUDE CLASS clsDate

    If SelectedDay <> "" Then
        If Weekday(SelectedDayTag, 2) = 7 Or Weekday(SelectedDayTag, 2) = 6 Then
            dFrame.Controls(SelectedDay).ForeColor = &H2144FF
        Else
            dFrame.Controls(SelectedDay).ForeColor = &H48372C
        End If

    Else

    End If
    SelectDate lblDate
End Sub

Private Sub lblDate_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
'@AssignedModule clsDate
'@INCLUDE CLASS clsDate
'@INCLUDE USERFORM uCalendar
    SelectDate lblDate
    Unload uCalendar

End Sub

Sub SelectDate(Ctrl As control)
'@AssignedModule clsDate
'@INCLUDE CLASS clsDate
'@INCLUDE USERFORM uCalendar
'@INCLUDE DECLARATION Ctrl
    Dim curDate As Date
    With uCalendar
        .lblSelectedDate = Ctrl.Caption
        .lblSelectedMonth = .lblMonthName
        .lblSelectedYear = .txtYearName
        .lblSelectedDateName = Format(Ctrl.Tag, "dddd")
        .txtSelectedDate = Format(Ctrl.Tag, "dd.mm.yyyy")

        lblSelectedDateBackPosition Ctrl
        Ctrl.ForeColor = vbWhite
        SelectedDay = Ctrl.Name
        SelectedDayTag = Ctrl.Tag
    End With
End Sub

Private Sub lblDate_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
'@AssignedModule clsDate
'@INCLUDE CLASS clsDate
    framevisibleFalse
    lblDateBackPosition lblDate
    dayMouseOut
    lblDate.ForeColor = vbWhite
    PassiveDay = lblDate.Name
    PassiveDayTag = lblDate.Tag
End Sub

Private Sub lblDateBackPosition(Ctrl As control)
'@AssignedModule clsDate
'@INCLUDE PROCEDURE MouseMoveIcon
'@INCLUDE CLASS clsDate
'@INCLUDE DECLARATION Ctrl
    MouseMoveIcon
    With dFrame.Controls("lblDateBack")
        .Visible = True
        .Top = Ctrl.Top - 5
        .Left = Ctrl.Left + 1
    End With
End Sub

Private Sub lblMonth_Click()
'@AssignedModule clsDate
'@INCLUDE PROCEDURE getMonth
'@INCLUDE CLASS clsDate
'@INCLUDE USERFORM uCalendar
    With uCalendar
        .txtMonthNumber = lblMonth.Tag
        .frameMonth.Visible = False
        .lblMonthName = getMonth(.txtMonthNumber)
        createDates .txtYearName, .txtMonthNumber
    End With
End Sub

Private Sub lblYear_Click()
'@AssignedModule clsDate
'@INCLUDE CLASS clsDate
'@INCLUDE USERFORM uCalendar
    With uCalendar
        .txtYearName = lblYear
        .frameYear.Visible = False
        createDates .txtYearName, .txtMonthNumber
    End With

End Sub

Private Sub lblMonth_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
    '    MsgBox PassiveMonth
'@AssignedModule clsDate
'@INCLUDE CLASS clsDate
    lblMonthBackPosition lblMonth
    monthMouseOut
    lblMonth.ForeColor = vbWhite
    PassiveMonth = lblMonth.Name

End Sub

Private Sub lblYear_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
'@AssignedModule clsDate
'@INCLUDE CLASS clsDate

    lblYearBackPosition lblYear
    yearMouseOut
    lblYear.ForeColor = vbWhite
    PassiveYear = lblYear.Name

End Sub

Private Sub lblSelectedDateBackPosition(Ctrl As control)
'@AssignedModule clsDate
'@INCLUDE CLASS clsDate
'@INCLUDE DECLARATION Ctrl
    With dFrame.Controls("lblSelectedDateBack")
        .Visible = True
        .Top = Ctrl.Top - 5
        .Left = Ctrl.Left + 1
    End With
End Sub

Private Sub lblYearBackPosition(Ctrl As control)
'@AssignedModule clsDate
'@INCLUDE PROCEDURE MouseMoveIcon
'@INCLUDE CLASS clsDate
'@INCLUDE DECLARATION Ctrl
    MouseMoveIcon
    dForm.Controls("lblYearBack").Top = Ctrl.Top - 4
End Sub

Private Sub lblMonthBackPosition(Ctrl As control)
'@AssignedModule clsDate
'@INCLUDE PROCEDURE MouseMoveIcon
'@INCLUDE CLASS clsDate
'@INCLUDE DECLARATION Ctrl
    MouseMoveIcon
    dForm.Controls("lblMonthBack").Top = Ctrl.Top - 4
End Sub

Public Sub dayMouseOut()
'@AssignedModule clsDate
'@INCLUDE CLASS clsDate
    On Error Resume Next
    If PassiveDay <> "" Then

        If Weekday(PassiveDayTag, 2) = 7 Or Weekday(PassiveDayTag, 2) = 6 Then
            dFrame.Controls(PassiveDay).ForeColor = &H2144FF
        Else
            dFrame.Controls(PassiveDay).ForeColor = &H48372C
        End If

    End If
    If SelectedDay <> "" Then
        dFrame.Controls(SelectedDay).ForeColor = vbWhite
    End If

End Sub

Private Sub monthMouseOut()
'@AssignedModule clsDate
'@INCLUDE CLASS clsDate

    If PassiveMonth <> "" Then
        mFrame.Controls(PassiveMonth).ForeColor = vbGrayText
    End If
End Sub

Private Sub yearMouseOut()
'@AssignedModule clsDate
'@INCLUDE CLASS clsDate

    If PassiveYear <> "" Then
        yFrame.Controls(PassiveYear).ForeColor = vbGrayText
    End If
End Sub


'M_Calendar_API	Module

'-----------------------------------------------------------------------------------------------------------
#If VBA7 Then

    Public Declare PtrSafe Sub ReleaseCapture Lib "user32" ()
    Public Declare PtrSafe Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, _
                                                                            ByVal wMsg As Long, _
                                                                            ByVal wParam As Long, _
                                                                            lParam As Any) As Long
    '----------------------------------------------------------------------------------------------------
    Public Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwNilliseconds As Long)
    Public Declare PtrSafe Function SetLayeredWindowAttributes Lib "user32" (ByVal hwnd As Long, ByVal crKey As Long, ByVal bAlpha As Byte, ByVal dwFlags As Long) As Long
    Public Declare PtrSafe Function GetWindowLong Lib "user32.dll" Alias "GetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long) As Long
    Public Declare PtrSafe Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
    Public Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    Public Declare PtrSafe Function DrawMenuBar Lib "user32" (ByVal hwnd As Long) As Long
    Public Declare PtrSafe Function FindWindowA Lib "user32" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    Public Declare PtrSafe Function LoadCursorBynum Lib "user32" Alias "LoadCursorA" (ByVal hInstance As Long, ByVal lpCursorName As Long) As Long
    Public Declare PtrSafe Function SetCursor Lib "user32" (ByVal hCursor As Long) As Long
    Public Declare PtrSafe Function MoveJanela Lib "user32" Alias "SetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
    Public Declare PtrSafe Function CreateRoundRectRgn Lib "gdi32" (ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long, ByVal X3 As Long, ByVal Y3 As Long) As Long
    Public Declare PtrSafe Function SetWindowRgn Lib "user32" (ByVal hwnd As Long, ByVal hRgn As Long, ByVal bRedraw As Boolean) As Long
    
#Else
    Public Declare Sub ReleaseCapture Lib "user32" ()
    Public Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hWnd As Long, _
                                                                            ByVal wMsg As Long, _
                                                                            ByVal wParam As Long, _
                                                                            lParam As Any) As Long
    '----------------------------------------------------------------------------------------------------
    Public Declare Sub Sleep Lib "kernel32" (ByVal dwNilliseconds As Long)
    Public Declare Function SetLayeredWindowAttributes Lib "user32" (ByVal hWnd As Long, ByVal crKey As Long, ByVal bAlpha As Byte, ByVal dwFlags As Long) As Long
    Public Declare Function GetWindowLong Lib "user32.dll" Alias "GetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
    Public Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
    Public Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    Public Declare Function DrawMenuBar Lib "user32" (ByVal hWnd As Long) As Long
    Public Declare Function FindWindowA Lib "user32" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    Public Declare Function LoadCursorBynum Lib "user32" Alias "LoadCursorA" (ByVal hInstance As Long, ByVal lpCursorName As Long) As Long
    Public Declare Function SetCursor Lib "user32" (ByVal hCursor As Long) As Long
    Public Declare Function MoveJanela Lib "user32" Alias "SetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
    Public Declare Function CreateRoundRectRgn Lib "gdi32" (ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long, ByVal X3 As Long, ByVal Y3 As Long) As Long
    Public Declare Function SetWindowRgn Lib "user32" (ByVal hWnd As Long, ByVal hRgn As Long, ByVal bRedraw As Boolean) As Long

#End If

Private Const GWL_EXSTYLE As Long = (-20)
Private Const WS_EX_DLGMODALFRAME As Long = &H1
Private Const GWL_STYLE As Long = (-16)
Private Const WS_CAPTION = 55000000
Private Const WS_EX_LAYERED = &H80000
'Private Const LWA_COLORKEY = &H1
Private Const LWA_ALPHA = &H2
Private Const IDC_HAND = 32649&
Public MeuForm As Long
Public ESTILO As Long
Public Const ESTILO_ATUAL As Long = (-16)
Public Const HTCAPTION = 2
Public Const WM_NCLBUTTONDOWN = &HA1

Private lngPixelsX As Long
Private lngPixelsY As Long
Private strThunder As String
Private blnCreate As Boolean
Private lnghWnd_Form As Long
Private lnghWnd_Sub As Long

Private Const cstMask As Long = &H7FFFFFFF

Public PassiveMonth, PassiveDay, PassiveYear, PassiveDayTag, SelectedDay, SelectedDayTag

Public Function getMonth(iMonth As Integer, Optional language As String)
'    Select Case languege
'@AssignedModule M_Calendar_API
        
        Select Case iMonth Mod 12
           Case Is = 1, "-11"
                getMonth = "JANUARY"
           Case Is = 2, "-10"
                getMonth = "FEBRUARY"
           Case Is = 3, "-9"
                getMonth = "MARCH"
           Case Is = 4, "-8"
                getMonth = "APRIL"
           Case Is = 5, "-7"
                getMonth = "MAY"
           Case Is = 6, "-6"
                getMonth = "JUNE"
           Case Is = 7, "-5"
                getMonth = "JULY"
           Case Is = 8, "-4"
                getMonth = "AUGUST"
           Case Is = 9, "-3"
                getMonth = "SEPTEMBER"
           Case Is = 10, "-2"
                getMonth = "OCTOBER"
           Case Is = 11, "-1"
                getMonth = "NOVEMBER"
           Case Is = 0, 12
                getMonth = "DECEMBER"

        End Select
'    End Select
End Function

Function HideTitleBarAndBorder(frm As Object)
'@AssignedModule M_Calendar_API
'@INCLUDE DECLARATION GWL_EXSTYLE
'@INCLUDE DECLARATION GWL_STYLE
'@INCLUDE DECLARATION WS_CAPTION
'@INCLUDE DECLARATION WS_EX_DLGMODALFRAME
'@INCLUDE DECLARATION DrawMenuBar
'@INCLUDE DECLARATION FindWindow
'@INCLUDE DECLARATION GetWindowLong
'@INCLUDE DECLARATION SetWindowLong


    Dim lngWindow As Long
    Dim lFrmHdl As Long
    lFrmHdl = FindWindow(vbNullString, frm.Caption)
    lngWindow = GetWindowLong(lFrmHdl, GWL_STYLE)
    lngWindow = lngWindow And (Not WS_CAPTION)
    SetWindowLong lFrmHdl, GWL_STYLE, lngWindow
    lngWindow = GetWindowLong(lFrmHdl, GWL_EXSTYLE)
    lngWindow = lngWindow And Not WS_EX_DLGMODALFRAME
    SetWindowLong lFrmHdl, GWL_EXSTYLE, lngWindow
    DrawMenuBar lFrmHdl

End Function

Function MakeUserformTransparent(frm As Object, colorKey As Variant, Optional color As Variant)
'@AssignedModule M_Calendar_API
'@INCLUDE DECLARATION GWL_EXSTYLE
'@INCLUDE DECLARATION LWA_COLORKEY
'@INCLUDE DECLARATION WS_EX_LAYERED
'@INCLUDE DECLARATION FindWindow
'@INCLUDE DECLARATION GetWindowLong
'@INCLUDE DECLARATION SetLayeredWindowAttributes
'@INCLUDE DECLARATION SetWindowLong
LWA_COLORKEY = colorKey

Dim formhandle As Long
Dim bytOpacity As Byte

formhandle = FindWindow(vbNullString, frm.Caption)
If IsMissing(color) Then color = &H8000&        '//rgbWhite
bytOpacity = 130

SetWindowLong formhandle, GWL_EXSTYLE, GetWindowLong(formhandle, GWL_EXSTYLE) Or WS_EX_LAYERED

frm.BackColor = color
SetLayeredWindowAttributes formhandle, color, bytOpacity, LWA_COLORKEY

End Function

Public Function MouseCursor(CursorType As Long)
'@AssignedModule M_Calendar_API
'@INCLUDE DECLARATION LoadCursorBynum
'@INCLUDE DECLARATION SetCursor
  Dim lngRet As Long
  lngRet = LoadCursorBynum(0&, CursorType)
  lngRet = SetCursor(lngRet)
End Function

Public Function MouseMoveIcon()
'@AssignedModule M_Calendar_API
'@INCLUDE PROCEDURE MouseCursor
'@INCLUDE DECLARATION IDC_HAND
    Call MouseCursor(IDC_HAND)
End Function

Public Sub moverForm(Form As Object, obj As Object, Button As Integer)
'@AssignedModule M_Calendar_API
'@INCLUDE DECLARATION HTCAPTION
'@INCLUDE DECLARATION WM_NCLBUTTONDOWN
'@INCLUDE DECLARATION FindWindowA
'@INCLUDE DECLARATION SendMessage
'@INCLUDE DECLARATION ReleaseCapture
    Dim lngMyHandle As Long, lngCurrentStyle As Long, lngNewStyle As Long
    If val(Application.Version) < 9 Then
        lngMyHandle = FindWindowA("ThunderXFrame", Form.Caption)
    Else
        lngMyHandle = FindWindowA("ThunderDFrame", Form.Caption)
    End If
    
    If Button = 1 Then
        With obj
            Call ReleaseCapture
            Call SendMessage(lngMyHandle, WM_NCLBUTTONDOWN, HTCAPTION, 0&)
        End With
    End If
End Sub
Public Sub removeTudo(ObjForm As Object)
'@AssignedModule M_Calendar_API
'@INCLUDE DECLARATION ESTILO_ATUAL
'@INCLUDE DECLARATION WS_CAPTION
'@INCLUDE DECLARATION FindWindowA
'@INCLUDE DECLARATION MoveJanela
'@INCLUDE DECLARATION ESTILO
'@INCLUDE DECLARATION MeuForm
    MeuForm = FindWindowA(vbNullString, ObjForm.Caption)
    ESTILO = ESTILO Or WS_CAPTION
    MoveJanela MeuForm, ESTILO_ATUAL, (ESTILO)
End Sub



'z_RadialMenu	UserForm

Option Explicit
Private WithEvents Emitter As EventListenerEmitter
Private Sub Emitter_MouseMove(control As Object, Shift As Integer, x As Single, y As Single)
'@INCLUDE CLASS EventListenerEmitter
'@AssignedModule z_RadialMenu
'@INCLUDE USERFORM z_RadialMenu
    If control.Name = "iMain" Or control.Name = Me.Name Then Exit Sub
    control.ZOrder (0)
End Sub
Private Sub UserForm_Initialize()
'@INCLUDE CLASS aUserform
'@AssignedModule z_RadialMenu
'@INCLUDE USERFORM z_RadialMenu
    Me.BackColor = vbMagenta
    With aUserform.Init(Me)
        .TRANSPARENT (vbMagenta)
        .Borderless
    End With
    Me.Height = 400
    Me.Width = 400
    iMain.Left = Me.Width / 2 - iMain.Width / 2
    iMain.Top = Me.Height / 2 - iMain.Height / 2
    toggleMainImage
End Sub
Sub toggleMainImage()
'@INCLUDE PROCEDURE FileExists
'@INCLUDE PROCEDURE IniReadKey
'@INCLUDE DECLARATION black
'@AssignedModule z_RadialMenu
'@INCLUDE USERFORM z_RadialMenu
    Dim picForMenuExpanded As String
    picForMenuExpanded = IniReadKey(ThisWorkbook.Path & "\config\radialmenu.ini", "Settings", "picForMenuExpanded")
    If picForMenuExpanded = "" Then picForMenuExpanded = "WhiteCircle"
    picForMenuExpanded = ThisWorkbook.Path & "\img\" & picForMenuExpanded & ".jpg"
    Dim picForMenuCollapsed As String
    picForMenuCollapsed = IniReadKey(ThisWorkbook.Path & "\config\radialmenu.ini", "Settings", "picForMenuCollapsed")
    If picForMenuCollapsed = "" Then picForMenuCollapsed = "PurpleCircle"
    picForMenuCollapsed = ThisWorkbook.Path & "\img\" & picForMenuCollapsed & ".jpg"
    If Not FileExists(picForMenuCollapsed) Or Not FileExists(picForMenuExpanded) Then
        MsgBox "Could not fild image files"
        Stop
    End If
    Dim targetFile As String
    With iMain
        If .Picture Is Nothing Then
            .Picture = LoadPicture(picForMenuCollapsed)
            .Tag = "collapsed"
            targetFile = picForMenuCollapsed
        ElseIf .Tag <> "collapsed" Then
            .Picture = LoadPicture(picForMenuCollapsed)
            .Tag = "collapsed"
            targetFile = picForMenuCollapsed
        Else
            .Picture = LoadPicture(picForMenuExpanded)
            .Tag = "expanded"
            targetFile = picForMenuExpanded
        End If
        .BorderStyle = fmBorderStyleNone
        .Width = 48
        .Height = 48
        .BackStyle = fmBackStyleTransparent
    End With
    If InStr(1, Mid(targetFile, InStrRev(targetFile, "\")), "white", vbTextCompare) > 0 Then
        iMain.ForeColor = vbBlack
    ElseIf InStr(1, Mid(targetFile, InStrRev(targetFile, "\")), "black", vbTextCompare) > 0 Then
        iMain.ForeColor = vbWhite
    End If
    Me.Repaint
End Sub
Private Sub iMain_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
    'if left mouse is pressed
'@INCLUDE PROCEDURE moverForm
'@AssignedModule z_RadialMenu
'@INCLUDE USERFORM z_RadialMenu
    If Button = 1 Then moverForm Me, Me, Button
End Sub
Private Sub iMain_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
    'if right click
'@INCLUDE PROCEDURE SwitchThemeHexagon
'@INCLUDE PROCEDURE SwitchThemeCircle
'@AssignedModule z_RadialMenu
'@INCLUDE USERFORM z_RadialMenu
    If Button = 2 Then
        Const popupName = "RM_Menu"
        On Error Resume Next
        CommandBars(popupName).Delete
        On Error GoTo 0
        With CommandBars.Add(popupName, msoBarPopup, , True)
            With .Controls.Add(msoControlButton)
                .OnAction = "RadialMenuCommand_Unload"
                .Caption = "Unload Me"
            End With
            With .Controls.Add(msoControlPopup)
                .Caption = "Themes"
                .BeginGroup = True
                With .Controls.Add(msoControlButton)
                    .Caption = "Circle"
                    .OnAction = "SwitchThemeCircle"
                End With
                With .Controls.Add(msoControlButton)
                    .Caption = "Hexagon"
                    .OnAction = "SwitchThemeHexagon"
                End With
            End With
            .ShowPopup
        End With
    End If
End Sub
Private Sub iMain_Click()
'@AssignedModule z_RadialMenu
'@INCLUDE USERFORM z_RadialMenu
    ToggleMenu
End Sub
Sub ToggleMenu()
'@INCLUDE CLASS EventListenerEmitter
'@AssignedModule z_RadialMenu
'@INCLUDE USERFORM z_RadialMenu
'@INCLUDE DECLARATION Emitter
    toggleMainImage
    Dim Visibility As Boolean
    Dim control As MSForms.control
    If Me.Controls.count = 1 Then
        'createRadialMenu( numLayers As Integer, _
                           numControls As Integer, _
                           startingAngle As Integer, _
                           ClockwisePlacement As Boolean, _
                           ParamArray Pairs() As Variant)
        createRadialMenu 3, _
                         Array(8, 6, 6), _
                         0, _
                         True   ', _
                              "1-1", "caption", _
                              "1-3", "purpleCircle", _
                              "2-6", "hi"
        Set Emitter = New EventListenerEmitter
        Emitter.AddEventListenerAll Me
    Else
        Visibility = Not Controls(1).Visible 'starts at 0
        For Each control In Me.Controls
            If control.Name <> "iMain" Then control.Visible = Visibility
        Next
    End If
    Me.Repaint
End Sub
Sub createRadialMenu(numLayers As Integer, controlsPerLayer As Variant, startingAngle As Integer, ClockwisePlacement As Boolean, ParamArray Pairs() As Variant)
'@INCLUDE PROCEDURE FileExists
'@INCLUDE PROCEDURE IniReadKey
'@AssignedModule z_RadialMenu
'@INCLUDE USERFORM z_RadialMenu
    If UBound(controlsPerLayer) + 1 <> numLayers Then
        Dim dif: dif = UBound(controlsPerLayer) + 1 - numLayers
        dif = IIf(dif > 0, "-", "+") & Abs(dif)
        MsgBox "You are trying to create " & numLayers & " Layers" & vbNewLine & _
               "but passed controlsPerLayer = Array(" & Join(controlsPerLayer, ",") & ")" & vbNewLine & _
               "You should have " & dif & " argument(s) in your array."
        Stop
    End If
    Dim control As MSForms.Label
    Dim centerX As Single
    Dim centerY As Single
    centerX = iMain.Left + iMain.Width / 2 ' X-coordinate of center point
    centerY = iMain.Top + iMain.Height / 2 ' Y-coordinate of center point
    Dim layerIndex As Integer
    For layerIndex = 1 To numLayers
        Dim angleStep As Single
        angleStep = (IIf(ClockwisePlacement, -1, 1) * 360) / controlsPerLayer(layerIndex - 1)
        Dim radius As Single
        radius = CalculateRadius(layerIndex, CInt(controlsPerLayer(layerIndex - 1))) ' Calculate the radius
        Dim angle As Single
        angle = startingAngle  'where to start
        Dim DefaultImage As String
        DefaultImage = IniReadKey(ThisWorkbook.Path & "\config\radialmenu.ini", "Settings", "picForItemsDefault")
        If DefaultImage = "" Then DefaultImage = "BlackCircle"
        Dim targetFile As String
        targetFile = ThisWorkbook.Path & "\img\" & DefaultImage & ".jpg"
        Dim controlIndex As Integer
        For controlIndex = 1 To controlsPerLayer(layerIndex - 1)
            Set control = Me.Controls.Add("Forms.Label.1", "control-" & layerIndex & "-" & controlIndex)
            If FileExists(targetFile) Then
                control.Picture = LoadPicture(targetFile)
            End If
            control.MousePointer = fmMousePointerCustom
            control.MouseIcon = LoadPicture(ThisWorkbook.Path & "\img\Hand Cursor Pointer.ico")
            control.Caption = control.Name
            control.ForeColor = vbWhite
            control.BackStyle = fmBackStyleTransparent
            control.PicturePosition = fmPicturePositionCenter
            control.Height = iMain.Height
            control.Width = iMain.Height
            Dim xPosition As Single
            Dim yPosition As Single
            xPosition = centerX + radius * Cos(DegToRad(angle))
            yPosition = centerY - radius * Sin(DegToRad(angle))
            control.Left = xPosition - control.Width / 2
            control.Top = yPosition - control.Height / 2
            angle = angle + angleStep
        Next controlIndex
    Next layerIndex
    If IsMissing(Pairs) Then Exit Sub
    For Each control In Controls
        If control.Name <> "iMain" Then control.Visible = False
    Next
    Dim i As Long
    For i = LBound(Pairs) To UBound(Pairs) Step 2
        Set control = Controls("control-" & Split(Pairs(i), "-")(0) & "-" & Split(Pairs(i), "-")(1))
        With control
            .Visible = True
            Dim command As String: command = Pairs(i + 1)
            targetFile = ThisWorkbook.Path & "\img\" & command & ".jpg"
            If FileExists(targetFile) Then
                control.Picture = LoadPicture(targetFile)
                control.Tag = "custom"
            Else
                control.Caption = command
            End If
        End With
    Next
    For Each control In Controls
        If control.Name <> "iMain" Then If control.Visible = False Then Controls.Remove control.Name
    Next
End Sub
Function CalculateRadius(layerIndex As Integer, controlsPerLayer As Integer) As Single
    ' Implement your logic to calculate the radius for each layer (distance from the center)
'@AssignedModule z_RadialMenu
'@INCLUDE USERFORM z_RadialMenu
    CalculateRadius = layerIndex * 50 ' adjust as needed
End Function
Function DegToRad(ByVal degrees As Single) As Single
'@AssignedModule z_RadialMenu
'@INCLUDE USERFORM z_RadialMenu
    DegToRad = degrees * WorksheetFunction.Pi / 180
End Function
Private Sub Emitter_Click(control As Object)
'@INCLUDE PROCEDURE ProcedureExists
'@INCLUDE CLASS EventListenerEmitter
'@AssignedModule z_RadialMenu
'@INCLUDE USERFORM z_RadialMenu
    If control.Name = "iMain" Then Exit Sub
    'we can either use the control's name to get its layer & index
    Dim controlIndex As String:     controlIndex = Split(control.Name, "-", 2)(1)
    Select Case controlIndex
    Case "1-1"
        MsgBox "found me"
    Case "2-1"
    '... etc
    Case Else
    End Select
    'or we could use the caption
    Select Case control.Caption
        Case "Sample1"
        Case "Sample2"
        Case Else
            If ProcedureExists(ThisWorkbook, control.Caption) Then
                Application.Run control.Caption
            Else
            End If
    End Select
End Sub

'EventListenerItem	Class

Rem Author Robert Todar

Option Explicit
Option Compare Text

'SET FROM AddEventListener - NEEDED TO EMIT EVENT BACK TO IT.
Private WithEvents Emitter As EventListenerEmitter

'CONTROLS THAT HAVE THE EVENTS
Private WithEvents Form As MSForms.UserForm
Private WithEvents Textbox As MSForms.Textbox
Private WithEvents Label As MSForms.Label
Private WithEvents CommandButton As MSForms.CommandButton
Private WithEvents ComboBox As MSForms.ComboBox
Private WithEvents Frame As MSForms.Frame

Private WithEvents Image As MSForms.Image

Private Type state
    control As Object
    IsHoveredControl As Boolean
    IsFocusedControl As Boolean
End Type

Private This As state

'TODO
' - ADD EVENTS FOR ALL USERFORM CONTROLS
' - ADD MORE EVENTS THAN THE LIST BELOW
' - DOUBLE CHECK THAT EMITTS ARE ALL CURRENT

'CURRENT EVENTS (WILL ADD MORE AS I HAVE NEED)
' - MouseOver
' - MouseOut
' - MouseMove
' - Click
' - DblClick
' - Focus
' - Blur
' - KeyUp
' - KeyDown

' The Only public method. This will be called from EventListeneRemitter class module
Public Sub AddEventListener(ByRef ControlOrForm As Object, ByRef EmitterReference As EventListenerEmitter)
    ' Capture the emitter class. This will be used to emit events from each control.
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    Set Emitter = EmitterReference

    ' This is used to compare and check to see if this is the control triggering the event.
    Set This.control = ControlOrForm

    ' Set control (or form) based on its type
    Select Case TypeName(ControlOrForm)
    Case "CommandButton"
        Set CommandButton = ControlOrForm

    Case "ComboBox"
        Set ComboBox = ControlOrForm

    Case "Frame"
        Set Frame = ControlOrForm

    Case "MultiPage"
'
    Case "Label"
        Set Label = ControlOrForm

    Case "TextBox"
        Set Textbox = ControlOrForm
    Case "Image"
        Set Image = ControlOrForm
    Case Else

        If TypeOf ControlOrForm Is MSForms.UserForm Then
            Set Form = ControlOrForm
        Else
            Rem todo
            Rem err.Raise 5, TypeName(Me), "Invalid control: Currently unable to listen to events on " & TypeName(ControlOrForm)
        End If

    End Select
End Sub

'***********************************************************************************
' Helper functions
'***********************************************************************************

' Called on mousemove event. This is a way of creating a mouseover and mouseout event.
Private Sub CheckIfHoveredControl()
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    If Not This.IsHoveredControl Then
        This.IsHoveredControl = True
        Emitter.EmitEvent This.control, MouseOver
    End If
End Sub

' Called on mousemove event. This is a way of creating a mouseover and mouseout event.
Private Sub CheckIfFocusedControl()
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    If Not This.IsFocusedControl Then
        If TypeName(This.control) = "Frame" Then
            Emitter.SetFocusToControl This.control.ActiveControl
        Else
            This.IsFocusedControl = True
            Emitter.EmitEvent This.control, Focus
        End If
    End If
End Sub

' Simple Collection factory  for ease of use.
Private Function ToCollection(ParamArray keyValuePairs() As Variant) As Collection
    ' Check to see if there is even number of parameters
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerItem
    Dim ArrayLenght As Long
    ArrayLenght = UBound(keyValuePairs) - LBound(keyValuePairs) + 1

    If ArrayLenght Mod 2 <> 0 Then
        Err.Raise 5, TypeName(Me), "Invalid parameters: expecting key/value pairs, but received an odd number of arguments."
    End If

    Set ToCollection = New Collection
    Dim index As Long
    For index = LBound(keyValuePairs) To UBound(keyValuePairs) Step 2
        ToCollection.Add keyValuePairs(index + 1), keyValuePairs(index)
    Next index
End Function

'***********************************************************************************
' EVENTS
'***********************************************************************************

' ONCE AN EVENT HAS EMMITED, EACH EVENTListenerITEM WILL LISTEN FOR THAT EVENT
Private Sub Emitter_EmittedEvent(ByRef control As Object, ByVal EventName As EmittedEvent, ByRef EventParameters As Collection)
    ' CREATE A MOUSEOVER MOUSEOUT EVENTS
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter

'    On Error GoTo EH '<-- TODO proper error handling
    Select Case EventName
    Case MouseOver
        'todo catastrophic error occurs with dynamic controls??
        If This.control.Name <> control.Name And This.IsHoveredControl Then
            This.IsHoveredControl = False
            Emitter.EmitEvent This.control, MouseOut
        End If

    Case Focus
        If This.control.Name <> control.Name And This.IsFocusedControl Then
            This.IsFocusedControl = False
            Emitter.EmitEvent This.control, Blur
        ElseIf This.control.Name = control.Name And This.IsFocusedControl = False Then
            This.IsFocusedControl = True
        End If

    End Select
EH:
End Sub

'------------------------------------------------------------------------
' USERFORM
'------------------------------------------------------------------------
Private Sub Form_Click()
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent This.control, Click
End Sub

Private Sub Form_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent This.control, DoubleClick, ToCollection("Cancel", Cancel)
End Sub

Private Sub Form_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    CheckIfHoveredControl
    Emitter.EmitEvent This.control, MouseMove, ToCollection("Button", Button, "Shift", Shift, "X", x, "Y", y)
End Sub

Private Sub Form_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent This.control, MouseDown, ToCollection("Button", Button, "Shift", Shift, "X", x, "Y", y)
End Sub

Private Sub Form_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent This.control, MouseUp, ToCollection("Button", Button, "Shift", Shift, "X", x, "Y", y)
End Sub

'------------------------------------------------------------------------
' COMMAND BUTTON
'------------------------------------------------------------------------
Private Sub CommandButton_Click()
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent This.control, Click
End Sub

Private Sub CommandButton_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent This.control, DoubleClick, ToCollection("Cancel", Cancel)
End Sub

Private Sub CommandButton_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    CheckIfHoveredControl
    Emitter.EmitEvent This.control, MouseMove, ToCollection("Button", Button, "Shift", Shift, "X", x, "Y", y)
End Sub

Private Sub CommandButton_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    CheckIfFocusedControl
    Emitter.EmitEvent This.control, MouseUp, ToCollection("Button", Button, "Shift", Shift, "X", x, "Y", y)
End Sub

Private Sub CommandButton_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent This.control, MouseDown, ToCollection("Button", Button, "Shift", Shift, "X", x, "Y", y)
End Sub

Private Sub CommandButton_KeyUp(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    CheckIfFocusedControl
    Emitter.EmitEvent This.control, KeyUp, ToCollection("KeyCode", KeyCode, "Shift", Shift)
End Sub

Private Sub CommandButton_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent This.control, KeyDown, ToCollection("KeyCode", KeyCode, "Shift", Shift)
End Sub

'------------------------------------------------------------------------
' IMAGE
'------------------------------------------------------------------------
Private Sub Image_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent This.control, MouseDown
End Sub

'------------------------------------------------------------------------
' LABEL
'------------------------------------------------------------------------
Private Sub Label_Click()
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent This.control, Click
End Sub

Private Sub Label_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent This.control, DoubleClick, ToCollection("Cancel", Cancel)
End Sub

Private Sub Label_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    CheckIfHoveredControl
    Emitter.EmitEvent This.control, MouseMove, ToCollection("Button", Button, "Shift", Shift, "X", x, "Y", y)
End Sub

Private Sub Label_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent This.control, MouseDown, ToCollection("Button", Button, "Shift", Shift, "X", x, "Y", y)
End Sub

Private Sub Label_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent This.control, MouseUp, ToCollection("Button", Button, "Shift", Shift, "X", x, "Y", y)
End Sub

'------------------------------------------------------------------------
' Frame
'------------------------------------------------------------------------
Private Sub Frame_Click()
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent This.control, Click
End Sub

Private Sub Frame_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent This.control, DoubleClick, ToCollection("Cancel", Cancel)
End Sub

Private Sub Frame_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    CheckIfHoveredControl
    Emitter.EmitEvent This.control, MouseMove, ToCollection("Button", Button, "Shift", Shift, "X", x, "Y", y)
End Sub

Private Sub Frame_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    CheckIfFocusedControl        'FRAME DOESN'T TAKE FOCUS BUT ACTIVE CONTROL IN FRAME DOES
    Emitter.EmitEvent This.control, MouseDown
End Sub

Private Sub Frame_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent This.control, MouseUp, ToCollection("Button", Button, "Shift", Shift, "X", x, "Y", y)
End Sub

'------------------------------------------------------------------------
' Textbox
'------------------------------------------------------------------------
Private Sub Textbox_Click()
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent This.control, Click
End Sub

Private Sub Textbox_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent This.control, DoubleClick, ToCollection("Cancel", Cancel)
End Sub

Private Sub Textbox_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    CheckIfHoveredControl
    Emitter.EmitEvent This.control, MouseMove, ToCollection("Button", Button, "Shift", Shift, "X", x, "Y", y)
End Sub

Private Sub Textbox_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    CheckIfFocusedControl
    Emitter.EmitEvent This.control, MouseUp, ToCollection("Button", Button, "Shift", Shift, "X", x, "Y", y)
End Sub

Private Sub Textbox_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent This.control, MouseDown, ToCollection("Button", Button, "Shift", Shift, "X", x, "Y", y)
End Sub

Private Sub Textbox_KeyUp(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    CheckIfFocusedControl
    Emitter.EmitEvent This.control, KeyUp, ToCollection("KeyCode", KeyCode, "Shift", Shift)
End Sub

Private Sub Textbox_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent This.control, KeyDown, ToCollection("KeyCode", KeyCode, "Shift", Shift)
End Sub

Private Sub TextBox_Change() 'added
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent This.control, Change
End Sub

'------------------------------------------------------------------------
' Combobox
'------------------------------------------------------------------------
Private Sub ComboBox_Click()
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent This.control, Click
End Sub

Private Sub ComboBox_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent This.control, DoubleClick, ToCollection("Cancel", Cancel)
End Sub

Private Sub ComboBox_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    CheckIfHoveredControl
    Emitter.EmitEvent This.control, MouseMove, ToCollection("Button", Button, "Shift", Shift, "X", x, "Y", y)
End Sub

Private Sub ComboBox_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer) 'added
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent This.control, KeyDown, ToCollection("KeyCode", KeyCode, "Shift", Shift)
End Sub

Private Sub ComboBox_KeyUp(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer) 'added
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    CheckIfFocusedControl
    Emitter.EmitEvent This.control, KeyUp, ToCollection("KeyCode", KeyCode, "Shift", Shift)
End Sub

Private Sub ComboBox_Change() 'added
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent This.control, Change
End Sub

Private Sub ComboBox_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single) 'added
'@AssignedModule EventListenerItem
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS EventListenerItem
'@INCLUDE DECLARATION Emitter
    CheckIfFocusedControl
    Emitter.EmitEvent This.control, MouseUp, ToCollection("Button", Button, "Shift", Shift, "X", x, "Y", y)
End Sub

'z_MultiPage	UserForm



Option Explicit

Private Sub UserForm_Initialize()
'@AssignedModule z_MutiPage
'@INCLUDE CLASS aMultiPage
'@INCLUDE CLASS aColorScheme
'@INCLUDE USERFORM z_MutiPage
    SidebarRight.Visible = False
    SidebarBottom.Visible = False
    
    '// the class is predeclaredId = true but shouldn't this way still work?
'    Dim am1 As aMultiPage
'    Set am1 = New aMultiPage
'    am1.Init(MultiPage1).BuildMenu createSidebarMinimizers:=True

    aMultiPage.Init(MultiPage1).BuildMenu createSidebarMinimizers:=True

End Sub


'aMultiPage	Class

'TODO
'test buildmenu targeting a multipage inside a multipage

'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Class      : aMultiPage
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 29-06-2023 13:41    Alex
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Private WithEvents Emitter As EventListenerEmitter

Const AUTHOR_EMAIL = "anastasioualex@gmail.com"

Private sbLeftWidth As Long
Private sbRightWidth As Long
Private sbBottomHeight As Long

#If Win64 Then
Public hwnd As LongPtr 'LongLong
#Else
Public hwnd As Long
#End If

Private oForm As Object

Public oMultipage As MultiPage


''''''''''''''''''''''''''
'Multipage BackColor start
''''''''''''''''''''''''''
Private Type RECT
    Left As Long
    Top As Long
    Right As Long
    Bottom As Long
End Type

Private Type uPicDesc
    Size As Long
    Type As Long
    #If VBA7 Then
        hPic As LongPtr
        hPal As LongPtr
    #Else
       hPic As Long
       hPal As Long
    #End If
End Type

Private Type GUID
    Data1 As Long
    Data2 As Integer
    Data3 As Integer
    Data4(0 To 7) As Byte
End Type


#If VBA7 Then
    Private Declare PtrSafe Function InternetGetConnectedState Lib "wininet.dll" (ByRef dwFlags As Long, ByVal dwReserved As Long) As Long
    Private Declare PtrSafe Function LoadLibrary Lib "kernel32" Alias "LoadLibraryA" (ByVal lpLibFileName As String) As LongPtr
    Private Declare PtrSafe Function FreeLibrary Lib "kernel32" (ByVal hLibModule As LongPtr) As Long
    Private Declare PtrSafe Function OleCreatePictureIndirectAut Lib "oleAut32.dll" Alias "OleCreatePictureIndirect" (PicDesc As uPicDesc, RefIID As GUID, ByVal fPictureOwnsHandle As Long, iPic As IPicture) As Long
    Private Declare PtrSafe Function OleCreatePictureIndirectPro Lib "olepro32.dll" Alias "OleCreatePictureIndirect" (PicDesc As uPicDesc, RefIID As GUID, ByVal fPictureOwnsHandle As Long, iPic As IPicture) As Long
    Private Declare PtrSafe Function CopyImage Lib "user32" (ByVal handle As LongPtr, ByVal un1 As Long, ByVal n1 As Long, ByVal n2 As Long, ByVal un2 As Long) As LongPtr
    Private Declare PtrSafe Function GetDC Lib "user32" (ByVal hwnd As LongPtr) As LongPtr
    Private Declare PtrSafe Function ReleaseDC Lib "user32" (ByVal hwnd As LongPtr, ByVal hDC As LongPtr) As Long
    Private Declare PtrSafe Function CreateCompatibleBitmap Lib "gdi32" (ByVal hDC As LongPtr, ByVal nWidth As Long, ByVal nHeight As Long) As LongPtr
    Private Declare PtrSafe Function CreateCompatibleDC Lib "gdi32" (ByVal hDC As LongPtr) As LongPtr
    Private Declare PtrSafe Function DeleteObject Lib "gdi32" (ByVal hObject As LongPtr) As Long
    Private Declare PtrSafe Function SelectObject Lib "gdi32" (ByVal hDC As LongPtr, ByVal hObject As LongPtr) As LongPtr
    Private Declare PtrSafe Function CreateSolidBrush Lib "gdi32" (ByVal crColor As Long) As LongPtr
    Private Declare PtrSafe Function FillRect Lib "user32" (ByVal hDC As LongPtr, lpRect As RECT, ByVal hBrush As LongPtr) As Long
    Private Declare PtrSafe Function SetRect Lib "user32" (lpRect As RECT, ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As Long
    
    Private hDC As LongPtr, hMemDc As LongPtr, hMemBmp As LongPtr, hBrush As LongPtr, hCopy As LongPtr, ar() As LongPtr
    
#Else
    Private Declare Function InternetGetConnectedState Lib "wininet.dll" (ByRef dwFlags As Long, ByVal dwReserved As Long) As Long
    Private Declare Function LoadLibrary Lib "kernel32" Alias "LoadLibraryA" (ByVal lpLibFileName As String) As Long
    Private Declare Function FreeLibrary Lib "kernel32" (ByVal hLibModule As Long) As Long
    Private Declare Function OleCreatePictureIndirectAut Lib "oleAut32.dll" Alias "OleCreatePictureIndirect" (PicDesc As uPicDesc, RefIID As GUID, ByVal fPictureOwnsHandle As Long, iPic As IPicture) As Long
    Private Declare Function OleCreatePictureIndirectPro Lib "olepro32.dll" Alias "OleCreatePictureIndirect" (PicDesc As uPicDesc, RefIID As GUID, ByVal fPictureOwnsHandle As Long, iPic As IPicture) As Long
    Private Declare Function CopyImage Lib "user32" (ByVal handle As Long, ByVal un1 As Long, ByVal n1 As Long, ByVal n2 As Long, ByVal un2 As Long) As Long
    Private Declare Function GetDC Lib "user32" (ByVal hwnd As Long) As Long
    Private Declare Function ReleaseDC Lib "user32" (ByVal hwnd As Long, ByVal hdc As Long) As Long
    Private Declare Function CreateCompatibleBitmap Lib "gdi32" (ByVal hdc As Long, ByVal nWidth As Long, ByVal nHeight As Long) As Long
    Private Declare Function CreateCompatibleDC Lib "gdi32" (ByVal hdc As Long) As Long
    Private Declare Function DeleteObject Lib "gdi32" (ByVal hObject As Long) As Long
    Private Declare Function SelectObject Lib "gdi32" (ByVal hdc As Long, ByVal hObject As Long) As Long
    Private Declare Function CreateSolidBrush Lib "gdi32" (ByVal crColor As Long) As Long
    Private Declare Function FillRect Lib "user32" (ByVal hdc As Long, lpRect As RECT, ByVal hBrush As Long) As Long
    Private Declare Function SetRect Lib "user32" (lpRect As RECT, ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As Long
    
    Private hDC As Long, hMemDc As Long, hMemBmp As Long, hBrush As Long, hCopy As Long, ar() As Long
    
#End If


Private Const IMAGE_BITMAP = 0
Private Const PICTYPE_BITMAP = 1
Private Const LR_COPYRETURNORG = &H4
Private Const S_OK = 0
''''''''''''''''''''''''''
'Multipage BackColor end
''''''''''''''''''''''''''


'Public WithEvents oMultiPageEvent As MultiPage

'Private MenuLabels() As New aMultiPage

'Private MenuLabelCounter As Long
'Public WithEvents MenuLabelEvent As MSForms.Label
'
'Private Sub MenuLabelEvent_Click()
'    MsgBox MenuLabelEvent.Caption
'End Sub

Public Function Init(MP As control) As aMultiPage
'@AssignedModule aMultiPage
'@INCLUDE CLASS aMultiPage
    If TypeName(MP) <> "MultiPage" Then Stop
    Set oForm = MP.Parent
    Set oMultipage = MP
'    Set oMultiPageEvent = oMultiPage
    hwnd = MP.[_GethWnd]
    Set Init = Me
End Function

Public Sub BuildMenu(createSidebarMinimizers As Boolean)
'@AssignedModule aMultiPage
'@INCLUDE PROCEDURE AvailableFormOrFrameRow
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS aUserform
'@INCLUDE CLASS aMultiPage
'@INCLUDE DECLARATION MyColors
'@INCLUDE DECLARATION Ctrl
'@INCLUDE DECLARATION Emitter
    Dim MP As MultiPage: Set MP = oMultipage
    oForm.Height = MP.Height + oForm.Height - oForm.InsideHeight
    oForm.BackColor = MyColors.FormBackgroundDarkGray


    Dim SidebarLeft As Frame
    Set SidebarLeft = oForm.Controls.Add("forms.frame.1")
    SidebarLeft.Name = "SidebarLeft"
    With SidebarLeft
        .Caption = ""
        .SpecialEffect = fmSpecialEffectFlat
'        .BorderStyle = fmBorderStyleSingle
        .Left = 0
        .Top = 0
        .Height = MP.Height
        .Width = 60
        .BackColor = MyColors.FormSidebarMediumGray

    End With
    
    With MP
        .Left = SidebarLeft.Left + SidebarLeft.Width
        .Top = 0
'        .Width = oForm.InsideWidth - SidebarLeft.Width
        .Height = oForm.InsideHeight
        .Style = fmTabStyleNone
        Dim i As Long
        For i = 0 To MP.Pages.count - 1
            SetBackColor i, BackColor:=MyColors.FormBackgroundDarkGray
        Next
    End With
    
    Dim lbl As MSForms.Label
    
    Dim page
    For Each page In MP.Pages
        Set lbl = SidebarLeft.Controls.Add("forms.label.1")
        lbl.Name = "sidebarLabel" & page.Name
        With lbl
            If page.index = 0 Then .BackColor = MyColors.FormSelectedGreen
            .BorderStyle = fmBorderStyleSingle
'            .BorderColor = MyColors.FormSelectedGreen
            .WordWrap = False
            .AutoSize = True
            .Font.Size = 12
            .Top = AvailableFormOrFrameRow(SidebarLeft)
            .Left = 0
            .ForeColor = vbWhite
            .Caption = Space(4) & page.Caption
            .AutoSize = False
            .Height = 24
            .Tag = "page-" & page.index
            .ControlTipText = WorksheetFunction.Trim(.Caption)
        End With
'        MenuLabelCounter = MenuLabelCounter + 1
'        ReDim Preserve MenuLabels(1 To MenuLabelCounter)
'        Set MenuLabels(MenuLabelCounter).MenuLabelEvent = lbl
    Next
    
    Dim Ctrl As control
    Dim maxWidth As Long: maxWidth = 0
    For Each Ctrl In SidebarLeft.Controls
        If maxWidth < Ctrl.Width Then maxWidth = Ctrl.Width
    Next
    For Each Ctrl In SidebarLeft.Controls
        Ctrl.Width = maxWidth + 12
    Next
    SidebarLeft.Width = maxWidth + 12
    
    MP.Left = SidebarLeft.Left + SidebarLeft.Width
    
    Dim SidebarRight As MSForms.Frame
    Dim SidebarBottom As MSForms.Frame
    On Error Resume Next
        Set SidebarRight = oForm.Controls("SidebarRight")
        Set SidebarBottom = oForm.Controls("SidebarBottom")
        If Not SidebarRight.Visible Then Set SidebarRight = Nothing
        If Not SidebarBottom.Visible Then Set SidebarBottom = Nothing
    On Error GoTo 0
    
    If Not SidebarRight Is Nothing Then
        If SidebarRight.Visible Then
            With SidebarRight
                .Caption = ""
                .SpecialEffect = fmSpecialEffectFlat
                .BorderStyle = fmBorderStyleNone
                .BackColor = MyColors.FormSidebarMediumGray 'vbred
                .Top = MP.Top
                .Left = MP.Left + MP.Width
                If SidebarBottom Is Nothing Then
                    .Height = MP.Height
                Else
                    If SidebarBottom.Visible = True Then
                        .Height = MP.Height + SidebarBottom.Height
                    Else
                        .Height = MP.Height
                    End If
                End If
            End With
        End If
    End If
    
    If Not SidebarBottom Is Nothing Then
        If SidebarBottom.Visible Then
            SidebarLeft.Height = SidebarLeft.Height + SidebarBottom.Height
            With SidebarBottom
                .Caption = ""
                .SpecialEffect = fmSpecialEffectFlat
                .BorderStyle = fmBorderStyleNone
                .BackColor = MyColors.FormSidebarMediumGray 'vbred
                .Top = MP.Top & MP.Height
                .Left = SidebarLeft.Left + SidebarLeft.Width - 1
    '            If SidebarRight Is Nothing Then
                    .Width = MP.Width + 2
    '            Else
    '                .Width = MP.Width + SidebarRight.Width
    '            End If
                
            End With
        End If
    End If
    
    aUserform.Init(oForm).ResizeToFitControls

    sbLeftWidth = SidebarLeft.Width
    If Not SidebarRight Is Nothing Then sbRightWidth = SidebarRight.Width
    If Not SidebarBottom Is Nothing Then sbBottomHeight = SidebarBottom.Height

    If createSidebarMinimizers Then
        Dim item
        For Each item In Array("Left", "Right")
            If Not (item = "Right" And SidebarRight Is Nothing) Then
                Set lbl = oForm.Controls("Sidebar" & item).Controls.Add("forms.label.1", "ResizeSidebar" & item)
                With lbl
                    .Font.Name = "Consolas"
                    .AutoSize = False
                    .Width = oForm.Controls("Sidebar" & item).Width
                    .Height = 16
                    .Left = 0
                    .Top = oForm.Controls("Sidebar" & item).Top + oForm.Controls("Sidebar" & item).Height - lbl.Height '- 6
                    .ForeColor = vbWhite
                    .Font.Bold = True
                    .Font.Size = 14
                    .Caption = "<"
                End With
            End If
        Next
    End If
    
    For Each Ctrl In oForm.Controls
        If TypeName(Ctrl) = "Label" Then
            Ctrl.MouseIcon = LoadPicture(ThisWorkbook.Path & "\img\Hand Cursor Pointer.ico")
            Ctrl.MousePointer = fmMousePointerCustom
        End If
    Next
    
    Set Emitter = New EventListenerEmitter
    Emitter.AddEventListenerAll oForm
      
End Sub


Private Sub Emitter_LabelMouseOut(Label As MSForms.Label)
'@AssignedModule aMultiPage
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS aMultiPage
    If InStr(1, Label.Tag, "page-") > 0 Or InStr(1, Label.Name, "ResizeSidebar") > 0 Then
        If Label.BackColor <> &H80B91E Then Label.BackColor = &H534848
    End If
End Sub

Private Sub Emitter_LabelMouseOver(Label As MSForms.Label)
'@AssignedModule aMultiPage
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS aMultiPage
    If InStr(1, Label.Tag, "page-") > 0 Or InStr(1, Label.Name, "ResizeSidebar") > 0 Then
        If Label.BackColor <> &H80B91E Then Label.BackColor = &H808080
    End If
End Sub

Private Sub Emitter_LabelClick(ByRef Label As MSForms.Label)
'@AssignedModule aMultiPage
'@INCLUDE PROCEDURE FollowLink
'@INCLUDE PROCEDURE CLIP
'@INCLUDE PROCEDURE OutlookCheck
'@INCLUDE PROCEDURE GetInternetConnectedState
'@INCLUDE CLASS EventListenerEmitter
'@INCLUDE CLASS aUserform
'@INCLUDE CLASS aMultiPage
'@INCLUDE DECLARATION AUTHOR_EMAIL
'@INCLUDE DECLARATION Ctrl
    If InStr(1, Label.Tag, "page-") > 0 Then
        Dim Ctrl As control
        For Each Ctrl In oForm.Controls
            If InStr(1, Ctrl.Tag, "page-") > 0 Then Ctrl.BackColor = &H534848
        Next
        Label.BackColor = &H80B91E
        If InStr(1, Label.Tag, "page-") > 0 Then
            oMultipage.Value = Split(Label.Tag, "-")(1)
        End If
    End If
    
    If InStr(1, Label.Caption, ">") > 0 Or InStr(1, Label.Caption, "<") > 0 Then
        Dim SidebarLeft As MSForms.control
        Dim SidebarRight As MSForms.control
        Dim SidebarBottom As MSForms.control
        Dim MP As MSForms.control
        On Error Resume Next
        Set SidebarLeft = oForm.Controls("SidebarLeft")
        Set SidebarRight = oForm.Controls("SidebarRight")
        Set SidebarBottom = oForm.Controls("SidebarBottom")
        Set MP = oForm.Controls("MultiPage1")
        On Error GoTo 0
        
        If InStr(1, Label.Name, "Sidebar") > 0 Then
            If InStr(1, Label.Name, "Right") > 0 Then
                If SidebarRight.Width <> sbRightWidth Then
                    SidebarRight.Width = sbRightWidth
                    oForm.Controls("ResizeSidebarRight").Caption = "<"
                Else
                    SidebarRight.Width = 12
                    oForm.Controls("ResizeSidebarRight").Caption = ">"
                End If
                
            ElseIf InStr(1, Label.Name, "Bottom") > 0 Then
    '            oForm.Controls("SidebarBottom").Height = sbBottomHeight
            ElseIf InStr(1, Label.Name, "Left") > 0 Then
                If SidebarLeft.Width <> sbLeftWidth Then
                    SidebarLeft.Width = sbLeftWidth
                    oForm.Controls("ResizeSidebarLeft").Caption = "<"
                Else
                    SidebarLeft.Width = 12
                    oForm.Controls("ResizeSidebarLeft").Caption = ">"
                End If
                MP.Left = SidebarLeft.Left + SidebarLeft.Width
                If Not SidebarRight Is Nothing Then SidebarRight.Left = MP.Left + MP.Width
                If Not SidebarBottom Is Nothing Then SidebarBottom.Left = SidebarLeft.Left + SidebarLeft.Width
            End If
            
    '       aUserform.Init(oForm).ResizeToFitControls
            If SidebarRight Is Nothing Then
                oForm.Width = MP.Left + MP.Width
            Else
                If SidebarRight.Visible Then
                    oForm.Width = SidebarRight.Left + SidebarRight.Width + 12
                Else
                    oForm.Width = MP.Left + MP.Width
                End If
            End If
        End If
    End If
    
    If InStr(1, Label.Tag, "followlink-") > 0 Then
        Select Case Split(Label.Tag, "-")(1)
            Case "youtube": FollowLink "https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg"
            Case "github": FollowLink "https://github.com/alexofrhodes/"
            Case "blog": FollowLink "https://alexofrhodes.github.io/"
            Case "buymeacoffee": FollowLink "http://paypal.me/alexofrhodes"
            Case "email"
                If GetInternetConnectedState = False Then
                    MsgBox "Seems Internet is not available"
                    Exit Sub
                End If
                If OutlookCheck = True Then
                    MailDev
                Else
                    Dim out As String
                    out = AUTHOR_EMAIL
                    CLIP out
                    MsgBox ("Seems Outlook is not available" & Chr(10) & _
                    "DEV's email address " & vbNewLine & out & vbNewLine & "copied to clipboard")
                End If
        End Select
    End If
End Sub


Public Sub AddThemeControlsSidbarRight()
'@AssignedModule aMultiPage
'@INCLUDE CLASS aMultiPage
'@INCLUDE CLASS aFrame
    aFrame.Init(oForm.Controls("SidebarRight")).AddThemeControls
End Sub

Public Sub AddContactsToSidebarBottom()
'@AssignedModule aMultiPage
'@INCLUDE PROCEDURE FileExists
'@INCLUDE PROCEDURE AvailableFormOrFrameColumn
'@INCLUDE CLASS aMultiPage
    Dim SidebarBottom As MSForms.Frame
    On Error Resume Next
    Set SidebarBottom = oForm.Controls("SidebarBottom")
    On Error GoTo 0
    If SidebarBottom Is Nothing Then Exit Sub
    Dim lbl As MSForms.Label
    Dim newPicture As IPictureDisp
    Dim filepath As String
    Dim myLinks(1 To 5)
    myLinks(1) = "github"
    myLinks(2) = "blog"
    myLinks(3) = "youtube"
    myLinks(4) = "buymeacoffee"
    myLinks(5) = "email"
    
    Dim item
    For Each item In myLinks
        filepath = ThisWorkbook.Path & "\img\" & item & ".bmp"
        If FileExists(filepath) Then
            Set newPicture = LoadPicture(filepath)
            Set lbl = SidebarBottom.Controls.Add("Forms.Label.1")
            lbl.Visible = False
            With lbl
                .Top = 6
                .Width = 24
                .Height = 24
                .Left = AvailableFormOrFrameColumn(SidebarBottom, 0, , 12)
                Set .Picture = Nothing
                .Picture = newPicture
                .Tag = "followlink-" & item
                .ControlTipText = item
            End With
            lbl.Visible = True
        End If
    Next
End Sub


Public Function ActivePage() As MSForms.page
'@AssignedModule aMultiPage
'@INCLUDE CLASS aMultiPage
    Set ActivePage = oMultipage.Pages(oMultipage.Value)
End Function

Public Sub SetBackColor(PageIndex, BackColor As Long)
'eg
'    Call SetBackColor(Page:=MultiPage1.Pages(0), BackColor:=vbRed)
'    Call SetBackColor(Page:=MultiPage1.Pages(1), BackColor:=RGB(20, 200, 100))
'@AssignedModule aMultiPage
'@INCLUDE CLASS aMultiPage
'@INCLUDE DECLARATION GUID
'@INCLUDE DECLARATION GetDC
'@INCLUDE DECLARATION ReleaseDC

'by Jaafar
'https://www.mrexcel.com/board/threads/can-a-userform-multipage-backcolor-be-changed.79069/page-4

    Dim page As MSForms.page
    Set page = oMultipage.Pages(PageIndex)
    #If VBA7 Then
        Dim hLib As LongPtr
    #Else
        Dim hLib As Long
    #End If

    Dim R As RECT
    Dim IID_IDispatch As GUID
    Dim uPicinfo As uPicDesc
    Dim iPic As IPicture
    Dim lRet As Long
    Static i As Integer
    
    page.PictureSizeMode = fmPictureSizeModeStretch
    
    hDC = GetDC(0)
    SetRect R, 0, 0, 1, 1

    With R
        hMemBmp = CreateCompatibleBitmap(hDC, .Right - .Left, .Bottom - .Top)
    End With

    hMemDc = CreateCompatibleDC(hDC)
    DeleteObject SelectObject(hMemDc, hMemBmp)
    hBrush = CreateSolidBrush(BackColor)
    FillRect hMemDc, R, hBrush
    hCopy = CopyImage(hMemBmp, IMAGE_BITMAP, 0, 0, LR_COPYRETURNORG)

    With IID_IDispatch
        .Data1 = &H20400
        .Data4(0) = &HC0
        .Data4(7) = &H46
    End With
  
    With uPicinfo
        .Size = Len(uPicinfo)
        .Type = PICTYPE_BITMAP
        .hPic = hCopy
        .hPal = 0
    End With
    
    hLib = LoadLibrary("oleAut32.dll")
        If hLib Then
            lRet = OleCreatePictureIndirectAut(uPicinfo, IID_IDispatch, True, iPic)
        Else
            hLib = LoadLibrary("olepro32.dll")
            lRet = OleCreatePictureIndirectPro(uPicinfo, IID_IDispatch, True, iPic)
        End If
    FreeLibrary hLib
    
    If lRet = S_OK Then
        Set page.Picture = iPic
    Else
        MsgBox "Unable to create Picture", vbCritical, "Error."
    End If

    DeleteObject hMemBmp
    DeleteObject hMemDc
    DeleteObject hBrush
    ReleaseDC 0, hDC

    ReDim Preserve ar(i)
    ar(i) = hCopy
    i = i + 1

End Sub

Private Sub DeleteResources()
'private sub userform_Terminate()
    'Call DeleteResources
'end sub
'@AssignedModule aMultiPage
'@INCLUDE CLASS aMultiPage
    Dim element As Variant
    
    For Each element In ar
        DeleteObject element
    Next

End Sub


Function OutlookCheck() As Boolean
'@AssignedModule aMultiPage
'@INCLUDE CLASS aMultiPage
    Dim xOLApp As Object
    Set xOLApp = CreateObject("Outlook.Application")
    If Not xOLApp Is Nothing Then
        OutlookCheck = True
        Set xOLApp = Nothing
        Exit Function
    End If
    OutlookCheck = False
End Function


Sub MailDev()
'@AssignedModule aMultiPage
'@INCLUDE CLASS aMultiPage
'@INCLUDE DECLARATION AUTHOR_EMAIL
    Dim OutApp As Object
    Dim OutMail As Object
    Dim strBody As String
    Set OutApp = CreateObject("Outlook.Application")
    Set OutMail = OutApp.CreateItem(0)
    On Error Resume Next
    With OutMail
        .to = AUTHOR_EMAIL
        .cc = vbNullString
        .BCC = vbNullString
        .Subject = "Feedback or request - " & ThisWorkbook.Name
        .body = strBody
        .display
    End With
    On Error GoTo 0
    Set OutMail = Nothing
    Set OutApp = Nothing
End Sub


'uModules	UserForm


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* UserForm   : uModules
'* Purpose    :
'* Copyright  :
'*
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 17-08-2023 13:31    Alex                merged forms for modules Add / Rename / Remove
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Private Sub listOpenBooks_Click()
'@AssignedModule uModulesRemove
'@INCLUDE USERFORM uModulesRemove
    addCompsList Workbooks(listOpenBooks.List(listOpenBooks.ListIndex))
End Sub

Private Sub UserForm_Initialize()
    SidebarRight.Visible = True
    SidebarBottom.Visible = False
    
    '// the class is predeclaredId = true but shouldn't this way still work?
'    Dim am1 As aMultiPage
'    Set am1 = New aMultiPage
'    am1.Init(MultiPage1).BuildMenu createSidebarMinimizers:=True

    aMultiPage.Init(MultiPage1).BuildMenu createSidebarMinimizers:=True
    
    aListBox.Init(listOpenBooks).LoadVBProjects
End Sub

Private Sub SelectFromList_Click()
'@AssignedModule uModulesAdd
'@INCLUDE USERFORM uModulesAdd
    If listOpenBooks.ListIndex = -1 Then
        MsgBox "No book selected"
        Exit Sub
    End If
    Dim TargetWorkbook As Workbook
    Set TargetWorkbook = Workbooks(listOpenBooks.List(listOpenBooks.ListIndex))
    ModulesAdd TargetWorkbook
End Sub



Private Sub AddComponent(TargetWorkbook As Workbook, Module_Class_Form_Sheet As Long, componentArray As Variant)
    '@INCLUDE ModuleExists
'@AssignedModule uModulesAdd
'@INCLUDE PROCEDURE ModuleExists
'@INCLUDE PROCEDURE CreateOrSetSheet
'@INCLUDE USERFORM uModulesAdd
    Dim CompType As Long
    CompType = Module_Class_Form_Sheet
    Dim vbProj As VBProject
    Set vbProj = TargetWorkbook.VBProject
    Dim vbComp As VBComponent
    Dim NewSheet As Worksheet
    Dim i As Long
    Dim counter As Long
    On Error GoTo ErrorHandler
    For i = LBound(componentArray) To UBound(componentArray)
        If componentArray(i) <> vbNullString Then
            Select Case CompType
            Case Is = 1, 2, 3
                If ModuleExists(CStr(componentArray(i)), TargetWorkbook) = False Then
                    If CompType = 1 Then Set vbComp = vbProj.VBComponents.Add(vbext_ct_StdModule)
                    If CompType = 2 Then Set vbComp = vbProj.VBComponents.Add(vbext_ct_ClassModule)
                    If CompType = 3 Then Set vbComp = vbProj.VBComponents.Add(vbext_ct_MSForm)
                End If
                vbComp.Name = componentArray(i)
            Case Is = 4
                If CompType = 4 Then
                    Set NewSheet = CreateOrSetSheet(CStr(componentArray(i)), TargetWorkbook)
                    NewSheet.Name = componentArray(i)
                End If
            End Select
        End If
loop1:
    Next i
    On Error GoTo 0
    Exit Sub
ErrorHandler:
    counter = counter + 1
    componentArray(i) = componentArray(i) & counter
    GoTo loop1
End Sub


Private Sub ModulesAdd(TargetWorkbook As Workbook)
'@AssignedModule uModulesAdd
'@INCLUDE USERFORM uModulesAdd
    Dim coll As Collection
    Set coll = New Collection
    Dim element As Variant
    coll.Add Split(Me.tModule.text, vbNewLine)
    coll.Add Split(Me.tClass.text, vbNewLine)
    coll.Add Split(Me.tUserform.text, vbNewLine)
    coll.Add Split(Me.tDocument.text, vbNewLine)
    Dim typeCounter As Long
    For Each element In coll
        If UBound(element) <> -1 Then
            typeCounter = typeCounter + 1
            AddComponent TargetWorkbook, typeCounter, element
        End If
    Next element
    MsgBox typeCounter & " components added to " & TargetWorkbook.Name
End Sub


Private Sub GetInfo_Click()
'@AssignedModule uModulesAdd
'@INCLUDE USERFORM uModulesAdd
'@INCLUDE USERFORM uAuthor
    uAuthor.Show
End Sub


Private Sub Remover_Click()
'@AssignedModule uModulesRemove
'@INCLUDE USERFORM uModulesRemove
    If listOpenBooks.ListIndex = -1 Then
        MsgBox "No book selected"
        Exit Sub
    End If
    Dim TargetWorkbook As Workbook
    Set TargetWorkbook = Workbooks(listOpenBooks.List(listOpenBooks.ListIndex))
    RemoveModules TargetWorkbook
End Sub

Private Sub RemoveModules(TargetWorkbook As Workbook)
'@AssignedModule uModulesRemove
'@INCLUDE CLASS aModule
'@INCLUDE USERFORM uModulesRemove
    If LComponents.ListCount = 0 Then Exit Sub
    Dim Module As VBComponent
    Dim i As Long
    For i = 0 To LComponents.ListCount - 1
        If LComponents.Selected(i) Then
            If oCode.Value = True Then
                Set Module = TargetWorkbook.VBProject.VBComponents(LComponents.List(i, 1))
                aModule.Init(Module).CodeRemove
            ElseIf oComps.Value = True Then
                Set Module = TargetWorkbook.VBProject.VBComponents(LComponents.List(i, 1))
                aModule.Init(Module).Delete
            End If
        End If
    Next i
    addCompsList TargetWorkbook
End Sub


Private Sub addCompsList(TargetWorkbook As Workbook)
'@AssignedModule uModulesRename
'@INCLUDE PROCEDURE GetSheetByCodeName
'@INCLUDE CLASS aModule
'@INCLUDE CLASS aListBox
'@INCLUDE USERFORM uModulesRename
    LComponents.Clear
    Dim vbComp As VBComponent
    For Each vbComp In TargetWorkbook.VBProject.VBComponents
        If vbComp.Name <> "ThisWorkbook" Then
            LComponents.AddItem
            LComponents.List(LComponents.ListCount - 1, 0) = aModule.Init(vbComp).TypeToString
            LComponents.List(LComponents.ListCount - 1, 1) = vbComp.Name
            If vbComp.Type = vbext_ct_Document Then
                LComponents.List(LComponents.ListCount - 1, 2) = GetSheetByCodeName(TargetWorkbook, vbComp.Name).Name
            End If
        End If
    Next
    Me.Caption = "Comps of " & TargetWorkbook.Name
    aListBox.Init(LComponents).SortOnColumn 1

    SyncNames TargetWorkbook
End Sub

Private Sub RenameComponents_Click()
'@AssignedModule uModulesRename
'@INCLUDE PROCEDURE GetSheetByCodeName
'@INCLUDE USERFORM uModulesRename
    If listOpenBooks.ListIndex = -1 Then
        MsgBox "No book selected"
        Exit Sub
    End If
    Dim TargetWorkbook As Workbook
    Set TargetWorkbook = Workbooks(listOpenBooks.List(listOpenBooks.ListIndex))
    Dim NewNames As Variant
    Dim i As Long
    NewNames = Split(textboxNewName, vbNewLine)
    For i = 0 To UBound(NewNames)
        If NewNames(i) = vbNullString Then
            NewNames(i) = LComponents.List(i)
        End If
    Next i
    For i = 0 To UBound(NewNames)
Retry:
        On Error GoTo EH
'        Select Case LComponents.list(i, 0)
'        Case Is = "Module", "Class", "UserForm"
            If LComponents.List(i, 1) <> NewNames(i) Then
                TargetWorkbook.VBProject.VBComponents(LComponents.List(i, 1)).Name = NewNames(i)
            End If
'        Case Is = "Document"
'            If LComponents.list(i, 1) <> NewNames(i) Then
'                GetSheetByCodeName(TargetWorkbook, LComponents.list(i, 1)).name = NewNames(i)
'            End If
'        End Select
    Next
    For i = 0 To LComponents.ListCount - 1
        LComponents.List(i, 1) = NewNames(i)
    Next i
    textboxNewName.text = vbNullString
    Dim str As String
    str = Join(NewNames, vbNewLine)
    textboxNewName.text = str
    MsgBox "Components renamed"
    Exit Sub
EH:
    NewNames(i) = NewNames(i) & "_R"
    Resume Retry:
End Sub



Private Sub SyncNames(TargetWorkbook As Workbook)
'@AssignedModule uModulesRename
'@INCLUDE USERFORM uModulesRename
    Dim str As String
    Dim i As Long
    For i = 0 To LComponents.ListCount - 1
        str = str & IIf(i > 0, vbNewLine, "") & LComponents.List(i, 1)
    Next
    textboxNewName.text = str
    textboxNewName.ScrollBars = fmScrollBarsVertical
    textboxNewName.SetFocus
    textboxNewName.SelStart = 0
End Sub
