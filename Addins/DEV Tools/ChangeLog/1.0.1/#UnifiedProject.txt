'ThisWorkbook	Document

Option Explicit


Private Sub Workbook_BeforeClose(Cancel As Boolean)
'@INCLUDE PROCEDURE KillVbaGui
    KillVbaGui
End Sub

Private Sub Workbook_Open()
    '@INCLUDE PROCEDURE RunVbaGui
    '@INCLUDE PROCEDURE CreateAllBars
    '@AssignedModule ThisWorkbook

    RunVbaGui
    
End Sub


'helper	Document

Option Explicit


'Dependencies	Module



'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Module     : Dependencies
'* Purpose    : list dependencies, export/import procedures/components
'* Copyright  :
'*
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : some time ago       Alex
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


#If VBA7 Then
Public Declare PtrSafe Function CloseClipboard Lib "user32" () As Long
Public Declare PtrSafe Function EmptyClipboard Lib "user32" () As Long
Public Declare PtrSafe Function OpenClipboard Lib "user32" (ByVal hwnd As Long) As Long
#Else
Public Declare Function CloseClipboard Lib "user32" () As Long
Public Declare Function EmptyClipboard Lib "user32" () As Long
Public Declare Function OpenClipboard Lib "user32" (ByVal hwnd As Long) As Long
#End If

Rem ___CHANGE THESE TO MATCH YOUR FOLDER AND REPO____
'------------------------------------------------------------------------------
Public Const GITHUB_LIBRARY = "https://raw.githubusercontent.com/alexofrhodes/VBA-Library/"
'------------------------------------------------------------------------------
Public Const GITHUB_LIBRARY_DECLARATIONS = GITHUB_LIBRARY & "Declarations/"
Public Const GITHUB_LIBRARY_PROCEDURES = GITHUB_LIBRARY & "Procedures/"
Public Const GITHUB_LIBRARY_USERFORMS = GITHUB_LIBRARY & "Userforms/"
Public Const GITHUB_LIBRARY_CLASSES = GITHUB_LIBRARY & "Classes/"
'------------------------------------------------------------------------------
Public Const GITHUB_BLOG = "https://alexofrhodes.github.io/"
Public Const GITHUB_URL = "https://github.com/alexofrhodes/"
'------------------------------------------------------------------------------
Public Const AUTHOR_YOUTUBE = "https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg"
Public Const AUTHOR_VK = "https://vk.com/video/playlist/735281600_1"
Public Const AUTHOR_NAME = "Anastasiou Alex"
Public Const AUTHOR_EMAIL = "AnastasiouAlex@gmail.com"
Public Const AUTHOR_COPYRIGHT = ""
Public Const AUTHOR_OTHERTEXT = ""

Public Const GUID = "NBGD41100771701DDE7600"

Public ShowInVBE    As Boolean

'------------------------------------------------------------------------------
Public Function LOCAL_LIBRARY(): LOCAL_LIBRARY = LIBRARY_FOLDER: End Function
'------------------------------------------------------------------------------
Public Function LOCAL_LIBRARY_DECLARATIONS(): LOCAL_LIBRARY_DECLARATIONS = LOCAL_LIBRARY & "Declarations\": End Function
Public Function LOCAL_LIBRARY_PROCEDURES(): LOCAL_LIBRARY_PROCEDURES = LOCAL_LIBRARY & "Procedures\": End Function
Public Function LOCAL_LIBRARY_USERFORMS(): LOCAL_LIBRARY_USERFORMS = LOCAL_LIBRARY & "Userforms\": End Function
Public Function LOCAL_LIBRARY_CLASSES(): LOCAL_LIBRARY_CLASSES = LOCAL_LIBRARY & "Classes\": End Function

Function LIBRARY_FOLDER() As String
    If GetMotherBoardProp = GUID Then
        LIBRARY_FOLDER = "C:\Users\acer\Documents\GitHub\VBA-Library\"
    Else
        LIBRARY_FOLDER = Environ$("USERPROFILE") & "\Documents\vbArc\Library\"
    End If
End Function

Public Function AUTHOR_MEDIA() As String
    AUTHOR_MEDIA = "'* BLOG       : " & GITHUB_BLOG & vbNewLine & _
                   "'* GITHUB     : " & GITHUB_URL & vbNewLine & _
                   "'* YOUTUBE    : " & AUTHOR_YOUTUBE & vbNewLine & _
                   "'* VK         : " & AUTHOR_VK & vbNewLine & "'*" & vbNewLine
End Function

Function DevInfo() As String
    DevInfo = Join( _
                Array( _
                    "AUTHOR     " & AUTHOR_NAME, _
                    "EMAIL      " & AUTHOR_EMAIL, _
                    "BLOG       " & GITHUB_BLOG, _
                    "GITHUB     " & GITHUB_URL, _
                    "YOUTUBE    " & AUTHOR_YOUTUBE, _
                    "VK         " & AUTHOR_VK), _
                vbNewLine)
End Function


'* Modified   : Date and Time       Author              Description
'* Updated    : 22-08-2023 08:29    Alex                (z_zTest.bas > ListOfIncludes)

Function ListOfIncludes(TargetWorkbook As Workbook)
'@LastModified 2308220829
'@INCLUDE CLASS aWorkbook
'@INCLUDE PROCEDURE ArrayQuickSort
'@INCLUDE PROCEDURE ArrayDuplicatesRemove
'@INCLUDE PROCEDURE ArrayReplace
'@INCLUDE PROCEDURE ArrayTrim
    Dim arr
    arr = ArrayTrim( _
            Split( _
                aWorkbook.Init(ThisWorkbook).Code, _
                vbNewLine))
    Dim i As Long
    For i = LBound(arr) To UBound(arr)
        arr(i) = WorksheetFunction.Proper(arr(i))
    Next
    arr = ArrayDuplicatesRemove( _
            Filter( _
                Filter( _
                    arr, _
                    "'@INCLUDE PROCEDURE ", _
                    True, _
                    vbTextCompare), _
                """", _
                False))
    ArrayReplace arr, "'@INCLUDE PROCEDURE ", ""
    ArrayQuickSort arr
    
    ListOfIncludes = arr
End Function

'* Modified   : Date and Time       Author              Description
'* Updated    : 22-08-2023 08:28    Alex                (Dependencies.bas > ProceduresNotExported)

Function ProceduresNotExported(TargetWorkbook As Workbook)
'@LastModified 2308220828
'@INCLUDE PROCEDURE FileExists
'@INCLUDE PROCEDURE ListOfIncludes
    Dim out
    Dim TargetFile
    Dim Procedure
    For Each Procedure In ListOfIncludes(TargetWorkbook)
        TargetFile = LOCAL_LIBRARY_PROCEDURES & Procedure & ".txt"
        If Not FileExists(TargetFile) Then
            out = out & IIf(out <> "", vbNewLine, "") & Procedure
        End If
    Next
    out = Split(out, vbNewLine)
    ProceduresNotExported = out
End Function

'* Modified   : Date and Time       Author              Description
'* Updated    : 22-08-2023 08:28    Alex                (Dependencies.bas > IncludeNotImported)

Function IncludeNotImported(TargetWorkbook As Workbook)
'@LastModified 2308220828
'@INCLUDE PROCEDURE FileExists
'@INCLUDE PROCEDURE ListOfIncludes
    Dim out
    Dim TargetFile
    Dim Procedure
    For Each Procedure In ListOfIncludes(TargetWorkbook)
        If Not ProcedureExists(TargetWorkbook, Procedure) Then
            out = out & IIf(out <> "", vbNewLine, "") & Procedure
        End If
    Next
    out = Split(out, vbNewLine)
    IncludeNotImported = out
End Function

'--------------------------------------------
Sub AddLinkedListsToActiveProcedure()
    AddLinkedLists ThisWorkbook, ActiveModule, ActiveProcedure
End Sub

Sub ExportActiveProcedure()
    ExportProcedure ThisWorkbook, ActiveModule, ActiveProcedure, ExportMergedTxt:=True
End Sub

Sub ExportAllProceduresOfThisWorkbook()
    ExportAllProcedures ThisWorkbook
End Sub

Sub ImportActiveProcedureDependencies()
    ImportProcedureDependencies ActiveProcedure, ThisWorkbook, ActiveModule, Overwrite:=True
End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 30-10-2023 12:23    Alex                (Dependencies.bas > AddLinkedListsToAllProcedures : )

Sub AddLinkedListsToAllProcedures(TargetWorkbook As Workbook)
'@LastModified 2310301223
    Dim Procedure
    Dim module      As VBComponent
    For Each module In TargetWorkbook.VBProject.VBComponents
        If module.Type = vbext_ct_StdModule And module.Name <> "Dependencies" Then
            For Each Procedure In ProceduresOfModule(module)
                AddLinkedLists TargetWorkbook, module, CStr(Procedure)
            Next Procedure
        End If
    Next module
    Toast "Done"
End Sub

Sub AddLinkedListsToActiveWorkbook()
    AddLinkedListsToAllProcedures ActiveCodepaneWorkbook
End Sub

Sub AddLinkedListsToProceduresOfModule(module As VBComponent)
    Dim Procedure
    On Error GoTo EH
    For Each Procedure In ProceduresOfModule(module)
        Debug.Print Procedure
        AddLinkedLists , module, CStr(Procedure)
    Next Procedure
    Debug.Print vbNewLine & "---" & "Done"
    Exit Sub
EH:
    Debug.Print "Error at: " & module.Name & vbTab & Procedure
    Resume Next
End Sub

Sub ExportAllProcedures(TargetWorkbook As Workbook)
    Dim Procedure
    Dim module      As VBComponent
    For Each module In TargetWorkbook.VBProject.VBComponents
        If module.Type = vbext_ct_StdModule Then
            For Each Procedure In ProceduresOfModule(module)
                ExportProcedure TargetWorkbook, module, CStr(Procedure), False
            Next Procedure
        End If
    Next module
End Sub

Sub RemoveComments(TargetWorkbook As Workbook)
    Dim module      As VBComponent
    Dim S           As String
    Dim i           As Long
    For Each module In TargetWorkbook.VBProject.VBComponents
        For i = module.CodeModule.CountOfLines To 1 Step -1
            S = Trim(module.CodeModule.Lines(i, 1))
            If S Like "'*" Then module.CodeModule.DeleteLines i, 1
        Next i
    Next
End Sub

Function ArrayAppend(ByVal arr1 As Variant, ByVal arr2 As Variant) As Variant
    Dim holdarr     As Variant
    Dim ub1         As Long
    Dim ub2         As Long
    Dim i           As Long
    Dim newind      As Long
    If IsEmpty(arr1) Or Not IsArray(arr1) Then
        arr1 = Array()
    End If
    If IsEmpty(arr2) Or Not IsArray(arr2) Then
        arr2 = Array()
    End If
    ub1 = UBound(arr1)
    ub2 = UBound(arr2)
    If ub1 = -1 Then
        ArrayAppend = arr2
        Exit Function
    End If
    If ub2 = -1 Then
        ArrayAppend = arr1
        Exit Function
    End If
    holdarr = arr1
    ReDim Preserve holdarr(ub1 + ub2 + 1)
    newind = UBound(arr1) + 1
    For i = 0 To ub2
        If VarType(arr2(i)) = vbObject Then
            Set holdarr(newind) = arr2(i)
        Else
            holdarr(newind) = arr2(i)
        End If
        newind = newind + 1
    Next i
    ArrayAppend = holdarr
End Function

Public Sub ArrayQuickSort(ByRef SortableArray As Variant, Optional lngMin As Long = -1, Optional lngMax As Long = -1)
    On Error Resume Next
    Dim i           As Long
    Dim j           As Long
    Dim varMid      As Variant
    Dim varX        As Variant
    If IsEmpty(SortableArray) Then
        Exit Sub
    End If
    If InStr(TypeName(SortableArray), "()") < 1 Then
        Exit Sub
    End If
    If lngMin = -1 Then
        lngMin = LBound(SortableArray)
    End If
    If lngMax = -1 Then
        lngMax = UBound(SortableArray)
    End If
    If lngMin >= lngMax Then
        Exit Sub
    End If
    i = lngMin
    j = lngMax
    varMid = Empty
    varMid = SortableArray((lngMin + lngMax) \ 2)
    If IsObject(varMid) Then
        i = lngMax
        j = lngMin
    ElseIf IsEmpty(varMid) Then
        i = lngMax
        j = lngMin
    ElseIf IsNull(varMid) Then
        i = lngMax
        j = lngMin
    ElseIf varMid = "" Then
        i = lngMax
        j = lngMin
    ElseIf VarType(varMid) = vbError Then
        i = lngMax
        j = lngMin
    ElseIf VarType(varMid) > 17 Then
        i = lngMax
        j = lngMin
    End If
    While i <= j
        While SortableArray(i) < varMid And i < lngMax
            i = i + 1
        Wend
        While varMid < SortableArray(j) And j > lngMin
            j = j - 1
        Wend
        If i <= j Then
            varX = SortableArray(i)
            SortableArray(i) = SortableArray(j)
            SortableArray(j) = varX
            i = i + 1
            j = j - 1
        End If
    Wend
    If (lngMin < j) Then Call ArrayQuickSort(SortableArray, lngMin, j)
    If (i < lngMax) Then Call ArrayQuickSort(SortableArray, i, lngMax)
End Sub

Public Function cleanArray(varArray As Variant) As Variant()
    Dim TempArray() As Variant
    Dim OldIndex    As Integer
    Dim NewIndex    As Integer
    Dim Output      As String
    If Not ArrayAllocated(varArray) Then Exit Function
    ReDim TempArray(LBound(varArray) To UBound(varArray))
    For OldIndex = LBound(varArray) To UBound(varArray)
        Output = CleanTrim(varArray(OldIndex))
        If Not Output = "" Then
            TempArray(NewIndex) = Output
            NewIndex = NewIndex + 1
        End If
    Next OldIndex
    ReDim Preserve TempArray(LBound(varArray) To NewIndex - 1)
    cleanArray = TempArray
End Function

Function ArrayDuplicatesRemove(myArray As Variant) As Variant
    Dim nFirst As Long, nLast As Long, i As Long
    Dim item        As String

    Dim arrTemp()   As String
    Dim coll        As New Collection
    If Not ArrayAllocated(myArray) Then Exit Function
    nFirst = LBound(myArray)
    nLast = UBound(myArray)
    ReDim arrTemp(nFirst To nLast)

    For i = nFirst To nLast
        arrTemp(i) = CStr(myArray(i))
    Next i

    On Error Resume Next
    For i = nFirst To nLast
        coll.Add arrTemp(i), arrTemp(i)
    Next i
    Err.clear
    On Error GoTo 0

    nLast = coll.Count + nFirst - 1
    ReDim arrTemp(nFirst To nLast)

    For i = nFirst To nLast
        arrTemp(i) = coll(i - nFirst + 1)
    Next i

    ArrayDuplicatesRemove = arrTemp

End Function

Public Function ArrayToCollection(items As Variant) As Collection
    If Not ArrayAllocated(items) Then Exit Function
    Dim coll        As New Collection
    Dim i           As Integer
    For i = LBound(items) To UBound(items)
        coll.Add items(i)
    Next
    Set ArrayToCollection = coll
End Function

Function CleanTrim(ByVal S As String, Optional ConvertNonBreakingSpace As Boolean = True) As String
    Dim X As Long, CodesToClean As Variant
    CodesToClean = Array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, _
            21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 127, 129, 141, 143, 144, 157)
    If ConvertNonBreakingSpace Then S = Replace(S, Chr(160), " ")
    S = Replace(S, vbCr, "")
    For X = LBound(CodesToClean) To UBound(CodesToClean)
        If InStr(S, Chr(CodesToClean(X))) Then
            S = Replace(S, Chr(CodesToClean(X)), vbNullString)
        End If
    Next
    CleanTrim = S
    CleanTrim = Trim(S)
End Function

Sub AddLinkedLists(Optional TargetWorkbook As Workbook, _
                    Optional module As VBComponent, _
                    Optional Procedure As String)
    If Not AssignCPSvariables(TargetWorkbook, module, Procedure) Then Exit Sub
    ProcedureLinesRemoveInclude TargetWorkbook, module, Procedure
    ProcedureAssignedModuleAdd TargetWorkbook, module, Procedure
    AddListOfLinkedProceduresToProcedure TargetWorkbook, module, Procedure
    AddListOfLinkedClassesToProcedure TargetWorkbook, module, Procedure
    AddListOfLinkedUserformsToProcedure TargetWorkbook, module, Procedure
    AddListOfLinkedDeclarationsToProcedure TargetWorkbook, module, Procedure
End Sub


Sub AddListOfLinkedClassesToProcedure( _
        Optional TargetWorkbook As Workbook, _
        Optional module As VBComponent, _
        Optional ProcedureName As String)

    If Not AssignCPSvariables(TargetWorkbook, module, ProcedureName) Then Stop
    Dim ListOfImports As String
    Dim Code        As String
    Code = ProcedureCode(TargetWorkbook, module, ProcedureName)
    Dim myClasses   As Collection
    Set myClasses = LinkedClasses(TargetWorkbook, module, ProcedureName)
    Dim element     As Variant
    For Each element In myClasses
        If InStr(1, Code, "@INCLUDE CLASS " & element) = 0 _
                And InStr(1, ListOfImports, "@INCLUDE CLASS " & element) = 0 Then
            If ListOfImports = "" Then
                ListOfImports = "'@INCLUDE CLASS " & element
            Else
                ListOfImports = ListOfImports & vbNewLine & "'@INCLUDE CLASS " & element
            End If
        End If
    Next
    If ListOfImports <> "" Then
        module.CodeModule.InsertLines _
                ProcedureBodyLineFirstAfterComments(module, ProcedureName), ListOfImports
    End If
End Sub

Sub AddListOfLinkedDeclarationsToProcedure( _
                                            Optional TargetWorkbook As Workbook, _
                                            Optional module As VBComponent, _
                                            Optional ProcedureName As String)

    If ProcedureName = "" Then ProcedureName = ActiveProcedure
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim ListOfImports As String
    If module Is Nothing Then Set module = ModuleOfProcedure(TargetWorkbook, ProcedureName)
    Dim ProcedureText As String
    ProcedureText = ProcedureCode(TargetWorkbook, module, ProcedureName)
    Dim myDeclarations As Collection
    Set myDeclarations = LinkedDeclarations(TargetWorkbook, module, ProcedureName)
    Dim coll        As New Collection
    Dim element     As Variant
    For Each element In myDeclarations
        If InStr(1, ProcedureText, "'@INCLUDE DECLARATION " & element) = 0 Then
            If ListOfImports = "" Then
                ListOfImports = "'@INCLUDE DECLARATION " & element
            Else
                ListOfImports = ListOfImports & vbNewLine & "'@INCLUDE DECLARATION " & element
            End If
        End If
    Next
    If ListOfImports <> "" Then
        module.CodeModule.InsertLines ProcedureBodyLineFirstAfterComments(module, ProcedureName), ListOfImports
    End If
End Sub

Sub AddListOfLinkedProceduresToProcedure( _
        Optional TargetWorkbook As Workbook, _
        Optional module As VBComponent, _
        Optional ProcedureName As String)

    If Not AssignCPSvariables(TargetWorkbook, module, ProcedureName) Then Stop
    Dim Procedures  As Collection
    Set Procedures = LinkedProcedures(TargetWorkbook, module, ProcedureName)
    Dim ListOfImports As String
    Dim Code        As String
    Code = ProcedureCode(TargetWorkbook, module, ProcedureName)
    Dim Procedure   As Variant
    For Each Procedure In Procedures
        If InStr(1, Code, "@INCLUDE PROCEDURE " & Procedure) = 0 And InStr(1, ListOfImports, "@INCLUDE PROCEDURE " & Procedure) = 0 Then
            If ListOfImports = "" Then
                ListOfImports = "'@INCLUDE PROCEDURE " & Procedure
            Else
                ListOfImports = ListOfImports & vbNewLine & "'@INCLUDE PROCEDURE " & Procedure
            End If
        End If
    Next
    If ListOfImports <> "" Then
        module.CodeModule.InsertLines ProcedureBodyLineFirstAfterComments(module, ProcedureName), ListOfImports
    End If
End Sub

Sub AddListOfLinkedUserformsToProcedure( _
        Optional TargetWorkbook As Workbook, _
        Optional module As VBComponent, _
        Optional ProcedureName As String)

    If Not AssignCPSvariables(TargetWorkbook, module, ProcedureName) Then Stop

    Dim ListOfImports As String
    Dim Code        As String
    Code = ProcedureCode(TargetWorkbook, module, ProcedureName)
    Dim myClasses   As Collection
    Set myClasses = LinkedUserforms(TargetWorkbook, module, ProcedureName)
    Dim element     As Variant
    For Each element In myClasses
        If InStr(1, Code, "@INCLUDE USERFORM " & element) = 0 And InStr(1, ListOfImports, "@INCLUDE USERFORM " & element) = 0 Then
            If ListOfImports = "" Then
                ListOfImports = "'@INCLUDE USERFORM " & element
            Else
                ListOfImports = ListOfImports & vbNewLine & "'@INCLUDE USERFORM " & element
            End If
        End If
    Next
    If ListOfImports <> "" Then
        module.CodeModule.InsertLines ProcedureBodyLineFirstAfterComments(module, ProcedureName), ListOfImports
    End If
End Sub

Public Function ActiveProcedure() As String
    Application.VBE.ActiveCodePane.GetSelection L1&, c1&, L2&, c2&
    ActiveProcedure = Application.VBE.ActiveCodePane.CodeModule.ProcOfLine(L1&, vbext_pk_Proc)
End Function

Public Function ActiveModule() As VBComponent
    '@LastModified 2308171258
    
    Dim Module1 As VBComponent
    'may erroneously return userform or worksheet

    Set Module1 = Application.VBE.SelectedVBComponent
    Dim Module2 As VBComponent
    If Not Application.VBE.ActiveCodePane Is Nothing Then Set Module2 = Application.VBE.ActiveCodePane.CodeModule.Parent

    If Module1.Name = Module2.Name Then
        Set ActiveModule = Module1
    Else
        Dim ans As Long
        ans = MsgBox("SelectedVBComponent <> ActiveCodePane.CodeModule.Parent" & vbLf & _
                      "Choose " & Module1.Name & " ?    Click no to choose " & Module2.Name, _
                      vbExclamation + vbYesNoCancel)
        Select Case ans
            Case vbYes: Set ActiveModule = Module1
            Case vbNo: Set ActiveModule = Module2
            Case vbCancel: Stop
        End Select
    End If
End Function


Public Function ActiveCodepaneWorkbook() As Workbook
    On Error GoTo ErrorHandler
    Dim WorkbookName As String
    WorkbookName = Application.VBE.SelectedVBComponent.Collection.Parent.fileName
    WorkbookName = Right(WorkbookName, Len(WorkbookName) - InStrRev(WorkbookName, "\"))
    Set ActiveCodepaneWorkbook = Workbooks(WorkbookName)
    Exit Function
ErrorHandler:
    MsgBox "doesn't work on new-unsaved workbooks"
End Function

Public Function ArrayAllocated(ByVal arr As Variant) As Boolean
    On Error Resume Next
    ArrayAllocated = IsArray(arr) And (Not IsError(LBound(arr, 1))) And LBound(arr, 1) <= UBound(arr, 1)
End Function

Public Function ArrayDimensionLength(SourceArray As Variant) As Integer
    Dim i           As Integer
    Dim test        As Long
    On Error GoTo catch
    Do
        i = i + 1
        test = UBound(SourceArray, i)
    Loop
catch:
    ArrayDimensionLength = i - 1
End Function

Public Sub ArrayToRange2D(arr2d As Variant, cell As Range)

    If ArrayDimensionLength(arr2d) = 1 Then arr2d = WorksheetFunction.Transpose(arr2d)
    Dim dif         As Long
    dif = IIf(LBound(arr2d, 1) = 0, 1, 0)
    Dim rng         As Range
    Set rng = cell.Resize(UBound(arr2d, 1) + dif, UBound(arr2d, 2) + dif)

    If Application.WorksheetFunction.CountA(rng) > 0 Then
        Exit Sub
    End If

    rng.Value = arr2d
End Sub

Function AssignCPSvariables( _
        ByRef TargetWorkbook As Workbook, _
        ByRef module As VBComponent, _
        ByRef Procedure As String) As Boolean

    If Not AssignWorkbookVariable(TargetWorkbook) Then Exit Function
    If Not AssignModuleVariable(TargetWorkbook, module, Procedure) Then Exit Function
    If Not AssignProcedureVariable(TargetWorkbook, Procedure) Then Exit Function
    AssignCPSvariables = True

End Function

Function AssignModuleVariable( _
        ByVal TargetWorkbook As Workbook, _
        ByRef module As VBComponent, _
        Optional ByVal Procedure As String) As Boolean
    If module Is Nothing Then
        If Procedure = "" Then
            Set module = ActiveModule
        End If
        On Error Resume Next
        Set module = ModuleOfProcedure(TargetWorkbook, Procedure)
        On Error GoTo 0
    End If
    AssignModuleVariable = Not module Is Nothing
End Function

Function AssignProcedureVariable(TargetWorkbook As Workbook, ByRef Procedure As String) As Boolean
    If Procedure = "" Then
        Dim cps     As String
        cps = CodepaneSelection
        If Len(cps) > 0 Then
            Procedure = cps
        Else
            Procedure = ActiveProcedure
        End If
        If Not ProcedureExists(TargetWorkbook, Procedure) Then
            Debug.Print Procedure & " not found in Workbook " & TargetWorkbook.Name
        End If
    End If
    AssignProcedureVariable = Not Procedure = ""
End Function

Function AssignWorkbookVariable(ByRef TargetWorkbook As Workbook) As Boolean
    If TargetWorkbook Is Nothing Then
        On Error Resume Next
        Set TargetWorkbook = ActiveCodepaneWorkbook
        On Error GoTo 0
    End If
    AssignWorkbookVariable = Not TargetWorkbook Is Nothing
End Function

Function CheckPath(path) As String
    Dim RetVal
    RetVal = "I"
    If (RetVal = "I") And FileExists(path) Then RetVal = "F"
    If (RetVal = "I") And FolderExists(path) Then RetVal = "D"
    If (RetVal = "I") And URLExists(path) Then RetVal = "U"
    CheckPath = RetVal
End Function

Function ClassNames(Optional TargetWorkbook As Workbook)
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Set ClassNames = ComponentNames(vbext_ct_ClassModule, TargetWorkbook)
End Function

Public Function CodepaneSelection() As String
    Dim startLine As Long, StartColumn As Long, endLine As Long, EndColumn As Long
    Application.VBE.ActiveCodePane.GetSelection startLine, StartColumn, endLine, EndColumn
    If endLine - startLine = 0 Then
        CodepaneSelection = Mid(Application.VBE.ActiveCodePane.CodeModule.Lines(startLine, 1), StartColumn, EndColumn - StartColumn)
        Exit Function
    End If
    Dim str         As String
    Dim i           As Long
    For i = startLine To endLine
        If str = "" Then
            str = Mid(Application.VBE.ActiveCodePane.CodeModule.Lines(i, 1), StartColumn)
        ElseIf i < endLine Then
            str = str & vbNewLine & Application.VBE.ActiveCodePane.CodeModule.Lines(i, 1)
        Else
            str = str & vbNewLine & Left(Application.VBE.ActiveCodePane.CodeModule.Lines(i, 1), EndColumn - 1)
        End If
    Next
    CodepaneSelection = str
End Function

Public Function CollectionContains( _
        Kollection As Collection, _
        Optional Key As Variant, _
        Optional item As Variant) As Boolean
    Dim strKey      As String
    Dim var         As Variant
    If Not IsMissing(Key) Then
        strKey = CStr(Key)
        On Error Resume Next
        CollectionContains = True
        var = Kollection(strKey)
        If Err.Number = 91 Then GoTo CheckForObject
        If Err.Number = 5 Then GoTo NotFound
        On Error GoTo 0
        Exit Function
CheckForObject:
        If IsObject(Kollection(strKey)) Then
            CollectionContains = True
            On Error GoTo 0
            Exit Function
        End If
NotFound:
        CollectionContains = False
        On Error GoTo 0
        Exit Function
    ElseIf Not IsMissing(item) Then
        CollectionContains = False
        For Each var In Kollection
            If var = item Then
                CollectionContains = True
                Exit Function
            End If
        Next var
    Else
        CollectionContains = False
    End If
End Function

Public Function CollectionSort(colInput As Collection) As Collection
    Dim iCounter    As Integer
    Dim iCounter2   As Integer
    Dim Temp        As Variant
    Set CollectionSort = New Collection
    For iCounter = 1 To colInput.Count - 1
        For iCounter2 = iCounter + 1 To colInput.Count
            If colInput(iCounter) > colInput(iCounter2) Then
                Temp = colInput(iCounter2)
                colInput.Remove iCounter2
                colInput.Add Temp, , iCounter
            End If
        Next iCounter2
    Next iCounter
    Set CollectionSort = colInput
End Function

Function CollectionsToArray2D(collections As Collection) As Variant
    If collections.Count = 0 Then Exit Function
    Dim columnCount As Long
    columnCount = collections.Count
    Dim rowCount    As Long
    rowCount = collections.item(1).Count
    Dim var         As Variant
    ReDim var(1 To rowCount, 1 To columnCount)
    Dim cols        As Long
    Dim rows        As Long
    For rows = 1 To rowCount
        For cols = 1 To collections.Count
            var(rows, cols) = collections(cols).item(rows)
        Next cols
    Next rows
    CollectionsToArray2D = var
End Function

Function ComponentNames( _
        moduleType As vbext_ComponentType, _
        Optional TargetWorkbook As Workbook)
    Dim coll        As New Collection
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim module      As VBComponent
    For Each module In TargetWorkbook.VBProject.VBComponents
        If module.Type = moduleType Then
            coll.Add module.Name
        End If
    Next
    Set ComponentNames = coll
End Function

Function DeclarationsKeywordSubstring(str As Variant, Optional delim As String _
        , Optional afterWord As String _
        , Optional beforeWord As String _
        , Optional counter As Integer _
        , Optional outer As Boolean _
        , Optional includeWords As Boolean) As String
    Dim i           As Long
    If afterWord = "" And beforeWord = "" And counter = 0 Then
        MsgBox ("Pass at least 1 parameter betweenn -AfterWord- , -BeforeWord- , -counter-")
        Exit Function
    End If
    If TypeName(str) = "String" Then
        If delim <> "" Then
            str = Split(str, delim)
            If UBound(str) <> 0 Then
                If afterWord = "" And beforeWord = "" And counter <> 0 Then
                    If counter - 1 <= UBound(str) Then
                        DeclarationsKeywordSubstring = str(counter - 1)
                        Exit Function
                    End If
                End If
                For i = LBound(str) To UBound(str)
                    If afterWord <> "" And beforeWord = "" Then
                        If i <> 0 Then
                            If str(i - 1) = afterWord Or str(i - 1) = "#" & afterWord Then
                                DeclarationsKeywordSubstring = str(i)
                                Exit Function
                            End If
                        End If
                    ElseIf afterWord = "" And beforeWord <> "" Then
                        If i <> UBound(str) Then
                            If str(i + 1) = beforeWord Or str(i + 1) = "#" & beforeWord Then
                                DeclarationsKeywordSubstring = str(i)
                                Exit Function
                            End If
                        End If
                    ElseIf afterWord <> "" And beforeWord <> "" Then
                        If i <> 0 And i <> UBound(str) Then
                            If (str(i - 1) = afterWord Or str(i - 1) = "#" & afterWord) And (str(i + 1) = beforeWord Or str(i + 1) = "#" & beforeWord) Then
                                DeclarationsKeywordSubstring = str(i)
                                Exit Function
                            End If
                        End If
                    End If
                Next i
            End If
        Else
            If InStr(1, str, afterWord) > 0 And InStr(1, str, beforeWord) > 0 Then
                If includeWords = False Then
                    DeclarationsKeywordSubstring = Mid(str, InStr(1, str, afterWord) + Len(afterWord))
                Else
                    DeclarationsKeywordSubstring = Mid(str, InStr(1, str, afterWord))
                End If
                If outer = True Then
                    If includeWords = False Then
                        DeclarationsKeywordSubstring = Left(DeclarationsKeywordSubstring, InStrRev(DeclarationsKeywordSubstring, beforeWord) - 1)
                    Else
                        DeclarationsKeywordSubstring = Left(DeclarationsKeywordSubstring, InStrRev(DeclarationsKeywordSubstring, beforeWord) + Len(beforeWord) - 1)
                    End If
                Else
                    If includeWords = False Then
                        DeclarationsKeywordSubstring = Left(DeclarationsKeywordSubstring, InStr(1, DeclarationsKeywordSubstring, beforeWord) - 1)
                    Else
                        DeclarationsKeywordSubstring = Left(DeclarationsKeywordSubstring, InStr(1, DeclarationsKeywordSubstring, beforeWord) + Len(beforeWord) - 1)
                    End If
                End If
                Exit Function
            End If
        End If
    Else
    End If
    DeclarationsKeywordSubstring = vbNullString
End Function

Sub DeclarationsTableCreate(TargetWorkbook As Workbook)

    DeclarationsWorksheetCreate

    Dim TargetWorksheet As Worksheet
    Set TargetWorksheet = ThisWorkbook.Sheets("Declarations_Table")
    If Format(Now, "YYMMDDHHNN") - TargetWorksheet.Range("Z1").Value < 60 Then Exit Sub

    TargetWorksheet.Range("A2").CurrentRegion.offset(1).clear
    ArrayToRange2D CollectionsToArray2D( _
            getDeclarations( _
            wb:=TargetWorkbook, _
            includeScope:=True, _
            includeType:=True, _
            includeKeywords:=True, _
            includeDeclarations:=True, _
            includeComponentName:=True, _
            includeComponentType:=True)), _
            TargetWorksheet.Range("A2")

    TargetWorksheet.Range("Z1").Value = Format(Now, "YYMMDDHHNN")

    DeclarationsTableSort
End Sub


Function DeclarationsTableKeywords() As Collection
    Dim TargetWorksheet As Worksheet
    Set TargetWorksheet = ThisWorkbook.Sheets("Declarations_Table")
    Dim Lr          As Long: Lr = getLastRow(TargetWorksheet)
    Dim coll        As New Collection
    Dim cell        As Range
    For Each cell In TargetWorksheet.Range("C2:C" & Lr)
        On Error Resume Next
        coll.Add cell.TEXT, cell.TEXT
        On Error GoTo 0
    Next
    Set DeclarationsTableKeywords = coll
End Function


Sub DeclarationsTableSort()

    Dim TargetWorksheet As Worksheet
    Set TargetWorksheet = ThisWorkbook.Worksheets("Declarations_Table")

    Dim sort1       As String: sort1 = "B1"
    Dim sort2       As String: sort2 = "C1"
    Dim sort3       As String    ': sort3 = "D1"

    With TargetWorksheet.Sort
        .SortFields.clear
        .SortFields.Add Key:=TargetWorksheet.Range(sort1), Order:=xlAscending

        If Not sort2 = "" Then
            .SortFields.Add Key:=TargetWorksheet.Range(sort2), Order:=xlAscending
        End If
        If Not sort3 = "" Then
            .SortFields.Add Key:=TargetWorksheet.Range(sort3), Order:=xlAscending
        End If

        .SetRange TargetWorksheet.Range("A1").CurrentRegion
        .Header = xlYes
        .Apply
    End With

End Sub



Function DeclarationsWorksheetCreate() As Boolean
    If WorksheetExists("Declarations_Table", ThisWorkbook) Then Exit Function
    Dim TargetWorksheet As Worksheet
    Set TargetWorksheet = ThisWorkbook.Sheets.Add
    With TargetWorksheet
        .Name = "Declarations_Table"
        .Cells.VerticalAlignment = xlVAlignTop
        .Range("A1:F1").Value = Split("SCOPE,TYPE,NAME,CODE,MODULE TYPE,MODULE NAME", ",")
        .rows(1).Cells.Font.Bold = True
        .rows(1).Cells.Font.Size = 14
    End With
End Function

Sub ExportLinkedDeclaration(TargetWorkbook As Workbook, DeclarationName As String)
    DeclarationsTableCreate TargetWorkbook
    Dim TargetWorksheet As Worksheet
    Set TargetWorksheet = ThisWorkbook.Sheets("Declarations_Table")

    Dim codeName    As String
    Dim codeText    As String
    Dim cell        As Range
    On Error Resume Next
    Set cell = TargetWorksheet.Columns(3).Find(DeclarationName, LookAt:=xlWhole)
    On Error GoTo 0
    If cell Is Nothing Then Exit Sub

    codeName = DeclarationName
    codeText = cell.offset(0, 1).TEXT
    TxtOverwrite LOCAL_LIBRARY_DECLARATIONS & DeclarationName & ".txt", codeText

End Sub



Sub ExportProcedure( _
        Optional TargetWorkbook As Workbook, _
        Optional module As VBComponent, _
        Optional ProcedureName As String, _
        Optional ExportMergedTxt As Boolean)

    If Not AssignCPSvariables(TargetWorkbook, module, ProcedureName) Then Exit Sub

    ProjetFoldersCreate

    Dim ExportedProcedures As New Collection
    On Error GoTo ErrorHandler

    ExportedProcedures.Add CStr(ProcedureName), CStr(ProcedureName)

    Dim Procedure
    For Each Procedure In LinkedProceduresDeep(ProcedureName, TargetWorkbook)
        ExportedProcedures.Add CStr(Procedure), CStr(Procedure)
    Next

    If ExportedProcedures.Count > 1 Then
        For Each Procedure In ExportedProcedures
            ExportTargetProcedure TargetWorkbook, , CStr(Procedure)
        Next
        If ExportMergedTxt Then
            Dim MergedName As String: MergedName = "Merged_" & ProcedureName
            Dim fileName As String: fileName = LOCAL_LIBRARY_PROCEDURES & MergedName & ".txt"
            Dim MergedString As String

            For Each Procedure In ExportedProcedures
                MergedString = MergedString & vbNewLine & ProcedureCode(TargetWorkbook, , Procedure)
            Next
            Debug.Print "OVERWROTE " & MergedName
            TxtOverwrite fileName, MergedString
            TxtPrependContainedProcedures fileName
        End If
    End If

    FollowLink LOCAL_LIBRARY_PROCEDURES

    Exit Sub
ErrorHandler:
    MsgBox "An error occured in Sub ExportProcedure"
End Sub

Sub ExportTargetProcedure( _
        Optional TargetWorkbook As Workbook, _
        Optional module As VBComponent, _
        Optional Procedure As String)

    If Not AssignCPSvariables(TargetWorkbook, module, Procedure) Then Exit Sub

    Dim proclastmod
    proclastmod = ProcedureLastModified(TargetWorkbook, module, Procedure)
    If proclastmod = 0 Then
        AddLinkedLists TargetWorkbook, module, Procedure
        proclastmod = ProcedureLastModAdd(TargetWorkbook, module, Procedure)
    End If

    Dim Code        As String
    Code = ProcedureCode(TargetWorkbook, module, CStr(Procedure))
    Dim FileFullName As String
    FileFullName = LOCAL_LIBRARY_PROCEDURES & Procedure & ".txt"
    If FileExists(FileFullName) Then
        Dim filelastmod
        filelastmod = StringLastModified(TxtRead(FileFullName))
        If proclastmod > filelastmod Then
            Debug.Print "OVERWROTE " & Procedure
            TxtOverwrite FileFullName, Code
        End If
    Else
        Debug.Print "NEW " & Procedure
        TxtOverwrite FileFullName, Code
    End If

    Dim element
    For Each element In LinkedUserforms(TargetWorkbook, module, CStr(Procedure))
        TargetWorkbook.VBProject.VBComponents(element).Export LOCAL_LIBRARY_USERFORMS & element & ".frm"
    Next
    For Each element In LinkedClasses(TargetWorkbook, module, CStr(Procedure))
        TargetWorkbook.VBProject.VBComponents(element).Export LOCAL_LIBRARY_CLASSES & element & ".cls"
    Next
    For Each element In LinkedDeclarations(TargetWorkbook, module, CStr(Procedure))
        ExportLinkedDeclaration TargetWorkbook, CStr(element)
    Next
End Sub

Public Function FileExists(ByVal fileName As String) As Boolean
    If InStr(1, fileName, "\") = 0 Then Exit Function
    If Right(fileName, 1) = "\" Then fileName = Left(fileName, Len(fileName) - 1)
    FileExists = (Dir(fileName, vbArchive + vbHidden + vbReadOnly + vbSystem) <> "")
End Function

Function FolderExists(ByVal strPath As String) As Boolean
'@LastModified 2310251309
    On Error Resume Next
    FolderExists = ((GetAttr(strPath) And vbDirectory) = vbDirectory)
End Function

Sub FoldersCreate(FolderPath As String)
    On Error Resume Next
    Dim individualFolders() As String
    Dim tempFolderPath As String
    Dim ArrayElement As Variant
    individualFolders = Split(FolderPath, "\")
    For Each ArrayElement In individualFolders
        tempFolderPath = tempFolderPath & ArrayElement & "\"
        If FolderExists(tempFolderPath) = False Then
            MkDir tempFolderPath
        End If
    Next ArrayElement
End Sub

Sub FollowLink(FolderPath As String)
    If Right(FolderPath, 1) = "\" Then FolderPath = Left(FolderPath, Len(FolderPath) - 1)
    On Error Resume Next
    Dim oShell      As Object
    Dim Wnd         As Object
    Set oShell = CreateObject("Shell.Application")
    For Each Wnd In oShell.Windows
        If Wnd.Name = "File Explorer" Then
            If Wnd.document.Folder.Self.path = FolderPath Then Exit Sub
        End If
    Next Wnd
    Application.ThisWorkbook.FollowHyperlink Address:=FolderPath, NewWindow:=True
End Sub

Function FormatVBA7(str As String) As String
'FormatVBA7(join(filter(filter(split(aworkbook.Init(thisworkbook).Code,vbnewline),"Declare ",True ,vbTextCompare),"""" & "Declare", False,vbTextCompare),vbnewline))
    Dim selectedText
    selectedText = str
    selectedText = Replace(selectedText, " _" & vbNewLine, "")
    selectedText = Split(selectedText, vbNewLine)
    Dim IsVba7      As String
    Dim NotVba7     As String
    Dim colIsVBA7   As New Collection
    Dim colNotVBA7  As New Collection
    Dim i           As Long
    For i = LBound(selectedText) To UBound(selectedText)
        If InStr(1, selectedText(i), "PtrSafe", vbTextCompare) Then
            IsVba7 = selectedText(i)
            NotVba7 = Replace(selectedText(i), "Declare ptrsafe ", "Declare ", , , vbTextCompare)
        Else
            IsVba7 = Replace(selectedText(i), "Declare ", "Declare PtrSafe ")
            NotVba7 = selectedText(i)
        End If
        colIsVBA7.Add IsVba7
        colNotVBA7.Add NotVba7
    Next
    Set colIsVBA7 = CollectionSort(colIsVBA7)
    Set colNotVBA7 = CollectionSort(colNotVBA7)
    Dim out         As String
    out = "#If VBA7 then" & vbNewLine & _
            collectionToString(colIsVBA7, vbNewLine) & vbNewLine & _
            "#Else" & vbNewLine & _
            collectionToString(colNotVBA7, vbNewLine) & vbNewLine & _
            "#End If"
    FormatVBA7 = out

End Function

Function GetMotherBoardProp() As String

    Dim strComputer As String
    Dim objSvcs     As Object
    Dim objItms As Object, objItm As Object
    Dim vItem
    strComputer = "."
    Set objSvcs = GetObject("winmgmts:\\" & strComputer & "\root\cimv2")
    Set objItms = objSvcs.execquery("Select * from Win32_BaseBoard")
    For Each objItm In objItms
        GetMotherBoardProp = objItm.SerialNumber
    Next

    Set objSvcs = Nothing
End Function

Public Function GetSheetByCodeName(wb As Workbook, codeName As String) As Worksheet
    Dim sh          As Worksheet
    For Each sh In wb.Worksheets
        If UCase(sh.codeName) = UCase(codeName) Then Set GetSheetByCodeName = sh: Exit For
    Next sh
End Function

Sub ImportClass( _
        Optional ClassName As String, _
        Optional TargetWorkbook As Workbook, _
        Optional Overwrite As Boolean)

    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    If ClassName = "" Then ClassName = CodepaneSelection
    If ClassName = "" Or InStr(1, ClassName, " ") > 0 Then Exit Sub
    Dim FilePath    As String
    FilePath = LOCAL_LIBRARY_CLASSES & ClassName & ".cls"
    If CheckPath(FilePath) = "I" Then
        On Error Resume Next
        Dim Code    As String
        Code = TXTReadFromUrl(GITHUB_LIBRARY_CLASSES & ClassName & ".cls")
        On Error GoTo 0
        If Len(Code) > 0 And Not UCase(Code) Like ("*NOT FOUND*") Then
            TxtOverwrite FilePath, Code
        Else
            MsgBox "File " & ClassName & ".cls not found neither localy nor online"
            Exit Sub
        End If
    End If

    If ModuleExists(ClassName, TargetWorkbook) Then
        If Overwrite = True Then
            TargetWorkbook.VBProject.VBComponents.Remove TargetWorkbook.VBProject.VBComponents(ClassName)
        Else
            Exit Sub
        End If
    End If
    TargetWorkbook.VBProject.VBComponents.Import FilePath
End Sub


Sub ImportDeclaration( _
        Optional DeclarationName As String, _
        Optional module As VBComponent, _
        Optional TargetWorkbook As Workbook)

    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    If DeclarationName = "" Then DeclarationName = CodepaneSelection
    If DeclarationName = "" Or InStr(1, DeclarationName, " ") > 0 Then Exit Sub
    Dim FilePath    As String
    FilePath = LOCAL_LIBRARY_DECLARATIONS & DeclarationName & ".txt"
    Dim Code        As String
    On Error Resume Next
    Code = TxtRead(FilePath)
    On Error GoTo 0

    If Len(Code) = 0 Then    'CheckPath(filePath) = "I" Then
        On Error Resume Next
        Code = TXTReadFromUrl(GITHUB_LIBRARY_DECLARATIONS & DeclarationName & ".txt")
        On Error GoTo 0
        If Len(Code) > 0 And Not UCase(Code) Like ("*NOT FOUND*") Then
            Code = FormatVBA7(Code)
            TxtOverwrite FilePath, Code
        Else
            Debug.Print "File " & DeclarationName & ".txt not found localy or online"
            Exit Sub
        End If
    Else

    End If
    If InStr(1, WorkbookCode(TargetWorkbook), Code, vbTextCompare) > 0 Then Exit Sub
    If module Is Nothing Then Set module = ModuleAddOrSet(TargetWorkbook, "vbArcImports", vbext_ct_StdModule)
    module.CodeModule.AddFromString Code

End Sub

Sub ImportProcedure( _
        Optional Procedure As String, _
        Optional TargetWorkbook As Workbook, _
        Optional module As VBComponent, _
        Optional Overwrite As Boolean)

    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    If Procedure = "" Then Procedure = CodepaneSelection
    If Procedure = "" Or InStr(1, Procedure, " ") > 0 Then Exit Sub
    Dim ProcedurePath As String
    ProcedurePath = LOCAL_LIBRARY_PROCEDURES & Procedure & ".txt"

    Dim Code        As String
    On Error Resume Next
    Code = TxtRead(ProcedurePath)
    On Error GoTo 0

    If Len(Code) = 0 Then
        On Error Resume Next
        Code = TXTReadFromUrl(GITHUB_LIBRARY_PROCEDURES & Procedure & ".txt")
        On Error GoTo 0
        If Len(Code) > 0 And Not UCase(Code) Like ("*NOT FOUND*") Then
            TxtOverwrite ProcedurePath, Code
        Else
            Debug.Print "File " & Procedure & ".txt not found neither localy nor online"
            Exit Sub
        End If
    End If

    Dim filelastmod
    filelastmod = StringLastModified(Code)
    Dim proclastmod

    If ProcedureExists(TargetWorkbook, Procedure) = True Then
        Set module = ModuleOfProcedure(TargetWorkbook, Procedure)
        proclastmod = ProcedureLastModified(TargetWorkbook, module, Procedure)
        If Overwrite = True Then
            If proclastmod = 0 Or proclastmod < filelastmod Then
                ProcedureReplace module, Procedure, TxtRead(ProcedurePath)
            End If
        End If
    Else
        If module Is Nothing Then
            '            Dim ModuleName As String
            '                ModuleName = StringProcedureAssignedModule(Code)
            '            If ModuleName = "" Then ModuleName = "vbArcImports"
            '            Set Module = ModuleAddOrSet(TargetWorkbook, ModuleName, vbext_ct_StdModule)
            Set module = ModuleAddOrSet(TargetWorkbook, "vbArcImports", vbext_ct_StdModule)
        End If
        module.CodeModule.AddFromFile ProcedurePath
    End If

    ImportProcedureDependencies Procedure, TargetWorkbook, module, Overwrite
    '    ProcedureMoveToAssignedModule TargetWorkbook, Module, Procedure
End Sub

Sub ImportProcedureDependencies( _
        Optional Procedure As String, _
        Optional TargetWorkbook As Workbook, _
        Optional module As VBComponent, _
        Optional Overwrite As Boolean)

    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    If Procedure = "" Then
        Dim cps     As String
        cps = CodepaneSelection
        If Len(cps) > 0 Then
            Procedure = cps
        Else
            Procedure = ActiveProcedure
        End If
        If Not ProcedureExists(TargetWorkbook, Procedure) Then Exit Sub
    End If
    On Error Resume Next
    If module Is Nothing Then Set module = ModuleOfProcedure(TargetWorkbook, Procedure)
    If module Is Nothing Then Exit Sub
    On Error GoTo 0
    Dim var
    Dim importfile  As String
    var = Split(ProcedureCode(TargetWorkbook, module, Procedure), vbNewLine)
    var = Filter(var, "'@INCLUDE ")
    Dim TextLine    As Variant
    For Each TextLine In var
        TextLine = Trim(TextLine)
        If TextLine Like "'@INCLUDE *" Then
            importfile = Split(TextLine, " ")(2)
            importfile = Replace(importfile, vbNewLine, "")
            If TextLine Like "'@INCLUDE PROCEDURE *" Then
                ImportProcedure importfile, TargetWorkbook, module, Overwrite
            ElseIf TextLine Like "'@INCLUDE CLASS *" Then
                ImportClass importfile, TargetWorkbook, Overwrite
            ElseIf TextLine Like "'@INCLUDE USERFORM *" Then
                ImportUserform importfile, TargetWorkbook, Overwrite
            ElseIf TextLine Like "'@INCLUDE DECLARATION *" Then
                ImportDeclaration importfile, module, TargetWorkbook
            End If
        End If
    Next
End Sub

Sub ImportUserform( _
        Optional UserformName As String, _
        Optional TargetWorkbook As Workbook, _
        Optional Overwrite As Boolean)
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    If UserformName = "" Then UserformName = CodepaneSelection
    If UserformName = "" Or InStr(1, UserformName, " ") > 0 Then Exit Sub
    Dim FilePathFrM As String
    FilePathFrM = LOCAL_LIBRARY_USERFORMS & UserformName & ".frm"
    Dim FilePathFrX As String
    FilePathFrX = LOCAL_LIBRARY_USERFORMS & UserformName & ".frx"

    If CheckPath(FilePathFrM) = "I" Then
        On Error Resume Next
        Dim codeFrM As String
        codeFrM = TXTReadFromUrl(GITHUB_LIBRARY_USERFORMS & UserformName & ".frm")
        Dim codeFrX As String
        codeFrX = TXTReadFromUrl(GITHUB_LIBRARY_USERFORMS & UserformName & ".frx")
        On Error GoTo 0
        If Len(codeFrM) > 0 And Len(codeFrX) > 0 Then
            TxtOverwrite FilePathFrM, codeFrM
            TxtOverwrite FilePathFrX, codeFrX
        Else
            MsgBox "File " & UserformName & ".frm/.frx not found neither localy nor online"
            Exit Sub
        End If
    End If

    If ModuleExists(UserformName, TargetWorkbook) Then
        If Overwrite = True Then
            TargetWorkbook.VBProject.VBComponents.Remove TargetWorkbook.VBProject.VBComponents(UserformName)
        Else
            Exit Sub
        End If
    End If
    TargetWorkbook.VBProject.VBComponents.Import FilePathFrM
End Sub

Public Function getLastCell(TargetWorksheet As Worksheet)
    Dim cell As Range
    Set cell = TargetWorksheet.Cells.Find(What:="*", _
                    After:=Range("A1"), _
                    LookAt:=xlPart, _
                    LookIn:=xlFormulas, _
                    SearchOrder:=xlByRows, _
                    SearchDirection:=xlPrevious, _
                    MatchCase:=False)
    If cell Is Nothing Then Set cell = TargetWorksheet.Range("A1")
    Set getLastCell = cell
End Function

Public Function Len2( _
        ByVal val As Variant) _
        As Integer
    If IsArray(val) And Right(TypeName(val), 2) = "()" Then
        Len2 = UBound(val) - LBound(val) + 1
    ElseIf TypeName(val) = "String" Then
        Len2 = Len(val)
    ElseIf IsNumeric(val) Then
        Len2 = Len(CStr(val))
    Else
        Len2 = val.Count
    End If
End Function

Function LinkedClasses( _
        TargetWorkbook As Workbook, _
        module As VBComponent, _
        Procedure As String) As Collection

    Dim coll        As New Collection
    Dim var         As Variant
    var = classCallsOfModule(module)
    Dim Code        As String
    Code = ProcedureCode(TargetWorkbook, module, Procedure)
    Dim Keyword     As String
    Dim ClassName   As String
    Dim element     As Variant
    Dim i           As Long
    On Error Resume Next
    For i = LBound(var, 1) To UBound(var, 1)
        If InStr(1, Code, var(i, 1)) > 0 Or InStr(1, Code, var(i, 2)) > 0 Then
            coll.Add var(i, 1), var(i, 1)
        End If
    Next
    For Each element In ClassNames
        If InStr(1, Code, element) > 0 Then
            coll.Add element, CStr(element)
        End If
    Next
    On Error GoTo 0
    Set LinkedClasses = coll
End Function

Function LinkedDeclarations( _
        Optional TargetWorkbook As Workbook, _
        Optional module As VBComponent, _
        Optional Procedure As String) As Collection

    If Not AssignCPSvariables(TargetWorkbook, module, Procedure) Then Stop

    DeclarationsTableCreate TargetWorkbook

    Dim TargetWorksheet As Worksheet: Set TargetWorksheet = ThisWorkbook.Sheets("Declarations_Table")
    Dim coll        As New Collection
    Dim Code        As String: Code = ProcedureCode(TargetWorkbook, module, Procedure)
    Dim element
    For Each element In DeclarationsTableKeywords
        If RegexTest(Code, "\b ?" & CStr(element) & "\b") Then
            On Error Resume Next
            coll.Add CStr(element), CStr(element)
            On Error GoTo 0
        End If
    Next
    Set LinkedDeclarations = coll
End Function

Function LinkedProcedures( _
        Optional TargetWorkbook As Workbook, _
        Optional module As VBComponent, _
        Optional ProcedureName As String) As Collection
    If Not AssignCPSvariables(TargetWorkbook, module, ProcedureName) Then Stop
    Dim Procedures  As Collection
    Set Procedures = ProceduresOfWorkbook(TargetWorkbook)
    Dim Code        As String
    Code = ProcedureCode(TargetWorkbook, module, ProcedureName)
    Dim coll        As New Collection
    Dim Procedure   As Variant
    For Each Procedure In Procedures
        If UCase(CStr(Procedure)) <> UCase(CStr(ProcedureName)) Then
            If RegexTest(Code, "\W" & CStr(Procedure) & "[.(\W]") = True Then
                coll.Add Procedure, CStr(Procedure)
            End If
        End If
    Next
    Set LinkedProcedures = coll
End Function

Function LinkedProceduresDeep( _
        ProcedureName As Variant, _
        TargetWorkbook As Workbook) As Collection

    Dim AllProcedures As Collection: Set AllProcedures = ProceduresOfWorkbook(TargetWorkbook)
    Dim Processed   As Collection: Set Processed = New Collection
    Dim CalledProcedures As Collection: Set CalledProcedures = New Collection

    Dim Procedure   As Variant
    Dim module      As VBComponent

    Processed.Add CStr(ProcedureName), CStr(ProcedureName)
    On Error Resume Next
    For Each Procedure In LinkedProcedures(TargetWorkbook, , CStr(ProcedureName))
        CalledProcedures.Add CStr(Procedure), CStr(Procedure)
    Next
    On Error GoTo 0

    Dim CalledProceduresCount As Long
    CalledProceduresCount = CalledProcedures.Count
    Dim element
repeat:
    For Each element In CalledProcedures
        If Not CollectionContains(Processed, , CStr(element)) Then
            On Error Resume Next
            For Each Procedure In LinkedProcedures(TargetWorkbook, , CStr(element))
                CalledProcedures.Add CStr(Procedure), CStr(Procedure)
            Next
            On Error GoTo 0
            Processed.Add CStr(element), CStr(element)
        End If
    Next
    If CalledProcedures.Count > CalledProceduresCount Then
        CalledProceduresCount = CalledProcedures.Count
        GoTo repeat
    End If

    Set LinkedProceduresDeep = CollectionSort(CalledProcedures)
End Function


Sub LinkedProceduresMoveHere(Optional Procedure As String)
    Dim TargetWorkbook As Workbook
    Set TargetWorkbook = ActiveCodepaneWorkbook
    If Not AssignProcedureVariable(TargetWorkbook, Procedure) Then Exit Sub
    Dim el
    For Each el In LinkedProceduresDeep(Procedure, TargetWorkbook)
        ProcedureMoveHere CStr(el)
    Next
End Sub




Function LinkedUserforms( _
        TargetWorkbook As Workbook, _
        module As VBComponent, _
        Procedure As String) As Collection
    Dim coll        As New Collection
    Dim Code        As String
    Code = ProcedureCode(TargetWorkbook, module, Procedure)
    Dim FormName
    For Each FormName In UserformNames(TargetWorkbook)
        If RegexTest(Code, "\W" & FormName & "[.(\W]") = True Then coll.Add FormName    '& " " & "(Userform)"
    Next
    Set LinkedUserforms = coll
End Function

Function ModuleAddOrSet( _
        TargetWorkbook As Workbook, _
        TargetName As String, _
        moduleType As VBIDE.vbext_ComponentType) As VBComponent


    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim module      As VBComponent
    On Error Resume Next
    Set module = TargetWorkbook.VBProject.VBComponents(TargetName)
    On Error GoTo 0
    If module Is Nothing Then
        Set module = TargetWorkbook.VBProject.VBComponents.Add(moduleType)
        module.Name = TargetName
    End If
    Set ModuleAddOrSet = module
End Function




Function ModuleCode(module As VBComponent) As String
    With module.CodeModule
        If .CountOfLines = 0 Then ModuleCode = "": Exit Function
        ModuleCode = .Lines(1, .CountOfLines)
    End With
End Function

Public Function ModuleExists( _
        TargetName As String, _
        TargetWorkbook As Workbook) As Boolean
    Dim module      As VBComponent
    On Error Resume Next
    Set module = TargetWorkbook.VBProject.VBComponents(TargetName)
    On Error GoTo 0
    ModuleExists = Not module Is Nothing
End Function

'* Modified   : Date and Time       Author              Description
'* Updated    : 25-10-2023 13:24    Alex                (Dependencies.bas > ModuleOfProcedure)

Public Function ModuleOfProcedure( _
        TargetWorkbook As Workbook, _
        ProcedureName As Variant) As VBComponent
'@LastModified 2310251324
    Dim ProcKind    As VBIDE.vbext_ProcKind
    Dim lineNum As Long, NumProc As Long
    Dim Procedure   As String
    Dim module      As VBComponent
    For Each module In TargetWorkbook.VBProject.VBComponents
        If module.Type = vbext_ct_StdModule Then
            With module.CodeModule
                lineNum = .CountOfDeclarationLines + 1
                Do Until lineNum >= .CountOfLines
                    Procedure = .ProcOfLine(lineNum, ProcKind)
                    If UCase(Procedure) = UCase(ProcedureName) Then
                        Set ModuleOfProcedure = module
                        Exit Function
                    End If
                    lineNum = .procStartLine(Procedure, ProcKind) + .ProcCountLines(Procedure, ProcKind) + 1
                Loop
            End With
        End If
    Next module
End Function

Function ModuleOrSheetName(module As VBComponent) As String
    If module.Type = vbext_ct_Document Then
        If module.Name = "ThisWorkbook" Then
            ModuleOrSheetName = module.Name
        Else
            ModuleOrSheetName = GetSheetByCodeName(WorkbookOfModule(module), module.Name).Name
        End If
    Else
        ModuleName = module.Name
    End If
End Function

Function ModuleTypeToString(componentType As VBIDE.vbext_ComponentType) As String
    Select Case componentType
        Case vbext_ct_ActiveXDesigner
            ModuleTypeToString = "ActiveX Designer"
        Case vbext_ct_ClassModule
            ModuleTypeToString = "Class"
        Case vbext_ct_Document
            ModuleTypeToString = "Document"
        Case vbext_ct_MSForm
            ModuleTypeToString = "UserForm"
        Case vbext_ct_StdModule
            ModuleTypeToString = "Module"
        Case Else
            ModuleTypeToString = "Unknown Type: " & CStr(componentType)
    End Select
End Function

Function ProcedureAssignedModule( _
        TargetWorkbook As Workbook, _
        module As VBComponent, _
        Procedure As String) As VBComponent
    Dim ComponentName As Variant
    ComponentName = Split(ProcedureCode(TargetWorkbook, module, Procedure), vbNewLine)
    ComponentName = Filter(ComponentName, "'@AssignedModule")
    If Len2(ComponentName) <> 1 Then Exit Function
    Dim ub          As Long
    ub = UBound(Split(ComponentName(0), " "))
    ComponentName = Split(ComponentName(0), " ")(ub)
    Set ProcedureAssignedModule = ModuleAddOrSet(TargetWorkbook, CStr(ComponentName), vbext_ct_StdModule)
End Function

Sub ProcedureAssignedModuleAdd( _
        Optional TargetWorkbook As Workbook, _
        Optional module As VBComponent, _
        Optional Procedure As String)
    If Not AssignCPSvariables(TargetWorkbook, module, Procedure) Then Stop
    ProcedureLinesRemove "'@AssignedModule *", TargetWorkbook, module, Procedure
    module.CodeModule.InsertLines ProcedureBodyLineFirstAfterComments(module, Procedure), _
            "'@AssignedModule " & module.Name
End Sub

Function ProcedureBodyLineFirst( _
        module As VBComponent, _
        Procedure As String) As Long
    ProcedureBodyLineFirst = ProcedureTitleLineFirst(module, Procedure) + ProcedureTitleLineCount(module, Procedure)
End Function

Function ProcedureBodyLineFirstAfterComments( _
        module As VBComponent, _
        Procedure As String) As Long
    Dim N           As Long
    Dim S           As String
    For N = ProcedureBodyLineFirst(module, Procedure) To module.CodeModule.CountOfLines
        S = Trim(module.CodeModule.Lines(N, 1))
        If S = vbNullString Then
            Exit For
        ElseIf Left(S, 1) = "'" Then
        ElseIf Left(S, 3) = "Rem" Then
        ElseIf Right(Trim(module.CodeModule.Lines(N - 1, 1)), 1) = "_" Then
        ElseIf Right(S, 1) = "_" Then
        Else
            Exit For
        End If
    Next N
    ProcedureBodyLineFirstAfterComments = N
End Function



Public Function ProcedureCode( _
        Optional TargetWorkbook As Workbook, _
        Optional module As VBComponent, _
        Optional Procedure As Variant, _
        Optional IncludeHeader As Boolean = True) As String
    If Not AssignCPSvariables(TargetWorkbook, module, CStr(Procedure)) Then Exit Function
    Dim lProcStart  As Long
    Dim lProcBodyStart As Long
    Dim lProcNoLines As Long
    Const vbext_pk_Proc = 0
    On Error GoTo Error_Handler
    lProcStart = module.CodeModule.procStartLine(Procedure, vbext_pk_Proc)
    lProcBodyStart = module.CodeModule.ProcBodyLine(Procedure, vbext_pk_Proc)
    lProcNoLines = module.CodeModule.ProcCountLines(Procedure, vbext_pk_Proc)
    If IncludeHeader = True Then
        ProcedureCode = module.CodeModule.Lines(lProcStart, lProcNoLines)
    Else
        lProcNoLines = lProcNoLines - (lProcBodyStart - lProcStart)
        ProcedureCode = module.CodeModule.Lines(lProcBodyStart, lProcNoLines)
    End If
Error_Handler_Exit:
    On Error Resume Next
    Exit Function
Error_Handler:
    Debug.Print "Error Source: ProcedureCode" & vbCrLf & _
            "Error Description: " & Err.Description & _
            Switch(Erl = 0, vbNullString, Erl <> 0, vbCrLf & "Line No: " & Erl)
    Resume Error_Handler_Exit
End Function

Function ProcedureExists( _
        TargetWorkbook As Workbook, _
        ProcedureName As Variant) As Boolean
    Dim Procedures  As Collection
    Set Procedures = ProceduresOfWorkbook(TargetWorkbook)
    Dim Procedure   As Variant
    For Each Procedure In Procedures
        If UCase(CStr(Procedure)) = UCase(ProcedureName) Then
            ProcedureExists = True
            Exit Function
        End If
    Next
End Function

Function ProcedureLastModAdd( _
        Optional TargetWorkbook As Workbook, _
        Optional module As VBComponent, _
        Optional Procedure As String, _
        Optional ModificationDate As Double)



    If Not AssignCPSvariables(TargetWorkbook, module, Procedure) Then Exit Function
    If ModificationDate = 0 Then ModificationDate = Format(Now, "yymmddhhnn")
    Dim LastModLine As Long
    LastModLine = ProcedureLineContaining(module, Procedure, "'@LastModified *")
    If LastModLine = 0 Then GoTo PASS
    Dim LDate       As Double
    LDate = Split(module.CodeModule.Lines(LastModLine, 1), " ")(1)
    ProcedureLinesRemove "'@LastModified *", TargetWorkbook, module, Procedure
PASS:
    module.CodeModule.InsertLines ProcedureBodyLineFirst(module, Procedure), _
            "'@LastModified " & ModificationDate

    ProcedureLastModAdd = ModificationDate
End Function

Function ProcedureLastModified( _
        Optional TargetWorkbook As Workbook, _
        Optional module As VBComponent, _
        Optional Procedure As String)
    If Not AssignCPSvariables(TargetWorkbook, module, Procedure) Then Stop
    ProcedureLastModified = StringLastModified(ProcedureCode(TargetWorkbook, module, Procedure))
End Function

Function ProcedureLinesCount( _
        module As VBComponent, _
        Procedure As String) As Long
    ProcedureLinesCount = module.CodeModule.ProcCountLines(Procedure, vbext_pk_Proc)
End Function

Public Function ProcedureLinesFirst( _
        module As VBComponent, _
        Procedure As String) As Long
    Dim ProcKind    As VBIDE.vbext_ProcKind
    ProcKind = vbext_pk_Proc
    ProcedureLinesFirst = module.CodeModule.procStartLine(Procedure, ProcKind)
End Function


Public Function ProcedureLinesLast( _
        module As VBComponent, _
        Procedure As String, _
        Optional IncludeTail As Boolean) As Long
    Dim ProcKind    As VBIDE.vbext_ProcKind
    ProcKind = vbext_pk_Proc
    Dim startAt     As Long
    startAt = module.CodeModule.procStartLine(Procedure, ProcKind)
    Dim CountOf     As Long
    CountOf = module.CodeModule.ProcCountLines(Procedure, ProcKind)
    Dim endAt       As Long
    endAt = startAt + CountOf - 1
    If Not IncludeTail Then
        Do While Not Trim(module.CodeModule.Lines(endAt, 1)) Like "End *"
            endAt = endAt - 1
        Loop
    End If
    ProcedureLinesLast = endAt
End Function

Sub ProcedureLinesRemove( _
        myCriteria As String, _
        Optional TargetWorkbook As Workbook, _
        Optional module As VBComponent, _
        Optional Procedure As String)
    If Not AssignCPSvariables(TargetWorkbook, module, Procedure) Then Stop

    Dim Code        As String
    Dim i           As Long
    For i = ProcedureLinesLast(module, Procedure) To ProcedureLinesFirst(module, Procedure) Step -1
        Code = Trim(module.CodeModule.Lines(i, 1))
        If Code Like myCriteria Then module.CodeModule.DeleteLines i
    Next
End Sub

Sub ProcedureLinesRemoveInclude( _
        Optional TargetWorkbook As Workbook, _
        Optional module As VBComponent, _
        Optional Procedure As String)
    If Not AssignCPSvariables(TargetWorkbook, module, Procedure) Then Stop
    ProcedureLinesRemove "'@INCLUDE", TargetWorkbook, module, Procedure
End Sub


Sub ProcedureMoveHere( _
        Optional Procedure As String)


    Dim TargetWorkbook As Workbook
    Set TargetWorkbook = ActiveCodepaneWorkbook
    If Not AssignProcedureVariable(TargetWorkbook, Procedure) Then Exit Sub
    Dim module      As VBComponent
    Set module = ModuleOfProcedure(TargetWorkbook, Procedure)
    Dim S           As String
    S = ProcedureCode(TargetWorkbook, module, Procedure)

    If InStr(1, S, "'@AssignedModule") = 0 Then
        ProcedureAssignedModuleAdd TargetWorkbook, module, Procedure
        S = ProcedureCode(TargetWorkbook, module, Procedure)
    End If

    Dim sl As Long, cl As Long
    sl = ProcedureLinesFirst(module, Procedure)
    cl = ProcedureLinesLast(module, Procedure, False) - sl + 1
    ActiveModule.CodeModule.InsertLines ProcedureLinesLast(module, ActiveProcedure, True) + 1, S
    module.CodeModule.DeleteLines sl, cl
End Sub

Sub ProcedureMoveToAssignedModule( _
        Optional TargetWorkbook As Workbook, _
        Optional module As VBComponent, _
        Optional Procedure As String)
    If Not AssignCPSvariables(TargetWorkbook, module, Procedure) Then Exit Sub
    Dim MoveToModule As VBComponent
    Set MoveToModule = ProcedureAssignedModule(TargetWorkbook, module, Procedure)
    If MoveToModule Is Nothing Then Exit Sub
    ProcedureMoveToModule TargetWorkbook, module, Procedure, MoveToModule
End Sub

Sub ProcedureMoveToModule( _
        TargetWorkbook As Workbook, _
        module As VBComponent, _
        Procedure As String, _
        MoveToModule As VBComponent)
    Dim Code        As String
    Code = ProcedureCode(TargetWorkbook, module, Procedure)
    Dim startLine   As Long
    startLine = ProcedureLinesFirst(module, Procedure)
    Dim CountLines  As Long
    CountLines = ProcedureLinesCount(module, Procedure)
    MoveToModule.CodeModule.InsertLines MoveToModule.CodeModule.CountOfLines + 1, vbNewLine & Code
    module.CodeModule.DeleteLines startLine, CountLines

End Sub

Public Sub ProcedureReplace( _
        module As VBComponent, _
        Procedure As String, _
        Code As String)

    Dim startLine   As Integer
    Dim NumLines    As Integer
    With module.CodeModule
        startLine = .procStartLine(Procedure, vbext_pk_Proc)
        NumLines = .ProcCountLines(Procedure, vbext_pk_Proc)
        .DeleteLines startLine, NumLines
        .InsertLines startLine, Code
    End With
End Sub

Function ProcedureTitle( _
        module As VBComponent, _
        Procedure As String) As String
    Dim titleLine   As Long
    titleLine = ProcedureTitleLineFirst(module, Procedure)
    Dim Title       As String
    Title = module.CodeModule.Lines(titleLine, 1)
    Dim counter     As Long
    counter = 1
    Do While Right(Title, 1) = "_"
        counter = counter + 1
        Title = module.CodeModule.Lines(titleLine, counter)
    Loop

    ProcedureTitle = Title
End Function

Function ProcedureTitleLineCount( _
        module As VBComponent, _
        Procedure As String) As Long

    ProcedureTitleLineCount = ProcedureTitleLineLast(module, Procedure) - ProcedureTitleLineFirst(module, Procedure) + 1
End Function



Public Function ProcedureTitleLineFirst( _
        module As VBComponent, _
        Procedure As String) As Long
    ProcedureTitleLineFirst = module.CodeModule.ProcBodyLine(Procedure, vbext_pk_Proc)
End Function

Function ProcedureTitleLineLast( _
        module As VBComponent, _
        Procedure As String) As Long
    ProcedureTitleLineLast = ProcedureTitleLineFirst(module, Procedure) + UBound(Split(ProcedureTitle(module, Procedure), vbNewLine))
End Function

Public Function ProceduresOfModule( _
        module As VBComponent) As Collection
    Dim ProcKind    As VBIDE.vbext_ProcKind
    Dim lineNum     As Long
    Dim coll        As New Collection
    Dim Procedure   As String
    With module.CodeModule
        lineNum = .CountOfDeclarationLines + 1
        Do Until lineNum >= .CountOfLines
            ProcedureAs = .ProcOfLine(lineNum, ProcKind)
            coll.Add ProcedureAs
            lineNum = .procStartLine(ProcedureAs, ProcKind) + .ProcCountLines(ProcedureAs, ProcKind) + 1
        Loop
    End With
    Set ProceduresOfModule = coll
End Function

Function ProceduresOfTXT( _
        Code As String) As Collection


    Code = Replace(Code, vbNewLine, vbLf)
    Dim var
    var = Split(Code, vbLf)

    Dim out
    out = ArrayAppend(Filter(var, "Sub" & Space(1), True, vbBinaryCompare), Filter(var, "Function ", True, vbBinaryCompare))
    If TypeName(out) = "Empty" Then Exit Function
    out = Filter(out, "(", True)
    out = Filter(out, "Declare", False)
    out = Filter(out, Chr(34) & "Sub", False)
    out = Filter(out, Chr(34) & "Function", False)
    out = Filter(out, "End Sub", False)
    out = Filter(out, "End Function", False)

    Dim i           As Long
    For i = LBound(out) To UBound(out)
        out(i) = Left(out(i), InStr(1, out(i), "(") - 1)
        out(i) = Replace(out(i), "Private ", "")
        out(i) = Replace(out(i), "Public ", "")
        out(i) = Replace(out(i), "Sub ", "")
        out(i) = Replace(out(i), "Function ", "")
        If UBound(Split(out(i), " ")) > 0 Then
            out(i) = ""
        End If
    Next

    ArrayQuickSort out
    out = cleanArray(out)
    out = ArrayDuplicatesRemove(out)
    Set ProceduresOfTXT = ArrayToCollection(out)
End Function

Sub CallSeparateProcedures()
    Dim FilePath    As Variant
    FilePath = DataFilePicker("*.txt", False)
    If FilePath = vbNullString Then Exit Sub
    Dim OutputFolder As Variant
    OutputFolder = SelectFolder(Left(FilePath, InStrRev(FilePath, "\")))

    TxtSeparateProcedures FilePath, OutputFolder

End Sub

Sub TxtSeparateProcedures(FilePath As Variant, Optional OutputFolder As Variant)

    '@AssignedModule F_FileFolder
    '@INCLUDE PROCEDURE TxtOverwrite
    '@INCLUDE PROCEDURE TxtRead
    Dim fname       As String
    If OutputFolder = "" Then
        OutputFolder = Left(FilePath, InStrRev(FilePath, "\"))
    Else
        FoldersCreate CStr(OutputFolder)
    End If
    Dim Code        As Variant
    Code = Split(TxtRead(FilePath), vbLf)
    Dim out         As String
    Dim i           As Long
    For i = LBound(Code) To UBound(Code)

        out = IIf(out = "", Code(i), out & Code(i)) & vbNewLine
        If RegexTest(Code(i), "Sub ") _
                And Not Code(i) Like Chr(34) & "*Sub*" Then
            fname = Split(Code(i), "Sub ")(1)
            fname = Trim(Split(fname, "(")(0)) & ".txt"
        ElseIf RegexTest(Code(i), "Function ") _
                And Not Code(i) Like Chr(34) & "*Function*" Then
            fname = Split(Code(i), "Function ")(1)
            fname = Trim(Split(fname, "(")(0)) & ".txt"
        End If
        If Trim(Code(i)) = "End Sub" Or Trim(Code(i)) = "End Function" Then
            TxtOverwrite OutputFolder & fname, out
            out = ""
            fname = ""
        End If
    Next

End Sub

Function ProceduresOfWorkbook( _
        TargetWorkbook As Workbook, _
        Optional ExcludeDocument As Boolean = True, _
        Optional ExcludeClass As Boolean = True, _
        Optional ExcludeForm As Boolean = True) As Collection
    Dim module      As VBComponent
    Dim ProcKind    As VBIDE.vbext_ProcKind
    Dim lineNum     As Long
    Dim coll        As New Collection
    Dim ProcedureName As String
    For Each module In TargetWorkbook.VBProject.VBComponents
        If ExcludeClass = True And module.Type = vbext_ct_ClassModule Then GoTo SKIP
        If ExcludeDocument = True And module.Type = vbext_ct_Document Then GoTo SKIP
        If ExcludeForm = True And module.Type = vbext_ct_MSForm Then GoTo SKIP
        With module.CodeModule
            lineNum = .CountOfDeclarationLines + 1
            Do Until lineNum >= .CountOfLines
                ProcedureName = .ProcOfLine(lineNum, ProcKind)
                If InStr(1, ProcedureName, "_") = 0 Then
                    coll.Add ProcedureName
                End If
                lineNum = .procStartLine(ProcedureName, ProcKind) + .ProcCountLines(ProcedureName, ProcKind) + 1
            Loop
        End With
SKIP:
    Next module
    Set ProceduresOfWorkbook = coll
End Function

Sub ProjetFoldersCreate()
    Dim element
    For Each element In vbarcFolders
        FoldersCreate CStr(element)
    Next
End Sub

Public Function RegexTest( _
        ByVal string1 As String, _
        ByVal stringPattern As String, _
        Optional ByVal globalFlag As Boolean, _
        Optional ByVal ignoreCaseFlag As Boolean, _
        Optional ByVal multilineFlag As Boolean) As Boolean
    Dim REGEX       As Object
    Set REGEX = CreateObject("VBScript.RegExp")
    With REGEX
        .Global = globalFlag
        .IgnoreCase = ignoreCaseFlag
        .MultiLine = multilineFlag
        .pattern = stringPattern
    End With
    RegexTest = REGEX.test(string1)
End Function

'* Modified   : Date and Time       Author              Description
'* Updated    : 22-08-2023 11:03    Alex                (Dependencies.bas > StringLastModified)

Function StringLastModified(txt As String)
'@LastModified 2308221103

    Dim Code        As Variant
    Code = Filter(Filter(Split(txt, vbLf), "'@LastModified ", True), """", False)
    If ArrayAllocated(Code) Then
        Dim lastDate As Variant
        If Trim(Code(0)) Like "'@LastModified *" Then
            lastDate = Split(Code(0), " ")(1)
            lastDate = DateSerial(Left(lastDate, 2), Mid(lastDate, 3, 2), Mid(lastDate, 5, 2)) _
                    & " " & TimeSerial(Mid(lastDate, 7, 2), Mid(lastDate, 9, 2), 0)
            StringLastModified = Split(Code(0), " ")(1)
        End If
    Else

    End If
End Function

Function StringProcedureAssignedModule(txt As String) As String
    Dim ComponentName As Variant
    ComponentName = Split(txt, vbLf)
    ComponentName = Filter(ComponentName, "'@AssignedModule")
    If Not ArrayAllocated(ComponentName) Then Exit Function
    Dim ub          As Long
    ub = UBound(Split(ComponentName(0), " "))
    ComponentName = Split(ComponentName(0), " ")(ub)
    StringProcedureAssignedModule = ComponentName
End Function



Function TXTReadFromUrl(url As String) As String
    On Error GoTo Err_GetFromWebpage
    Dim objWeb      As Object
    Dim strXML      As String
    Set objWeb = CreateObject("Msxml2.ServerXMLHTTP")
    objWeb.Open "GET", url, False
    objWeb.setRequestHeader "Content-Type", "text/xml"
    objWeb.setRequestHeader "Cache-Control", "no-cache"
    objWeb.setRequestHeader "Pragma", "no-cache"
    objWeb.send
    Do While objWeb.readyState <> 4
        DoEvents
    Loop
    strXML = objWeb.responseText
    TXTReadFromUrl = strXML
End_GetFromWebpage:
    Set objWeb = Nothing
    Exit Function
Err_GetFromWebpage:
    MsgBox Err.Description & " (" & Err.Number & ")"
    Resume End_GetFromWebpage
End Function

Sub TxtOverwrite(sFile As String, sText As String)
    On Error GoTo ERR_HANDLER
    Dim FileNumber  As Integer
    FileNumber = FreeFile
    Open sFile For Output As #FileNumber
    Print #FileNumber, sText
    Close #FileNumber
Exit_Err_Handler:
    Exit Sub
ERR_HANDLER:
    MsgBox "The following error has occurred" & vbCrLf & vbCrLf & _
            "Error Number: " & Err.Number & vbCrLf & _
            "Error Source: TxtOverwrite" & vbCrLf & _
            "Error Description: " & Err.Description, vbCritical, "An Error has Occurred!"
    GoTo Exit_Err_Handler
End Sub

Sub TxtPrepend(FilePath As String, txt As String)
    Dim S           As String
    S = TxtRead(FilePath)
    TxtOverwrite FilePath, txt & vbNewLine & S
End Sub


Sub CallTxtPrependContainedProcedures()
    Dim FilePath    As Variant
    FilePath = DataFilePicker("*.txt", False)
    If FilePath = vbNullString Then Exit Sub
    TxtPrependContainedProcedures CStr(FilePath)
End Sub

Sub TxtPrependContainedProcedures(fileName As String)
    Dim S           As String: S = TxtRead(fileName)
    Dim V           As New Collection
    Set V = ProceduresOfTXT(S)
    If V.Count = 0 Then Exit Sub
    Dim line        As String: line = String(30, "'")
    TxtPrepend fileName, _
            "'Contains the following " & "#" & V.Count & " procedures " & vbNewLine & line & vbNewLine & _
            "'" & collectionToString(V, vbNewLine & "'") & vbNewLine & line & vbNewLine & vbNewLine
End Sub

Function TxtRead(sPath As Variant) As String
    Dim sTXT        As String
    If Dir(sPath) = "" Then
        Debug.Print "File was not found."
        Debug.Print sPath
        Exit Function
    End If
    Open sPath For Input As #1
    Do Until EOF(1)
        Line Input #1, sTXT
        TxtRead = TxtRead & sTXT & vbLf
    Loop
    Close
    If Len(TxtRead) = 0 Then
        TxtRead = ""
    Else
        TxtRead = Left(TxtRead, Len(TxtRead) - 1)
    End If
End Function

Function URLExists(url) As Boolean
    Dim Request     As Object
    Dim FF          As Integer
    Dim rc          As Variant

    On Error GoTo EndNow
    Set Request = CreateObject("WinHttp.WinHttpRequest.5.1")

    With Request
        .Open "GET", url, False
        .send
        rc = .statusText
    End With
    Set Request = Nothing
    If rc = "OK" Then URLExists = True

    Exit Function
EndNow:
End Function

Function UserformNames(TargetWorkbook As Workbook)
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Set UserformNames = ComponentNames(vbext_ct_MSForm, TargetWorkbook)
End Function






Function WorkbookCode(TargetWorkbook) As String
    If TypeName(TargetWorkbook) <> "Workbook" Then Stop
    Dim module      As VBComponent
    Dim txt
    For Each module In TargetWorkbook.VBProject.VBComponents
        If module.CodeModule.CountOfLines > 0 Then
            txt = txt & _
                    vbNewLine & _
                    "'" & String(10, "=") & ModuleOrSheetName(module) & " (" & module.Type & ") " & String(10, "=") & _
                    vbNewLine & _
                    ModuleCode(module)
        End If
    Next
    WorkbookCode = txt
End Function


Function WorkbookOfModule(vbComp As VBComponent) As Workbook
    Set WorkbookOfModule = WorkbookOfProject(vbComp.Collection.Parent)
End Function

Function WorkbookOfProject(vbProj As VBProject) As Workbook
    tmpStr = vbProj.fileName
    tmpStr = Right(tmpStr, Len(tmpStr) - InStrRev(tmpStr, "\"))
    Set WorkbookOfProject = Workbooks(tmpStr)
End Function



Function WorksheetExists(SheetName As String, TargetWorkbook As Workbook) As Boolean
    Dim TargetWorksheet As Worksheet
    On Error Resume Next
    Set TargetWorksheet = TargetWorkbook.Sheets(SheetName)
    On Error GoTo 0
    WorksheetExists = Not TargetWorksheet Is Nothing
End Function

Function classCallsOfModule(module As VBComponent) As Variant


    Dim Code        As Variant
    Dim element     As Variant
    Dim Keyword     As Variant
    Dim var         As Variant
    ReDim var(1 To 2, 1 To 1)
    Dim counter     As Long
    counter = 0
    If module.CodeModule.CountOfDeclarationLines > 0 Then
        Code = module.CodeModule.Lines(1, module.CodeModule.CountOfDeclarationLines)
        Code = Replace(Code, "_" & vbNewLine, "")
        Code = Split(Code, vbNewLine)
        Code = Filter(Code, " As ", , vbTextCompare)
        For Each element In Code
            element = Trim(element)
            If element Like "* As *" Then
                Keyword = Split(element, " As ")(0)
                Keyword = Split(Keyword, " ")(UBound(Split(Keyword, " ")))
                element = Split(element, " As ")(1)
                element = Replace(element, "New ", "")

                For Each ClassName In ClassNames
                    If element = ClassName Then

                        ReDim Preserve var(1 To 2, 1 To counter + 1)
                        var(1, UBound(var, 2)) = element
                        var(2, UBound(var, 2)) = Keyword
                        counter = counter + 1
                    End If
                Next
            End If
        Next
        If var(1, 1) <> "" Then

            If UBound(var, 2) > 1 Then
                classCallsOfModule = WorksheetFunction.Transpose(var)
            Else
                Dim VAR2(1 To 1, 1 To 2)
                VAR2(1, 1) = var(1, 1)
                VAR2(1, 2) = var(2, 1)
                classCallsOfModule = VAR2
            End If
        End If
    End If

End Function

Function collectionToString(coll As Collection, delim As String) As String
    Dim element
    Dim out         As String
    For Each element In coll
        out = IIf(out = "", element, out & delim & element)
    Next
    collectionToString = out
End Function

Function getDeclarations( _
        wb As Workbook, _
        Optional includeScope As Boolean, _
        Optional includeType As Boolean, _
        Optional includeKeywords As Boolean, _
        Optional includeDeclarations As Boolean, _
        Optional includeComponentName As Boolean, _
        Optional includeComponentType As Boolean) As Collection

    Dim ComponentCollection As New Collection
    Dim ComponentTypecollection As New Collection
    Dim DeclarationsCollection As New Collection
    Dim KeywordsCollection As New Collection
    Dim Output      As New Collection
    Dim ScopeCollection As New Collection
    Dim TypeCollection As New Collection

    Dim element     As Variant
    Dim OriginalDeclarations As Variant
    Dim str         As Variant

    Dim tmp         As String
    Dim helper      As String
    Dim i           As Long

    Dim module      As VBComponent
    For Each module In wb.VBProject.VBComponents
        If module.Type = vbext_ct_StdModule Or module.Type = vbext_ct_MSForm Then
            If module.CodeModule.CountOfDeclarationLines > 0 Then
                str = module.CodeModule.Lines(1, module.CodeModule.CountOfDeclarationLines)
                str = Replace(str, "_" & vbNewLine, "")
                OriginalDeclarations = str
                tmp = str
                Do While InStr(1, str, "End Type") > 0
                    tmp = Mid(str, InStr(1, str, "Type "), InStr(1, str, "End Type") - InStr(1, str, "Type ") + 8)
                    str = Replace(str, tmp, Split(tmp, vbNewLine)(0))
                Loop
                Do While InStr(1, str, "End Enum") > 0
                    tmp = Mid(str, InStr(1, str, "Enum "), InStr(1, str, "End Enum") - InStr(1, str, "Enum ") + 8)
                    str = Replace(str, tmp, Split(tmp, vbNewLine)(0))
                Loop
                Do While InStr(1, str, "  ") > 0
                    str = Replace(str, "  ", " ")
                Loop

                str = Split(str, vbNewLine)
                tmp = OriginalDeclarations

                For Each element In str
                    If Len(CStr(element)) > 0 And Not Trim(CStr(element)) Like "'*" And Not Trim(CStr(element)) Like "Rem*" Then
                        If RegexTest(CStr(element), "\b ?Enum \b") Then
                            KeywordsCollection.Add DeclarationsKeywordSubstring(CStr(element), " ", "Enum")
                            DeclarationsCollection.Add DeclarationsKeywordSubstring(tmp, , "Enum " & KeywordsCollection.item(KeywordsCollection.Count), "End Enum", , , True)
                            TypeCollection.Add "Enum"
                            ComponentCollection.Add module.Name
                            ComponentTypecollection.Add ModuleTypeToString(module.Type)
                            ScopeCollection.Add IIf(InStr(1, DeclarationsCollection.item(DeclarationsCollection.Count), "Public", vbTextCompare), "Public", "Private")
                        ElseIf RegexTest(CStr(element), "\b ?Type \b") Then
                            KeywordsCollection.Add DeclarationsKeywordSubstring(CStr(element), " ", "Type")
                            DeclarationsCollection.Add DeclarationsKeywordSubstring(tmp, , "Type " & KeywordsCollection.item(KeywordsCollection.Count), "End Type", , , True)
                            TypeCollection.Add "Type"
                            ComponentCollection.Add module.Name
                            ComponentTypecollection.Add ModuleTypeToString(module.Type)
                            ScopeCollection.Add IIf(InStr(1, DeclarationsCollection.item(DeclarationsCollection.Count), "Public", vbTextCompare), "Public", "Private")
                        ElseIf InStr(1, CStr(element), "Const ", vbTextCompare) > 0 Then
                            KeywordsCollection.Add DeclarationsKeywordSubstring(CStr(element), " ", "Const")
                            DeclarationsCollection.Add CStr(element)
                            TypeCollection.Add "Const"
                            ComponentCollection.Add module.Name
                            ComponentTypecollection.Add ModuleTypeToString(module.Type)
                            ScopeCollection.Add IIf(InStr(1, DeclarationsCollection.item(DeclarationsCollection.Count), "Public", vbTextCompare), "Public", "Private")
                        ElseIf RegexTest(CStr(element), "\b ?Sub \b") Then
                            KeywordsCollection.Add DeclarationsKeywordSubstring(CStr(element), " ", "Sub")
                            DeclarationsCollection.Add CStr(element)
                            TypeCollection.Add "Sub"
                            ComponentCollection.Add module.Name
                            ComponentTypecollection.Add ModuleTypeToString(module.Type)
                            ScopeCollection.Add IIf(InStr(1, DeclarationsCollection.item(DeclarationsCollection.Count), "Public", vbTextCompare), "Public", "Private")
                        ElseIf RegexTest(CStr(element), "\b ?Function \b") Then
                            KeywordsCollection.Add DeclarationsKeywordSubstring(CStr(element), " ", "Function")
                            DeclarationsCollection.Add CStr(element)
                            TypeCollection.Add "Function"
                            ComponentCollection.Add module.Name
                            ComponentTypecollection.Add ModuleTypeToString(module.Type)
                            ScopeCollection.Add IIf(InStr(1, DeclarationsCollection.item(DeclarationsCollection.Count), "Public", vbTextCompare), "Public", "Private")
                        ElseIf element Like "*(*) As *" Then
                            helper = Left(element, InStr(1, CStr(element), "(") - 1)
                            helper = Mid(helper, InStrRev(helper, " ") + 1)
                            KeywordsCollection.Add helper
                            DeclarationsCollection.Add CStr(element)
                            TypeCollection.Add "Other"
                            ComponentCollection.Add module.Name
                            ComponentTypecollection.Add ModuleTypeToString(module.Type)
                            ScopeCollection.Add IIf(InStr(1, DeclarationsCollection.item(DeclarationsCollection.Count), "Public", vbTextCompare), "Public", "Private")
                        ElseIf element Like "* As *" Then
                            KeywordsCollection.Add DeclarationsKeywordSubstring(CStr(element), " ", , "As")
                            DeclarationsCollection.Add CStr(element)
                            TypeCollection.Add "Other"
                            ComponentCollection.Add module.Name
                            ComponentTypecollection.Add ModuleTypeToString(module.Type)
                            ScopeCollection.Add IIf(InStr(1, DeclarationsCollection.item(DeclarationsCollection.Count), "Public", vbTextCompare), "Public", "Private")
                        Else
                        End If
                    End If
                Next element
            End If
        End If
    Next module

    If includeScope = True Then Output.Add ScopeCollection
    If includeType = True Then Output.Add TypeCollection
    If includeKeywords = True Then Output.Add KeywordsCollection
    If includeDeclarations = True Then Output.Add DeclarationsCollection
    If includeComponentType = True Then Output.Add ComponentTypecollection
    If includeComponentName = True Then Output.Add ComponentCollection

    Set getDeclarations = Output
End Function

Function getLastRow(TargetSheet As Worksheet)
    Dim LastCell    As Range
    Set LastCell = TargetSheet.Cells.Find("*", SearchOrder:=xlByRows, SearchDirection:=xlPrevious)
    getLastRow = LastCell.Row
End Function

Function vbarcFolders() As Collection
    Dim coll        As New Collection
    coll.Add LOCAL_LIBRARY_PROCEDURES
    coll.Add LOCAL_LIBRARY_CLASSES
    coll.Add LOCAL_LIBRARY_USERFORMS
    coll.Add LOCAL_LIBRARY_DECLARATIONS
    Set vbarcFolders = coll
End Function

Function ProcedureLineContaining(module As VBComponent, Procedure As String, this As String) As Long
    Dim i           As Long
    For i = ProcedureLinesFirst(module, Procedure) To ProcedureLinesLast(module, Procedure)
        If module.CodeModule.Lines(i, 1) Like this Then
            ProcedureLineContaining = i
            Exit Function
        End If
    Next
End Function

Public Function ClearClipboard()
    OpenClipboard (0&)
    EmptyClipboard
    CloseClipboard
End Function

Public Function CLIP(Optional StoreText As String) As String
    Dim X           As Variant
    X = StoreText
    With CreateObject("htmlfile")
        With .parentWindow.clipboardData
            Select Case True
                Case Len(StoreText)
                    .SetData "text", X
                Case Else
                    CLIP = .GetData("text")
            End Select
        End With
    End With
End Function



'aCodeModule	Class


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Class      : aCodeModule
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 04-05-2023 12:17    Alex
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Dim oWorkbook       As Workbook
Dim oModule         As VBComponent
Private cm          As CodeModule

Public ColumnFirst  As Long
Public ColumnLast    As Long
Public rowCount      As Long
Public RowFirst      As Long
Public RowLast       As Long

Public CodemoduleSelection     As String
Public SelectionAfter          As String
Public SelectionBefore         As String
Public SelectionLength         As Long
Public SelectionLinesCode      As String

'* Modified   : Date and Time       Author              Description
'* Updated    : 22-08-2023 11:01    Alex                (aCodeModule.cls > ActivateProcedure)

Public Sub ActivateProcedure()
'@LastModified 2308221101
    aProcedure.Init(ActiveCodepaneWorkbook, ActiveModule, CodemoduleSelection).Activate
End Sub

Public Sub ImportProcedure()
    '@INCLUDE CLASS aCodeModule
    '@INCLUDE CLASS aProcedure
    '@AssignedModule aCodeModule
    aProcedure.Active.ImportProcedure CodemoduleSelection, False
End Sub

Public Function Parent() As VBComponent
    Set Parent = oModule
End Function
Public Function Active() As aCodeModule
    '@INCLUDE PROCEDURE ActiveModule
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    Init ActiveModule
    Set Active = Me
End Function

Public Function Init(module As VBComponent) As aCodeModule
    '@INCLUDE PROCEDURE WorkbookOfModule
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    Set oModule = module
    Set cm = oModule.CodeModule
    Set oWorkbook = WorkbookOfModule(module)
    AssignVariables
    Set Init = Me
End Function

Private Sub Class_Terminate()
    'do something
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule

End Sub

Private Sub AssignVariables()
    '@INCLUDE PROCEDURE CountOfCharacters
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule

    Dim startLine As Long, StartColumn As Long, endLine As Long, EndColumn As Long
    cm.CodePane.GetSelection startLine, StartColumn, endLine, EndColumn

    ColumnFirst = StartColumn
    ColumnLast = EndColumn

    RowFirst = startLine
    RowLast = endLine
    If RowLast > startLine And EndColumn = 1 Then
        RowLast = endLine - 1
    End If
    rowCount = RowLast - RowFirst + 1

    SelectionLinesCode = cm.Lines(RowFirst, rowCount)


    If ColumnLast - ColumnFirst = 0 Then
        If endLine > RowLast Then
            ColumnLast = Len(cm.Lines(RowLast, 1)) + 1
        End If
    End If

    SelectionAfter = Mid(cm.Lines(RowLast, 1), ColumnLast)    ' + IIf(Len(CodemoduleSelection) > 0, 1, 0))
    SelectionBefore = Mid(cm.Lines(RowFirst, 1), 1, ColumnFirst - 1)

    If rowCount = 1 And (ColumnLast - ColumnFirst > 0) Then
        SelectionLength = ColumnLast - ColumnFirst
    Else
        SelectionLength = Len(SelectionLinesCode) - Len(SelectionBefore) - Len(SelectionAfter) - 1 - Len(CountOfCharacters(SelectionLinesCode, vbNewLine)) * 2
    End If

    If RowLast - RowFirst = 0 Then
        CodemoduleSelection = Mid(cm.Lines(RowFirst, 1), ColumnFirst, ColumnLast - ColumnFirst)
        Exit Sub
    End If
    Dim str         As String
    Dim i           As Long
    For i = RowFirst To RowLast
        If str = "" Then
            str = Mid(cm.Lines(i, 1), ColumnFirst)
        ElseIf i < RowLast Then
            str = str & vbNewLine & cm.Lines(i, 1)
        Else
            str = str & vbNewLine & Left(cm.Lines(i, 1), ColumnLast - 1)
        End If
    Next
    CodemoduleSelection = str

End Sub

Sub Todo()
    '@INCLUDE CLASS aCodeModule
    '@INCLUDE DECLARATION AUTHOR_NAME
    '@AssignedModule aCodeModule
    Const tFormat = "dd-mm-yyyy hh:nn"
    Dim module      As VBComponent
    Set module = oModule
    Dim txtName     As String
    txtName = AUTHOR_NAME
    If txtName = vbNullString Then txtName = Environ("UserName")
    Dim nLine       As Long
    nLine = aCodeModule.Init(module).RowFirst
    Do While nLine > 1 And Right(module.CodeModule.Lines(nLine, 1), 1) = "_"
        nLine = nLine - 1
    Loop
    Dim sLine       As String
    sLine = module.CodeModule.Lines(nLine, 1)
    Dim sSpec       As String
    sSpec = Space(Len(sLine) - Len(Trim(sLine)))
    Dim sTodo       As String
    sTodo = sSpec & "'* @TODO Created: " & _
            VBA.Format$(Now, tFormat) & _
            " Author: " & txtName & vbCrLf & _
            sSpec & "'* @TODO "
    module.CodeModule.InsertLines nLine, vbNewLine & sTodo & vbNewLine
End Sub

Sub ToggleComments()
    '@INCLUDE PROCEDURE IsCommentLine
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    Dim sLine       As String
    Dim i           As Long
    For i = RowFirst To RowLast
        sLine = cm.Lines(i, 1)
        If IsCommentLine(sLine) Then
            If Trim(sLine) Like "Rem*" Then
                UnremTargetLine i
            ElseIf Trim(sLine) Like "'*" Then
                UncommentTargetLine i
            End If
        Else
            CommentTargetLine i
        End If
    Next
    SetSelection RowFirst, 1, RowLast, 10000
End Sub

Public Sub DimSeparate()
    '@INCLUDE PROCEDURE StringFormatAlignRowsElements
    '@INCLUDE PROCEDURE IndentationCount
    '@INCLUDE CLASS aCodeModule
    '@INCLUDE CLASS aCollection
    '@AssignedModule aCodeModule
    Dim coll        As New Collection
    Dim Code        As String: Code = SelectionLinesCode
    Dim FirstLine   As Long: FirstLine = RowFirst
    Dim iSpace      As Long
    Dim iCount      As Long: iCount = rowCount

    If iCount = 1 Then
        iSpace = IndentationCount(cm.Lines(FirstLine, 1))
        Code = cm.Lines(FirstLine, iCount)
        Code = Join(Split(Code, ", "), vbNewLine & Space(iSpace) & "Dim ")
    Else
        Dim element
        For Each element In Split(Code, vbNewLine)
            iSpace = IndentationCount(CStr(element))
            coll.Add Join(Split(element, ", "), vbNewLine & Space(iSpace) & "Dim ")
        Next
        Code = aCollection.Init(coll).ToString(vbNewLine)
    End If
    Code = StringFormatAlignRowsElements(Code, " As ", True)

    cm.DeleteLines FirstLine, iCount
    cm.InsertLines FirstLine, Code
    SetSelection FirstLine, 1, FirstLine + UBound(Split(Code, vbNewLine)), 10000
End Sub

Public Sub DimMerge()
    '@INCLUDE PROCEDURE RegExpReplace
    '@INCLUDE PROCEDURE IndentationCount
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    Dim Code        As String: Code = SelectionLinesCode
    Dim FirstLine   As Long: FirstLine = RowFirst
    Dim iCount      As Long: iCount = rowCount
    Dim iSpace      As Long: iSpace = IndentationCount(cm.Lines(FirstLine, 1))
    Code = cm.Lines(FirstLine, iCount)
    If Code Like "*" & vbNewLine Then Code = Left(Code, Len(Code) - Len(vbNewLine))
    Code = Replace(Join(Split(Code, vbNewLine)), "Dim ", ", ")
    Code = Replace(Code, ",", "Dim", , 1)
    Code = Space(iSpace) & RegExpReplace(Code, "\s{2,}", " ")
    Code = Replace(Code, " ,", ",")
    Code = Mid(Code, 2)
    cm.DeleteLines FirstLine, iCount
    cm.InsertLines FirstLine, Code
    SetSelection FirstLine, 1, FirstLine, 10000
End Sub

Public Sub SetSelection(startLine As Long, StartColumn As Long, endLine As Long, EndColumn As Long)
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    cm.CodePane.SetSelection startLine, StartColumn, endLine, EndColumn
    AssignVariables
End Sub

Public Sub Move_Up()
    '@INCLUDE PROCEDURE ActiveProcedure
    '@INCLUDE CLASS aCodeModule
    '@INCLUDE CLASS aProcedure
    '@AssignedModule aCodeModule
    Dim blockStart  As Long: blockStart = RowFirst
    Dim blockEnd    As Long: blockEnd = RowLast
    Dim blockCountOfLines As Long: blockCountOfLines = blockEnd - blockStart + 1
    Dim blockString As String: blockString = cm.Lines(blockStart, blockCountOfLines)
    Dim insertBlockAtLine As Long: insertBlockAtLine = blockStart - 1
    Dim ap          As String: ap = ActiveProcedure
    If ap = "" Then Exit Sub
    Select Case insertBlockAtLine
        Case 1, aProcedure.Init(, , ap).Line_Declaration_First
            Exit Sub
    End Select
    cm.DeleteLines blockStart, blockCountOfLines
    cm.InsertLines insertBlockAtLine, blockString
    SetSelection insertBlockAtLine, 1, insertBlockAtLine + blockCountOfLines - 1, 10000
End Sub

Public Sub Move_Down()
    '@INCLUDE PROCEDURE ActiveProcedure
    '@INCLUDE CLASS aCodeModule
    '@INCLUDE CLASS aProcedure
    '@AssignedModule aCodeModule
    Dim blockStart  As Long: blockStart = RowFirst
    Dim blockEnd    As Long: blockEnd = RowLast
    Dim blockCountOfLines As Long: blockCountOfLines = blockEnd - blockStart + 1
    Dim blockString As String: blockString = cm.Lines(blockStart, blockCountOfLines)
    Dim insertBlockAtLine As Long: insertBlockAtLine = blockStart + 1
    Dim ap          As String: ap = ActiveProcedure
    If ap = "" Then Exit Sub
    Select Case insertBlockAtLine + blockCountOfLines - 1
        Case cm.CountOfLines, aProcedure.Init(, , ap).Line_Last
            Exit Sub
    End Select
    cm.DeleteLines blockStart, blockCountOfLines
    cm.InsertLines insertBlockAtLine, blockString
    SetSelection insertBlockAtLine, 1, insertBlockAtLine + blockCountOfLines - 1, 10000
End Sub

Public Sub Inject(str As String)
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    Dim Code        As String: Code = SelectionBefore & str & SelectionAfter
    Dim endLine     As Long
    'catch error when selected all lines
    If rowCount > cm.CountOfLines Then endLine = endLine - 1
    cm.DeleteLines RowFirst, rowCount
    cm.InsertLines RowFirst, Code
'    Debug.Print cm.Name & vbTab & RowFirst
    SetSelection RowFirst, _
            ColumnFirst, _
            RowFirst + UBound(Split(str, vbLf)), _
            IIf((UBound(Split(str, vbLf))) = 0, ColumnLast, 1) + Len(Split(str, vbLf)(UBound(Split(str, vbLf))))
End Sub

Public Sub Insert(str As String)
    cm.InsertLines RowFirst, str
End Sub


Private Function CopyTemplateFromSheet(Template As String)
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    Dim cell        As Range
    Dim ws          As Worksheet
    Set ws = ThisWorkbook.Sheets("Templates")
    On Error Resume Next
    Set cell = ws.Columns(1).SpecialCells(xlCellTypeConstants).Find(Template, LookAt:=xlWhole)
    On Error GoTo 0

    CopyTemplateFromSheet = cell.offset(0, 1)
End Function

Private Sub InjectTemplateFromSheet(Template As String)
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    If Len(Selection) > 0 Then Exit Sub
    Dim ws          As Worksheet: Set ws = ThisWorkbook.Sheets("Templates")
    Dim cell        As Range
    On Error Resume Next
    Set cell = ws.Columns(1).SpecialCells(xlCellTypeConstants).Find(Template, LookAt:=xlWhole)
    On Error GoTo 0
    If Not cell Is Nothing Then Inject cell.offset(0, 1)
End Sub

Public Sub Format_VBA7()
    '@INCLUDE PROCEDURE FormatVBA7
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    SelectRows
    Inject FormatVBA7(CodemoduleSelection)
End Sub

Public Sub Substitute(oldValue As String, NewValue As String, Optional Count As Long = -1)
    '@INCLUDE PROCEDURE CountOfCharacters
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    Dim str         As String: str = CodemoduleSelection
    Dim lastRowLength As Long
    lastRowLength = 1 + Len(Replace(Split(str, vbNewLine)(UBound(Split(str, vbNewLine))), oldValue, NewValue))
    Dim Code        As String
    Code = SelectionBefore & _
            Replace(str, oldValue, NewValue, , Count, vbTextCompare) & _
            SelectionAfter
    cm.DeleteLines RowFirst, rowCount
    cm.InsertLines RowFirst, Code
    SetSelection RowFirst, _
            ColumnFirst, _
            RowFirst + CountOfCharacters(Code, vbNewLine), _
            IIf(CountOfCharacters(Code, vbNewLine) > 0, lastRowLength, ColumnFirst + Len(Code))
End Sub

Public Sub CaseLower()
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    Inject LCase(CodemoduleSelection)
End Sub

Public Sub CaseProper()
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    Inject WorksheetFunction.Proper(CodemoduleSelection)
End Sub

Public Sub CaseUpper()
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    Inject UCase(CodemoduleSelection)
End Sub

Sub Sort_Comma()
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    Sort ","
End Sub

Private Sub SelectRows()
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    SetSelection RowFirst, 1, RowLast, 10000
End Sub

Public Sub Sort_Lines()
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    SelectRows
    Sort vbNewLine
End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 12-09-2023 14:24    Alex                (aCodeModule.cls > SortLinesByLength) initial release

Public Sub SortLinesByLength()
'@LastModified 2309121424
    SelectRows
    Dim arr
    arr = Split(CodemoduleSelection, vbNewLine)
    ArraySortByLength arr, LBound(arr), UBound(arr)
    Inject Join(arr, vbNewLine)
End Sub

Public Sub Sort(delimeter As String)
    '@INCLUDE PROCEDURE SortSelectionArray
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    Dim Code        As String: Code = CodemoduleSelection
    Dim arr
    arr = Split(Code, delimeter)
    arr = SortSelectionArray(arr)
    Dim str         As String: str = Join(arr, delimeter)
    Code = SelectionBefore & _
            str & _
            SelectionAfter


    cm.DeleteLines RowFirst, rowCount
    cm.InsertLines RowFirst, Code
    SetSelection RowFirst, _
            ColumnFirst, _
            RowLast, _
            IIf(InStr(1, Code, vbNewLine) = 0, ColumnLast, Len(arr(UBound(arr)))) + IIf(InStr(1, Code, vbNewLine) = 0, 0, 1)
End Sub

Public Sub InjectArgumentStyleFolded()
    '@INCLUDE PROCEDURE ActiveCodepaneWorkbook
    '@INCLUDE CLASS aCodeModule
    '@INCLUDE CLASS aProcedure
    '@AssignedModule aCodeModule
    Dim result      As String: result = aProcedure.Init(ActiveCodepaneWorkbook, , CodemoduleSelection).ArgumentStyleFolded
    If result <> "" Then Inject result
End Sub

Public Sub Encapsulate_Quotes()
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    Encapsulate Chr(34), Chr(34)
End Sub

Public Sub Encapsulate_Parenthesis()
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    Encapsulate "(", ")"
End Sub

Public Sub Encapsulate(Before As String, After As String)
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    Dim str         As String: str = CodemoduleSelection
    Dim Code        As String
    Code = SelectionBefore & _
            Before & str & After & _
            SelectionAfter
    cm.DeleteLines RowFirst, rowCount
    cm.InsertLines RowFirst, Code
    SetSelection RowFirst, ColumnFirst, RowLast, ColumnLast + 2
End Sub

'Sub Encapsulate_CommaSeparatedValues_Quotes()
'    cpsFormatEncapsulateMultiple Chr(34), Chr(34), ","
'End Sub
'
'Sub Encapsulate_CommaSeparatedValues_Parenthesis()
'    cpsFormatEncapsulateMultiple "(", ")", ","
'End Sub
'
'Sub EncapsulateMultipleLinesWithParenthesis()
'    cpsFormatEncapsulateMultiple "(", ")", ","
'End Sub
'
'Sub EncapsulateMultipleLinesWithQuotes()
'    cpsFormatEncapsulateMultiple Chr(34), Chr(34), vbNewLine
'End Sub
'
Public Sub EncapsulateMultiple( _
                              Before As String, _
                              After As String, _
                              Splitter As String)
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    Dim Code        As String: Code = CodemoduleSelection
    Dim arr: arr = Split(Code, Splitter)
    Dim counter     As Long
    For counter = LBound(arr) To UBound(arr) - IIf(Right(UBound(arr), Len(Splitter)) = Splitter, Len(Splitter), 0)
        arr(counter) = Before & arr(counter) & After
    Next
    Code = Join(arr, Splitter)
    Code = SelectionBefore & Code & SelectionAfter
    cm.DeleteLines RowFirst, rowCount
    cm.InsertLines RowFirst, Code
    SetSelection RowFirst, _
                 ColumnFirst, _
                 RowLast, _
                 ColumnLast + ( _
                 (Len(Before) + (Len(After))) * (UBound(arr) + 1))
End Sub

Public Sub UnFoldLine()
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    Dim str         As String: str = CodemoduleSelection
    If Trim(str) = "" Then Exit Sub
    Dim Code        As String
    Code = SelectionBefore & _
            Join(Split(str, "_" & vbNewLine), " ") & _
            SelectionAfter

    cm.DeleteLines RowFirst, rowCount
    cm.InsertLines RowFirst, Code
    SetSelection RowFirst, ColumnFirst, RowFirst, 10000
End Sub

Public Sub FoldLine()
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    If rowCount > 1 Then UnFoldLine
    If InStr(1, CodemoduleSelection, ",") = 0 And InStr(1, CodemoduleSelection, "(") = 0 Then
        SetSelection RowFirst, ColumnFirst, RowFirst, 10000
        '        Debug.Print "Select a whole line or part of a line with comma separated arguments."
        '        Exit Sub
    End If
    Dim str         As String
    str = CodemoduleSelection

    str = Join(Split(str, ", "), ", _" & vbNewLine & Space(ColumnFirst - 1))
    str = Replace(str, "(", "( _" & vbNewLine & Space(ColumnFirst - 1), , 1)

    Dim Code        As String
    Code = SelectionBefore & _
            str & _
            SelectionAfter
    cm.DeleteLines RowFirst, rowCount
    cm.InsertLines RowFirst, Code
    SetSelection RowFirst, ColumnFirst, RowFirst + UBound(Split(Code, " _" & vbNewLine)), 10000
End Sub

Public Sub RotateCommas()
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    Rotate ","
End Sub

Public Sub RotateLines()
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    Rotate vbNewLine
End Sub

Public Sub Rotate(delim As String)
    Rem Rotate multiple  eg. a,b,c,d -> b,c,d,a
    '@INCLUDE PROCEDURE ArrayRotate
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    Dim S           As String
    S = CodemoduleSelection
    S = Join(ArrayRotate(Split(S, delim)), delim)
    S = SelectionBefore & S & SelectionAfter
    Dim idx         As Long: idx = RowFirst
    cm.DeleteLines idx, rowCount
    cm.InsertLines idx, S
    SetSelection RowFirst, ColumnFirst, RowLast, ColumnLast
End Sub

Public Sub rotateEqualInLines()
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    RotateMultiple "=", vbNewLine
End Sub

Public Sub RotateMultiple(flipper As String, Splitter As String)
    '@INCLUDE PROCEDURE ArrayRemoveEmptyElements
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    Dim startLine   As Long
    Dim StartColumn As Long
    Dim endLine     As Long
    Dim EndColumn   As Long
    Application.VBE.ActiveCodePane.GetSelection startLine, _
                                                StartColumn, _
                                                endLine, _
                                                EndColumn
    Dim Code        As String: Code = CodemoduleSelection
    Dim arr         As Variant
    arr = Split(Code, Splitter)
    arr = ArrayRemoveEmptyElements(arr)
    Dim counter     As Long
    For counter = LBound(arr) To UBound(arr) - IIf(Right(UBound(arr), Len(Splitter)) = Splitter, Len(Splitter), 0)
        arr(counter) = Split(arr(counter), flipper)(1) & flipper & Split(arr(counter), flipper)(0)
    Next
    Code = Join(arr, Splitter)
    Code = SelectionBefore & _
            Code & _
            SelectionAfter
    cm.DeleteLines startLine, endLine - startLine + 1
    cm.InsertLines startLine, Code
    SetSelection startLine, StartColumn, endLine, EndColumn
End Sub

Public Sub Duplicate()
    '@INCLUDE PROCEDURE ActiveProcedure
    '@INCLUDE CLASS aCodeModule
    '@INCLUDE CLASS aProcedure
    '@AssignedModule aCodeModule
    Dim S           As String
    If rowCount > 1 Then
        SelectRows
        S = CodemoduleSelection & vbNewLine & CodemoduleSelection
    Else
        Dim RowNumber As Long: RowNumber = RowFirst
        Dim ap      As String: ap = ActiveProcedure: If ap = "" Then Exit Sub
        Dim Limit   As Long: Limit = aProcedure.Init(, , ap).Line_Body_FirstAfterComments
        Do While Len(Trim(cm.Lines(RowNumber, 1))) = 0 _
                And RowNumber - 1 >= Limit
            RowNumber = RowNumber - 1
        Loop
        If Len(Trim(cm.Lines(RowNumber, 1))) > 0 Then
            S = cm.Lines(RowNumber, 1)
        Else
            Exit Sub
        End If
    End If
    cm.InsertLines RowFirst, S
End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 17-08-2023 08:24    Alex                (Increment)

Public Sub Increment()
    '@LastModified 2308170824
    '@INCLUDE PROCEDURE IncreaseAllNumbersInString
    '@INCLUDE CLASS aCodeModule
    '@INCLUDE CLASS aProcedure
    '@AssignedModule aCodeModule
    If rowCount > 1 Then Exit Sub
    Dim RowNumber   As Long: RowNumber = RowFirst

    Do While Len(Trim(cm.Lines(RowNumber, 1))) = 0    'And RowNumber - 1 >= Limit
        RowNumber = RowNumber - 1
    Loop

    Dim S           As String
    If Len(Trim(cm.Lines(RowNumber, 1))) > 0 Then
        S = cm.Lines(RowNumber, 1)
    Else
        Exit Sub
    End If

    Dim ap          As String
    Dim i           As Long
    For i = 0 To 3
        On Error Resume Next
        ap = cm.ProcOfLine(RowNumber, i)
        On Error GoTo 0
        If ap <> "" Then Exit For
    Next
    If ap = "" Then Exit Sub

    S = IncreaseAllNumbersInString(S)
    cm.InsertLines RowNumber + 1, S
    SetSelection RowNumber + 1, 1, RowFirst + 1, 10000
End Sub

Public Sub Cut()
    '@INCLUDE PROCEDURE CLIP
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    CLIP SelectionLinesCode
    Debug.Print CodemoduleSelection
    cm.DeleteLines RowFirst, rowCount
    SetSelection RowFirst, 1, RowFirst, 1
    AssignVariables
End Sub

Public Sub Copy()
    '@INCLUDE PROCEDURE CLIP
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    SelectRows
    CLIP SelectionLinesCode
    AssignVariables
End Sub

Public Sub BeautifyFunction()
    '@INCLUDE PROCEDURE StringFormatFunctionNested
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    Dim txt         As String: txt = CodemoduleSelection
    If txt = "" Then Exit Sub
    txt = StringFormatFunctionNested(txt)
    IndentForInject txt
    Inject txt
End Sub

Private Sub IndentForInject(ByRef txt As String)
    '@INCLUDE PROCEDURE ActiveProcedure
    '@INCLUDE PROCEDURE ActiveModule
    '@INCLUDE PROCEDURE ProcedureLinesLast
    '@INCLUDE PROCEDURE ProcedureTitleLineLast
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    Dim var: var = Split(txt, vbNewLine): If UBound(var) < 1 Then Exit Sub
    Dim Indent      As Long: Indent = ColumnFirst: If Indent < 2 Then Exit Sub
    Dim i           As Long
    For i = LBound(var) + 1 To UBound(var)
        var(i) = Space(Indent) & var(i)
        txt = Join(var, vbNewLine)
    Next
End Sub

'Function cpsCurrentRegionLineBlockFirst() As String
'    Dim Module As VBComponent
'    Set Module = ActiveModule
'    If Len(Module.codeModule.Lines(cpsLineFirst, 1)) = 0 Then Exit Function
'
'    Dim Procedure As String
'        Procedure = ActiveProcedure
'    Dim StartLine As Long
'        StartLine = cpsLineFirst
'    Dim nLine As Long
'        nLine = StartLine
'    If nLine - 1 > 1 _
     '    And nLine - 1 > ProcedureTitleLineLast(Module, Procedure) Then
'        Do Until Len(Module.codeModule.Lines(nLine, 1)) _
         '               - Len(Trim(Module.codeModule.Lines(nLine, 1))) = 4
'            nLine = nLine - 1
'        Loop
'    End If
'    StartLine = nLine
'    cpsCurrentRegionLineBlockFirst = StartLine
'End Function
'
'Function cpsCurrentRegionLineBlockLast() As String
'    Dim Module As VBComponent
'    Set Module = ActiveModule
'    If Len(Module.codeModule.Lines(cpsLineFirst, 1)) = 0 Then Exit Function
'    Dim Procedure As String
'        Procedure = ActiveProcedure
'    Dim EndLine As Long
'        EndLine = cpsLineLast
'    Dim nLine As Long
'        nLine = EndLine
'    If nLine + 1 < ProcedureLinesLast(Module, Procedure) Then
'        Do Until Len(Module.codeModule.Lines(nLine, 1)) _
         '               - Len(Trim(Module.codeModule.Lines(nLine, 1))) = 4
'            nLine = nLine + 1
'        Loop
'    End If
'    EndLine = nLine
'    cpsCurrentRegionLineBlockLast = EndLine
'End Function
'
'Function cpsCurrentRegionLineFirst() As String
'    Dim Module As VBComponent
'    Set Module = ActiveModule
'    If Len(Module.codeModule.Lines(cpsLineFirst, 1)) = 0 Then Exit Function
'
'    Dim Procedure As String
'        Procedure = ActiveProcedure
'    Dim StartLine As Long
'        StartLine = cpsLineFirst
'    Dim nLine As Long
'        nLine = StartLine
'    Do While nLine - 1 > 1 _
     '    And nLine - 1 > ProcedureTitleLineLast(Module, Procedure) _
     '    And Len(Trim(Module.codeModule.Lines(nLine - 1, 1))) > 0
'        nLine = nLine - 1
'    Loop
'    StartLine = nLine
'    cpsCurrentRegionLineFirst = StartLine
'End Function
'
'Function cpsCurrentRegionLineLast() As String
'    Dim Module As VBComponent
'    Set Module = ActiveModule
'    If Len(Module.codeModule.Lines(cpsLineFirst, 1)) = 0 Then Exit Function
'    Dim Procedure As String
'        Procedure = ActiveProcedure
'    Dim EndLine As Long
'        EndLine = cpsLineLast
'    Dim nLine As Long
'        nLine = EndLine
'    Do While nLine + 1 < ProcedureLinesLast(Module, Procedure) _
     '    And Len(Trim(Module.codeModule.Lines(nLine + 1, 1))) > 0
'        nLine = nLine + 1
'    Loop
'    EndLine = nLine
'    cpsCurrentRegionLineLast = EndLine
'End Function
'
'Function cpsCurrentRegionLinesCode() As String
'    Dim Module As VBComponent
'    Set Module = ActiveModule
'    If Len(Module.codeModule.Lines(cpsLineFirst, 1)) = 0 Then Exit Function
'
'    Dim Procedure As String
'        Procedure = ActiveProcedure
'    Dim StartLine As Long
'        StartLine = cpsLineFirst
'    Dim nLine As Long
'        nLine = StartLine
'    Do While nLine - 1 > 1 _
     '    And nLine - 1 > ProcedureTitleLineLast(Module, Procedure) _
     '    And Len(Trim(Module.codeModule.Lines(nLine - 1, 1))) > 0
'        nLine = nLine - 1
'    Loop
'    StartLine = nLine
'
'    Dim EndLine As Long
'        EndLine = cpsLineLast
'    nLine = EndLine
'    Do While nLine + 1 < ProcedureLinesLast(Module, Procedure) _
     '    And Len(Trim(Module.codeModule.Lines(nLine + 1, 1))) > 0
'        nLine = nLine + 1
'    Loop
'    EndLine = nLine
'    cpsCurrentRegionLinesCode = Module.codeModule.Lines(StartLine, EndLine - StartLine + 1)
'End Function

Public Sub Comment()
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    Dim rowLine     As String
    Dim i           As Long
    For i = RowFirst To RowLast
        CommentTargetLine i
    Next
    oModule.CodeModule.CodePane.SetSelection RowFirst, 1, RowLast, 1000
End Sub

Public Sub CommentTargetLine(targetLine As Long)
    '@INCLUDE PROCEDURE IsCommentLine
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    Dim sLine       As String: sLine = oModule.CodeModule.Lines(targetLine, 1)
    If IsCommentLine(sLine) Then Exit Sub
    Dim dif         As Long: dif = Len(sLine) - Len(LTrim(sLine))
    oModule.CodeModule.ReplaceLine targetLine, Space(dif) & "'" & Trim(sLine)
End Sub

Public Sub UnComment()
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    Dim i           As Long
    For i = RowFirst To RowLast
        UncommentTargetLine i
    Next
    oModule.CodeModule.CodePane.SetSelection RowFirst, 1, RowLast, 1000
End Sub

Public Sub UncommentTargetLine(targetLine As Long)
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    Dim sLine       As String
    With oModule.CodeModule
        sLine = .Lines(targetLine, 1)
        If Left(Trim(sLine), 1) = "'" Then
            .ReplaceLine targetLine, Replace(sLine, "'", "", , 1)
        End If
    End With
End Sub

Public Sub RemAdd()
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    Dim i           As Long
    For i = RowFirst To RowLast
        RemTargetLine i
    Next
    oModule.CodeModule.CodePane.SetSelection RowFirst, 1, RowLast, 1000
End Sub

Private Sub RemTargetLine(targetLine As Long)
    '@INCLUDE PROCEDURE IsCommentLine
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    Dim rowLine     As String: rowLine = oModule.CodeModule.Lines(targetLine, 1)
    If IsCommentLine(rowLine) Then Exit Sub
    oModule.CodeModule.ReplaceLine targetLine, _
                                   Space( _
                                   Len(rowLine) - Len(LTrim(rowLine))) & "Rem " & Trim(rowLine)
End Sub

Public Sub RemRemove()
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    Dim i           As Long
    For i = RowFirst To RowLast
        UnremTargetLine i
    Next
    oModule.CodeModule.CodePane.SetSelection RowFirst, 1, RowLast, 1000
End Sub

Public Sub UnremTargetLine(targetLine As Long)
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    Dim sLine       As String
    With oModule.CodeModule
        sLine = .Lines(targetLine, 1)
        If Left(Trim(sLine), 4) = "Rem " Then
            .ReplaceLine targetLine, Replace(sLine, "Rem ", "", , 1)
        End If
    End With
End Sub

Public Sub BringProcedureHere()
    '@INCLUDE PROCEDURE ActiveProcedure
    '@INCLUDE PROCEDURE ActiveModule
    '@INCLUDE PROCEDURE ActiveCodepaneWorkbook
    '@INCLUDE CLASS aCodeModule
    '@INCLUDE CLASS aProcedure
    '@AssignedModule aCodeModule
    aProcedure.Init(ActiveCodepaneWorkbook, ActiveModule, ActiveProcedure).BringProcedureHere CodemoduleSelection
End Sub

Public Sub AlignAs()
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    Align " As ", SearchFromLeft:=True
End Sub

Public Sub AlignColumn()
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    Align ":", SearchFromLeft:=True
    Align ":", SearchFromLeft:=False
End Sub

Public Sub AlignComments()
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule
    Align "'", SearchFromLeft:=False
End Sub

Public Sub Align( _
                AlignString As String, _
                SearchFromLeft As Boolean, _
                Optional AlignAtColumn As Long)
    '@INCLUDE PROCEDURE StringFormatAlignRowsElements
    '@INCLUDE CLASS aCodeModule
    '@AssignedModule aCodeModule

    Dim S           As String: S = StringFormatAlignRowsElements( _
                                   SelectionLinesCode, _
                                   AlignString, _
                                   SearchFromLeft, _
                                   AlignAtColumn)
    Dim LineFirst   As Long: LineFirst = RowFirst
    oModule.CodeModule.DeleteLines LineFirst, rowCount
    oModule.CodeModule.InsertLines LineFirst, S
    SelectRows
End Sub

Public Property Get ProceduresByName() As Collection
    Dim out           As New Collection
    Dim S             As String: S = CodemoduleSelection
    Dim ProcedureName As String
    Dim Procedures    As Collection
    Set Procedures = aWorkbook.Init(oWorkbook).Procedures(True, False, False, False)
    Dim Procedure   As aProcedure
    For Each Procedure In Procedures
        ProcedureName = Procedure.Name
        If RegexTest(S, ProcedureName) Then out.Add ProcedureName, ProcedureName
    Next
    Set ProceduresByName = out
End Property

Public Function ProceduresByDeclaration() As Collection
    '@AssignedModule aCodeModule
    '@INCLUDE PROCEDURE ProceduresOfTXT
    '@INCLUDE PROCEDURE RegexTest
    '@INCLUDE CLASS aCodeModule
    '@INCLUDE CLASS aProcedure
    Dim out         As New Collection
    Dim S           As String: S = CodemoduleSelection
    Dim ProcedureName As String
    Dim Procedures  As Collection
    Set Procedures = ProceduresOfTXT(S)
    Dim Procedure   As aProcedure
    For Each Procedure In Procedures
        ProcedureName = Procedure.Name
        If RegexTest(S, ProcedureName) Then out.Add ProcedureName, ProcedureName
    Next
    Set ProceduresByDeclaration = out
End Function




Public Sub AssignEnumValues(Optional ToThePower As Boolean = True)
    '@AssignedModule aCodeModule
    '@INCLUDE CLASS aCodeModule
    Dim row1 As Long, row2 As Long
    row1 = ActiveEnumStartLine
    row2 = ActiveEnumEndLine
    Dim Code        As String: Code = cm.Lines(row1 + 1, row2 - row1 - 1)
    Dim arr: arr = Split(Code, vbNewLine)
    Code = ""
    Dim out         As String
    Dim i           As Long
    For i = 0 To UBound(arr)
        If InStr(1, arr(i), "=") > 0 Then arr(i) = Split(arr(i), "=")(0)
        arr(i) = Space(4) & Trim(arr(i))
    Next
    If ToThePower = True Then
        For i = 0 To UBound(arr)
            out = arr(i) & "= 2 ^ " & i
            Code = IIf(Code = "", out, Code & vbNewLine & out)
        Next
    Else
        For i = 0 To UBound(arr)
            out = arr(i) & "= " & i + 1
            Code = IIf(Code = "", out, Code & vbNewLine & out)
        Next
    End If
    cm.DeleteLines row1 + 1, row2 - row1 - 1
    cm.InsertLines row1 + 1, Code
End Sub

Public Sub EnumToCase()
    Rem point inside enum before calling this from immediate window or vbe menu button
    '@AssignedModule aCodeModule
    '@INCLUDE PROCEDURE CLIP
    '@INCLUDE CLASS aCodeModule
    Dim enumName    As String: enumName = ActiveEnumName
    Dim arr: arr = Split(oModule.CodeModule.Lines(ActiveEnumStartLine + 1, ActiveEnumEndLine - ActiveEnumStartLine - 1), vbNewLine)
    Dim out         As String: out = "Select case Variable "
    Dim Code        As String: Code = out
    Dim i           As Long
    For i = 0 To UBound(arr)
        If InStr(1, arr(i), "=") > 0 Then arr(i) = Split(arr(i), "=")(0)
        arr(i) = Trim(arr(i))
    Next
    For i = 0 To UBound(arr)
        If arr(i) <> "" Then
            out = "    Case is = " & enumName & "." & arr(i) & vbNewLine
            Code = IIf(Code = "", out, Code & vbNewLine & out)
        End If
    Next
    Code = Code & vbNewLine & "End Select"
    Debug.Print "The following was copied to clipboard:"
    Debug.Print String(20, "-")
    Debug.Print Code
    CLIP Code
End Sub

Private Function ActiveEnumName() As String
    '@AssignedModule aCodeModule
    '@INCLUDE CLASS aCodeModule
    Dim line        As String
    Dim i           As Long
    For i = aCodeModule.Init(oModule).RowFirst To 1 Step -1
        line = oModule.CodeModule.Lines(i, 1)
        If InStr(1, line, "Enum ") > 0 Then
            ActiveEnumName = Trim(Split(line, "Enum ")(1))
            Exit Function
        End If
    Next
End Function

Private Function ActiveEnumStartLine() As Long
    '@AssignedModule aCodeModule
    '@INCLUDE CLASS aCodeModule
    Dim i           As Long
    Dim line        As String
    For i = aCodeModule.Init(oModule).RowFirst To 1 Step -1
        line = oModule.CodeModule.Lines(i, 1)
        If InStr(1, line, "Enum ") > 0 Then
            ActiveEnumStartLine = i
            Exit Function
        End If
    Next
End Function

Private Function ActiveEnumEndLine() As Long
    '@AssignedModule aCodeModule
    '@INCLUDE CLASS aCodeModule
    Dim i           As Long
    Dim enumName    As String
    Dim line        As String
    For i = aCodeModule.Init(oModule).RowFirst To oModule.CodeModule.CountOfLines
        line = oModule.CodeModule.Lines(i, 1)
        If InStr(1, line, "End Enum") > 0 Then
            ActiveEnumEndLine = i
            Exit Function
        End If
    Next
End Function

Public Function Procedure() As aProcedure
    '@INCLUDE CLASS aProcedure
    '@AssignedModule aCodeModule
    '@INCLUDE PROCEDURE ActiveProcedure
    '@INCLUDE PROCEDURE Toast
    '@INCLUDE CLASS aCodeModule
    If ActiveProcedure = "" Then
        Toast "The carret is not inside a procedure"
        Exit Function
    End If
    Set Procedure = aProcedure.Active
End Function

Public Sub injectDivider(Optional Character As String = "~")
    '@AssignedModule aCodeModule
    '@INCLUDE CLASS aCodeModule
    If Len(Trim(cm.Lines(RowFirst, 1))) = 0 Then
        cm.ReplaceLine RowFirst, "'" & String(Procedure.LargestLineLength - 1, "character")
    Else
        cm.InsertLines RowFirst, "'" & String(Procedure.LargestLineLength - 1, "character")
    End If
End Sub

'aProcedure	Class


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Class      : aProcedure
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 04-05-2023 12:18    Alex
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Private oProcedure  As String
Private oWorkbook   As Workbook
Private oModule     As VBComponent
Private oProcKind   As vbext_ProcKind

Private coll_LinkedProcedures As Collection
Private coll_LinkedProceduresDeep As Collection

Public Enum Code_Part
    All_Code
    Declaration_Code
    Declaration_Clean_Code
    Body_Code
    Header_Code
End Enum

Public Enum Property_Type
    Modified
    Ignore
    Parent_Assigned
End Enum

Public Sub InjectTemplate()
    InjectToBodyBottom _
        NewProcedureTemplate( _
            ReturnsObject:=False, _
            addErrorHandling:=True), _
        SkipIfExists:=True
    InjectModification
'    Debug.Print "You may want to use the following after writing the procedure's code:"
'    Debug.Print String(50, "-")
'    Debug.Print "aprocedure.active.InjectObjectsRelease"
'    Debug.Print "aProcedure.Active.InjectLinkedLists"
End Sub

Public Sub InjectTemplateObject()
    InjectToBodyBottom _
        NewProcedureTemplate( _
            ReturnsObject:=True, _
            addErrorHandling:=True), _
        SkipIfExists:=True
    InjectModification
'    Debug.Print "You may want to use the following after writing the procedure's code:"
'    Debug.Print String(50, "-")
'    Debug.Print "aprocedure.active.InjectObjectsRelease"
End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 29-08-2023 12:07    Alex                (z_zTest.bas > NewProcedure) initial release

Private Function NewProcedureTemplate(ReturnsObject As Boolean, addErrorHandling As Boolean) As String
'@LastModified 2308291207
'@INCLUDE CLASS aProcedure
'@INCLUDE CLASS aModule
'@INCLUDE CLASS LogFile
'@INCLUDE CLASS CallStack

'
    If ActiveProcedure = "" Then Exit Function
    Dim am As New aModule:      Set am = am.Active
    Dim ap As New aProcedure:   Set ap = aProcedure.Active
    If Trim(Join(Split(ap.Code_Body))) <> vbNullString Then Exit Function
    Const C_Tab = vbTab
    Dim isFunction As Boolean:  isFunction = (ap.KindAsString = "Function" Or ap.KindAsString = "Get")
    
    Dim q As String: q = """"
    If Not am.HeaderContains("C_MODULE_NAME") Then oModule.CodeModule.AddFromString "Private Const C_MODULE_NAME = " & q & am.Name & q
    Dim S As String, msg As String

    S = Join( _
            Array( _
                "'=== Constants ===", _
                C_Tab & "Const C_PROCEDURE_NAME = " & q & ap.Name & q, _
                vbLf, _
                "'=== Variables ===", _
                ""), _
            vbLf)
    If isFunction Then S = Join(Array(S, C_Tab & "Dim Output As " & ap.returnType), vbLf)
    
    S = Join( _
            Array( _
                S, _
                "'=== Initialize ==="), _
            vbLf)
    
    msg = q & Now & vbTab & "Start:" & vbTab & q & " & " & "C_PROCEDURE_NAME"
    S = Join( _
            Array( _
                S, _
                C_Tab & "debug.print " & msg, _
                C_Tab & "LogFile.log " & msg), _
            vbLf)
    
    Dim Args As String: Args = ap.Arguments
    
    S = Join( _
            Array( _
                S, _
                C_Tab & "CallStack.Push C_MODULE_NAME, C_PROCEDURE_NAME" & IIf(Args <> "", ", " & ap.Arguments, ""), _
                IIf(addErrorHandling, C_Tab & "On error goto ErrorHandler", ""), _
                vbLf, _
                "'=== Code ===", _
                vbLf, _
                "'=== Terminate ===", _
                "NormalExit:"), _
            vbLf)

    If isFunction Then S = Join(Array(S, C_Tab & "" & IIf(ReturnsObject, "Set ", "") & ap.Name & " = output", vbLf), vbLf)
    
    msg = VBA.Replace(msg, "Start", "End", , 1, vbTextCompare)
    S = Join( _
            Array( _
                S, _
                C_Tab & "debug.print " & msg, _
                C_Tab & "LogFile.log " & msg, _
                C_Tab & "CallStack.Pop", _
                "'Bellow you may want to call aprocedure.active.InjectObjectsReleaseHere", _
                "'=== Clean Up ===", _
                "", _
                C_Tab & "Exit " & ap.KindAsString, _
                ""), _
            vbLf)
    If addErrorHandling Then
        S = Join( _
                Array( _
                    S, _
                    "ErrorHandler:", _
                    C_Tab & "CallStack.PrintErrorInfo", _
                    C_Tab & "CallStack.LogErrorInfo", _
                    C_Tab & "ERR.CLEAR", _
                    C_Tab & "ERR.Raise 999,C_PROCEDURE_NAME,CALLSTACK.ErrorInfo"), _
                vbLf)
    End If
    NewProcedureTemplate = S
    

'note'
''''''
'    MsgBox "The following error has occurred" & vbCrLf & vbCrLf & _
'            "Error Number: " & Err.Number & vbCrLf & _
'            "Error Source: TxtOverwrite" & vbCrLf & _
'            "Error Description: " & Err.Description, vbCritical, "An Error has Occurred!"
End Function

Public Sub Activate()
    oModule.Activate
    Dim startPos    As Long: startPos = InStr(1, oModule.CodeModule.Lines(Me.Line_Declaration_First, 1), Me.Name, vbTextCompare)
    oModule.CodeModule.CodePane.SetSelection Line_Declaration_First, _
                                             startPos, _
                                             Line_Declaration_First, _
                                             startPos + Len(Me.Name)
End Sub

Public Function Init( _
        Optional TargetWorkbook As Workbook, _
        Optional module As VBComponent, _
        Optional Procedure As String, _
        Optional ProcKind As vbext_ProcKind) As aProcedure
    '@AssignedModule aProcedure
    '@INCLUDE PROCEDURE AssignCPSvariables
    '@INCLUDE CLASS aProcedure
    If Not AssignCPSvariables(TargetWorkbook, module, Procedure) Then End
    oProcedure = Procedure
    Set oWorkbook = TargetWorkbook
    Set oModule = module
    oProcKind = ProcKind
    Set Init = Me
    Set coll_LinkedProceduresDeep = Nothing
End Function

Public Function Active() As aProcedure
    '@AssignedModule aProcedure
    '@INCLUDE PROCEDURE ActiveModule
    '@INCLUDE PROCEDURE ActiveCodepaneWorkbook
    '@INCLUDE CLASS aCodeModule
    '@INCLUDE CLASS aProcedure
    Dim module      As VBComponent: Set module = ActiveModule
    Dim Procedure   As String
    Dim i           As Long
    Dim ProcKind    As vbext_ProcKind
    Dim lineNum     As Long: lineNum = aCodeModule.Init(module).RowFirst
    For i = 0 To 4
        ProcKind = i
        Procedure = module.CodeModule.ProcOfLine(lineNum, ProcKind)
        If Procedure <> vbNullString Then
            Init ActiveCodepaneWorkbook, module, Procedure, ProcKind
            Set Active = Me
            Exit For
        End If
    Next
End Function

Public Sub Copy( _
        TargetWorkbook As Workbook, _
        Overwrite As Boolean)
    '@AssignedModule aProcedure
    '@INCLUDE PROCEDURE LinkedProceduresDeep
    '@INCLUDE PROCEDURE ModuleAddOrSet
    '@INCLUDE PROCEDURE ModuleOfProcedure
    '@INCLUDE PROCEDURE ProcedureExists
    '@INCLUDE PROCEDURE ProcedureReplace
    '@INCLUDE CLASS aProcedure
    Dim module      As VBComponent
    Dim S           As String
    Dim Procedure   As Variant
    Dim ap          As aProcedure
    For Each Procedure In LinkedProceduresDeep
        Set ap = New aProcedure
        ap.Init oWorkbook, , CStr(Procedure)
        S = ap.Code_All
        If Not ProcedureExists(TargetWorkbook, CStr(Procedure)) Then
            Set module = ModuleAddOrSet(TargetWorkbook, "vbArcImports", vbext_ct_StdModule)
            module.CodeModule.AddFromString S
        Else
            Set module = ModuleOfProcedure(TargetWorkbook, CStr(Procedure))
            If Overwrite = True Then ProcedureReplace module, CStr(Procedure), S
        End If
    Next
End Sub

Public Function Contains( _
        this As String, _
        WholeWord As Boolean, _
        MatchCase As Boolean, _
        PatternSearch As Boolean) As String
    '@AssignedModule aProcedure
    '@INCLUDE CLASS aProcedure

    Contains = oModule.CodeModule.Find( _
            this, _
            1, _
            Line_First, _
            Line_Last, _
            10000, _
            WholeWord, _
            MatchCase, _
            PatternSearch)
End Function

Public Function Contains_InHeader( _
        this As String, _
        WholeWord As Boolean, _
        MatchCase As Boolean, _
        PatternSearch As Boolean) As String
    '@AssignedModule aProcedure
    '@INCLUDE CLASS aProcedure

    Contains_InHeader = oModule.CodeModule.Find( _
            this, _
            1, _
            Line_Header_First, _
            Line_Header_Last, _
            10000, _
            WholeWord, _
            MatchCase, _
            PatternSearch)
End Function

Public Function Contains_InBody( _
        this As String, _
        WholeWord As Boolean, _
        MatchCase As Boolean, _
        PatternSearch As Boolean) As String
    '@AssignedModule aProcedure
    '@INCLUDE CLASS aProcedure

    Contains_InBody = oModule.CodeModule.Find( _
            this, _
            1, _
            Line_Body_First, _
            Line_Body_Last, _
            10000, _
            WholeWord, _
            MatchCase, _
            PatternSearch)
End Function

Public Function Scope() As String
    '@AssignedModule aProcedure
    '@INCLUDE CLASS aProcedure
    Dim sTitle      As String
    sTitle = Code_Declaration_Clean
    If UCase(sTitle) Like UCase("*" & "Public " & "*" & oProcedure & "*") Then
        Scope = "Public"
    ElseIf UCase(sTitle) Like UCase("*" & "Private " & "*" & oProcedure & "*") Then
        Scope = "Private"
    Else
        Select Case Parent.Type
            Case vbext_ct_StdModule, vbext_ct_ClassModule
                Scope = "Public"
            Case Else
                Scope = "Private"
        End Select
    End If
End Function

Private Sub AssignLineStartEnd(CodePart As Code_Part, ByRef LineStart As Long, ByRef LineEnd As Long)
    '@AssignedModule aProcedure
    '@INCLUDE CLASS aProcedure
    Select Case CodePart
        Case Code_Part.All_Code
            LineStart = Line_First
            LineEnd = Line_Last
        Case Code_Part.Body_Code
            LineStart = Line_Body_First
            LineEnd = Line_Body_Last
        Case Code_Part.Header_Code
            LineStart = Line_Header_First
            LineEnd = Line_Header_Last
    End Select
End Sub

Public Sub CommentsToOwnLine()
    '@AssignedModule aProcedure
    '@INCLUDE PROCEDURE CommentsMoveToOwnLine
    '@INCLUDE CLASS aProcedure
    Dim S           As String: S = CommentsMoveToOwnLine(Code_All)
    Dim i           As Long: i = Line_First
    Delete
    oModule.CodeModule.InsertLines i, S
End Sub

Public Function Property(PropertyType As Property_Type) As Variant
    '@AssignedModule aProcedure
    '@INCLUDE CLASS aProcedure
    Select Case PropertyType

        Case Property_Type.Modified: Property = PropertyGet(Modified)
        Case Property_Type.Parent_Assigned: Property = PropertyGet(Parent_Assigned)

    End Select
End Function

Public Property Get ArgumentCount() As Long
    Dim S           As String: S = Code_Declaration_Clean
    If S Like "*" & oProcedure & "()*" Then Exit Property
    ArgumentCount = UBound(Split(S, ",")) + 1
End Property

Public Property Get Name() As String
    Name = oProcedure
End Property

Public Property Get returnType() As String
    returnType = "Invalid"
    If Not (KindAsString = "Function" Or KindAsString = "Get") Then Exit Property
    Dim Title       As String: Title = Code_Declaration_Clean
    If Title Like "*) As *" Then
        returnType = Mid(Title, InStrRev(Title, ") As ") + Len(") As ")) ' Split(Title, ") As ")(1)
    Else
        returnType = "Variant"
    End If
End Property

Public Property Get Parent() As VBComponent
    Set Parent = oModule
End Property

Public Property Get ParentAssigned() As VBComponent
    Dim ModuleName  As String: ModuleName = Property(Parent_Assigned)
    If ModuleName = "" Then Exit Property
    Set ParentAssigned = ModuleAddOrSet(oWorkbook, ModuleName, vbext_ct_StdModule)
    'End Property

    'Public Property Set ParentAssigned(Module As VBComponent)
    '
    '    Set oModule = Module
End Property

Public Property Get KindAsLong() As Long
    Dim S           As String: S = Code_Declaration_Clean
    Select Case True
        Case InStr(1, S, "Get " & oProcedure) > 0: KindAsLong = vbext_pk_Get    '3
        Case InStr(1, S, "Let " & oProcedure) > 0: KindAsLong = vbext_pk_Let    '1
        Case InStr(1, S, "Set " & oProcedure) > 0: KindAsLong = vbext_pk_Set    '2
        Case Else: KindAsLong = vbext_pk_Proc    '0
    End Select
End Property

Public Property Get KindAsString() As String
    Dim S           As String: S = Code_Declaration_Clean
    Select Case True
        Case InStr(1, S, "Get " & oProcedure) > 0: KindAsString = "Get"
        Case InStr(1, S, "Let " & oProcedure) > 0: KindAsString = "Let"
        Case InStr(1, S, "Set " & oProcedure) > 0: KindAsString = "Set"
        Case Else
            If InStr(1, S, "Function " & oProcedure) > 0 Then
                KindAsString = "Function"
            ElseIf InStr(1, S, "Sub " & oProcedure) > 0 Then
                KindAsString = "Sub"
            End If
    End Select
End Property


Private Sub Class_Terminate()
    ReSetVariables
End Sub

Private Sub ReSetVariables()
    Set oWorkbook = Nothing
    Set oModule = Nothing
    oProcedure = ""
End Sub

'Public Function lineIndex(idx As Line_Index) As Long
'    Select Case idx
'        Case Line_Index.Procedure_First: lineIndex = Line_First
'        Case Line_Index.Procedure_Last: lineIndex = Line_Last
'        Case Line_Index.Procedure_Count: lineIndex = Line_Count
'        Case Line_Index.Declaration_First: lineIndex = Line_Declaration_First
'        Case Line_Index.Declaration_Last: lineIndex = Line_Declaration_Last
'        Case Line_Index.Declaration_Count: lineIndex = Line_Declaration_Count
'        Case Line_Index.Body_First: lineIndex = Line_Body_First
'        Case Line_Index.Body_First_AfterComments: lineIndex = Line_Body_FirstAfterComments
'        Case Line_Index.Body_Last: lineIndex = Line_Body_Last
'        Case Line_Index.Body_Count: lineIndex = Line_Body_Count
'        Case Line_Index.Header_First: lineIndex = Line_Header_First
'        Case Line_Index.Header_Last: lineIndex = Line_Header_Last
'        Case Line_Index.Header_Count: lineIndex = Line_Header_Count
'
'    End Select
'End Function

Public Function LineLike(this As String, CodePart As Code_Part) As Long
    Dim LineStart As Long, LineEnd As Long
    AssignLineStartEnd CodePart, LineStart, LineEnd
    Dim targetLine  As String
    Dim i           As Long
    For i = LineStart To LineEnd
        targetLine = Trim(oModule.CodeModule.Lines(i, 1))
        If UCase(targetLine) Like UCase(this) Then
            LineLike = i
            Exit Function
        End If
    Next
End Function

Public Sub EnsureBlankLineBeforeProcedure()
    Dim line        As Long: line = Line_Declaration_First
    If line = 1 Then oModule.CodeModule.InsertLines 1, "": Exit Sub
    Dim check       As String
    On Error Resume Next
    check = oModule.CodeModule.ProcOfLine(line - 1, oProcKind)
    On Error GoTo 0
    If check <> Name Then oModule.CodeModule.InsertLines line, ""
End Sub

Public Function Line_Header_First() As Long
    EnsureBlankLineBeforeProcedure
    Line_Header_First = Line_First
End Function

Public Function Line_Header_Last() As Long
    EnsureBlankLineBeforeProcedure
    Line_Header_Last = Line_Declaration_First - 1
End Function

Public Function Line_Header_Count()
    Line_Header_Count = Line_Header_Last - Line_Header_First + 1
End Function

Public Function Line_First() As Long
    '@todo
    Line_First = oModule.CodeModule.procStartLine(oProcedure, oProcKind)    'findProcedureKind(omodule,oprocedure)
    If Line_First = 0 Then Debug.Print "error in firstline (wrong procKind)": End
End Function

Public Function Line_Count() As Long
    Line_Count = oModule.CodeModule.ProcCountLines(oProcedure, oProcKind)
End Function

Public Function Line_Last() As Long
    Line_Last = Line_First + Line_Count - 1
End Function

Public Function Line_Body_First() As Long
    Line_Body_First = Line_Declaration_First + Line_Declaration_Count
End Function

Public Function Line_Body_FirstAfterComments() As Long
    Dim i           As Long
    Dim S           As String
    For i = Line_Body_First To Line_Body_Last
        S = Trim(oModule.CodeModule.Lines(i, 1))
        If S = vbNullString Then
            Exit For
        ElseIf Left(S, 1) = "'" Then
        ElseIf Left(S, 3) = "Rem" Then
        ElseIf Right(Trim(oModule.CodeModule.Lines(i - 1, 1)), 1) = "_" Then
        ElseIf Right(S, 1) = "_" Then
        Else
            Exit For
        End If
    Next
    Line_Body_FirstAfterComments = i
End Function

Public Function Line_Body_Last() As Long
    Line_Body_Last = Line_Last - 1
End Function

Public Function Line_Body_Count() As Long
    Line_Body_Count = Line_Body_Last - Line_Body_First + 1
End Function

Public Function Line_Declaration_First() As Long
    Line_Declaration_First = oModule.CodeModule.ProcBodyLine(oProcedure, oProcKind)
End Function

Public Function Line_Declaration_Last() As Long
    Line_Declaration_Last = Line_Declaration_First + Line_Declaration_Count - 1
End Function

Public Function Line_Declaration_Count() As Long
    Dim targetLine  As Long: targetLine = Line_Declaration_First
    Dim counter     As Long: counter = 1
    Dim S           As String: S = oModule.CodeModule.Lines(targetLine, counter)
    Do While Right(S, 1) = "_"
        counter = counter + 1
        S = oModule.CodeModule.Lines(targetLine, counter)
    Loop
    Line_Declaration_Count = counter
End Function

Public Function Code_All()
    Code_All = oModule.CodeModule.Lines(Line_First, Line_Count)
End Function
Public Function Code_Body()
    Code_Body = oModule.CodeModule.Lines(Line_Body_First, Line_Body_Count)
End Function
Public Function Code_Header()
    Code_Header = oModule.CodeModule.Lines(Line_Header_First, Line_Header_Count)
End Function
Public Function Code_Declaration()
    Code_Declaration = oModule.CodeModule.Lines(Line_Declaration_First, Line_Declaration_Count)
End Function
Public Function Code_Declaration_Clean()
    If InStr(1, Code_Declaration, "_") = 0 Then
        Code_Declaration_Clean = Trim(Code_Declaration)
    Else
        Code_Declaration_Clean = VBA.Replace(Join(ArrayRemoveEmptyElements(ArrayTrim(Split(Code_Declaration, "_" & vbNewLine))), " "), "( ", "(")
    End If
End Function

Public Function collLinkedProceduresDeep() As Collection
    If coll_LinkedProceduresDeep Is Nothing Then
        Set coll_LinkedProceduresDeep = LinkedProceduresDeep
    End If
    Set collLinkedProceduresDeep = coll_LinkedProceduresDeep
End Function

Public Function collLinkedProcedures() As Collection
    If coll_LinkedProcedures Is Nothing Then
        Set coll_LinkedProcedures = LinkedProcedures
    End If
    Set collLinkedProcedures = coll_LinkedProcedures
End Function

Public Function LinkedProcedures() As Collection
    '@TODO befor Procedues was a collection of strings, now objects. Use aWorkbook...ProceduresArray???
    Dim Procedures  As Collection
    Set Procedures = aWorkbook.Init(oWorkbook).ProceduresNames(True, False, False, False)
    Dim S           As String: S = Code_All
    Dim coll        As New Collection
    Dim Procedure   As Variant
    For Each Procedure In Procedures
        If UCase(CStr(Procedure)) <> UCase(CStr(oProcedure)) Then
            If RegexTest(S, "\W" & CStr(Procedure) & "[.(\W]") = True Then
                coll.Add Procedure, CStr(Procedure)
            End If
        End If
    Next
    Set LinkedProcedures = coll
End Function

Public Function LinkedProceduresDeep() As Collection
    '@LastModified 2307201045
    Dim AllProcedures As Collection: Set AllProcedures = aWorkbook.Init(oWorkbook).ProceduresNames(True, False, False, False)
    Dim Processed   As Collection: Set Processed = New Collection
    Dim CalledProcedures As Collection: Set CalledProcedures = New Collection

    Dim Procedure   As Variant
    Dim module      As VBComponent

    Processed.Add CStr(oProcedure), CStr(oProcedure)
    CalledProcedures.Add CStr(oProcedure), CStr(oProcedure)
    On Error Resume Next
    For Each Procedure In LinkedProcedures
        CalledProcedures.Add CStr(Procedure), CStr(Procedure)
    Next
    On Error GoTo 0

    Dim ap          As aProcedure
    Dim CalledProceduresCount As Long
    CalledProceduresCount = CalledProcedures.Count
    Dim element
repeat:
    For Each element In CalledProcedures
        If Not aCollection.Init(Processed).Contains(, CStr(element)) Then
            On Error Resume Next
            Set ap = New aProcedure
            For Each Procedure In ap.Init(oWorkbook, , CStr(element)).LinkedProcedures
                CalledProcedures.Add CStr(Procedure), CStr(Procedure)
            Next
            On Error GoTo 0
            Processed.Add CStr(element), CStr(element)
        End If
    Next
    If CalledProcedures.Count > CalledProceduresCount Then
        CalledProceduresCount = CalledProcedures.Count
        GoTo repeat
    End If

    Set LinkedProceduresDeep = aCollection.Init(CalledProcedures).Sort.items
End Function

Sub UnfoldDeclaration()
    Dim result      As String: result = Code_Declaration_Clean & vbLf & Code_Body & vbLf & oModule.CodeModule.Lines(Line_Last, 1)
    Replace result
End Sub
Sub FoldDeclaration()
    Dim startLine   As Long
    Dim LastLine    As Long
    Dim FirstColumn As Long
    Dim LastColumn  As Long

    If ArgumentCount = 0 Then Exit Sub
    Dim cp          As aCodeModule
    Set cp = aCodeModule.Init(oModule)

    startLine = Line_Declaration_First
    FirstColumn = InStr(1, oModule.CodeModule.Lines(startLine, 1), "(")
    LastLine = Line_Declaration_Last
    '    Do While InStr(1, oModule.CodeModule.Lines(LastLine, 1), ")") = 0
    '        LastLine = LastLine - 1
    '    Loop
    LastColumn = InStr(1, oModule.CodeModule.Lines(LastLine, 1), ")") + 1
    If LastColumn = 0 Then Exit Sub

    cp.SetSelection startLine, FirstColumn, LastLine, LastColumn
    cp.FoldLine
    cp.SetSelection startLine, FirstColumn, Line_Declaration_Last, 10000
End Sub

Public Sub Export()
    Dim Procedure
    For Each Procedure In collLinkedProceduresDeep
        LinkedExport CStr(Procedure)
    Next
End Sub

Private Sub LinkedExport(Procedure As String)
    Dim module      As VBComponent
    Set module = ModuleOfProcedure(oWorkbook, Procedure)
    Dim c           As New aProcedure
    c.Init oWorkbook, module, Procedure
    Dim proclastmod As String: proclastmod = c.Property(Modified)
    If proclastmod = vbNullString Then
        c.InjectLinkedLists
        c.PropertySet Modified, Format(Now, "yymmddhhnn")
        proclastmod = c.Property(Modified)
    End If
    Dim S           As String: S = c.Code_All
    Dim FileFullName As String: FileFullName = LOCAL_LIBRARY_PROCEDURES & Procedure & ".txt"

    If FileExists(FileFullName) Then
        Dim filelastmod
        filelastmod = StringLastModified(TxtRead(FileFullName))
        If proclastmod > filelastmod Then
            Debug.Print "OVERWROTE " & Procedure
            TxtOverwrite FileFullName, S
        Else
            Debug.Print "Skipping " & Procedure & " because:"
            Debug.Print vbTab & "StringLastModified(TxtRead(FileFullName)) >= Property(Modified)"
        End If
    Else
        Debug.Print "NEW " & Procedure
        TxtOverwrite FileFullName, S
    End If
    Dim element
    For Each element In c.LinkedUserforms
        oWorkbook.VBProject.VBComponents(element).Export LOCAL_LIBRARY_USERFORMS & element & ".frm"
    Next
    For Each element In c.LinkedClasses
        oWorkbook.VBProject.VBComponents(element).Export LOCAL_LIBRARY_CLASSES & element & ".cls"
    Next
    For Each element In c.LinkedDeclarations
        ExportDeclaration CStr(element)
    Next
End Sub

Sub ExportDeclaration(DeclarationName As String)
    aWorkbook.Init(oWorkbook).DeclarationsTableCreate
    Dim TargetWorksheet As Worksheet
    Set TargetWorksheet = ThisWorkbook.Sheets("Declarations_Table")

    Dim codeName    As String
    Dim codeText    As String
    Dim cell        As Range
    On Error Resume Next
    Set cell = TargetWorksheet.Columns(3).Find(DeclarationName, LookAt:=xlWhole)
    On Error GoTo 0
    If cell Is Nothing Then Exit Sub

    codeName = DeclarationName
    codeText = cell.offset(0, 1).TEXT
    TxtOverwrite LOCAL_LIBRARY_DECLARATIONS & DeclarationName & ".txt", codeText

End Sub
Public Sub InjectLinkedLists()
    RemoveIncludeLines
    InjectLinkedDeclarations
    InjectLinkedClasses
    InjectLinkedUserforms
    InjectLinkedProcedures
End Sub

Public Sub Indent()
    Dim S           As String
    Dim nIndent     As Long
    Dim i           As Long
    For i = Line_First To Line_Last
        S = LTrim$(oModule.CodeModule.Lines(i, 1))
        If Trim(S) <> "" Then
            If IsBlockEnd(S) Then nIndent = nIndent - 1
            If nIndent < 0 Then nIndent = 0
            S = Space$(nIndent * 4) & S
            oModule.CodeModule.ReplaceLine i, S
            If IsBlockStart(LTrim$(S)) Then nIndent = nIndent + 1
        End If
    Next
End Sub

Public Sub NumbersAdd()
    Dim counter     As Long: counter = 1
    Dim LineStart As Long, LineEnd As Long
    AssignLineStartEnd Body_Code, LineStart, LineEnd
    Dim S           As String
    Dim i           As Long
    For i = LineStart To LineEnd
        S = oModule.CodeModule.Lines(i, 1)
        If IsLineNumberAble(S) _
                And Right(Trim(oModule.CodeModule.Lines(i - 1, 1)), 1) <> "_" Then
            oModule.CodeModule.ReplaceLine i, counter & ":" & S
            counter = counter + 1
        End If
    Next i
End Sub

Public Sub NumbersRemove()
    Dim counter     As Long: counter = 1
    Dim LineStart As Long, LineEnd As Long
    AssignLineStartEnd Body_Code, LineStart, LineEnd
    Dim S           As String
    Dim i           As Long
    For i = LineStart To LineEnd
        S = oModule.CodeModule.Lines(i, 1)
        If IsNumeric(Left(Trim(S), 1)) Then
            oModule.CodeModule.ReplaceLine i, _
                    Mid(S, InStr(S, ":") + 1)
            'Space(InStr(s, ":"))
        End If
    Next i
End Sub

Public Sub RemoveEmptyLines()
    Dim LineStart As Long, LineEnd As Long
    AssignLineStartEnd Body_Code, LineStart, LineEnd
    Dim i           As Long
    For i = LineEnd To LineStart Step -1
        If Len(Trim(oModule.CodeModule.Lines(i, 1))) = 0 Then
            oModule.CodeModule.DeleteLines i, 1
        End If
    Next
End Sub

Public Sub CommentsRemove(RemoveRem As Boolean, CodePart As Code_Part)
    Replace StringCommentsRemove(CodePart, RemoveRem)

    '    Dim N               As Long
    '    Dim lineText        As String
    '    Dim QUOTES          As Long
    '    Dim Q               As Long
    '    Dim StartPos        As Long
    '    Dim L As Long
    '    Dim LineStart As Long, LineEnd As Long
    '    AssignLineStartEnd CodePart, LineStart, LineEnd
    '    Dim j As Long
    '    For j = LineEnd To LineStart Step -1
    '        lineText = LTrim(oModule.CodeModule.Lines(j, 1))
    '        If Not RemoveRem Then If lineText Like "Rem *" Then GoTo SKIP
    '        StartPos = 1
    'Retry:
    '        N = InStr(StartPos, lineText, "'")
    '        Q = InStr(StartPos, lineText, """")
    '        QUOTES = 0
    '        If Q < N Then
    '            For L = 1 To N
    '                If Mid(lineText, L, 1) = """" Then
    '                    QUOTES = QUOTES + 1
    '                End If
    '            Next L
    '        End If
    '        If QUOTES = Application.WorksheetFunction.Odd(QUOTES) Then
    '            StartPos = N + 1
    '            GoTo Retry:
    '        Else
    '            Select Case N
    '                Case Is = 0
    '
    '                Case Is = 1
    '                    oModule.CodeModule.DeleteLines j, 1
    '                Case Is > 1
    '                    oModule.CodeModule.ReplaceLine j, Left(oModule.CodeModule.Lines(j, 1), N - 1)
    '            End Select
    '        End If
    'SKIP:
    '    Next j
End Sub

Public Sub RemoveIncludeLines()
    RemoveLinesLike "'@INCLUDE *"
End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 22-08-2023 13:56    Alex                (aProcedure.cls > RemoveLinesLike)

Public Sub RemoveLinesLike(this As String)
'@LastModified 2308221356
    this = UCase(this)
    Dim S           As String
    Dim i           As Long
    For i = Line_Body_Last To Line_Header_First Step -1
        S = Trim(oModule.CodeModule.Lines(i, 1))
        S = UCase(S)
        If S Like this Then
            oModule.CodeModule.DeleteLines i
        End If
    Next
End Sub

Public Sub InjectLinkedClasses()
    Dim ListOfImports As String
    Dim S           As String: S = Code_All
    Dim element     As Variant
    For Each element In LinkedClasses
        If InStr(1, S, "@INCLUDE CLASS " & element) = 0 _
                And InStr(1, ListOfImports, "@INCLUDE CLASS " & element) = 0 Then
            If ListOfImports = "" Then
                ListOfImports = "'@INCLUDE CLASS " & element
            Else
                ListOfImports = ListOfImports & vbNewLine & "'@INCLUDE CLASS " & element
            End If
        End If
    Next
    If ListOfImports <> "" Then
        oModule.CodeModule.InsertLines _
                Line_Body_FirstAfterComments, ListOfImports
    End If
End Sub

Public Sub InjectLinkedProcedures()
    Dim Procedures  As Collection
    Set Procedures = collLinkedProcedures
    Dim ListOfImports As String
    Dim S           As String: S = Code_All
    Dim Procedure   As Variant
    For Each Procedure In Procedures
        If InStr(1, S, "@INCLUDE PROCEDURE " & Procedure) = 0 And InStr(1, ListOfImports, "@INCLUDE PROCEDURE " & Procedure) = 0 Then
            If ListOfImports = "" Then
                ListOfImports = "'@INCLUDE PROCEDURE " & Procedure
            Else
                ListOfImports = ListOfImports & vbNewLine & "'@INCLUDE PROCEDURE " & Procedure
            End If
        End If
    Next
    If ListOfImports <> "" Then
        oModule.CodeModule.InsertLines Line_Body_FirstAfterComments, ListOfImports
    End If
End Sub

Public Sub InjectLinkedUserforms()
    Dim ListOfImports As String
    Dim S           As String: S = Code_All
    Dim element     As Variant
    For Each element In LinkedUserforms
        If InStr(1, S, "@INCLUDE USERFORM " & element) = 0 And InStr(1, ListOfImports, "@INCLUDE USERFORM " & element) = 0 Then
            If ListOfImports = "" Then
                ListOfImports = "'@INCLUDE USERFORM " & element
            Else
                ListOfImports = ListOfImports & vbNewLine & "'@INCLUDE USERFORM " & element
            End If
        End If
    Next
    If ListOfImports <> "" Then
        oModule.CodeModule.InsertLines Line_Body_FirstAfterComments, ListOfImports
    End If
End Sub

Public Sub InjectLinkedDeclarations()
    Dim ListOfImports As String
    Dim S           As String: S = Code_All
    Dim coll        As New Collection
    Dim element     As Variant
    For Each element In LinkedDeclarations
        If InStr(1, S, "'@INCLUDE DECLARATION " & element) = 0 Then
            If ListOfImports = "" Then
                ListOfImports = "'@INCLUDE DECLARATION " & element
            Else
                ListOfImports = ListOfImports & vbNewLine & "'@INCLUDE DECLARATION " & element
            End If
        End If
    Next
    If ListOfImports <> "" Then
        oModule.CodeModule.InsertLines Line_Body_FirstAfterComments, ListOfImports
    End If
End Sub

Public Function LinkedDeclarations() As Collection
    aWorkbook.Init(oWorkbook).DeclarationsTableCreate
    Dim TargetWorksheet As Worksheet: Set TargetWorksheet = ThisWorkbook.Sheets("Declarations_Table")
    Dim coll        As New Collection
    Dim S           As String: S = Code_All
    Dim element
    For Each element In DeclarationsTableKeywords
        If RegexTest(S, "\b ?" & CStr(element) & "\b") Then
            On Error Resume Next
            coll.Add CStr(element), CStr(element)
            On Error GoTo 0
        End If
    Next
    Set LinkedDeclarations = coll
End Function

Function DeclarationsTableKeywords() As Collection
    Dim TargetWorksheet As Worksheet
    Set TargetWorksheet = ThisWorkbook.Sheets("Declarations_Table")
    Dim Lr          As Long: Lr = getLastRow(TargetWorksheet)
    Dim coll        As New Collection
    Dim cell        As Range
    For Each cell In TargetWorksheet.Range("C2:C" & Lr)
        On Error Resume Next
        coll.Add cell.TEXT, cell.TEXT
        On Error GoTo 0
    Next
    Set DeclarationsTableKeywords = coll
End Function

Public Function LinkedUserforms()
    Dim coll        As New Collection
    Dim S           As String: S = Code_All
    Dim FormName
    For Each FormName In aModules.Init(oWorkbook).UserformNames
        If RegexTest(S, "\W" & FormName & "[.(\W]") = True Then coll.Add FormName
    Next
    Set LinkedUserforms = coll
End Function




Public Function LinkedClasses() As Collection
    Dim coll        As New Collection
    Dim var         As Variant
    var = aModule.Init(oModule).ClassCalls
    Dim S           As String: S = Code_All
    Dim Keyword     As String
    Dim ClassName   As String
    Dim element     As Variant
    Dim i           As Long
    On Error Resume Next
    For i = LBound(var, 1) To UBound(var, 1)
        If InStr(1, S, var(i, 1)) > 0 Or InStr(1, S, var(i, 2)) > 0 Then
            coll.Add var(i, 1), var(i, 1)
        End If
    Next
    For Each element In aModules.Init(oWorkbook).ClassNames
        If InStr(1, S, element) > 0 Then
            coll.Add element, CStr(element)
        End If
    Next
    On Error GoTo 0
    Set LinkedClasses = coll
End Function


Function LinkedSheets() As Collection
    Dim SheetNames  As New Collection
    Dim TargetWorksheet As Worksheet
    For Each TargetWorksheet In oWorkbook.Worksheets
        On Error Resume Next
        SheetNames.Add TargetWorksheet.Name
        SheetNames.Add oWorkbook.Worksheets(TargetWorksheet.Name).codeName
        On Error GoTo 0
    Next
    Dim element
    Dim S           As String: S = Code_All
    Dim coll        As New Collection
    For Each element In SheetNames
        If InStr(1, CStr(element), " ") > 0 And InStr(1, S, CStr(element)) > 0 Then
            coll.Add CStr(element)
        ElseIf RegexTest(S, "\W" & CStr(element) & "[.(\W]") = True Then
            coll.Add CStr(element), CStr(element)
        End If
    Next
    Set LinkedSheets = coll
End Function


Public Sub ExportLinkedCode()
    Dim Code        As String: Code = LinkedCode
    Dim MergedName  As String: MergedName = "Merged_" & oProcedure
    Dim fileName    As String: fileName = LOCAL_LIBRARY_PROCEDURES & MergedName & ".txt"
    Debug.Print "OVERWROTE " & MergedName
    TxtOverwrite fileName, Code
    TxtPrependContainedProcedures fileName
    FollowLink fileName
End Sub

Private Function LinkedCode() As String
    Dim MergedString As String: MergedString = Code_All
    Dim Procedure
    For Each Procedure In collLinkedProceduresDeep
        MergedString = MergedString & vbNewLine & aProcedure.Init(oWorkbook, , CStr(Procedure)).Code_All
    Next
    LinkedCode = MergedString
End Function

Public Sub ImportDependencies(Optional Overwrite As Boolean)
    ImportProcedureDependencies oProcedure, Overwrite
End Sub

Private Sub ImportProcedureDependencies( _
        Procedure As String, _
        Overwrite As Boolean)

    Dim module      As VBComponent
    On Error Resume Next
    Set module = ModuleOfProcedure(oWorkbook, Procedure)
    If module Is Nothing Then Exit Sub
    On Error GoTo 0
    Dim obj         As String
    Dim Code        As String
    Code = aProcedure.Init(oWorkbook, module, Procedure).Code_All
    Dim var
    var = Split(Code, vbNewLine)
    var = Filter(var, "'@INCLUDE ")
    Dim TextLine    As Variant
    For Each TextLine In var
        TextLine = UCase(Trim(TextLine))
        If TextLine Like "'@INCLUDE *" Then
            obj = Split(TextLine, " ")(2)
            obj = VBA.Replace(obj, vbNewLine, "")
            Select Case True
                Case TextLine Like "'@INCLUDE PROCEDURE *": ImportProcedure obj, Overwrite
                Case TextLine Like "'@INCLUDE CLASS *": ImportClass obj, Overwrite
                Case TextLine Like "'@INCLUDE USERFORM *": ImportUserform obj, Overwrite
                Case TextLine Like "'@INCLUDE DECLARATION *": ImportDeclaration obj
            End Select
        End If
    Next
End Sub

Sub Update()
    ImportProcedure oProcedure, True
End Sub

Public Sub ImportProcedure( _
        Procedure As String, _
        Overwrite As Boolean)
    '
    Dim ProcedurePath As String: ProcedurePath = LOCAL_LIBRARY_PROCEDURES & Procedure & ".txt"
    Dim result      As String
    On Error Resume Next
    result = TxtRead(ProcedurePath)
    On Error GoTo 0

    If Len(result) = 0 Then
        On Error Resume Next
        result = TXTReadFromUrl(GITHUB_LIBRARY_PROCEDURES & Procedure & ".txt")
        On Error GoTo 0
        If Len(result) > 0 And Not UCase(result) Like ("*NOT FOUND*") Then
            TxtOverwrite ProcedurePath, result
        Else
            Debug.Print "File " & Procedure & ".txt not found neither localy nor online"
            Exit Sub
        End If
    End If

    Dim filelastmod: filelastmod = StringLastModified(result)
    Dim proclastmod

    Dim module      As VBComponent
    If ProcedureExists(oWorkbook, Procedure) = True Then
        Set module = ModuleOfProcedure(oWorkbook, Procedure)
        proclastmod = ProcedureLastModified(oWorkbook, module, Procedure)
        If Overwrite = True Then
            If proclastmod = 0 Or proclastmod < filelastmod Then
                ProcedureReplace module, Procedure, TxtRead(ProcedurePath)
            End If
        End If
    Else
        '        Dim ModuleName As String
        '            ModuleName = StringProcedureAssignedModule(Result)
        '        If ModuleName = "" Then ModuleName = "vbArcImports"
        '        Set Module = ModuleAddOrSet(oWorkbook, ModuleName, vbext_ct_StdModule)
        Set module = ModuleAddOrSet(oWorkbook, "vbArcImports", vbext_ct_StdModule)
        module.CodeModule.AddFromFile ProcedurePath
    End If

    ImportProcedureDependencies Procedure, Overwrite
End Sub

Sub ImportDeclaration(DeclarationName As String)
    Dim FilePath    As String
    FilePath = LOCAL_LIBRARY_DECLARATIONS & DeclarationName & ".txt"
    Dim result      As String
    On Error Resume Next
    result = TxtRead(FilePath)
    On Error GoTo 0

    If Len(result) = 0 Then    'CheckPath(filePath) = "I" Then
        On Error Resume Next
        result = TXTReadFromUrl(GITHUB_LIBRARY_DECLARATIONS & DeclarationName & ".txt")
        On Error GoTo 0
        If Len(result) > 0 And Not UCase(result) Like ("*NOT FOUND*") Then
            TxtOverwrite FilePath, result
        Else
            Debug.Print "File " & DeclarationName & ".txt not found localy or online"
            Exit Sub
        End If
    Else

    End If
    If InStr(1, aWorkbook.Init(oWorkbook).Code, result, vbTextCompare) > 0 Then Exit Sub
    Dim module      As VBComponent
    Set module = ModuleAddOrSet(oWorkbook, "vbArcImports", vbext_ct_StdModule)
    module.CodeModule.AddFromString FormatVBA7(result)

End Sub

Sub ImportUserform(UserformName As String, _
        Overwrite As Boolean)

    Dim FilePathFrM As String
    FilePathFrM = LOCAL_LIBRARY_USERFORMS & UserformName & ".frm"
    Dim FilePathFrX As String
    FilePathFrX = LOCAL_LIBRARY_USERFORMS & UserformName & ".frx"

    If CheckPath(FilePathFrM) = "I" Then
        On Error Resume Next
        Dim codeFrM As String
        codeFrM = TXTReadFromUrl(GITHUB_LIBRARY_USERFORMS & UserformName & ".frm")
        Dim codeFrX As String
        codeFrX = TXTReadFromUrl(GITHUB_LIBRARY_USERFORMS & UserformName & ".frx")
        On Error GoTo 0
        If Len(codeFrM) > 0 And Len(codeFrX) > 0 Then
            TxtOverwrite FilePathFrM, codeFrM
            TxtOverwrite FilePathFrX, codeFrX
        Else
            Debug.Print "File " & UserformName & ".frm/.frx not found neither localy nor online"
            Exit Sub
        End If
    End If

    If ModuleExists(UserformName, oWorkbook) Then
        If Overwrite = True Then
            oWorkbook.VBProject.VBComponents.Remove oWorkbook.VBProject.VBComponents(UserformName)
        Else
            Exit Sub
        End If
    End If
    oWorkbook.VBProject.VBComponents.Import FilePathFrM
End Sub

Sub ImportClass(ClassName As String, _
        Overwrite As Boolean)

    Dim FilePath    As String
    FilePath = LOCAL_LIBRARY_CLASSES & ClassName & ".cls"
    If CheckPath(FilePath) = "I" Then
        On Error Resume Next
        Dim Code    As String
        Code = TXTReadFromUrl(GITHUB_LIBRARY_CLASSES & ClassName & ".cls")
        On Error GoTo 0
        If Len(Code) > 0 And Not UCase(Code) Like ("*NOT FOUND*") Then
            TxtOverwrite FilePath, Code
        Else
            MsgBox "File " & ClassName & ".cls not found neither localy nor online"
            Exit Sub
        End If
    End If

    If ModuleExists(ClassName, oWorkbook) Then
        If Overwrite = True Then
            oWorkbook.VBProject.VBComponents.Remove oWorkbook.VBProject.VBComponents(ClassName)
        Else
            Exit Sub
        End If
    End If
    oWorkbook.VBProject.VBComponents.Import FilePath
End Sub

Public Sub Replace(result As String)

    Dim startLine   As Integer
    Dim NumLines    As Integer
    With oModule.CodeModule
        startLine = .procStartLine(oProcedure, oProcKind)
        NumLines = .ProcCountLines(oProcedure, oProcKind)
        .DeleteLines startLine, NumLines
        .InsertLines startLine, result
    End With
End Sub

Private Function EnumOptionToString(PropertyType As Property_Type) As String
    Select Case PropertyType
        Case Property_Type.Modified: EnumOptionToString = "LastModified"
        Case Property_Type.Ignore: EnumOptionToString = "Ignore"
        Case Property_Type.Parent_Assigned: EnumOptionToString = "AssignedModule"

    End Select
End Function

Private Function PropertyGet(PropertyType As Property_Type) As String
    PropertyGet = vbNullString
    Dim line        As String: line = PropertyLine(PropertyType)
    If line = 0 Then Exit Function
    Dim targetLine  As String: targetLine = Trim(oModule.CodeModule.Lines(line, 1))
    PropertyGet = Split(targetLine, " ")(1)
End Function

Public Function PropertySet(PropertyType As Property_Type, Value As String)
    Dim line        As Long: line = PropertyLine(PropertyType)
    If line = 0 Then
        oModule.CodeModule.InsertLines Line_Body_First, "'@" & EnumOptionToString(PropertyType) & " " & Value
    Else
        Dim targetLine As String: targetLine = Trim(oModule.CodeModule.Lines(line, 1))
        oModule.CodeModule.ReplaceLine line, Split(targetLine)(0) & " " & Value
    End If

End Function

Private Function PropertyLine(PropertyType As Property_Type) As Long
    Dim this        As String: this = EnumOptionToString(PropertyType)
    Dim targetLine  As String
    Dim i           As Long
    For i = Line_First To Line_Last
        targetLine = Trim(oModule.CodeModule.Lines(i, 1))
        If UCase(targetLine) Like UCase("'@" & this & " *") Then
            PropertyLine = i
            Exit Function
        End If
    Next
End Function

Public Function ObjectsReleaseText() As String
    Dim LineStart As Long, LineEnd As Long
    AssignLineStartEnd Body_Code, LineStart, LineEnd
    Dim i           As Long
    Dim S As String, this As String, Keyword As String
    For i = LineStart To LineEnd
        S = Trim(oModule.CodeModule.Lines(i, 1))
        If (S Like "Set * = *" Or S Like "Dim*As New*") _
                And Not S Like "*= Nothing*" Then
            Keyword = Split(S, " ")(1)
            this = IIf(this <> "", this & vbNewLine, "") & "Set " & Keyword & " = Nothing"
        End If
    Next
    If this = "" Then Exit Function
    Dim var: var = Split(this, vbNewLine)
    Dim sCode As String: sCode = Code_All
    Dim out, el
    ReDim out(0 To 0)
    For Each el In var
        If InStr(1, sCode, el) = 0 Then
            If out(0) <> "" Then ReDim Preserve out(0 To UBound(out) + 1)
            out(UBound(out)) = el
        End If
    Next
    this = Join(out, vbNewLine)
    ObjectsReleaseText = this
End Function
Public Sub InjectObjectsReleaseAtEnd()
    Dim this As String: this = ObjectsReleaseText
    If this <> "" Then oModule.CodeModule.InsertLines Line_Last, this
End Sub
Public Sub InjectObjectsReleaseHere()
    aCodeModule.Active.Insert Space(4) & Join(Split(ObjectsReleaseText, vbNewLine), vbNewLine & Space(4))
End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 18-08-2023 08:31    Alex                (aProcedure.cls > InjectModification)
'* Updated    : 26-10-2023 00:32    Alex                (aProcedure.cls > InjectModification : added argument for description)

Public Sub InjectModification(Optional Desc As String = "")
'@LastModified 2310260032
    PropertySet Modified, Format(Now, "yymmddhhnn")

    Const vbTab2 = vbTab & vbTab
    Const vbTab4 = vbTab2 & vbTab2
    Dim sTime       As String: sTime = Format(Now, "dd-mm-yyyy hh:nn")
    Dim sProc       As String: sProc = oProcedure

    Dim sUser       As String: sUser = "Alex"
    If sUser = vbNullString Then sUser = Environ("UserName")
    Const sUPDATE   As String = "'* Updated    :"
    Dim sFirstLine  As String
    sFirstLine = "'* Modified   :" & vbTab & "Date and Time" & vbTab2 & _
            "Author" & vbTab4 & "Description" & vbCrLf
    Dim sSecondLine As String
    sSecondLine = sUPDATE & vbTab & sTime & vbTab & sUser & vbTab4 & "(" & oModule.Name & aModule.Init(oModule).Extension & " > " & sProc & " : " & Desc & ")"

    If InStr(1, Code_Header, "'* Created    :") Then
        Dim lineNo  As Long
        Dim i       As Long
        For i = Line_Header_First To Line_Header_Last
            If oModule.CodeModule.Lines(i, 1) Like "'* Created    :*" Then
                lineNo = i
                Exit For
            End If
        Next
        If oModule.CodeModule.Lines(lineNo + 1, 1) Like sUPDATE & "*" Then
            Do
                lineNo = lineNo + 1
            Loop While oModule.CodeModule.Lines(lineNo + 1, 1) Like sUPDATE & "*"
        End If
        oModule.CodeModule.InsertLines lineNo + 1, sSecondLine
        Exit Sub
    End If

    Dim nLine       As Long: nLine = Line_Declaration_First
    If nLine < 4 Then
        sSecondLine = vbLf & sFirstLine & sSecondLine
    ElseIf Not oModule.CodeModule.Lines(nLine - 2, 1) Like sUPDATE & "*" Then
        sSecondLine = vbLf & sFirstLine & sSecondLine
    End If
    If Len(oModule.CodeModule.Lines(nLine - 1, 1)) = 0 And nLine > 1 Then
        oModule.CodeModule.InsertLines nLine - 1, sSecondLine
    Else
        oModule.CodeModule.InsertLines nLine, sSecondLine & vbNewLine
    End If
End Sub

Public Function IndexInModule() As Long
    Dim Procedures  As New Collection
    Set Procedures = aModule.Init(oModule).ProceduresNames
    Dim index       As Long
    index = aCollection.Init(Procedures).IndexOf(oProcedure)
    IndexInModule = index
End Function

Public Sub MoveToTop()
    Dim Procedures  As New Collection: Set Procedures = aModule.Init(oModule).ProceduresNames
    Dim idx         As Long: idx = IndexInModule

    If idx = 1 Then Exit Sub

    Dim S           As String: S = Code_All
    Dim TargetProcedure As String: TargetProcedure = Procedures(1)

    Delete

    With oModule.CodeModule
        .InsertLines .procStartLine(TargetProcedure, oProcKind), S
    End With

    idx = Line_Declaration_First
    Application.VBE.ActiveCodePane.SetSelection idx, 1, idx, 1
End Sub

Public Sub MoveToBottom()
    Dim Procedures  As New Collection: Set Procedures = aModule.Init(oModule).ProceduresNames
    Dim idx         As Long: idx = IndexInModule

    If idx = Procedures.Count Then Exit Sub

    Dim S           As String: S = Code_All
    Dim TargetProcedure As String: TargetProcedure = Procedures(Procedures.Count)

    Delete

    With oModule.CodeModule
        .InsertLines .procStartLine(TargetProcedure, oProcKind) + _
                .ProcCountLines(TargetProcedure, oProcKind) + 1, _
                S
    End With

    idx = Line_Declaration_First
    Application.VBE.ActiveCodePane.SetSelection idx, 1, idx, 1
End Sub

Public Sub MoveDown()
    Dim Procedures  As New Collection: Set Procedures = aModule.Init(oModule).ProceduresNames
    Dim idx         As Long: idx = IndexInModule

    If idx = Procedures.Count Then Exit Sub

    Dim S           As String: S = Code_All
    Dim TargetProcedure As String: TargetProcedure = Procedures(idx + 1)

    Delete

    With oModule.CodeModule
        .InsertLines .procStartLine(TargetProcedure, oProcKind) + _
                .ProcCountLines(TargetProcedure, oProcKind) + 1, _
                S
    End With

    idx = Line_Declaration_First
    Application.VBE.ActiveCodePane.SetSelection idx, 1, idx, 1

End Sub

Public Sub MoveUp()
    Dim Procedures  As New Collection: Set Procedures = aModule.Init(oModule).ProceduresNames
    Dim idx         As Long: idx = IndexInModule

    If idx = 1 Then Exit Sub

    Dim S           As String: S = Code_All
    Dim TargetProcedure As String: TargetProcedure = Procedures(idx - 1)

    Delete

    With oModule.CodeModule
        .InsertLines .procStartLine(TargetProcedure, oProcKind), S
    End With

    idx = Line_Declaration_First
    Application.VBE.ActiveCodePane.SetSelection idx, 1, idx, 1

End Sub

Public Sub MoveToAssignedModule()
    Dim module      As VBComponent
    Set module = ParentAssigned
    If module Is Nothing Or module.Name = oModule.Name Then Exit Sub
    MoveToModule module
End Sub

Public Sub MoveToModule(module As VBComponent)
    Dim S           As String: S = Code_All
    Delete
    With module.CodeModule
        .InsertLines .CountOfLines + 1, vbNewLine & S
    End With
    Set oModule = module
End Sub

Public Sub Delete()
    TxtOverwrite Environ("TEMP") & "\" & oProcedure & ".txt", Code_All
    Debug.Print "made a backup of " & oProcedure & " in " & Environ("TEMP")
    oModule.CodeModule.DeleteLines Line_First, Line_Count
End Sub

Public Sub TestCreate()
    Dim arg         As String
    arg = ArgumentStyleFolded
    Dim Procedures  As Collection
    Set Procedures = aWorkbook.Init(oWorkbook).Procedures(True, False, False, False)

    Dim S           As String: S = vbNewLine
    If Not aCollection.Init(Procedures).Contains(, "test" & oProcedure) Then
        If KindAsString = "Sub" Then
            S = S & "Sub test" & oProcedure & "()" & vbNewLine
            S = S & "call " & arg & vbNewLine
            S = S & "End Sub"
        Else
            S = S & "Function test" & oProcedure & "()" & vbNewLine
            S = S & "Something = " & arg & vbNewLine
            S = S & "End Function"
        End If
    Else

    End If
    oModule.CodeModule.InsertLines Line_First, S
    Debug.Print "Created test" & oProcedure & " in " & oModule.Name
End Sub

Public Function Arguments() As String
    Dim str
    str = Code_Declaration_Clean
    str = Right(str, Len(str) - InStr(1, str, "("))
    str = Left(str, InStrRev(str, ")") - 1)
    If InStr(1, str, Chr(34) & "," & Chr(34)) > 0 Then
        str = VBA.Replace(str, Chr(34) & "," & Chr(34), Chr(34) & "|" & Chr(34))
    End If
    str = Split(str, ",")
    Dim i As Long
    Dim Output As String
    For i = LBound(str) To UBound(str)
        str(i) = VBA.Replace(str(i), Chr(34) & "|" & Chr(34), Chr(34) & "," & Chr(34))
        str(i) = Trim(Split(str(i), " As ")(0))
        str(i) = VBA.Replace(str(i), "Optional ", "")
        str(i) = VBA.Replace(str(i), "Astr(i) ", "")
        str(i) = VBA.Replace(str(i), "ByVal ", "")
        str(i) = VBA.Replace(str(i), "ByRef ", "")
        str(i) = VBA.Replace(str(i), "ParamArray ", "")
        str(i) = VBA.Replace(str(i), "_", "")
        Output = Output & IIf((i > LBound(str)) And (i <= UBound(str)), ", ", "") & str(i)
    Next
    Arguments = Output
End Function

Public Function ArgumentStyleFolded() As String
    If ArgumentCount = 0 Then Exit Function
    Dim str As Variant, S As String
    Dim firstPart As String, secondPart As String, Output As String
    str = Code_Declaration_Clean
    Output = oProcedure & "( _"
    Dim indentation As String
    indentation = Space(Len(Output) - 1)
    str = Right(str, Len(str) - InStr(1, str, "("))
    str = Left(str, InStrRev(str, ")") - 1)
    If InStr(1, str, Chr(34) & "," & Chr(34)) > 0 Then
        str = VBA.Replace(str, Chr(34) & "," & Chr(34), Chr(34) & "|" & Chr(34))
    End If
    str = Split(str, ",")
    Dim i           As Long
    For i = LBound(str) To UBound(str)
        str(i) = VBA.Replace(str(i), Chr(34) & "|" & Chr(34), Chr(34) & "," & Chr(34))
        
    Next
    For i = LBound(str) To UBound(str)
        S = Trim(str(i))

        S = VBA.Replace(S, "Optional ", "")
        S = VBA.Replace(S, "As ", "")
        S = VBA.Replace(S, "ByVal ", "")
        S = VBA.Replace(S, "ByRef ", "")
        S = VBA.Replace(S, "ParamArray ", "")
        S = VBA.Replace(S, "_", "")

        firstPart = Split(S, " ")(0)
        If InStr(1, S, " ") Then
            secondPart = Split(S, " ")(1)
        Else
            secondPart = "Variant"
        End If
        Output = Output & vbNewLine & indentation & firstPart & ":= " & "as" & secondPart & IIf(i <> UBound(str), ", _", ")")
    Next

    ArgumentStyleFolded = Output
End Function

Public Function ArgumentStyleClean() As String
    Dim var         As Variant
    Dim S           As String
    var = Split(ArgumentStyleFolded, vbNewLine)
    var = ArrayTrim(var)
    If UBound(var) = -1 Then
        ArgumentStyleClean = Me.Name & "()"
        Exit Function
    End If
    S = Join(var, vbNewLine)
    S = VBA.Replace(S, " _" & vbNewLine, "")
    ArgumentStyleClean = S
End Function

Sub PrintDims()
    dp Dims
End Sub

Public Property Get Dims() As Variant
    Dim S           As Variant: S = Split(Code_All, vbNewLine)
    Dim tmp: ReDim tmp(0 To 0)

    Dim i           As Long
    For i = LBound(S) To UBound(S)
        S(i) = Trim(S(i))
        If S(i) Like "*:*" Then S(i) = Split(S(i), ":")(0)
    Next

    S = ArrayFilterLike(S, "Dim *", True)
    Dim h           As String
    Dim element
    For i = LBound(S) To UBound(S)
        S(i) = Trim(StringCommentsRemove(S(i), False))
        If S(i) Like "Dim *,* As *" Then
            For Each element In Split(S(i), ", ")
                If InStr(1, element, "Dim ") = 0 Then element = "Dim " & element
                If InStr(1, element, " As ") = 0 Then element = element & " As "
                tmp(UBound(tmp)) = element
                ReDim Preserve tmp(0 To UBound(tmp) + 1)
            Next
        Else
            For Each element In Split(S(i), ", ")
                tmp(UBound(tmp)) = element
                ReDim Preserve tmp(0 To UBound(tmp) + 1)
            Next
        End If
    Next

    S = ArrayFilterLike(tmp, "Dim *", True)

    Dim var
    ReDim var(0 To 1, 0 To 0)
    For i = LBound(S) To UBound(S)
        element = S(i)
        If element Like "Dim * As *" Then

            element = Mid(element, 5)
            var(0, UBound(var, 2)) = Split(element, " As ")(0)
            var(1, UBound(var, 2)) = Split(element, " As ")(1)
            If Split(element, " As ")(1) Like "New *" Then
                var(1, UBound(var, 2)) = Split(var(1, UBound(var, 2)), " ")(1)
            End If
            If i < UBound(S) Then
                ReDim Preserve var(0 To 1, 0 To UBound(var, 2) + 1)
            End If
        ElseIf element Like "Dim *" Then

            Select Case Right(element, 1)
                Case "$": h = "String"
                Case "%": h = "Integer"
                Case "&": h = "Long"
                Case "!": h = "Single"
                Case "#": h = "Double"
                Case "@": h = "Currency"
                Case "^": h = "LongLong"
                Case Else: h = "Variant"
            End Select
            If h = "Variant" Then
                var(0, UBound(var, 2)) = Mid(element, 5)
            Else
                var(0, UBound(var, 2)) = Mid(element, 5, Len(element) - 1)
                Select Case Right(element, 1)
                    Case "$", "%", "&", "!", "#", "@", "^"
                        var(0, UBound(var, 2)) = Left(var(0, UBound(var, 2)), Len(var(0, UBound(var, 2))) - 1)
                End Select
            End If
            var(1, UBound(var, 2)) = h
            If i < UBound(S) Then
                ReDim Preserve var(0 To 1, 0 To UBound(var, 2) + 1)
            End If
        End If
    Next

    Dims = WorksheetFunction.Transpose(var)

End Property

Public Sub InjectToHeaderTop( _
        this As String, _
        SkipIfExists As Boolean)
    If SkipIfExists Then
        If InStr(1, Code_Body, this) > 0 Then Exit Sub
    End If
    oModule.CodeModule.InsertLines Line_First, _
            IIf(Len(oModule.CodeModule.Lines(Line_First, 1)) = 0, vbNewLine, "") & _
            this
End Sub

Public Sub InjectToHeaderBottom( _
        this As String, _
        SkipIfExists As Boolean)
    If SkipIfExists Then
        If InStr(1, Code_Body, this) > 0 Then Exit Sub
    End If
    oModule.CodeModule.InsertLines Line_Declaration_First, this
End Sub

Public Sub InjectToBodyTop( _
        this As String, _
        SkipIfExists As Boolean)
    If SkipIfExists Then
        If InStr(1, Code_Body, this) > 0 Then Exit Sub
    End If
    oModule.CodeModule.InsertLines Line_Body_First, this
End Sub

Public Sub InjectToBodyAfterComments( _
        this As String, _
        SkipIfExists As Boolean)
    If SkipIfExists Then
        If InStr(1, Code_Body, this) > 0 Then Exit Sub
    End If
    oModule.CodeModule.InsertLines Line_Body_FirstAfterComments, this
End Sub

Public Sub InjectToBodyBottom( _
        this As String, _
        SkipIfExists As Boolean)
    If SkipIfExists Then
        If InStr(1, Code_Body, this) > 0 Then Exit Sub
    End If
    oModule.CodeModule.InsertLines Line_Body_Last + 1, this
End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 17-08-2023 08:28    Alex                (InjectDescription)

Sub InjectDescription()
    '@LastModified 2308170828

    Const vbTab2 = vbTab & vbTab
    Const vbTab4 = vbTab2 & vbTab2
    Const sFersLine As String = "'* Modified   :" & vbTab & "Date and Time" & vbTab2 & "Author" & vbTab4 & "Description" & vbCrLf

    Dim txtName     As String: txtName = AUTHOR_NAME
    If txtName = vbNullString Then txtName = Environ("UserName")

    Dim txtContacts As String: txtContacts = AUTHOR_EMAIL
    If txtContacts <> vbNullString Then txtContacts = "'* Contacts   :" & vbTab & txtContacts & vbCrLf

    Dim txtCopyright As String: txtCopyright = AUTHOR_COPYRIGHT
    If txtCopyright <> vbNullString Then txtCopyright = "'* Copyright  :" & vbTab & txtCopyright & vbCrLf

    Dim txtOther    As String: txtOther = AUTHOR_OTHERTEXT
    If txtOther <> vbNullString Then txtOther = "'* Note       :" & vbTab & txtOther & vbCrLf

    Dim txtMedia    As String: txtMedia = "'* " & vbLf & AUTHOR_MEDIA
    Dim CurentCodePane As CodePane: Set CurentCodePane = oModule.CodeModule.CodePane
    Dim i           As Byte
    Dim ProcKind    As VBIDE.vbext_ProcKind
    Dim sProc       As String: sProc = ActiveProcedure
    Dim nLine       As Long
    nLine = Line_Declaration_First
    Dim sTemp       As String
    Dim sTime       As String
    Dim sType       As String
    Dim sProcDeclartion As String
    Dim sProcArguments As String

    Dim sUser       As String

    '* @TODO Created: 01-02-2023 08:20 Author: Anastasiou Alex
    '* @TODO if name is too long have to recalculate tab length

    sUser = "Alex"
    If sUser = vbNullString Then sUser = Environ("UserName")

    On Error Resume Next

    With CurentCodePane
        sTemp = VBA.Replace(String(90, "*"), "**", "* ")
        sTime = Format(Now, "dd-mm-yyyy hh:nn")

        For i = 0 To 4
            ProcKind = i
            sProcDeclartion = Code_Declaration_Clean
            If sProcDeclartion <> vbNullString Then Exit For
        Next
        sProcArguments = AddStringParameterFromProcedureHeader(sProcDeclartion)
        sType = TypeProcedureComment(sProcDeclartion)
        sTemp = _
                "'" & sTemp & vbCrLf & _
                "'" & sType & vbTab & sProc & vbCrLf & _
                "'* Author     :" & vbTab & txtName & vbCrLf & _
                txtContacts & _
                txtCopyright & _
                txtOther & _
                "'* Purpose    :" & vbTab & vbCrLf & _
                txtMedia & _
                sFersLine & _
                "'* Created    :" & vbTab & sTime & vbTab & sUser & vbCrLf & _
                sProcArguments & _
                "'" & sTemp
        InjectToHeaderTop sTemp, False

    End With
End Sub

Private Function AddStringParameterFromProcedureHeader(ByVal sPocDeclartion As String) As String
    '@BlogPosted
    Const vbTab2 = vbTab & vbTab
    Const vbTab4 = vbTab2 & vbTab2
    Dim sDeclaration As String
    sDeclaration = Right$(sPocDeclartion, Len(sPocDeclartion) - InStr(1, sPocDeclartion, "("))
    sDeclaration = Left$(sDeclaration, InStr(1, sDeclaration, ")") - 1)
    If sDeclaration = vbNullString Then Exit Function
    Dim arStr()     As String
    arStr = Split(sDeclaration, ",")
    Dim iMaxLen     As Byte
    iMaxLen = 0
    Dim iTempLen    As Byte
    Dim sTemp       As String
    Dim i           As Byte
    For i = 0 To UBound(arStr)
        iTempLen = Len(Trim$(arStr(i)))
        If iMaxLen < iTempLen Then iMaxLen = iTempLen
    Next i
    Dim numOfSpaces As Long
    numOfSpaces = iMaxLen - Len(Trim$("'* Argument(s):"))
    If numOfSpaces < 0 Then numOfSpaces = 0
    sDeclaration = "'*" & vbLf & "'* Argument(s):" & Space(numOfSpaces) & vbTab2 & "Description" & vbCrLf & "'*" & vbCrLf
    For i = 0 To UBound(arStr)
        sTemp = "'* " & Trim$(arStr(i)) & Space(iMaxLen - Len(Trim$(arStr(i)))) & " :"
        sDeclaration = sDeclaration & sTemp & vbCrLf
    Next i
    AddStringParameterFromProcedureHeader = sDeclaration & "'* " & vbCrLf
End Function

Private Function TypeProcedureComment(ByVal StrDeclarationProcedure As String) As String
    '@BlogPosted
    If StrDeclarationProcedure Like "*Sub*" Then
        TypeProcedureComment = "* Sub        :"
    ElseIf StrDeclarationProcedure Like "*Function*" Then
        TypeProcedureComment = "* Function   :"
    ElseIf StrDeclarationProcedure Like "*Property Set*" Then
        TypeProcedureComment = "* Prop Set   :"
    ElseIf StrDeclarationProcedure Like "*Property Get*" Then
        TypeProcedureComment = "* Prop Get   :"
    ElseIf StrDeclarationProcedure Like "*Property Let*" Then
        TypeProcedureComment = "* Prop Let   :"
    Else
        TypeProcedureComment = "* Un Type    :"
    End If
End Function

Sub InjectTimer()
    Dim ProcedureText As String
    ProcedureText = Code_All
    If Contains("StartTimer", True, True, False) Then Exit Sub
    InjectToBodyAfterComments "StartTimer " & """" & oProcedure & """", True
    Sleep 200
    InjectToBodyBottom "EndTimer", True
End Sub

Function SuggestedScope() As String

    Dim result      As String

    Select Case CallerModules.Count
        Case 0
            SuggestedScope = "Unspecified"
            result = result & vbNewLine & "Procedure " & Name & " has unclarified scope in " & oWorkbook.Name
            result = result & vbNewLine & "It is called 0 times, so it may be Unused, Unassigned, or Called from elsewhere"
            Exit Function
        Case 1
            SuggestedScope = "Private"
            result = result & vbNewLine & "Suggested scope for procedure " & Name & " is Private"
        Case Is > 1
            SuggestedScope = "Public"
            result = result & vbNewLine & "Suggested scope for procedure " & Name & " is Public"
    End Select

    result = result & vbNewLine & "because it is used in " & CallerModules.Count & " module(s) of " & oWorkbook.Name

End Function

Sub ScopeSuggested()
    Dim idx         As Long: idx = Line_Declaration_First
    Dim S           As String: S = oModule.CodeModule.Lines(idx, 1)
    Dim Suggestion  As String: Suggestion = SuggestedScope

    If Suggestion = "Private" Or Suggestion = "Public" Then
        Select Case True
            Case S Like "*Public*" & Name & "*"
                ScopePublic
            Case S Like "*Private*" & Name & "*"
                ScopePrivate
            Case Else
                Dim sKind As String: sKind = KindAsString
                oModule.CodeModule.ReplaceLine idx, Trim(VBA.Replace(S, sKind, " " & Suggestion & " " & sKind, , 1, vbTextCompare))
        End Select
    End If
End Sub

Sub ScopePrivate()
    Dim idx         As Long: idx = Line_Declaration_First
    Dim S           As String: S = Code_Declaration_Clean
    Dim Suggestion  As String: Suggestion = "Private"
    Select Case True
        Case S Like "*Public*" & Name & "*"
            Debug.Print Name
            oModule.CodeModule.ReplaceLine idx, VBA.Replace(S, "Public", "Private", , 1, vbTextCompare)
        Case S Like "*Private*" & Name & "*"

        Case Else
            Dim sKind As String: sKind = KindAsString
            Select Case sKind
                Case sKind Like "*Property*"
                    Debug.Print Name
                    oModule.CodeModule.ReplaceLine idx, VBA.Replace(S, "Property", Suggestion & " " & "Property", , 1, vbTextCompare)
                Case Else
                    Debug.Print Name
                    oModule.CodeModule.ReplaceLine idx, VBA.Replace(S, sKind, Suggestion & " " & sKind, , 1, vbTextCompare)
            End Select
    End Select
End Sub

Sub ScopePublic()
    Dim idx         As Long: idx = Line_Declaration_First
    Dim S           As String: S = Code_Declaration_Clean
    Dim Suggestion  As String: Suggestion = "Public"
    Select Case True
        Case S Like "*Public*" & Name & "*"

        Case S Like "*Private*" & Name & "*"
            Debug.Print Name
            oModule.CodeModule.ReplaceLine idx, VBA.Replace(S, "Private", "Public", , 1, vbTextCompare)
        Case Else
            Dim sKind As String: sKind = KindAsString
            Debug.Print Name
            oModule.CodeModule.ReplaceLine idx, Trim(VBA.Replace(S, sKind, " " & Suggestion & " " & sKind, , 1, vbTextCompare))
    End Select
End Sub

Function CallerModules() As Collection
    Dim myName      As String: myName = Name
    Dim coll        As New Collection
    Dim module      As aModule
    Dim matchCollection As New Collection
    For Each module In aModules.Init(oWorkbook).items
        If module.Contains(myName, True, True, False) Then
            On Error Resume Next
            coll.Add module.Name, module.Name
            On Error GoTo 0
        End If
    Next
    Set CallerModules = coll
End Function

Function CallerModulesToString() As String
    Dim element
    Dim result      As String
    For Each element In CallerModules
        result = result & IIf(result <> "", vbNewLine, "") & element
    Next
    CallerModulesToString = result
End Function

Function Callers() As Collection
    Dim myName      As String: myName = Name
    Dim result      As New Collection
    Dim module      As aModule
    Dim Procedure   As aProcedure
    For Each module In CallerModules
        For Each Procedure In module.Procedures
            If Procedure.Name <> myName Then
                If Procedure.Contains(myName, True, True, False) Then
                    On Error Resume Next
                    result.Add Procedure.Name, Procedure.Name
                    Exit For
                    On Error GoTo 0
                End If
            End If
        Next
    Next
    Set Callers = result
End Function

Function CallersToString() As String
    Dim element
    Dim result      As String
    For Each element In Callers
        result = result & IIf(result <> "", vbNewLine, "") & element
    Next
    CallersToString = result
End Function

Public Sub BringProcedureHere(Procedure As String)
    Dim ap          As New aProcedure
    ap.Init , , Procedure
    Dim S           As String
    S = ap.Code_All
    If InStr(1, S, "'@AssignedModule") = 0 Then
        ap.PropertySet Parent_Assigned, ap.Parent.Name
        S = ap.Code_All
    End If
    ap.Delete
    oModule.CodeModule.InsertLines Line_Last + 1, S
End Sub

Sub BringLinkedProceduresHere()
    Dim el
    Dim ap          As aProcedure
    For Each el In LinkedProceduresDeep
        BringProcedureHere CStr(el)
    Next
End Sub



Sub AddToLinkedTable()

    Dim aw          As aWorkbook
    Set aw = aWorkbook.Init(oWorkbook)
    Dim cell        As Range
    Dim TargetWorksheet As Worksheet
    On Error Resume Next
    Set TargetWorksheet = ThisWorkbook.Sheets("Linked_Table_" & aw.NameClean)
    If TargetWorksheet Is Nothing Then Toast "Worksheet Linked_Table_" & aw.NameClean & " does not exist. Create first. Terminating": Exit Sub
    Set cell = TargetWorksheet.Columns(4).Find(aProcedure, LookAt:=xlWhole)
    If Not cell Is Nothing Then Debug.Print "Procedure " & aProcedure & " was already exporterd. Terminating.": Exit Sub
    On Error GoTo 0

    Dim var
    ReDim var(1 To 8)
    var(1) = oWorkbook.Name
    var(2) = aModule.Init(oModule).TypeToString
    var(3) = oModule.Name
    var(4) = oProcedure
    var(5) = aCollection.Init(LinkedProcedures).ToString(vbNewLine)
    var(6) = aCollection.Init(LinkedClasses).ToString(vbNewLine)
    var(7) = aCollection.Init(LinkedUserforms).ToString(vbNewLine)
    var(8) = aCollection.Init(LinkedDeclarations).ToString(vbNewLine)

    Dim Lr          As Long
    Lr = getLastRow(TargetWorksheet) + 1
    TargetWorksheet.Range("A" & Lr & ":H" & Lr).Value = var
End Sub



Public Sub Enable_DebugPrint()
    Dim N           As Long
    Dim S           As String
    With oModule.CodeModule
        For N = Line_Last To Line_First Step -1
            S = .Lines(N, 1)
            If Left(Trim(S), 6) = "'Debug" Then
                aCodeModule.Init(oModule).UncommentTargetLine N
                '                s = VBA.Replace(s, "'", "", , 1)
                '                .ReplaceLine N, s
            End If
        Next N
    End With
End Sub
Public Sub Disable_DebugPrint()
    Dim N           As Long
    Dim S           As String
    With oModule.CodeModule
        For N = Line_Last To Line_First Step -1
            S = .Lines(N, 1)
            If Left(Trim(S), 5) = "Debug" Then
                aCodeModule.Init(oModule).CommentTargetLine N
                '                .ReplaceLine N, "'" & s
            End If
        Next N
    End With
End Sub


Public Sub Enable_Stop()
    Dim N           As Long
    Dim S           As String
    Dim Keyword     As String
    Keyword = "Stop"
    With oModule.CodeModule
        For N = Line_Last To Line_First Step -1
            S = .Lines(N, 1)
            If InStrExact(1, S, Keyword) > 0 Then
                S = VBA.Replace(S, "'", "", , 1)
                .ReplaceLine N, S
            End If
        Next N
    End With
End Sub
Public Sub Disable_Stop()
    Dim N           As Long
    Dim S           As String
    Dim Keyword     As String: Keyword = "Stop"
    With oModule.CodeModule
        For N = Line_Last To Line_First Step -1
            S = .Lines(N, 1)
            If InStrExact(1, S, Keyword) > 0 Then
                .ReplaceLine N, "'" & S
            End If
        Next N
    End With
End Sub


Public Sub Comments_ReplaceQuoteWithRem()
    Dim N           As Long
    Dim S           As String
    With oModule.CodeModule
        For N = Line_Last To Line_First Step -1
            S = .Lines(N, 1)
            If Left(Trim(S), 1) = "'" Then
                .ReplaceLine N, VBA.Replace(S, "'", "Rem ", , 1)
            End If
        Next N
    End With
End Sub


Public Sub UpdatableVariable_Add(this As String)
    Dim i           As Long: i = LineLike("*UpdatableVariable = *", Body_Code)
    If i = 0 Then Exit Sub
    Dim q           As String: q = Chr(34)
    Dim line        As String: line = oModule.CodeModule.Lines(i, 1)
    If UCase(Trim(line)) Like UCase("UpdatableVariable = *") And InStr(1, line, this, vbTextCompare) = 0 Then
        oModule.CodeModule.ReplaceLine i, VBA.Replace(VBA.Replace(line, q, q & this & ",", , 1, vbTextCompare), "," & q, q)
        line = oModule.CodeModule.Lines(i, 1)
        If InStr(1, line, q & ",") > 0 Then oModule.CodeModule.ReplaceLine i, VBA.Replace(line, q & ",", q)
    End If
End Sub

Public Sub UpdatableVariable_Remove(this As String)
    Dim i           As Long: i = LineLike("*UpdatableVariable = *", Body_Code)
    If i = 0 Then Exit Sub
    Dim q           As String: q = Chr(34)
    Dim result      As String
    Dim line        As String: line = oModule.CodeModule.Lines(i, 1)
    If Trim(line) Like "UpdatableVariable = *" Then
        If InStr(1, line, q & this & q, vbTextCompare) > 0 Then
            result = VBA.Replace(line, q & this & q, "")
            result = VBA.Replace(result, ",,", ",")
            result = VBA.Replace(result, q & ",", q)
            oModule.CodeModule.ReplaceLine i, result
        End If
    End If
End Sub

Sub CreateCaller(rng As Range)
    Dim shp         As Shape
    Set shp = ActiveSheet.Shapes.AddShape _
            (msoShapeRoundedRectangle, 1, 1, 500, 10)
    With shp.ThreeD
        .BevelTopType = msoBevelCircle
        .BevelTopInset = 6
        .BevelTopDepth = 6
    End With
    With shp.Fill
        .Visible = msoTrue
        .ForeColor.RGB = RGB(0, 176, 80)
        .Transparency = 0
        .Solid
    End With
    With shp.line
        .Visible = msoTrue
        .ForeColor.ObjectThemeColor = msoThemeColorBackground1
        .ForeColor.TintAndShade = 0
        .ForeColor.Brightness = 0
        .Transparency = 0
    End With

    With shp
        .OnAction = "'" & oWorkbook.Name & "'!" & oProcedure
        .Name = "Run_" & oProcedure
        .TextFrame2.TextRange.TEXT = oProcedure
        .TextFrame2.TextRange.Font.Bold = msoTrue
        .TextFrame2.TextRange.Font.Size = 11
        .TextFrame.HorizontalAlignment = xlHAlignCenter
        .TextFrame2.WordWrap = msoFalse
        .TextFrame2.AutoSize = msoAutoSizeShapeToFitText
        .Left = Selection.Left
        .Top = Selection.Top
    End With
End Sub

Function LargestLineLength()
    LargestLineLength = LargestLength(Split(Code_All, vbNewLine))
End Function

Sub ConvertBlankLinesToDividers(Optional Character As String = "~")
    Dim l           As Long: l = LargestLineLength
    Dim i           As Long
    For i = Line_Last To Line_Declaration_First Step -1
        If Len(Trim(oModule.CodeModule.Lines(i, 1))) = 0 Then
            oModule.CodeModule.ReplaceLine i, "'" & String(l - 1, Character)
        End If
    Next
End Sub

'A_MAIN	Module


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Module     : A_MAIN
'* Purpose    : These macros use the new classes and target ACTIVE procedure/module/designer
'*              There are plenty more procedures in the classes, have a look. Give feedback
'* Copyright  :
'*
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 22-08-2023 14:04    Alex
'* Modified   : 22-08-2023 14:04    Alex
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

'* Modified   : Date and Time       Author              Description
'* Updated    : 25-08-2023 12:23    Alex                (A_MAIN.bas > RunVbaGui) store process ID

Public Sub RunVbaGui()
'@LastModified 2308251223
'@INCLUDE DECLARATION LongPtr
'@INCLUDE PROCEDURE FileExists
'@INCLUDE PROCEDURE IniWrite
    Dim strProgramName As String
    strProgramName = ThisWorkbook.path & "\AHK\vbaGUI.exe"
    If Not FileExists(strProgramName) Then Exit Sub
    Dim hProcess As LongPtr
    hProcess = Shell("""" & strProgramName & """, vbNormalFocus)")
    IniWrite ThisWorkbook.path & "\AHK\process.ini", "ProgID", "vbaGUI", CStr(hProcess) ' Convert to string
End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 25-08-2023 12:57    Alex                (A_MAIN.bas > KillVbaGui)

Public Sub KillVbaGui()
'@LastModified 2308251257
'@INCLUDE PROCEDURE IniReadKey
'@INCLUDE PROCEDURE KillProcess
    Dim strProcessId As String
    strProcessId = IniReadKey(ThisWorkbook.path & "\AHK\process.ini", "ProgID", "vbaGUI")
    Dim processId As Long
    If IsNumeric(strProcessId) Then
        processId = CLng(strProcessId)
        If KillProcess(processId) Then
'            MsgBox "Process terminated successfully."
        Else
'            MsgBox "Failed to terminate the process."
        End If
    End If
End Sub

'____ Codemodule Formatting _____

Public Sub cm_ActivateProcedure():      aCodeModule.Active.ActivateProcedure:              End Sub
Public Sub cm_AlignAs():                aCodeModule.Active.AlignAs:                        End Sub
Public Sub cm_AlignColumn():            aCodeModule.Active.AlignColumn:                    End Sub
Public Sub cm_AlignComments():          aCodeModule.Active.AlignComments:                  End Sub
Public Sub cm_AssignEnumValues():       aCodeModule.Active.AssignEnumValues:               End Sub
Public Sub cm_BeautifyFunction():       aCodeModule.Active.BeautifyFunction:               End Sub
Public Sub cm_BringProcedureHere():     aCodeModule.Active.BringProcedureHere:             End Sub
Public Sub cm_CaseLower():              aCodeModule.Active.CaseLower:                      End Sub
Public Sub cm_CaseProper():             aCodeModule.Active.CaseProper:                     End Sub
Public Sub cm_CaseUpper():              aCodeModule.Active.CaseUpper:                      End Sub
Public Sub cm_Comment():                aCodeModule.Active.Comment:                        End Sub
Public Sub cm_Copy():                   aCodeModule.Active.Copy:                           End Sub
Public Sub cm_Cut():                    aCodeModule.Active.Cut:                            End Sub
Public Sub cm_DimMerge():               aCodeModule.Active.DimMerge:                       End Sub
Public Sub cm_DimSeparate():            aCodeModule.Active.DimSeparate:                    End Sub
Public Sub cm_Duplicate():              aCodeModule.Active.Duplicate:                      End Sub
Public Sub cm_EncapsulateParenthesis(): aCodeModule.Active.Encapsulate_Parenthesis:        End Sub
Public Sub cm_EncapsulateQuotes():      aCodeModule.Active.Encapsulate_Quotes:             End Sub
Public Sub cm_EnumToCase():             aCodeModule.Active.EnumToCase:                     End Sub
Public Sub cm_FindCode():               FindCode aCodeModule.Active.CodemoduleSelection:   End Sub
Public Sub cm_FoldLine():               aCodeModule.Active.FoldLine:                       End Sub
Public Sub cm_FormatVBA7():             aCodeModule.Active.Format_VBA7:                    End Sub
Public Sub cm_ImportProcedure():        aCodeModule.Active.ImportProcedure:                End Sub
Public Sub cm_Increment():              aCodeModule.Active.Increment:                      End Sub
Public Sub cm_InjectArgumentStyle():    aCodeModule.Active.InjectArgumentStyleFolded:      End Sub
Public Sub cm_injectDivider():          aCodeModule.Active.injectDivider:                  End Sub
Public Sub cm_MoveDown():               aCodeModule.Active.Move_Down:                      End Sub
Public Sub cm_MoveUp():                 aCodeModule.Active.Move_Up:                        End Sub
Public Sub cm_PrintLinesLike():         PrintLinesContaining aCodeModule.Active.CodemoduleSelection: End Sub
Public Sub cm_RemAdd():                 aCodeModule.Active.RemAdd:                         End Sub
Public Sub cm_RemRemove():              aCodeModule.Active.RemRemove:                      End Sub
Public Sub cm_RotateCommas():           aCodeModule.Active.RotateCommas:                   End Sub
Public Sub cm_SortComma():              aCodeModule.Active.Sort_Comma:                     End Sub
Public Sub cm_SortLines():              aCodeModule.Active.Sort_Lines:                     End Sub
Public Sub cm_ToDo():                   aCodeModule.Active.Todo:                           End Sub
Public Sub cm_ToggleComments():         aCodeModule.Active.ToggleComments:                 End Sub
Public Sub cm_UnFoldLine():             aCodeModule.Active.UnFoldLine:                     End Sub
Public Sub cm_Uncomment():              aCodeModule.Active.UnComment:                      End Sub

'____ PROCEDURE Ops _____

Public Sub ap_AddToLinkedTable():            aProcedure.Active.AddToLinkedTable:                                 End Sub
Public Sub ap_BringLinkedProceduresHere():   aProcedure.Active.BringLinkedProceduresHere:                        End Sub
Public Sub ap_CommentsRemove():              aProcedure.Active.CommentsRemove False, Body_Code:                  End Sub
Public Sub ap_CommentsToOwnLine():           aProcedure.Active.CommentsToOwnLine:                                End Sub
Public Sub ap_ConvertBlankLinesToDividers(): aProcedure.Active.ConvertBlankLinesToDividers:                      End Sub
Public Sub ap_CreateCaller():                On Error Resume Next: aProcedure.Active.CreateCaller InputBoxRange: End Sub
Public Sub ap_Export():                      aProcedure.Active.Export:                                           End Sub
Public Sub ap_ExportLinkedCode():            aProcedure.Active.ExportLinkedCode:                                 End Sub
Public Sub ap_FoldDeclaration():             aProcedure.Active.FoldDeclaration:                                  End Sub
Public Sub ap_ImportDependencies():          aProcedure.Active.ImportDependencies:                               End Sub
Public Sub ap_Indent():                      aProcedure.Active.Indent:                                           End Sub
Public Sub ap_InjectDescription():           aProcedure.Active.InjectDescription:                                End Sub
Public Sub ap_InjectLinkedLists():           aProcedure.Active.InjectLinkedLists:                                End Sub
Public Sub ap_InjectModification():          aProcedure.Active.InjectModification:                               End Sub
Public Sub ap_InjectObjectsRelease():        aProcedure.Active.InjectObjectsReleaseHere:                         End Sub
Public Sub ap_InjectTemplate():              aProcedure.Active.InjectTemplate:                                   End Sub
Public Sub ap_InjectTemplateObject():        aProcedure.Active.InjectTemplateObject:                             End Sub
Public Sub ap_InjectTimer():                 aProcedure.Active.InjectTimer:                                      End Sub
Public Sub ap_MoveDown():                    aProcedure.Active.MoveDown:                                         End Sub
Public Sub ap_MoveToAssignedModule():        aProcedure.Active.MoveToAssignedModule:                             End Sub
Public Sub ap_MoveToBottom():                aProcedure.Active.MoveToBottom:                                     End Sub
Public Sub ap_MoveToTop():                   aProcedure.Active.MoveToTop:                                        End Sub
Public Sub ap_MoveUp():                      aProcedure.Active.MoveUp:                                           End Sub
Public Sub ap_NumbersAdd():                  aProcedure.Active.NumbersAdd:                                       End Sub
Public Sub ap_NumbersRemove():               aProcedure.Active.NumbersRemove:                                    End Sub
Public Sub ap_PrintDims():                   aProcedure.Active.PrintDims:                                        End Sub
Public Sub ap_RemoveEmptyLines():            aProcedure.Active.RemoveEmptyLines:                                 End Sub
Public Sub ap_RemoveIncludeLines():          aProcedure.Active.RemoveIncludeLines:                               End Sub
Public Sub ap_TestCreate():                  aProcedure.Active.TestCreate:                                       End Sub
Public Sub ap_UnfoldDeclaration():           aProcedure.Active.UnfoldDeclaration:                                End Sub
Public Sub ap_Update():                      aProcedure.Active.Update:                                           End Sub

'____ MODULE    Ops _____
Public Sub am_CodeRemove():                  aModule.Active.CodeRemove:                  End Sub
Public Sub am_CommentsRemove():              aModule.Active.CommentsRemove:              End Sub
Public Sub am_CommentsToOwnLine():           aModule.Active.CommentsToOwnLine:           End Sub
Public Sub am_EnableDebugPrint():            aModule.Active.EnableDebugPrint:            End Sub
Public Sub am_DisableDebugPrint():           aModule.Active.DisableDebugPrint:           End Sub
Public Sub am_EnableStop():                  aModule.Active.EnableStop:                  End Sub
Public Sub am_DisableStop():                 aModule.Active.DisableStop:                 End Sub
Public Sub am_PredeclaredIdEnable():         aModule.Active.PredeclaredIDenable:         End Sub
Public Sub am_Duplicate():                   aModule.Active.Duplicate:                   End Sub
Public Sub am_Export():                      aModule.Active.Export PickFolder:           End Sub
Public Sub am_ExportProcedures():            aModule.Active.ExportProcedures PickFolder: End Sub
Public Sub am_HeaderAdd():                   aModule.Active.HeaderAdd:                   End Sub
Public Sub am_Indent():                      aModule.Active.Indent:                      End Sub
Public Sub am_ListProcedures():              aModule.Active.ListProcedures:              End Sub
Public Sub am_ListProceduresPublic():        aModule.Active.ListProceduresPublic:        End Sub
Public Sub am_PrintListOfInclude():          aModule.Active.PrintListOfInclude:          End Sub
Public Sub am_PrintTodoList():               aModule.Active.PrintTodoList:               End Sub
Public Sub am_ProcedureFoldDeclarations():   aModule.Active.ProcedureFoldDeclarations:   End Sub
Public Sub am_ProcedureScopePrivate():       aModule.Active.ProcedureScopePrivate:       End Sub
Public Sub am_ProcedureScopePublic():        aModule.Active.ProcedureScopePublic:        End Sub
Public Sub am_ProceduresNames():             dp aModule.Active.ProceduresNames:          End Sub
Public Sub am_RemoveEmptyLinesButLeaveOne(): aModule.Active.RemoveEmptyLinesButLeaveOne: End Sub
Public Sub am_RemoveEmptyLines():            aModule.Active.RemoveEmptyLines:            End Sub
Public Sub am_SortAZ():                      aModule.Active.ProcedureSortAZ:             End Sub
Public Sub am_SortByKind():                  aModule.Active.ProcedureSortByKind:         End Sub
Public Sub am_SortByScope():                 aModule.Active.ProcedureSortByScope:        End Sub
Public Sub am_UpdateProcedures():            aModule.Active.UpdateProcedures:            End Sub

'____ DESIGNER  Ops _____

Public Sub ad_CenterLabelCaption():            aDesigner.Active.CenterLabelCaption:            End Sub
Public Sub ad_CopyControlProperties():         aDesigner.Active.CopyControlProperties:         End Sub
Public Sub ad_PasteControlProperties():        aDesigner.Active.PasteControlProperties:        End Sub
Public Sub ad_RemoveCaption():                 aDesigner.Active.RemoveCaption:                 End Sub
Public Sub ad_RenameControlAndCode():          aDesigner.Active.RenameControlAndCode:          End Sub
Public Sub ad_ReplaceCommandButtonWithLabel(): aDesigner.Active.ReplaceCommandButtonWithLabel: End Sub
Public Sub ad_SetHandCursor():                 aDesigner.Active.SetHandCursor:                 End Sub
Public Sub ad_SetHandCursorToSubControls():    aDesigner.Active.SetHandCursorToSubControls:    End Sub
Public Sub ad_SortControlsHorizontally():      aDesigner.Active.SortControlsHorizontally:      End Sub
Public Sub ad_SortControlsVertically():        aDesigner.Active.SortControlsVertically:        End Sub
Public Sub ad_SwitchNames():                   aDesigner.Active.SwitchNames:                   End Sub
Public Sub ad_SwitchPositions():               aDesigner.Active.SwitchPositions:               End Sub
Public Sub ad_SideBySide():                    aModules.SideBySide ActiveModule.Name:          End Sub

'____ WORKBOOK  Ops _____
Public Sub aw_AddLinkedLists():                AddLinkedListsToActiveWorkbook:                 End Sub
Public Sub aw_Indent():                        aWorkbook.Init(ActiveCodepaneWorkbook).Indent:  End Sub

'____ USERFORMS ____

Public Sub uShow_CodeOnTheFly():     uCodeOnTheFly.Show:    End Sub
Public Sub uShow_ProjectExplorer():  uProjectExplorer.Show: End Sub
Public Sub uShow_References():       uReferences.Show:      End Sub
Public Sub uShow_Skeleton():         uSkeleton.Show:        End Sub
Public Sub uShow_Changelog():        uChangeLog.Show:       End Sub
Public Sub uShow_ChangelogManager(): uChangeLog.Show:       End Sub

Public Sub uShow_SnippetsWorkbook()
    ShowInVBE = False
    uSnippets.Show
End Sub

Public Sub uShow_SnippetsVBE()
    ShowInVBE = True
    uSnippets.Show
End Sub

'____ TXT _____

Public Sub txt_SeparateProcedures(): CallSeparateProcedures: End Sub
Public Sub txt_TxtPrepend(): CallTxtPrependContainedProcedures: End Sub


'aWorkbook	Class


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Class      : aWorkbook
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 04-05-2023 12:19    Alex
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Private oWorkbook   As Workbook

Public Function Init(TargetWorkbook As Workbook) As aWorkbook
    '@AssignedModule aWorkbook
    '@INCLUDE CLASS aWorkbook
    Set oWorkbook = TargetWorkbook
    Set Init = Me
End Function

Public Function item() As Workbook
    '@AssignedModule aWorkbook
    '@INCLUDE CLASS aWorkbook
    Set item = oWorkbook
End Function

Sub ReferencesList()
    '@AssignedModule aWorkbook
    '@INCLUDE CLASS aWorkbook
    '@INCLUDE DECLARATION GUID
    Dim ws          As Worksheet
    Set ws = ThisWorkbook.Sheets("References")
    ws.Cells(1, 1).Value = "Reference Description"
    ws.Cells(1, 2).Value = "GUID"
    ws.Cells(1, 3).Value = "Path"
    ws.Cells(1, 4).Value = "Version"
    Dim myRef       As Reference
    Dim refs        As VBIDE.REFERENCES
    Set refs = oWorkbook.VBProject.REFERENCES
    Dim i           As Long
    i = 2
    For Each myRef In refs
        ws.Cells(i, 1) = IIf(myRef.Description <> "", myRef.Description, myRef.Name)
        ws.Cells(i, 2) = myRef.GUID
        ws.Cells(i, 3) = myRef.fullPath
        ws.Cells(i, 4) = myRef.major & "." & myRef.minor
        i = i + 1
    Next myRef
End Sub

Sub AddReferenceFromFile(FilePath As String)
    '@AssignedModule aWorkbook
    '@INCLUDE CLASS aWorkbook
    Dim oRefs       As REFERENCES: Set oRefs = oWorkbook.VBProject.REFERENCES
    oRefs.AddFromFile FilePath
End Sub

Sub AddReferenceFromGUID(GUID As String, major As String, minor As String)
    '@AssignedModule aWorkbook
    '@INCLUDE CLASS aWorkbook
    '@INCLUDE DECLARATION GUID
    Dim oRefs       As REFERENCES: Set oRefs = oWorkbook.VBProject.REFERENCES
    oRefs.AddFromGuid GUID, major, minor
End Sub

Sub RemoveReferenceByName(RefName As String)
    '@AssignedModule aWorkbook
    '@INCLUDE CLASS aWorkbook
    Dim oRef        As Reference
    Dim oRefs       As REFERENCES: Set oRefs = oWorkbook.VBProject.REFERENCES
    For Each oRef In oRefs
        If oRef.Name = RefName Then
            oRefs.Remove oRef
            Exit For
        End If
    Next oRef
End Sub

Sub RemoveReferenceByDescription(RefDescription As String)
    '@AssignedModule aWorkbook
    '@INCLUDE CLASS aWorkbook
    Dim oRef        As Reference
    Dim oRefs       As REFERENCES: Set oRefs = oWorkbook.VBProject.REFERENCES
    For Each oRef In oRefs
        If oRef.Description = RefDescription Then
            oRefs.Remove oRef
            Exit For
        End If
    Next oRef
End Sub

Sub RemoveReferenceByGUID(refGUID As String)
    '@AssignedModule aWorkbook
    '@INCLUDE CLASS aWorkbook
    '@INCLUDE DECLARATION GUID
    Dim oRefs       As REFERENCES: Set oRefs = oWorkbook.VBProject.REFERENCES
    Dim oRef        As Reference
    For Each oRef In oRefs
        '        debug.print oRef.Name
        If oRef.GUID = refGUID Then
            oRefs.Remove oRef
            Exit For
        End If
    Next oRef
End Sub

Public Sub ExportReferences(FilePath As String)
    '@AssignedModule aWorkbook
    '@INCLUDE PROCEDURE TxtOverwrite
    '@INCLUDE CLASS aWorkbook
    '@INCLUDE DECLARATION GUID
    Dim result      As String
    Dim oRef        As Reference
    For Each oRef In oWorkbook.VBProject.REFERENCES
        result = result & IIf(result <> "", vbNewLine, "") & oRef.Name & vbTab & oRef.GUID & vbTab & oRef.major & vbTab & oRef.minor
    Next
    TxtOverwrite FilePath & NameClean & "_References.txt", result
End Sub


Public Sub ImportReferences(FilePath As String)
    '@AssignedModule aWorkbook
    '@INCLUDE CLASS aWorkbook
    Dim FSO         As New Scripting.FileSystemObject
    With FSO.OpenTextFile(FilePath, ForReading, True)
        Dim line    As Long
        Do While Not .AtEndOfStream
            Dim values As Variant
            values = Split(.ReadLine, vbTab)
            On Error Resume Next
            oWorkbook.VBProject.REFERENCES.AddFromGuid values(1), values(2), values(3)
        Loop
    End With
End Sub

Public Sub ReferenceAdd_VBIDE()
    '@AssignedModule aWorkbook
    '@INCLUDE CLASS aWorkbook
    On Error Resume Next
    ActiveWorkbook.VBProject.REFERENCES.AddFromGuid "{0002E157-0000-0000-C000-000000000046}", 5, 3
End Sub

Sub ReferenceAdd_ScriptControl()
    '@AssignedModule aWorkbook
    '@INCLUDE CLASS aWorkbook
    On Error Resume Next
    Application.VBE.ActiveVBProject.REFERENCES.AddFromGuid "{0E59F1D2-1FBE-11D0-8FF2-00A0D10038BC}", 1, 0
End Sub


Function TodoList()
    '@AssignedModule aWorkbook
    '@INCLUDE CLASS aWorkbook
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aModules
    Dim out         As String
    Dim am          As aModule
    For Each am In aModules.Init(oWorkbook).items
        If InStr(1, am.Code, "@TODO", vbTextCompare) > 0 Then
            out = out & IIf(out <> "", vbNewLine, "") & am.TodoList
        End If
    Next am
    TodoList = out
End Function

Function ProceduresLike(this As String) As Collection
    '@AssignedModule aWorkbook
    '@INCLUDE CLASS aProcedure
    '@INCLUDE CLASS aWorkbook
    Dim Procedure   As aProcedure
    Dim out         As New Collection
    For Each Procedure In Procedures(True, False, False, False)
        If UCase(Procedure.Name) Like UCase(this) Then
            out.Add Procedure
        End If
    Next
    Set ProceduresLike = out
End Function


'* Modified   : Date and Time       Author              Description
'* Updated    : 18-08-2023 12:43    Alex                fixed line aModules.Init(oWorkbook).Items (aWorkbook.cls > Code)

Public Function Code() As String
    '@LastModified 2308181243
    '@AssignedModule aWorkbook
    '@INCLUDE CLASS aWorkbook
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aModules
    Dim module      As aModule
    Dim txt
    For Each module In aModules.Init(oWorkbook).items
        If module.item.CodeModule.CountOfLines > 0 Then
            txt = txt & _
                    vbNewLine & _
                    "'" & String(10, "=") & " (" & module.TypeToString & ") " & module.Name & String(10, "=") & _
                    vbNewLine & _
                    module.Code
        End If
    Next
    Code = txt
End Function

Sub ModulesMerge(TargetModule As VBComponent, ParamArray Modules() As Variant)
    '@AssignedModule aWorkbook
    '@INCLUDE CLASS aWorkbook
    '@INCLUDE CLASS aModule
    Dim element     As Variant
    Dim module      As VBComponent
    For Each element In Modules
        Set module = element
        If module.Type = vbext_ct_StdModule Then
            If module.Name <> TargetModule.Name Then
                aModule.Init(module).CodeMove TargetModule
            End If
        End If
    Next
End Sub


Public Property Get ProceduresNames( _
        includeModule As Boolean, _
        includeDocument As Boolean, _
        includeClass As Boolean, _
        includeForm As Boolean) As Collection

    Dim module      As VBComponent
    Dim ProcKind    As VBIDE.vbext_ProcKind
    Dim lineNum     As Long
    Dim coll        As New Collection
    Dim ProcedureName As String
    Dim i           As Long
    For Each module In oWorkbook.VBProject.VBComponents
        If Not includeModule And module.Type = vbext_ct_StdModule Then GoTo SKIP
        If Not includeClass And module.Type = vbext_ct_ClassModule Then GoTo SKIP
        If Not includeDocument And module.Type = vbext_ct_Document Then GoTo SKIP
        If Not includeForm And module.Type = vbext_ct_MSForm Then GoTo SKIP
        With module.CodeModule
            lineNum = .CountOfDeclarationLines + 1
            Do Until lineNum >= .CountOfLines

                For i = 0 To 4
                    ProcKind = i
                    ProcedureName = .ProcOfLine(lineNum, ProcKind)
                    If ProcedureName <> vbNullString Then

                        'Possible Error:
                        '---------------
                        ' Procedures with an underscore _ which is used in events
                        ' and Private Procedures
                        ' may have the same name in different components

                        If InStr(1, ProcedureName, "_") = 0 Then
                            ProcedureName = .ProcOfLine(lineNum, ProcKind)
                            On Error Resume Next
                            coll.Add ProcedureName, module.Name & "|" & ProcedureName & "|" & ProcKind
                            On Error GoTo 0
                        End If

                        Exit For

                    End If
                Next
                lineNum = .procStartLine(ProcedureName, ProcKind) + .ProcCountLines(ProcedureName, ProcKind) + 1
            Loop
        End With
SKIP:
    Next module

    Set ProceduresNames = coll
End Property

Public Property Get Procedures( _
                            includeModule As Boolean, _
                            includeDocument As Boolean, _
                            includeClass As Boolean, _
                            includeForm As Boolean) As Collection
    'as aProcedure objects
    Dim module      As VBComponent
    Dim ProcKind    As VBIDE.vbext_ProcKind
    Dim lineNum     As Long
    Dim coll        As New Collection
    Dim ProcedureName As String
    Dim cProcedure  As aProcedure
    Dim i           As Long
    For Each module In oWorkbook.VBProject.VBComponents
        If Not includeModule And module.Type = vbext_ct_StdModule Then GoTo SKIP
        If Not includeClass And module.Type = vbext_ct_ClassModule Then GoTo SKIP
        If Not includeDocument And module.Type = vbext_ct_Document Then GoTo SKIP
        If Not includeForm And module.Type = vbext_ct_MSForm Then GoTo SKIP
        With module.CodeModule
            lineNum = .CountOfDeclarationLines + 1
            Do Until lineNum >= .CountOfLines

                For i = 0 To 4
                    ProcKind = i
                    ProcedureName = .ProcOfLine(lineNum, ProcKind)
                    If ProcedureName <> vbNullString Then

                        'Possible Error:
                        '---------------
                        ' Procedures with an underscore _ which is used in events
                        ' and Private Procedures
                        ' may have the same name in different components

                        If InStr(1, ProcedureName, "_") = 0 Then
                            ProcedureName = .ProcOfLine(lineNum, ProcKind)
                            Set cProcedure = New aProcedure
                            cProcedure.Init oWorkbook, module, ProcedureName, ProcKind
                            On Error Resume Next
                            coll.Add cProcedure, cProcedure.Name & ProcKind
                            'coll.Add ProcedureName, ProcedureName
                            'If Err.Number > 0 Then Debug.Print ProcedureName & " exists multiple times, added only once, may lead to error"
                            'Err.clear
                            On Error GoTo 0
                        End If

                        Exit For

                    End If
                Next
                lineNum = .procStartLine(ProcedureName, ProcKind) + .ProcCountLines(ProcedureName, ProcKind) + 1
            Loop
        End With
SKIP:
    Next module

    Set Procedures = coll
End Property


Function ProceduresArray()
    Dim module      As VBComponent
    Dim ProcKind    As VBIDE.vbext_ProcKind
    Dim lineNum     As Long
    Dim coll        As New Collection
    Dim ProcedureName As String
    Dim cProcedure  As aProcedure
    Dim arr
    Dim i           As Long
    Dim BodyLine    As Long
    ReDim arr(1 To 4, 1 To 1)
    For Each module In oWorkbook.VBProject.VBComponents
        With module.CodeModule
            lineNum = .CountOfDeclarationLines + 1
            Do Until lineNum >= .CountOfLines
                If arr(UBound(arr, 1), 1) <> "" Then
                    ReDim Preserve arr(1 To 4, 1 To UBound(arr, 2) + 1)
                End If
                On Error Resume Next
                For i = 0 To 4
                    ProcKind = i
                    ProcedureName = .ProcOfLine(lineNum, ProcKind)
                    If ProcedureName <> vbNullString Then
                        BodyLine = module.CodeModule.ProcBodyLine(ProcedureName, ProcKind)
                        arr(1, UBound(arr, 2)) = Switch(module.Type = vbext_ct_StdModule, "Module", _
                                module.Type = vbext_ct_ClassModule, "Class", _
                                module.Type = 3, "Userform", _
                                module.Type = 100, "Document", _
                                module.Type = 11, "ActiveXDesigner")
                        arr(2, UBound(arr, 2)) = module.Name
                        arr(3, UBound(arr, 2)) = Switch(ProcKind = vbext_pk_Proc, IIf(module.CodeModule.Lines(BodyLine, 1) Like "*Sub " & ProcedureName & "*", "Sub", "Function"), _
                                ProcKind = vbext_pk_Let, "Let", _
                                ProcKind = vbext_pk_Set, "Set", _
                                ProcKind = vbext_pk_Get, "Get")
                        arr(4, UBound(arr, 2)) = ProcedureName
                        Exit For
                    End If
                Next
                On Error GoTo 0
                lineNum = .procStartLine(ProcedureName, ProcKind) + .ProcCountLines(ProcedureName, ProcKind) + 1
            Loop
        End With
SKIP:
    Next module
    ProceduresArray = WorksheetFunction.Transpose(arr)
End Function

Sub Backup(targetFolder As String)
    oWorkbook.SaveCopyAs targetFolder & _
            Format(Now, "yyyy-mm-dd hh-nn") & " " & oWorkbook.Name
End Sub

Function Name()
    Name = oWorkbook.Name
End Function
Function Extension()
    Extension = Mid(Name, InStr(1, Name, "."))
End Function

Function NameClean()
    NameClean = Left(Name, InStrRev(Name, ".") - 1)
End Function

Public Sub ExportModules(targetPath As String)
    targetPath = VBA.Replace(targetPath & "\", "\\", "\")
    FoldersCreate targetPath
    Dim ams As aModules: Set ams = aModules.Init(oWorkbook)
    ams.Export targetPath, createSubfolders:=True
End Sub
Public Sub ExportProcedures(targetPath As String, createModuleSubfolders As Boolean)
    targetPath = VBA.Replace(targetPath & "\", "\\", "\")
    FoldersCreate targetPath
    Dim ams As aModules: Set ams = aModules.Init(oWorkbook)
    ams.ExportProcedures targetPath, createModuleSubfolders
End Sub
Public Sub ExportXML(targetPath As String)
    targetPath = Replace(targetPath & "\", "\\", "\")
    FoldersCreate targetPath
    Dim TmpFile     As String
    TmpFile = oWorkbook.path & "\temp_workbook_file" & Extension
    oWorkbook.SaveCopyAs TmpFile
    Dim c           As New clsEditOpenXML
    c.ExtractRibbonX TmpFile, targetPath & "customUI.xml"
    Kill TmpFile
    FolderDelete oWorkbook.path & "\Unzipped " & "temp_workbook_file" & Extension & ".zip"
    Set c = Nothing
End Sub

Public Sub Indent()
    aModules.Init(oWorkbook).Indent
End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 25-10-2023 23:22    Alex                (aWorkbook.cls > ExportCodeUnified)

Public Sub ExportCodeUnified(targetPath As String)
'@LastModified 2310252322
    targetPath = Replace(targetPath & "\", "\\", "\")
    FoldersCreate targetPath
    Dim result As String, tmp As String
    Dim am          As aModule
    For Each am In aModules.Init(oWorkbook).items
        tmp = "'" & am.Name & vbTab & am.TypeToString & vbNewLine & vbNewLine & am.Code
        result = IIf(result = "", tmp, result & vbNewLine & vbNewLine & tmp)
    Next
    TxtOverwrite targetPath & "#UnifiedProject.txt", result
End Sub

Function HasProject() As Boolean
    Dim WbProjComp  As Object
    On Error Resume Next
    Set WbProjComp = oWorkbook.VBProject.VBComponents
    HasProject = Not WbProjComp Is Nothing
End Function

Sub CreateLinkedTable_Sheet()
    Dim TargetWorksheet As Worksheet
    Set TargetWorksheet = CreateOrSetSheet("Linked_Table_" & NameClean, ThisWorkbook)
    If TargetWorksheet.Range("A1") <> "" Then Exit Sub
    Dim var
    ReDim var(1 To 8)

    var(1) = "WORKBOOK"
    var(2) = "MODULE TYPE"
    var(3) = "MODULE NAME"
    var(4) = "PROCEDURE"
    var(5) = "LINKED PROCEDURES"
    var(6) = "LINKED CLASSES"
    var(7) = "LINKED USERFORMS"
    var(8) = "LINKED DECLARATIONS"

    With TargetWorksheet
        .Range("A1:H1").Value = var
        With .rows(1).Cells.Font
            .Bold = True
            .Size = 14
        End With
    End With

End Sub

Sub CreateLinkedTable()

    StartTimer "tableOfProcedures"

    aWorkbook.Init(oWorkbook).DeclarationsTableCreate

    CreateLinkedTable_Sheet

    Dim TargetWorksheet As Worksheet
    Set TargetWorksheet = ThisWorkbook.Sheets("Linked_Table_" & NameClean)
    On Error Resume Next
    TargetWorksheet.ListObjects(1).Unlist
    On Error GoTo 0
    TargetWorksheet.Range("A1").CurrentRegion.offset(1).clear

    Dim var
    ReDim var(1 To 8, 1 To 1)

    Dim counter     As Long
    counter = 1

    Dim module      As VBComponent
    Dim Procedures  As Collection

    Dim Procedure   As aProcedure
    For Each module In oWorkbook.VBProject.VBComponents
        Select Case module.Type
            Case vbext_ct_StdModule, vbext_ct_Document, vbext_ct_MSForm    '@TODO check if adding these is ok
                Set Procedures = aModule.Init(module).Procedures
                For Each Procedure In Procedures
                    ReDim Preserve var(1 To 8, 1 To counter)
                    var(1, counter) = oWorkbook.Name
                    var(2, counter) = aModule.Init(module).TypeToString
                    var(3, counter) = module.Name
                    var(4, counter) = Procedure.Name
                    var(5, counter) = aCollection.Init(Procedure.LinkedProcedures).ToString(vbNewLine)
                    var(6, counter) = aCollection.Init(Procedure.LinkedClasses).ToString(vbNewLine)
                    var(7, counter) = aCollection.Init(Procedure.LinkedUserforms).ToString(vbNewLine)
                    var(8, counter) = aCollection.Init(Procedure.LinkedDeclarations).ToString(vbNewLine)

                    counter = counter + 1
                Next
        End Select
    Next

    var = WorksheetFunction.Transpose(var)
    ArrayToRange2D var, TargetWorksheet.Range("A2")

    LinkedProceduresTableSort
    TargetWorksheet.ListObjects.Add xlSrcRange, TargetWorksheet.Range("A1").CurrentRegion, , xlYes
    TargetWorksheet.Cells.VerticalAlignment = xlVAlignTop

    EndTimer

End Sub

Private Sub LinkedProceduresTableSort()
    Dim TargetWorksheet As Worksheet
    Set TargetWorksheet = ThisWorkbook.Worksheets("Linked_Table_" & NameClean)
    Dim sort1       As String
    sort1 = "A1"
    Dim sort2       As String
    sort2 = "C1"
    Dim sort3       As String
    sort3 = "D1"

    With TargetWorksheet.Sort
        .SortFields.clear
        .SortFields.Add Key:=TargetWorksheet.Range(sort1), Order:=xlAscending
        If Not sort2 = "" Then
            .SortFields.Add Key:=TargetWorksheet.Range(sort2), Order:=xlAscending
        End If
        If Not sort3 = "" Then
            .SortFields.Add Key:=TargetWorksheet.Range(sort3), Order:=xlAscending
        End If

        .SetRange TargetWorksheet.Range("A1").CurrentRegion
        '        .header = xlYes
        .Apply
    End With
End Sub

'Sub LinkedProceduresTableFilter()
'    Dim TargetWorksheet As Worksheet: Set TargetWorksheet = ThisWorkbook.SHEETS("LinkedProcedures_Table")
'    TargetWorksheet.rows.Hidden = False
'    On Error Resume Next
'    TargetWorksheet.ShowAllData
'    On Error GoTo 0
'    TargetWorksheet.Range("A6").CurrentRegion.AdvancedFilter _
     '        action:=xlFilterInPlace, _
     '        criteriaRange:=TargetWorksheet.Range("A1").CurrentRegion
'    LinkedProceduresTableSort
'End Sub


Sub ExportDeclarations(targetPath As String)
    targetPath = Replace(targetPath & "\", "\\", "\")
    FoldersCreate targetPath

    Dim DeclarationArray As Variant
    DeclarationArray = aCollection.CollectionsToArray2D(getDeclarations)
    If TypeName(DeclarationArray) <> "Empty" Then
        TxtOverwrite targetPath & "Declarations.txt", ArrayToString(DeclarationArray)
    End If
End Sub

Private Function DeclarationsWorksheetCreate() As Boolean
    If WorksheetExists("Declarations_Table", ThisWorkbook) Then Exit Function
    Dim TargetWorksheet As Worksheet
    Set TargetWorksheet = ThisWorkbook.Sheets.Add
    With TargetWorksheet
        .Name = "Declarations_Table"
        .Cells.VerticalAlignment = xlVAlignTop
        .Range("A1:F1").Value = Split("SCOPE,TYPE,NAME,CODE,MODULE TYPE,MODULE NAME", ",")
        .rows(1).Cells.Font.Bold = True
        .rows(1).Cells.Font.Size = 14
    End With
End Function

Public Sub DeclarationsTableCreate()

    DeclarationsWorksheetCreate

    Dim TargetWorksheet As Worksheet
    Set TargetWorksheet = ThisWorkbook.Sheets("Declarations_Table")
    'if sheet was created within the hour, you probably don't have new declarations
    If Format(Now, "YYMMDDHHNN") - TargetWorksheet.Range("Z1").Value < 60 Then Exit Sub

    TargetWorksheet.Range("A2").CurrentRegion.offset(1).clear
    ArrayToRange2D aCollection.CollectionsToArray2D( _
            getDeclarations( _
            includeScope:=True, _
            includeType:=True, _
            includeKeywords:=True, _
            includeDeclarations:=True, _
            includeComponentName:=True, _
            includeComponentType:=True)), _
            TargetWorksheet.Range("A2")

    TargetWorksheet.Range("Z1").Value = Format(Now, "YYMMDDHHNN")

    DeclarationsTableSort
End Sub

Private Sub DeclarationsTableSort()
    Dim TargetWorksheet As Worksheet
    Set TargetWorksheet = ThisWorkbook.Worksheets("Declarations_Table")

    Dim sort1       As String: sort1 = "B1"
    Dim sort2       As String: sort2 = "C1"
    Dim sort3       As String    ': sort3 = "D1"

    With TargetWorksheet.Sort
        .SortFields.clear
        .SortFields.Add Key:=TargetWorksheet.Range(sort1), Order:=xlAscending

        If Not sort2 = "" Then
            .SortFields.Add Key:=TargetWorksheet.Range(sort2), Order:=xlAscending
        End If
        If Not sort3 = "" Then
            .SortFields.Add Key:=TargetWorksheet.Range(sort3), Order:=xlAscending
        End If

        .SetRange TargetWorksheet.Range("A1").CurrentRegion
        .Header = xlYes
        .Apply
    End With
End Sub


Public Function DeclarationsTableKeywords() As Collection
    Dim TargetWorksheet As Worksheet
    Set TargetWorksheet = ThisWorkbook.Sheets("Declarations_Table")
    Dim Lr          As Long: Lr = getLastRow(TargetWorksheet)
    Dim coll        As New Collection
    Dim cell        As Range
    For Each cell In TargetWorksheet.Range("C2:C" & Lr)
        On Error Resume Next
        coll.Add cell.TEXT, cell.TEXT
        On Error GoTo 0
    Next
    Set DeclarationsTableKeywords = coll
End Function

Public Function getDeclarations( _
        Optional includeScope As Boolean, _
        Optional includeType As Boolean, _
        Optional includeKeywords As Boolean, _
        Optional includeDeclarations As Boolean, _
        Optional includeComponentName As Boolean, _
        Optional includeComponentType As Boolean) As Collection

    Dim ComponentCollection As New Collection
    Dim ComponentTypecollection As New Collection
    Dim DeclarationsCollection As New Collection
    Dim KeywordsCollection As New Collection
    Dim Output      As New Collection
    Dim ScopeCollection As New Collection
    Dim TypeCollection As New Collection

    Dim element     As Variant
    Dim OriginalDeclarations As Variant
    Dim str         As Variant

    Dim tmp         As String
    Dim helper      As String
    Dim i           As Long

    Dim module      As VBComponent
    For Each module In oWorkbook.VBProject.VBComponents
        '        If Module.Type = vbext_ct_StdModule Or Module.Type = vbext_ct_MSForm Then
        If module.CodeModule.CountOfDeclarationLines > 0 Then
            str = module.CodeModule.Lines(1, module.CodeModule.CountOfDeclarationLines)
            str = Replace(str, "_" & vbNewLine, "")
            OriginalDeclarations = str
            tmp = str
            Do While InStr(1, str, "End Type") > 0
                tmp = Mid(str, InStr(1, str, "Type "), InStr(1, str, "End Type") - InStr(1, str, "Type ") + 8)
                str = Replace(str, tmp, Split(tmp, vbNewLine)(0))
            Loop
            Do While InStr(1, str, "End Enum") > 0
                tmp = Mid(str, InStr(1, str, "Enum "), InStr(1, str, "End Enum") - InStr(1, str, "Enum ") + 8)
                str = Replace(str, tmp, Split(tmp, vbNewLine)(0))
            Loop
            Do While InStr(1, str, "  ") > 0
                str = Replace(str, "  ", " ")
            Loop

            str = Split(str, vbNewLine)
            tmp = OriginalDeclarations

            For Each element In str
                If Len(CStr(element)) > 0 And Not Trim(CStr(element)) Like "'*" And Not Trim(CStr(element)) Like "Rem*" Then
                    If RegexTest(CStr(element), "\b ?Enum \b") Then
                        KeywordsCollection.Add DeclarationsKeywordSubstring(CStr(element), " ", "Enum")
                        DeclarationsCollection.Add DeclarationsKeywordSubstring(tmp, , "Enum " & KeywordsCollection.item(KeywordsCollection.Count), "End Enum", , , True)
                        TypeCollection.Add "Enum"
                        ComponentCollection.Add module.Name
                        ComponentTypecollection.Add aModule.Init(module).TypeToString
                        ScopeCollection.Add IIf(InStr(1, DeclarationsCollection.item(DeclarationsCollection.Count), "Public", vbTextCompare), "Public", "Private")
                    ElseIf RegexTest(CStr(element), "\b ?Type \b") Then
                        KeywordsCollection.Add DeclarationsKeywordSubstring(CStr(element), " ", "Type")
                        DeclarationsCollection.Add DeclarationsKeywordSubstring(tmp, , "Type " & KeywordsCollection.item(KeywordsCollection.Count), "End Type", , , True)
                        TypeCollection.Add "Type"
                        ComponentCollection.Add module.Name
                        ComponentTypecollection.Add aModule.Init(module).TypeToString
                        ScopeCollection.Add IIf(InStr(1, DeclarationsCollection.item(DeclarationsCollection.Count), "Public", vbTextCompare), "Public", "Private")
                    ElseIf InStr(1, CStr(element), "Const ", vbTextCompare) > 0 Then
                        KeywordsCollection.Add DeclarationsKeywordSubstring(CStr(element), " ", "Const")
                        DeclarationsCollection.Add CStr(element)
                        TypeCollection.Add "Const"
                        ComponentCollection.Add module.Name
                        ComponentTypecollection.Add aModule.Init(module).TypeToString
                        ScopeCollection.Add IIf(InStr(1, DeclarationsCollection.item(DeclarationsCollection.Count), "Public", vbTextCompare), "Public", "Private")
                    ElseIf RegexTest(CStr(element), "\b ?Sub \b") Then
                        KeywordsCollection.Add DeclarationsKeywordSubstring(CStr(element), " ", "Sub")
                        DeclarationsCollection.Add CStr(element)
                        TypeCollection.Add "Sub"
                        ComponentCollection.Add module.Name
                        ComponentTypecollection.Add aModule.Init(module).TypeToString
                        ScopeCollection.Add IIf(InStr(1, DeclarationsCollection.item(DeclarationsCollection.Count), "Public", vbTextCompare), "Public", "Private")
                    ElseIf RegexTest(CStr(element), "\b ?Function \b") Then
                        KeywordsCollection.Add DeclarationsKeywordSubstring(CStr(element), " ", "Function")
                        DeclarationsCollection.Add CStr(element)
                        TypeCollection.Add "Function"
                        ComponentCollection.Add module.Name
                        ComponentTypecollection.Add aModule.Init(module).TypeToString
                        ScopeCollection.Add IIf(InStr(1, DeclarationsCollection.item(DeclarationsCollection.Count), "Public", vbTextCompare), "Public", "Private")
                    ElseIf element Like "*(*) As *" Then
                        helper = Left(element, InStr(1, CStr(element), "(") - 1)
                        helper = Mid(helper, InStrRev(helper, " ") + 1)
                        KeywordsCollection.Add helper
                        DeclarationsCollection.Add CStr(element)
                        TypeCollection.Add "Other"
                        ComponentCollection.Add module.Name
                        ComponentTypecollection.Add aModule.Init(module).TypeToString
                        ScopeCollection.Add IIf(InStr(1, DeclarationsCollection.item(DeclarationsCollection.Count), "Public", vbTextCompare), "Public", "Private")
                    ElseIf element Like "* As *" Then
                        KeywordsCollection.Add DeclarationsKeywordSubstring(CStr(element), " ", , "As")
                        DeclarationsCollection.Add CStr(element)
                        TypeCollection.Add "Other"
                        ComponentCollection.Add module.Name
                        ComponentTypecollection.Add aModule.Init(module).TypeToString
                        ScopeCollection.Add IIf(InStr(1, DeclarationsCollection.item(DeclarationsCollection.Count), "Public", vbTextCompare), "Public", "Private")
                    Else
                    End If
                End If
            Next element
        End If
        '        End If
    Next module

    If includeScope = True Then Output.Add ScopeCollection
    If includeType = True Then Output.Add TypeCollection
    If includeKeywords = True Then Output.Add KeywordsCollection
    If includeDeclarations = True Then Output.Add DeclarationsCollection
    If includeComponentType = True Then Output.Add ComponentTypecollection
    If includeComponentName = True Then Output.Add ComponentCollection

    Set getDeclarations = Output
End Function

Private Function DeclarationsKeywordSubstring( _
        str As Variant, Optional delim As String _
        , Optional afterWord As String _
        , Optional beforeWord As String _
        , Optional counter As Integer _
        , Optional outer As Boolean _
        , Optional includeWords As Boolean) As String

    Dim i           As Long
    If afterWord = "" And beforeWord = "" And counter = 0 Then
        MsgBox ("Pass at least 1 parameter betweenn -AfterWord- , -BeforeWord- , -counter-")
        Exit Function
    End If
    If TypeName(str) = "String" Then
        If delim <> "" Then
            str = Split(str, delim)
            If UBound(str) <> 0 Then
                If afterWord = "" And beforeWord = "" And counter <> 0 Then
                    If counter - 1 <= UBound(str) Then
                        DeclarationsKeywordSubstring = str(counter - 1)
                        Exit Function
                    End If
                End If
                For i = LBound(str) To UBound(str)
                    If afterWord <> "" And beforeWord = "" Then
                        If i <> 0 Then
                            If str(i - 1) = afterWord Or str(i - 1) = "#" & afterWord Then
                                DeclarationsKeywordSubstring = str(i)
                                Exit Function
                            End If
                        End If
                    ElseIf afterWord = "" And beforeWord <> "" Then
                        If i <> UBound(str) Then
                            If str(i + 1) = beforeWord Or str(i + 1) = "#" & beforeWord Then
                                DeclarationsKeywordSubstring = str(i)
                                Exit Function
                            End If
                        End If
                    ElseIf afterWord <> "" And beforeWord <> "" Then
                        If i <> 0 And i <> UBound(str) Then
                            If (str(i - 1) = afterWord Or str(i - 1) = "#" & afterWord) And (str(i + 1) = beforeWord Or str(i + 1) = "#" & beforeWord) Then
                                DeclarationsKeywordSubstring = str(i)
                                Exit Function
                            End If
                        End If
                    End If
                Next i
            End If
        Else
            If InStr(1, str, afterWord) > 0 And InStr(1, str, beforeWord) > 0 Then
                If includeWords = False Then
                    DeclarationsKeywordSubstring = Mid(str, InStr(1, str, afterWord) + Len(afterWord))
                Else
                    DeclarationsKeywordSubstring = Mid(str, InStr(1, str, afterWord))
                End If
                If outer = True Then
                    If includeWords = False Then
                        DeclarationsKeywordSubstring = Left(DeclarationsKeywordSubstring, InStrRev(DeclarationsKeywordSubstring, beforeWord) - 1)
                    Else
                        DeclarationsKeywordSubstring = Left(DeclarationsKeywordSubstring, InStrRev(DeclarationsKeywordSubstring, beforeWord) + Len(beforeWord) - 1)
                    End If
                Else
                    If includeWords = False Then
                        DeclarationsKeywordSubstring = Left(DeclarationsKeywordSubstring, InStr(1, DeclarationsKeywordSubstring, beforeWord) - 1)
                    Else
                        DeclarationsKeywordSubstring = Left(DeclarationsKeywordSubstring, InStr(1, DeclarationsKeywordSubstring, beforeWord) + Len(beforeWord) - 1)
                    End If
                End If
                Exit Function
            End If
        End If
    Else
        '
    End If
    DeclarationsKeywordSubstring = vbNullString
End Function

Public Sub DeclarationsTableExport()
    Dim ws          As Worksheet
    Set ws = ThisWorkbook.Sheets("Declarations_Table")
    Dim codeName    As String
    Dim codeText    As String
    Dim cell        As Range
    Dim Lr          As Long
    Lr = getLastRow(ws)
    Dim codeCollection As Collection
    For Each cell In ws.Range("C2:C" & Lr)
        codeName = cell.TEXT
        Set codeCollection = New Collection
        On Error Resume Next
        codeCollection.Add cell.offset(0, 1).TEXT, cell.offset(0, 1).TEXT
        On Error GoTo 0
        Do While cell.offset(1, 0).TEXT = cell.TEXT
            Set cell = cell.offset(1, 0)
            On Error Resume Next
            codeCollection.Add cell.offset(0, 1).TEXT, cell.offset(0, 1).TEXT
            On Error GoTo 0
        Loop
        codeText = aCollection.Init(codeCollection).ToString(IIf(codeCollection.Count > 1, vbNewLine, ""))
        TxtOverwrite LOCAL_LIBRARY_DECLARATIONS & codeName & ".txt", codeText
    Next
End Sub

Function getDeclaredKeywordsOfWorkbook() As Variant
    getDeclaredKeywordsOfWorkbook = WorksheetFunction.Transpose(aCollection.CollectionsToArray2D(getDeclarations(, , True)))
End Function

Function getDeclaredEnumOfWorkbook() As String
    Dim c           As Variant
    Dim out         As String
    For Each c In aCollection.CollectionsToArray2D(getDeclarations(, , , True))
        If InStr(1, CStr(c), "Enum ") > 0 Then out = IIf(out = "", c, out & vbNewLine & c)
    Next
    getDeclaredEnumOfWorkbook = out
End Function

Function getDeclaredTypeOfWorkbook() As String
    Dim c           As Variant
    Dim out         As String
    For Each c In aCollection.CollectionsToArray2D(getDeclarations(, , , True))
        If InStr(1, CStr(c), "Type ") > 0 Then out = IIf(out = "", c, out & vbNewLine & c)
    Next
    getDeclaredTypeOfWorkbook = out
End Function

Function getDeclaredSubOfWorkbook(TargetWorkbook As Workbook) As String
    Dim c           As Variant
    Dim out         As String
    For Each c In aCollection.CollectionsToArray2D(getDeclarations(, , , True))
        If InStr(1, CStr(c), "Sub ") > 0 Then out = IIf(out = "", c, out & vbNewLine & c)
    Next
    getDeclaredSubOfWorkbook = out
End Function

Function getDeclaredFunctionOfWorkbook() As String
    Dim c           As Variant
    Dim out         As String
    For Each c In aCollection.CollectionsToArray2D(getDeclarations(, , , True))
        If InStr(1, CStr(c), "Function ") > 0 Then out = IIf(out = "", c, out & vbNewLine & c)
    Next
    getDeclaredFunctionOfWorkbook = out
End Function



'aModule	Class


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Class      : aModule
'* Purpose    :
'* Copyright  :
'*
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 29-06-2023 14:39    Alex
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Private oModule     As VBComponent
Private oWorkbook   As Workbook

Public Sub PredeclaredIDenable()
    SetPredeclaredId True
End Sub

Public Sub SetPredeclaredId(Toggle As Boolean)
    '@AssignedModule aModule
    '@INCLUDE PROCEDURE TxtOverwrite
    '@INCLUDE PROCEDURE TxtRead
    '@INCLUDE CLASS aModule

    Dim FName1      As String: FName1 = ThisWorkbook.path & "\" & "TempClass.cls"
    oWorkbook.VBProject.VBComponents(oModule.Name).Export FName1
    TxtOverwrite FName1, VBA.Replace( _
            VBA.Replace(TxtRead(FName1), _
            IIf(Toggle = True, _
            "Attribute VB_PredeclaredId = False", _
            "Attribute VB_PredeclaredId = True"), _
            IIf(Toggle = True, _
            "Attribute VB_PredeclaredId = True", _
            "Attribute VB_PredeclaredId = False"), _
            1, _
            1), _
            vbLf, vbCrLf, _
            1, _
            -1)

    Delete
    oWorkbook.VBProject.VBComponents.Import FName1
    Kill FName1

End Sub

Public Function ClassCalls() As Variant
    'classCallsOfModule(0) is the class name
    'classCallsOfModule(1) is the keyword for the class name (eg dim clsCal as new classCalendar)
    '@AssignedModule aModule
    '@INCLUDE PROCEDURE ClassNames
    '@INCLUDE PROCEDURE classCallsOfModule
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aModules

    Dim Code        As Variant
    Dim element     As Variant
    Dim Keyword     As Variant
    Dim var         As Variant
    ReDim var(1 To 2, 1 To 1)
    Dim counter     As Long: counter = 0
    Dim ClassName   As Variant
    If oModule.CodeModule.CountOfDeclarationLines > 0 Then
        Code = oModule.CodeModule.Lines(1, oModule.CodeModule.CountOfDeclarationLines)
        Code = Replace(Code, "_" & vbNewLine, "")
        Code = Split(Code, vbNewLine)
        Code = Filter(Code, " As ", , vbTextCompare)
        For Each element In Code
            element = Trim(element)
            If element Like "* As *" Then
                Keyword = Split(element, " As ")(0)
                Keyword = Split(Keyword, " ")(UBound(Split(Keyword, " ")))
                element = Split(element, " As ")(1)
                element = Replace(element, "New ", "")
                For Each ClassName In aModules.Init(oWorkbook).ClassNames
                    If element = ClassName Then
                        ReDim Preserve var(1 To 2, 1 To counter + 1)
                        var(1, UBound(var, 2)) = element
                        var(2, UBound(var, 2)) = Keyword
                        counter = counter + 1
                        '                        Exit For
                    End If
                Next
            End If
        Next
        If var(1, 1) <> "" Then
            If UBound(var, 2) > 1 Then
                ClassCalls = WorksheetFunction.Transpose(var)
            Else
                Dim VAR2(1 To 1, 1 To 2)
                VAR2(1, 1) = var(1, 1)
                VAR2(1, 2) = var(2, 1)
                ClassCalls = VAR2
            End If
        End If
    End If

End Function
Public Function Active() As aModule
    '@AssignedModule aModule
    '@INCLUDE PROCEDURE ActiveModule
    '@INCLUDE CLASS aModule
    Init ActiveModule
    Set Active = Me
End Function

Public Function Init(module As Variant) As aModule
    '@AssignedModule aModule
    '@INCLUDE CLASS aModule
    If TypeName(module) = "VBComponent" Then
        Set oModule = module
    Else
        Set module = module.Parent.VBProject.VBComponents(module.codeName)
    End If
    Set oWorkbook = Parent
    Set Init = Me
End Function

Sub PrintListOfInclude()
    '@AssignedModule aModule
    '@INCLUDE PROCEDURE dp
    '@INCLUDE CLASS aModule
    dp ListOfInclude
End Sub

Function ListOfInclude() As Collection
    '@AssignedModule aModule
    '@INCLUDE PROCEDURE ArrayQuickSort
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aCollection

    Dim var: var = Split(Code, vbNewLine)
    ArrayQuickSort Filter(Filter(var, "'@INCLUDE ", True), """", False)
    Dim coll        As New Collection
    Dim el
    On Error Resume Next
    For Each el In var
        el = Trim(el)
        If el Like "'@INCLUDE *" Then
            coll.Add el, CStr(el)
        End If
    Next
    On Error GoTo 0
    var = aCollection.Init(coll).ToArray
    Dim matches     As String: matches = Join(var, vbNewLine)
    Dim out         As String: out = out & vbNewLine & "'=== Module: " & oModule.Name & "===" & vbNewLine & matches
    Set ListOfInclude = coll
End Function

Public Function Duplicate( _
        Optional NewName As String, _
        Optional ActivateNewModule As Boolean = True) As Boolean
    '@AssignedModule aModule
    '@INCLUDE CLASS aModule

    If NewName = "" Then NewName = Name & "_Copy"
    On Error GoTo Error_Handler
    Dim TargetFile  As String
    TargetFile = Environ("Temp") & "\" & NewName & Extension
    oModule.Name = NewName
    oModule.Export TargetFile
    oModule.Name = Name
    oWorkbook.VBProject.VBComponents.Import TargetFile
    If Len(Dir(TargetFile)) > 0 Then Kill Replace(TargetFile, Extension, ".*")
    If ActivateNewModule = True Then oWorkbook.VBProject.VBComponents(NewName).Activate
    '    DuplicateUserForm = True
Error_Handler_Exit:
    On Error Resume Next
    Exit Function
Error_Handler:
    MsgBox "The following error has occured" & vbCrLf & vbCrLf & _
            "Error Number: " & Err.Number & vbCrLf & _
            "Error Source: aModule.Duplicate" & vbCrLf & _
            "Error Description: " & Err.Description & _
            Switch(Erl = 0, "", Erl <> 0, vbCrLf & "Line No: " & Erl) _
            , vbOKOnly + vbCritical, "An Error has Occured!"
    Resume Error_Handler_Exit
End Function

Sub PrintTodoList()
    '@AssignedModule aModule
    '@INCLUDE PROCEDURE dp
    '@INCLUDE CLASS aModule
    dp TodoList
End Sub

Function TodoList()
    '@AssignedModule aModule
    '@INCLUDE CLASS aModule
    Dim out         As String
    Dim matches     As String
    matches = Join(Filter(Split(Code, vbNewLine), "@TODO", True), vbNewLine)
    out = out & vbNewLine & "'---------"
    out = out & vbNewLine & "'Module: " & Name
    out = out & vbNewLine & "'---------"
    '    out = out & vbNewLine & "'" & Replace(Matches, vbNewLine, vbNewLine & "'")
    out = out & vbNewLine & matches    ' "'" & Replace(Matches, vbNewLine, vbNewLine & "'")
    TodoList = out
End Function


Sub HeaderAdd()
    '@AssignedModule aModule
    '@INCLUDE PROCEDURE ActiveProcedure
    '@INCLUDE PROCEDURE PadRight
    '@INCLUDE CLASS aModule
    '@INCLUDE DECLARATION AUTHOR_COPYRIGHT
    '@INCLUDE DECLARATION AUTHOR_EMAIL
    '@INCLUDE DECLARATION AUTHOR_NAME
    '@INCLUDE DECLARATION AUTHOR_OTHERTEXT

    Const vbTab2 = vbTab & vbTab
    Const vbTab4 = vbTab & vbTab & vbTab & vbTab
    Const sFersLine As String = "'* Modified   :" & vbTab & "Date and Time" & vbTab & vbTab & "Author" & vbTab4 & "Description" & vbCrLf

    Dim txtName     As String: txtName = AUTHOR_NAME
    If txtName = vbNullString Then txtName = Environ("UserName")
    txtName = "'* Author     :" & vbTab & txtName & vbCrLf

    Dim txtContacts As String: txtContacts = AUTHOR_EMAIL
    If txtContacts <> vbNullString Then txtContacts = "'* Contacts   :" & vbTab & txtContacts & vbCrLf

    Dim txtCopyright As String: txtCopyright = AUTHOR_COPYRIGHT
    '    If txtCopyright <> vbNullString Then txtCopyright = "'* Copyright  :" & vbTab & txtCopyright & vbCrLf
    txtCopyright = "'* Copyright  :" & vbTab & txtCopyright & vbCrLf

    Dim txtOther    As String: txtOther = AUTHOR_OTHERTEXT
    If txtOther <> vbNullString Then txtOther = "'* Note       :" & vbTab & txtOther & vbCrLf

    Dim txtMedia    As String: txtMedia = "'* " & vbLf & AUTHOR_MEDIA
    Dim CurentCodePane As CodePane: Set CurentCodePane = oModule.CodeModule.CodePane
    Dim i           As Byte
    Dim ProcKind    As VBIDE.vbext_ProcKind
    Dim sProc       As String: sProc = ActiveProcedure
    Dim nLine       As Long: nLine = 1
    Dim sTemp       As String
    Dim sTime       As String
    Dim sType       As String
    Dim sProcDeclartion As String
    Dim sProcArguments As String

    Dim sUser       As String
    On Error GoTo ErrorHandler

    sUser = "Alex"
    If sUser = vbNullString Then sUser = Environ("UserName")

    sTemp = Replace(String(90, "*"), "**", "* ")
    sTime = Format(Now, "dd-mm-yyyy hh:nn")
    sProc = oModule.Name
    sType = "'* " & PadRight(Me.TypeToString, 11) & ":" & vbTab & sProc & vbCrLf

    If LineLike("* " & PadRight(Me.TypeToString, 11) & ": " & oModule.Name, True, True) > 0 Then GoTo UpdateHeader

    With oModule.CodeModule.CodePane
        sTemp = vbLf & "'" & sTemp & vbCrLf & _
                sType & _
                "'* Purpose    :" & vbCrLf & _
                txtCopyright & "'* " & vbCrLf & _
                txtName & _
                txtContacts & _
                txtOther & _
                txtMedia & _
                sFersLine & _
                "'* Created    :" & vbTab & sTime & vbTab & sUser & vbCrLf & _
                sProcArguments & _
                "'" & sTemp
        sTemp = sTemp & vbNewLine & IIf(HeaderContains("Option Explicit"), "", "Option Explicit" & vbNewLine) & _
                                    IIf(HeaderContains("Option Private Module"), "", "Option Private Module" & vbNewLine) & _
                                    IIf(HeaderContains("Option Base 1"), "", "Option Base 1") & vbNewLine & _
                                    IIf(HeaderContains("C_MODULE_NAME"), "", "C_MODULE_NAME = " & """" & Me.Name & """" & vbNewLine)
         
'         sTemp = sTemp & "'You may later want to use: amodule.active.ListProceduresPublic"
        .CodeModule.InsertLines 1, sTemp & vbNewLine
    End With
    
NormalExit:
    Exit Sub
    
UpdateHeader:
    nLine = LineLike("'* Created    : *", True, True) + 1
    'put update to bottom of changes list
    Do While Trim(oModule.CodeModule.Lines(nLine, 1)) Like "'* Modified*)"
        nLine = nLine + 1
    Loop
    oModule.CodeModule.InsertLines nLine, "'* Modified   :" & vbTab & sTime & vbTab & sUser
    GoTo NormalExit
    
ErrorHandler:
    GoTo NormalExit
End Sub

Function item() As VBComponent
    '@AssignedModule aModule
    '@INCLUDE CLASS aModule
    Set item = oModule
End Function

'* Modified   : Date and Time       Author              Description
'* Updated    : 22-08-2023 09:21    Alex                (aModule.cls > ListProcedures)

Public Sub ListProcedures()
'@LastModified 2308220921
    '@AssignedModule aModule
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aCollection
    Dim coll        As New Collection
    Set coll = ProceduresNames
    If coll.Count = 0 Then Exit Sub
    
    Dim txt         As String
    txt = "'@FOLDER ListOfProcedures" & vbNewLine & "'" & String(100, "-") & vbNewLine
    
    Dim tmp
    Dim arr:    arr = aCollection.Init(coll).ToArray
    Dim ll:     ll = LargestLength(coll)
    Dim ap As aProcedure
    For Each ap In Procedures
        Dim ks
        ks = ap.KindAsString
        Select Case ks
        Case "Get"
            tmp = "'" & Space(4) & "|> " & ks & " | --- " & ap.Name
        Case "Let", "Set"
            tmp = "'" & Space(4) & "|> --- | " & ks & " " & ap.Name
        Case "Sub"
            tmp = "'" & Space(4) & "|> Sub " & String(5, "-") & " " & ap.Name
        Case "Function"
            tmp = "'" & Space(4) & "|> Fun " & String(5, "-") & " " & ap.Name
        End Select
        tmp = tmp & Space(4 + (ll - Len(ap.Name))) & ":"
        
        Dim Desc As String, index As Long
        index = ap.LineLike("*'@Description*", Body_Code)
        If index > 0 Then
            Desc = ap.Parent.CodeModule.Lines(index, 1)
            tmp = tmp & " " & Desc
        End If
        txt = txt & tmp & vbNewLine
    Next
    txt = txt & "'" & String(100, "-") & vbNewLine
    txt = txt & "'@EndFolder ListOfProcedures" & vbNewLine
    FolderDelete "ListOfProcedures"
    oModule.CodeModule.InsertLines 1, txt
End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 22-08-2023 09:21    Alex                (aModule.cls > ListProceduresPublic)

Public Sub ListProceduresPublic()
'@LastModified 2308220921
    '@AssignedModule aModule
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aCollection
    Dim coll        As New Collection
    Set coll = PublicProceduresNames
    If coll.Count = 0 Then Exit Sub
    
    Dim txt         As String
    
    txt = "'@FOLDER ListOfProcedures" & vbNewLine & "'" & String(100, "-") & vbNewLine
    
    Dim tmp
    Dim arr:    arr = aCollection.Init(coll).ToArray
    Dim ll:     ll = LargestLength(coll)
    Dim ap As aProcedure
    For Each ap In Procedures
        Dim ks
        ks = ap.KindAsString
        Select Case ks
        Case "Get"
            tmp = "'" & Space(4) & "|> " & ks & " | --- " & ap.Name
        Case "Let", "Set"
            tmp = "'" & Space(4) & "|> --- | " & ks & " " & ap.Name
        Case "Sub"
            tmp = "'" & Space(4) & "|> Sub " & String(5, "-") & " " & ap.Name
        Case "Function"
            tmp = "'" & Space(4) & "|> Fun " & String(5, "-") & " " & ap.Name
        End Select
        tmp = tmp & Space(4 + (ll - Len(ap.Name))) & ":"
        
        Dim Desc As String, index As Long
        index = ap.LineLike("*'@Description*", Body_Code)
        If index > 0 Then
            Desc = ap.Parent.CodeModule.Lines(index, 1)
            tmp = tmp & " " & Desc
        End If
        txt = txt & tmp & vbNewLine
    Next
    txt = txt & "'" & String(100, "-") & vbNewLine
    txt = txt & "'@EndFolder ListOfProcedures" & vbNewLine
    FolderDelete "ListOfProcedures"
    oModule.CodeModule.InsertLines 1, txt
End Sub

Public Sub FolderDelete(FolderName As String)
'@LastModified 2310251309
    '@AssignedModule aModule
'@INCLUDE DECLARATION oModule
'@INCLUDE CLASS aModule
    Dim startLine As Long, endLine As Long
    Dim sLine       As String
    Dim i           As Long
    For i = 1 To oModule.CodeModule.CountOfLines
        sLine = Trim(oModule.CodeModule.Lines(i, 1))
        If sLine = "'@FOLDER " & FolderName Then startLine = i
        If startLine <> 0 Then
            If sLine = "'@EndFolder " & FolderName Then endLine = i
        End If
        If startLine <> 0 And endLine <> 0 Then Exit For
    Next
'
    If startLine = 0 Or endLine = 0 Then Exit Sub
    oModule.CodeModule.DeleteLines startLine, endLine - startLine + 1
End Sub

Public Sub ProcedureSortByKind()
    '@AssignedModule aModule
    '@INCLUDE PROCEDURE ArrayQuickSort
    '@INCLUDE CLASS aProcedure
    '@INCLUDE CLASS aModule
    If oModule.CodeModule.CountOfLines = 0 Then Exit Sub
    Dim coll        As New Collection: Set coll = Procedures
    Dim var         As Variant: ReDim var(1 To coll.Count)
    Dim p           As aProcedure
    Dim startLine   As Long
    Dim i           As Long
    For i = 1 To coll.Count
        Set p = coll(i)
        var(i) = p.Name
        If i = 1 Then startLine = p.Line_First
    Next
    ArrayQuickSort var
    Dim h           As String: h = Header
    Dim S           As String
    Dim TheSubs As String, TheFunctions As String
    For i = LBound(var) To UBound(var)
        Set p = aProcedure.Init(Parent, oModule, CStr(var(i)))
        S = p.Code_All
        If p.KindAsString = "Sub" Then
            TheSubs = TheSubs & IIf(TheSubs <> "", vbNewLine, "") & S
        Else
            TheFunctions = TheFunctions & IIf(TheFunctions <> "", vbNewLine, "") & S
        End If
    Next i
    CodeRemove
    oModule.CodeModule.AddFromString h & vbLf & TheSubs & vbLf & TheFunctions

End Sub
Public Sub ProcedureSortByScope()
    '@AssignedModule aModule
    '@INCLUDE PROCEDURE ArrayQuickSort
    '@INCLUDE CLASS aProcedure
    '@INCLUDE CLASS aModule
    If oModule.CodeModule.CountOfLines = 0 Then Exit Sub
    Dim coll        As New Collection: Set coll = Procedures
    Dim var         As Variant: ReDim var(1 To coll.Count)
    Dim p           As aProcedure
    Dim startLine   As Long
    Dim i           As Long
    For i = 1 To coll.Count
        Set p = coll(i)
        var(i) = p.Name
        If i = 1 Then startLine = p.Line_First
    Next
    ArrayQuickSort var
    Dim h           As String: h = Header
    Dim S           As String
    Dim ThePublic As String, ThePrivate As String
    For i = LBound(var) To UBound(var)
        Set p = aProcedure.Init(Parent, oModule, CStr(var(i)))
        S = p.Code_All
        If p.Scope = "Public" Then
            ThePublic = ThePublic & IIf(ThePublic <> "", vbNewLine, "") & S
        Else
            ThePrivate = ThePrivate & IIf(ThePublic <> "", vbNewLine, "") & S
        End If
    Next i
    CodeRemove
    oModule.CodeModule.AddFromString h & vbLf & ThePrivate & vbLf & ThePublic
End Sub

Public Sub ProcedureSortAZ()
    '@AssignedModule aModule
    '@INCLUDE PROCEDURE ArrayQuickSort
    '@INCLUDE CLASS aProcedure
    '@INCLUDE CLASS aModule
    If oModule.CodeModule.CountOfLines = 0 Then Exit Sub
    Dim coll        As New Collection: Set coll = Procedures
    Dim var         As Variant: ReDim var(1 To coll.Count)
    Dim p           As aProcedure
    Dim startLine   As Long
    Dim i           As Long
    For i = 1 To coll.Count
        Set p = coll(i)
        var(i) = p.Name
        If i = 1 Then startLine = p.Line_First
    Next
    ArrayQuickSort var
    Dim S           As String: S = Header
    For i = LBound(var) To UBound(var)
        Set p = aProcedure.Init(Parent, oModule, CStr(var(i)))
        S = S & IIf(S <> "", vbNewLine, "") & p.Code_All
    Next i
    CodeRemove
    oModule.CodeModule.AddFromString S
End Sub

Public Function Component() As VBComponent
    '@AssignedModule aModule
    '@INCLUDE CLASS aModule
    Set Component = oModule
End Function

Public Function LineLike( _
        this As String, _
        IgnoreIndentation As Boolean, _
        IgnoreCase As Boolean) As Long
    '@AssignedModule aModule
    '@INCLUDE CLASS aModule
    If oModule.CodeModule.CountOfLines = 0 Then Exit Function
    If IgnoreCase Then this = UCase(this)
    Dim sLine       As String
    Dim i           As Long
    For i = 1 To oModule.CodeModule.CountOfLines
        sLine = oModule.CodeModule.Lines(i, 1)
        If IgnoreIndentation Then sLine = Trim(sLine)
        If IgnoreCase Then sLine = UCase(sLine)
        If sLine Like this Then
            LineLike = i
            Exit Function
        End If
    Next
End Function

Public Function LinesLike( _
        this As String, _
        IgnoreIndentation As Boolean, _
        IgnoreCase As Boolean) As Collection
    '@AssignedModule aModule
    '@INCLUDE CLASS aModule
    If oModule.CodeModule.CountOfLines = 0 Then Exit Function
    If IgnoreCase Then this = UCase(this)
    Dim coll        As New Collection
    Dim sLine       As String
    Dim i           As Long
    For i = 1 To oModule.CodeModule.CountOfLines
        sLine = oModule.CodeModule.Lines(i, 1)
        If IgnoreIndentation Then sLine = Trim(sLine)
        If IgnoreCase Then sLine = UCase(sLine)
        If sLine Like this Then
            coll.Add i
        End If
    Next
    Set LinesLike = coll

End Function


'* Modified   : Date and Time       Author              Description
'* Updated    : 22-08-2023 13:56    Alex                (aModule.cls > RemoveLinesLike)

Public Sub RemoveLinesLike(this As String)
'@LastModified 2308221356
    Dim ap          As aProcedure
    For Each ap In Procedures
        ap.RemoveLinesLike this
    Next
End Sub

Public Sub ProcedureScopePrivate()
    '@AssignedModule aModule
    '@INCLUDE CLASS aProcedure
    '@INCLUDE CLASS aModule
    Dim ap          As aProcedure
    For Each ap In Procedures
        ap.ScopePrivate
    Next
End Sub

Public Sub ProcedureScopePublic()
    '@AssignedModule aModule
    '@INCLUDE CLASS aProcedure
    '@INCLUDE CLASS aModule
    Dim ap          As aProcedure
    For Each ap In Procedures
        ap.ScopePublic
    Next
End Sub
Sub EnableDebugPrint()
    '@AssignedModule aModule
    '@INCLUDE CLASS aProcedure
    '@INCLUDE CLASS aModule
    Dim ap          As aProcedure
    For Each ap In Procedures
        ap.Enable_DebugPrint
    Next
End Sub
Sub DisableDebugPrint()
    '@AssignedModule aModule
    '@INCLUDE CLASS aProcedure
    '@INCLUDE CLASS aModule
    Dim ap          As aProcedure
    For Each ap In Procedures
        ap.Disable_DebugPrint
    Next
End Sub
Public Sub EnableStop()
    '@AssignedModule aModule
    '@INCLUDE CLASS aProcedure
    '@INCLUDE CLASS aModule
    Dim ap          As aProcedure
    For Each ap In Procedures
        ap.Enable_Stop
    Next
End Sub
Public Sub DisableStop()
    '@AssignedModule aModule
    '@INCLUDE CLASS aProcedure
    '@INCLUDE CLASS aModule
    Dim ap          As aProcedure
    For Each ap In Procedures
        ap.Disable_Stop
    Next
End Sub

Public Sub ProcedureFoldDeclarations()
    '@AssignedModule aModule
    '@INCLUDE CLASS aProcedure
    '@INCLUDE CLASS aModule
    Dim ap          As aProcedure
    For Each ap In Procedures
        ap.FoldDeclaration
    Next
End Sub


Public Function Procedures() As Collection  'ExcludeUnderscore as Boolean '@TODO
    '@AssignedModule aModule
    '@INCLUDE CLASS aProcedure
    '@INCLUDE CLASS aModule
    Dim lineNum     As Long
    Dim ProcedureName As String
    Dim ProcKind    As Long
    Dim coll        As New Collection
    Dim i           As Long
    Dim cProcedure  As aProcedure
    With oModule.CodeModule

        lineNum = .CountOfDeclarationLines + 1
        Do Until lineNum >= .CountOfLines
            On Error Resume Next
            For i = 0 To 4
                ProcKind = i
                ProcedureName = .ProcOfLine(lineNum, ProcKind)
                If ProcedureName <> vbNullString Then Exit For
            Next
            On Error GoTo 0
            'Err.clear
            If ProcedureName = vbNullString Then Exit Function

            'Possible Error:
            '---------------
            ' Procedures with an underscore _ which is used in events
            ' and Private Procedures
            ' may have the same name in different components

            If InStr(1, ProcedureName, "_") = 0 Then    '>0 and ExcludeUnderscore then goto SKIP

                Set cProcedure = New aProcedure
                cProcedure.Init oWorkbook, oModule, ProcedureName, ProcKind
                On Error Resume Next
                coll.Add cProcedure    ', cProcedure.Name
                '                    coll.Add ProcedureName, ProcedureName
                '                    If Err.Number > 0 Then Debug.Print ProcedureName & " exists multiple times, added only once, may lead to error"
                '                    Err.clear
                On Error GoTo 0
                lineNum = .procStartLine(ProcedureName, ProcKind) + .ProcCountLines(ProcedureName, ProcKind) + 1
            End If
            lineNum = .procStartLine(ProcedureName, ProcKind) + .ProcCountLines(ProcedureName, ProcKind) + 1
            ProcedureName = vbNullString
        Loop
    End With
    Set Procedures = coll
End Function

Function ProceduresNames() As Collection
    '@AssignedModule aModule
    '@INCLUDE CLASS aProcedure
    '@INCLUDE CLASS aModule
    Dim ap          As aProcedure
    Dim coll        As New Collection
    Dim ProcedureName As String
    For Each ap In Procedures
        ProcedureName = ap.Name
        On Error Resume Next
        coll.Add ProcedureName, ProcedureName
        On Error GoTo 0
        If Err.Number > 0 Then Debug.Print ProcedureName & " exists multiple times, added only once, may lead to error"
        Err.clear
    Next
    Set ProceduresNames = coll
End Function
Function PublicProceduresNames() As Collection
    '@AssignedModule aModule
    '@INCLUDE CLASS aProcedure
    '@INCLUDE CLASS aModule
    Dim ap          As aProcedure
    Dim coll        As New Collection
    Dim ProcedureName As String
    For Each ap In Procedures
        ProcedureName = ap.Name
        On Error Resume Next
        If ap.Scope = "Public" Then coll.Add ProcedureName, ProcedureName
        On Error GoTo 0
        If Err.Number > 0 Then Debug.Print ProcedureName & " exists multiple times, added only once, may lead to error"
        Err.clear
    Next
    Set PublicProceduresNames = coll
End Function
Sub UpdateProcedures()
    '@AssignedModule aModule
    '@INCLUDE CLASS aProcedure
    '@INCLUDE CLASS aModule
    Dim Procedure   As aProcedure
    For Each Procedure In Procedures
        Procedure.Update
    Next
End Sub

Sub CommentsToOwnLine()
    '@AssignedModule aModule
    '@INCLUDE PROCEDURE CommentsMoveToOwnLine
    '@INCLUDE CLASS aModule
    Dim S           As String
    With oModule.CodeModule
        If .CountOfLines = 0 Then Exit Sub
        S = CommentsMoveToOwnLine(Code)
        CodeRemove
        .AddFromString S
    End With
End Sub

Public Sub Indent()
    '@AssignedModule aModule
    '@INCLUDE PROCEDURE IsBlockEnd
    '@INCLUDE PROCEDURE IsBlockStart
    '@INCLUDE CLASS aModule
    If oModule.CodeModule.CountOfLines = 0 Then Exit Sub
    Dim LineStart As Long, LineEnd As Long
    LineStart = 1
    LineEnd = oModule.CodeModule.CountOfLines
    Dim nIndent     As Long
    Dim S           As String
    Dim i           As Long
    For i = LineStart To LineEnd
        S = LTrim$(oModule.CodeModule.Lines(i, 1))
        If Trim(S) <> "" Then
            If IsBlockEnd(S) Then nIndent = nIndent - 1
            If nIndent < 0 Then nIndent = 0
            S = Space$(nIndent * 4) & S
            oModule.CodeModule.ReplaceLine i, S
            If IsBlockStart(LTrim$(S)) Then nIndent = nIndent + 1
        End If
    Next
End Sub

Sub Activate()
    '@AssignedModule aModule
    '@INCLUDE CLASS aModule
    With Application.VBE.MainWindow
        .Visible = True
        .WindowState = vbext_ws_Maximize
    End With
    With oModule.CodeModule.CodePane
        .Show
        .Window.Visible = True
        .Window.WindowState = vbext_ws_Maximize
        .Window.SetFocus
        .SetSelection 1, 1, 1, 1
    End With
End Sub

Function Code() As String
    '@AssignedModule aModule
    '@INCLUDE CLASS aModule
    With oModule.CodeModule
        If .CountOfLines = 0 Then Code = "": Exit Function
        Code = .Lines(1, .CountOfLines)
    End With
End Function

Public Function body() As String
    '@AssignedModule aModule
    '@INCLUDE CLASS aModule
    With oModule.CodeModule
        If .CountOfLines - .CountOfDeclarationLines = 0 Then Exit Function
        body = .Lines(.CountOfDeclarationLines + 1, .CountOfLines - .CountOfDeclarationLines)
    End With
End Function

Function Contains( _
        this As String, _
        WholeWord As Boolean, _
        MatchCase As Boolean, _
        PatternSearch As Boolean)
    '@AssignedModule aModule
    '@INCLUDE CLASS aModule

    If oModule.CodeModule.CountOfLines = 0 Then Exit Function
    Contains = oModule.CodeModule.Find( _
            this, _
            1, _
            1, _
            oModule.CodeModule.CountOfLines, _
            10000, _
            WholeWord, _
            MatchCase, _
            PatternSearch)
End Function

Function Header() As String
    '@AssignedModule aModule
    '@INCLUDE CLASS aModule
    If oModule.CodeModule.CountOfDeclarationLines = 0 Then Exit Function
    With oModule.CodeModule
        Header = .Lines(1, .CountOfDeclarationLines)
    End With
End Function

Function HeaderContains(this As String) As Boolean
    '@AssignedModule aModule
    '@INCLUDE CLASS aModule
    HeaderContains = (InStr(1, Header, this) > 0)
End Function

Function Ignore() As Boolean
    '@AssignedModule aModule
    '@INCLUDE CLASS aModule
    Ignore = InStr(1, Header, "@IGNORE", vbTextCompare) > 0
End Function

Public Property Get Parent() As Workbook
    Dim S           As String
    S = oModule.Collection.Parent.fileName
    S = Right(S, Len(S) - InStrRev(S, "\"))
    Set Parent = Workbooks(S)
End Property

Function Name() As String
    Name = oModule.Name
    If oModule.Type = vbext_ct_Document And oModule.Name <> "ThisWorkbook" Then
        On Error GoTo HELL
        Name = GetSheetByCodeName(Parent, oModule.Name).Name
        On Error GoTo 0
    End If
    Exit Function
HELL:
    Debug.Print "Probably the file is in another language"
    Name = "ThisWorkbook"
End Function

Function TypeToLong() As vbext_ComponentType
    TypeToLong = oModule.Type
End Function

Function TypeToString() As String
    Select Case oModule.Type
        Case vbext_ct_ActiveXDesigner
            TypeToString = "ActiveX Designer"
        Case vbext_ct_ClassModule
            TypeToString = "Class"
        Case vbext_ct_Document
            TypeToString = "Document"
        Case vbext_ct_MSForm
            TypeToString = "UserForm"
        Case vbext_ct_StdModule
            TypeToString = "Module"
        Case Else
            TypeToString = "Unknown Type: " & CStr(oModule.Type)
    End Select
End Function

Sub ExportProcedures(targetPath As String)
    If targetPath = "" Then Exit Sub    '<- FOR when called with FolderPicker
    targetPath = Replace(targetPath & "\", "\\", "\")
    FoldersCreate targetPath
    Dim ap          As aProcedure
    Dim coll        As New Collection: Set coll = Procedures
    If coll.Count > 0 Then
        For Each ap In coll
            TxtOverwrite targetPath & ap.Name & ".txt", ap.Code_All
        Next
    End If
End Sub

Sub Export(targetPath As String)
    If targetPath = "" Then Exit Sub    '<- FOR when called with FolderPicker
    targetPath = Replace(targetPath & "\", "\\", "\")
    FoldersCreate targetPath
    oModule.Export targetPath & Name & Extension
End Sub


Public Sub Rename(NewName As String)
    If Not ModuleExists(NewName, oWorkbook) Then oModule.Name = NewName
End Sub

Function Extension() As String
    Dim ext         As String
    Select Case oModule.Type
        Case vbext_ct_MSForm
            ext = ".frm"
        Case vbext_ct_ClassModule, vbext_ct_Document
            ext = ".cls"
            '        Case vbext_ct_Document
            '            If oModule.Name = "ThisWorkbook" Then
            '                Extension = ".WBcls"
            '            Else
            '                Extension = ".DOCcls"
            '            End If
        Case vbext_ct_StdModule
            ext = ".bas"
        Case Else
            ext = ".txt"
    End Select
    Extension = ext
End Function

Public Function Copy( _
        TargetWorkbook As Workbook, _
        OverwriteExisting As Boolean) As Boolean

    If Name = "ThisWorkbook" Then Exit Function
    If oModule.Type = vbext_ct_Document Then Exit Function
    If Parent.Name = TargetWorkbook.Name Then Exit Function
    Dim TempModule  As VBIDE.VBComponent

    If ModuleExists(Name, TargetWorkbook) Then
        If OverwriteExisting = True Then
            With TargetWorkbook.VBProject
                .VBComponents.Remove .VBComponents(Name)
            End With
        Else
            Exit Function
        End If
    End If

    Dim fname       As String
    fname = Environ("Temp") & "\" & Name & Extension
    oModule.Export fileName:=fname

    TargetWorkbook.VBProject.VBComponents.Import fileName:=fname
    Kill fname
    Copy = True
End Function

Sub Delete()
    If Ignore Then Exit Sub
    Application.DisplayAlerts = False
    If oModule.Type = vbext_ct_Document Then
        If oModule.Name = "ThisWorkbook" Then
            oModule.CodeModule.DeleteLines 1, oModule.CodeModule.CountOfLines
        Else
            If Parent.Sheets.Count = 1 Then Parent.Sheets.Add
            GetSheetByCodeName(oWorkbook, Name).Delete
        End If
    Else
        Parent.VBProject.VBComponents.Remove oModule
    End If
    Application.DisplayAlerts = True
End Sub

Sub CodeRemove()
    If Ignore Then Exit Sub
    If oModule.CodeModule.CountOfLines = 0 Then Exit Sub
    oModule.CodeModule.DeleteLines 1, oModule.CodeModule.CountOfLines    '+ 1
End Sub

Sub CodeMove(ToModule As VBComponent)
    If Ignore Then Exit Sub
    With ToModule.CodeModule
        .InsertLines 1, Header
        .InsertLines .CountOfLines + 1, body
    End With
    CodeRemove
End Sub

Sub DeleteIfEmpty()
    If Ignore Then Exit Sub
    If Name = "ThisWorkbook" Then Exit Sub
    If oModule.CodeModule.CountOfLines = 0 Then Delete
End Sub

Public Sub RemoveEmptyLinesButLeaveOne()
    Dim Code        As String
    Dim currentline As String, nextline As String
    Dim i           As Long
    With oModule.CodeModule
        If .CountOfLines > 0 Then
            For i = .CountOfLines - 1 To 1 Step -1
                currentline = Trim(.Lines(i, 1))
                nextline = Trim(.Lines(i + 1, 1))
                If Len(currentline) = 0 Then
                    If Len(nextline) = 0 Then
                        .DeleteLines i + 1, 1
                    End If
                End If
            Next
        End If
    End With
End Sub
Public Sub RemoveEmptyLines()
    Dim Code        As String
    Dim currentline As String, nextline As String
    Dim i           As Long
    With oModule.CodeModule
        If .CountOfLines > 0 Then
            For i = .CountOfLines - 1 To 1 Step -1
                currentline = Trim(.Lines(i, 1))
                If Len(currentline) = 0 Then
                    .DeleteLines i, 1
                End If
            Next
        End If
    End With
End Sub

Public Sub CommentsRemove()
    Dim ap          As aProcedure
    For Each ap In Procedures
        ap.CommentsRemove False, Body_Code
    Next ap
End Sub

'aModules	Class


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Class      : aModules
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 29-06-2023 13:46    Alex
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit
Private ModuleCollection As Collection
Private oWorkbook   As Workbook

Function Init(TargetWorkbook As Workbook) As aModules
    '@AssignedModule aModules
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aModules
    Set oWorkbook = TargetWorkbook
    Dim module      As VBComponent
    Dim coll        As New Collection
    Dim am          As aModule
    For Each module In oWorkbook.VBProject.VBComponents
        Set am = New aModule
        coll.Add am.Init(module), module.Name
    Next
    Set ModuleCollection = coll
    Set Init = Me
End Function

Sub PrintTodoList()
    '@AssignedModule aModules
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aModules
    Dim am          As aModule
    For Each am In items
        am.PrintTodoList
    Next
End Sub

Sub Export(targetPath As String, createSubfolders As Boolean)
    '@AssignedModule aModules
    '@INCLUDE PROCEDURE FoldersCreate
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aModules
    Dim ClassFolder As String: ClassFolder = targetPath
    Dim FormFolder  As String: FormFolder = targetPath
    Dim NormalModuleFolder As String: NormalModuleFolder = targetPath
    Dim DocumentFolder As String: DocumentFolder = targetPath

    If createSubfolders Then
        FormFolder = targetPath & "Userforms"
        NormalModuleFolder = targetPath & "Modules"
        DocumentFolder = targetPath & "Documents"
        ClassFolder = targetPath & "Classes"

        FoldersCreate FormFolder
        FoldersCreate NormalModuleFolder
        FoldersCreate ClassFolder
        FoldersCreate DocumentFolder
    End If

    Dim am          As aModule
    For Each am In Me.Classes: am.Export ClassFolder: Next am
    For Each am In Me.Userforms: am.Export FormFolder: Next am
    For Each am In Me.NormalModules: am.Export NormalModuleFolder: Next am
    For Each am In Me.Documents: am.Export DocumentFolder: Next am
End Sub

Sub InjectOptionExplicit()
    '@AssignedModule aModules
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aModules
    Dim am          As aModule
    For Each am In items
        If Not am.Contains("Option Explicit", False, True, False) Then am.item.CodeModule.InsertLines 1, "Option Explicit"
    Next
End Sub



Public Sub Indent()
    '@AssignedModule aModules
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aModules
    Dim module      As aModule
    For Each module In Me.items
        module.Indent
    Next
End Sub
Sub RemoveEmptyLinesButLeaveOne()
    '@AssignedModule aModules
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aModules
    Dim module      As aModule
    For Each module In items
        module.RemoveEmptyLinesButLeaveOne
    Next
End Sub
Sub UpdateProcedures()
    '@AssignedModule aModules
    '@INCLUDE CLASS aProcedure
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aModules
    Dim Procedure   As aProcedure
    Dim module      As aModule
    For Each module In items
        If module.TypeToLong = vbext_ct_StdModule Then
            For Each Procedure In module.Procedures
                If UCase(CStr(Procedure)) <> UCase("UpdateAllProcedures") Then
                    Procedure.Update
                End If
            Next
        End If
    Next
End Sub

Function items() As Collection
    '@AssignedModule aModules
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aModules
    Set items = ModuleCollection
End Function

Public Function item(IndexOrName As Variant) As aModule
    '@AssignedModule aModules
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aModules
    Set item = items.item(IndexOrName)
End Function

Function NormalModules() As Collection
    '@AssignedModule aModules
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aModules
    Dim coll        As New Collection
    Dim element     As aModule
    For Each element In ModuleCollection
        If element.TypeToLong = vbext_ct_StdModule Then
            coll.Add element, element.Name
        End If
    Next
    Set NormalModules = coll
End Function

Function Userforms() As Collection
    '@AssignedModule aModules
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aModules
    Dim coll        As New Collection
    Dim element     As aModule
    For Each element In ModuleCollection
        If element.TypeToLong = vbext_ct_MSForm Then
            coll.Add element, element.Name
        End If
    Next
    Set Userforms = coll
End Function

Function Classes() As Collection
    '@AssignedModule aModules
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aModules
    Dim coll        As New Collection
    Dim element     As aModule
    For Each element In ModuleCollection
        If element.TypeToLong = vbext_ct_ClassModule Then
            '            Debug.Print element.Name
            coll.Add element, element.Name
        End If
    Next
    Set Classes = coll
End Function

Function Documents() As Collection
    '@AssignedModule aModules
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aModules
    Dim coll        As New Collection
    Dim element     As aModule
    For Each element In ModuleCollection
        If element.TypeToLong = vbext_ct_Document Then
            coll.Add element, element.Name
        End If
    Next
    Set Documents = coll
End Function

Public Function Exists(TargetName As String) As Boolean
    '@AssignedModule aModules
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aModules
    Dim module      As VBComponent
    On Error Resume Next
    Set module = oWorkbook.VBProject.VBComponents(TargetName)
    On Error GoTo 0
    Exists = Not module Is Nothing
End Function

Function AddOrSet( _
        TargetName As String, _
        moduleType As VBIDE.vbext_ComponentType) As aModule
    '@AssignedModule aModules
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aModules

    Dim module      As VBComponent
    On Error Resume Next
    Set module = oWorkbook.VBProject.VBComponents(TargetName)
    On Error GoTo 0
    If module Is Nothing Then
        Set module = oWorkbook.VBProject.VBComponents.Add(moduleType)
        module.Name = TargetName
    End If
    Dim am          As New aModule
    am.Init module
    Set AddOrSet = am
End Function

Sub ImportPaths(ReplaceExisting As Boolean, ParamArray Paths() As Variant)
    '@AssignedModule aModules
    '@INCLUDE PROCEDURE Toast
    '@INCLUDE PROCEDURE DataFilePartExtension
    '@INCLUDE PROCEDURE DataFilePartName
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aModules
    If LBound(Paths) = -1 Then Exit Sub

    Dim Extension   As String
    Dim TargetName  As String
    Dim element

    Dim PASS        As Boolean
    For Each element In Paths
        Select Case True
            Case element Like "*.cls", "*.frm", "*.bas", "*.bas"
            Case Else: Exit Sub
        End Select
    Next
    For Each element In Paths
        TargetName = DataFilePartName(CStr(element), False)
        Extension = DataFilePartExtension(CStr(element))
        If Exists(TargetName) Then
            If ReplaceExisting Then
                aModule.Init(oWorkbook.VBProject.VBComponents(TargetName)).Delete
                oWorkbook.VBProject.VBComponents.Import CStr(element)
            End If
        Else
            oWorkbook.VBProject.VBComponents.Import CStr(element)
        End If
    Next element

    'https://github.com/rfl808/Notify
    Toast , "Import successful"
End Sub

Sub ImportPicker(ReplaceExisting As Boolean)
    '@AssignedModule aModules
    '@INCLUDE PROCEDURE ArrayAllocated
    '@INCLUDE PROCEDURE WorksheetExists
    '@INCLUDE PROCEDURE Toast
    '@INCLUDE PROCEDURE DataFilePartFolder
    '@INCLUDE PROCEDURE DataFilePicker
    '@INCLUDE PROCEDURE DataFilePartExtension
    '@INCLUDE PROCEDURE DataFilePartName
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aModules
    Dim SelectedModules: SelectedModules = DataFilePicker(Array("bas", "frm", "cls"), True)
    If Not ArrayAllocated(SelectedModules) Then Exit Sub
    Dim basePath    As String: basePath = DataFilePartFolder(SelectedModules(1), True)
    '    Dim SourceWorkbook     As Workbook
    '    Dim SourceWorkbookName As String:   SourceWorkbookName = Dir(basePath & "*.xl*")
    '    Dim wasOpen            As Boolean
    '
    '    If SourceWorkbookName <> "" Then: wasOpen = WorkbookExists(SourceWorkbookName)

    Dim Extension   As String
    Dim TargetName  As String
    Dim element
    For Each element In SelectedModules
        TargetName = DataFilePartName(CStr(element), False)
        Extension = DataFilePartExtension(CStr(element))
        '        If UCase(Extension) <> UCase("doccls") Then
        If Exists(TargetName) Then
            If ReplaceExisting Then
                aModule.Init(oWorkbook.VBProject.VBComponents(TargetName)).Delete
                oWorkbook.VBProject.VBComponents.Import CStr(element)
            End If
        Else
            oWorkbook.VBProject.VBComponents.Import CStr(element)
        End If

        '        ElseIf UCase(Extension) = UCase("doccls") And SourceWorkbookName <> "" Then
        '            If WorksheetExists(TargetName, oWorkbook) Then
        '                If ReplaceExisting Then
        ''                    TargetWorkbook.Worksheets.Copy
        '                    TargetWorkbook.Worksheets(TargetName).Delete
        '                Else
        '                    GoTo NextElement
        '                End If
        '
        '                If wasOpen = False Then
        '                    Application.EnableEvents = False
        '                    Set SourceWorkbook = Workbooks.Open(basePath & SourceWorkbookName)
        '                Else
        '                    Set SourceWorkbook = Workbooks(SourceWorkbookName)
        '                End If
        '                SourceWorkbook.SHEETS(TargetName).Copy Before:=TargetWorkbook.SHEETS(1)
        '                Application.EnableEvents = True
        '            End If
        '        End If
NextElement:
    Next element

    '    If wasOpen = False And WorkbookExists(SourceWorkbookName) Then SourceWorkbook.Close False
    'https://github.com/rfl808/Notify
    Toast , "Import successful"
End Sub

Sub ListProcedures()
    '@AssignedModule aModules
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aModules
    Dim module      As VBComponent
    For Each module In oWorkbook.VBProject.VBComponents
        If module.Type <> vbext_ct_ClassModule And module.Type <> vbext_ct_Document Then
            If module.CodeModule.CountOfLines > 0 Then
                aModule.Init(module).ListProcedures
            End If
        End If
    Next
End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 22-08-2023 13:55    Alex                (aModules.cls > RemoveLinesLike)

Public Sub RemoveLinesLike(this As String)
'@LastModified 2308221355
    Dim module      As aModule
    For Each module In items
        module.RemoveLinesLike this
    Next
End Sub

Sub SideBySide(ParamArray TwoModuleNamesOrOneFormName() As Variant)
    '@AssignedModule aModules
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aModules

    Dim Module1     As VBComponent
    Dim Module2     As VBComponent
    Set Module1 = oWorkbook.VBProject.VBComponents(TwoModuleNamesOrOneFormName(0))
    If UBound(TwoModuleNamesOrOneFormName) > 0 Then Set Module2 = oWorkbook.VBProject.VBComponents(TwoModuleNamesOrOneFormName(1))
    With Module1.CodeModule.CodePane.Window
        .Width = 800
        .Left = 1
        .Top = 1
        .Height = 932
        .Visible = True
        .WindowState = vbext_ws_Normal
        .SetFocus
    End With
    If Not Module2 Is Nothing Then
        With Module2.CodeModule.CodePane.Window
            .Width = 800
            .Left = 800
            .Top = 1
            .Height = 932
            .Visible = True
            .WindowState = vbext_ws_Normal
            .SetFocus
        End With
    ElseIf Module1.Type = vbext_ct_MSForm Then
        With Module1.DesignerWindow
            .Width = 800
            .Left = 800
            .Top = 1
            .Height = 932
            .Visible = True
            .WindowState = vbext_ws_Normal
            Module1.DesignerWindow.SetFocus
        End With
        Exit Sub

    End If
End Sub
'
'Sub CaseProperModulesOfWorkbook(Optional TargetWorkbook As Workbook)
'    Dim Module As VBComponent
'    For Each Module In TargetWorkbook.VBProject.VBComponents
'        If Module.Name <> "ThisWorkbook" Then
'            Module.Name = UCase(Left(Module.Name, 1)) & Mid(Module.Name, 2)
'        End If
'    Next
'End Sub

Public Sub Refresh()
    '@AssignedModule aModules
    '@INCLUDE PROCEDURE Toast
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aModules
    If oWorkbook.Name <> ThisWorkbook.Name Then
        ExportModules
        ImportModules
    Else
        Toast "Can't touch this"
    End If
End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 30-10-2023 09:43    Alex                (aModules.cls > ExportProcedures : + argument to create subfolders by module name)

Sub ExportProcedures(targetPath As String, Optional createModuleSubfolders As Boolean)
'@LastModified 2310300943
    '@AssignedModule aModules
    '@INCLUDE PROCEDURE FoldersCreate
    '@INCLUDE CLASS aProcedure
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aModules
    targetPath = Replace(targetPath & "\", "\\", "\")
    Dim ProcedurePath As String
    Dim am          As aModule
    Dim ap          As aProcedure
    Dim coll        As New Collection
    Dim ModulePath  As String
    For Each am In NormalModules 'Userforms and Classes should be exported as they are
        If createModuleSubfolders Then
            ModulePath = targetPath & am.Name & "\"
            FoldersCreate ModulePath
            am.ExportProcedures ModulePath
        Else
            am.ExportProcedures targetPath
        End If
    Next
End Sub

Private Sub ExportModules()
    '@AssignedModule aModules
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aModules
    Dim bExport     As Boolean
    Dim szExportPath As String
    Dim szFileName  As String
    Dim cmpComponent As VBIDE.VBComponent
    If FolderWithVBAProjectFiles = "Error" Then
        MsgBox "Export Folder not exist"
        Exit Sub
    End If
    On Error Resume Next
    Kill FolderWithVBAProjectFiles & "\*.*"
    On Error GoTo 0
    szExportPath = FolderWithVBAProjectFiles & "\"
    For Each cmpComponent In oWorkbook.VBProject.VBComponents
        bExport = True
        szFileName = cmpComponent.Name
        Select Case cmpComponent.Type
            Case vbext_ct_ClassModule
                szFileName = szFileName & ".cls"
            Case vbext_ct_MSForm
                szFileName = szFileName & ".frm"
            Case vbext_ct_StdModule
                szFileName = szFileName & ".bas"
            Case vbext_ct_Document
                bExport = False
        End Select
        If bExport Then
            cmpComponent.Export szExportPath & szFileName
        End If
    Next cmpComponent
End Sub

Private Sub ImportModules()
    '@AssignedModule aModules
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aModules
    Dim objFSO      As Scripting.FileSystemObject
    Dim objFile     As Scripting.File
    Dim szImportPath As String
    Dim szFileName  As String
    Dim cmpComponents As VBIDE.VBComponents
    If oWorkbook.Name = ThisWorkbook.Name Then
        MsgBox "Select another destination workbook" & _
                "Not possible to import in this workbook "
        Exit Sub
    End If
    If FolderWithVBAProjectFiles = "Error" Then
        MsgBox "Import Folder not exist"
        Exit Sub
    End If
    szImportPath = FolderWithVBAProjectFiles & "\"
    Set objFSO = New Scripting.FileSystemObject
    If objFSO.GetFolder(szImportPath).Files.Count = 0 Then
        MsgBox "There are no files to import"
        Exit Sub
    End If
    Call DeleteVBAModulesAndUserForms
    Set cmpComponents = oWorkbook.VBProject.VBComponents
    For Each objFile In objFSO.GetFolder(szImportPath).Files
        If (objFSO.GetExtensionName(objFile.Name) = "cls") Or _
                (objFSO.GetExtensionName(objFile.Name) = "frm") Or _
                (objFSO.GetExtensionName(objFile.Name) = "bas") Then
            cmpComponents.Import objFile.path
        End If
    Next objFile
End Sub

Private Function FolderWithVBAProjectFiles() As String
    '@AssignedModule aModules
    '@INCLUDE PROCEDURE FolderExists
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aModules
    Dim WshShell    As Object
    Dim FSO         As Object
    Dim SpecialPath As String
    Set WshShell = CreateObject("WScript.Shell")
    Set FSO = CreateObject("scripting.filesystemobject")
    SpecialPath = WshShell.SpecialFolders("MyDocuments")
    If Right(SpecialPath, 1) <> "\" Then
        SpecialPath = SpecialPath & "\"
    End If
    If FSO.FolderExists(SpecialPath & "VBAProjectFiles") = False Then
        On Error Resume Next
        MkDir SpecialPath & "VBAProjectFiles"
        On Error GoTo 0
    End If
    If FSO.FolderExists(SpecialPath & "VBAProjectFiles") = True Then
        FolderWithVBAProjectFiles = SpecialPath & "VBAProjectFiles"
    Else
        FolderWithVBAProjectFiles = "Error"
    End If
End Function

Private Sub DeleteVBAModulesAndUserForms()
    '@AssignedModule aModules
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aModules
    Dim vbProj      As VBIDE.VBProject
    Dim vbComp      As VBIDE.VBComponent
    Set vbProj = oWorkbook.VBProject
    For Each vbComp In vbProj.VBComponents
        If vbComp.Type = vbext_ct_Document Then
        Else
            vbProj.VBComponents.Remove vbComp
        End If
    Next vbComp
End Sub

Public Sub CommentsRemove()
    '@AssignedModule aModules
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aModules
    Dim am          As aModule
    For Each am In items
        am.CommentsRemove
    Next
End Sub

Sub RemoveProcedureList()
    '@AssignedModule aModules
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aModules
    Dim am          As aModule
    For Each am In items
        am.FolderDelete "ListOfProcedures"
    Next
End Sub

Function ClassNames()
    '@AssignedModule aModules
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aModules
    Set ClassNames = NamesOf(vbext_ct_ClassModule)
End Function
Function ModuleNames()
    '@AssignedModule aModules
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aModules
    Set ModuleNames = NamesOf(vbext_ct_StdModule)
End Function

Function UserformNames()
    '@AssignedModule aModules
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aModules
    Set UserformNames = NamesOf(vbext_ct_MSForm)
End Function
'Sub CaseProperModulesOfWorkbook()
'    Dim Module As VBComponent
'    For Each Module In oWorkbook.VBProject.VBComponents
'        If Module.Name <> "ThisWorkbook" Then
'            Module.Name = UCase(Left(Module.Name, 1)) & Mid(Module.Name, 2)
'        End If
'    Next
'End Sub


Public Function NamesOf(moduleType As vbext_ComponentType)
    '@AssignedModule aModules
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aModules
    Dim coll        As New Collection
    Dim module      As VBComponent
    For Each module In oWorkbook.VBProject.VBComponents
        If module.Type = moduleType Then
            coll.Add module.Name
        End If
    Next
    Set NamesOf = coll
End Function



'aCollection	Class


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Class      : aCollection
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 04-05-2023 12:17    Alex
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Public RestrictionTypename As String
Private myCollection As Collection

Public Property Get items() As Collection
    Set items = myCollection
End Property

Public Function Init(coll As Collection) As aCollection
    Select Case RestrictionTypename
        Case ""
            Set myCollection = coll

        Case Else
            Set myCollection = New Collection
            Dim element
            For Each element In coll
                Add element
            Next
    End Select
    Set Init = Me
End Function

Public Property Get item(NameOrNumber As Variant) As Variant
    Set item = myCollection(IndexOf(NameOrNumber))
End Property

Public Function IndexOf(ByVal item As Variant, _
        Optional ByVal StartIndex As Long = 1) As Long
    Dim collindex   As Long
    Dim collitemtype As Integer
    Dim itemtype    As Integer

    itemtype = VarType(item)
    For collindex = StartIndex To myCollection.Count
        collitemtype = VarType(myCollection(collindex))
        If collitemtype = itemtype Then
            Select Case collitemtype
                Case 0 To 1: IndexOf = collindex: Exit Function
                Case 2 To 8, 11, 14, 17: If myCollection(collindex) = item Then IndexOf = collindex: Exit Function
                Case 9: If myCollection(collindex) Is item Then IndexOf = collindex: Exit Function
                Case Else
                    Debug.Print "Unsupported type for CollectionIndexOf."
                    Debug.Assert False
            End Select
        End If
    Next
    IndexOf = 0
End Function

Public Sub RestrictionSet(ByVal Value As String)
    RestrictionTypename = Value
End Sub

Public Sub RestrictionRemove()
    RestrictionTypename = ""
End Sub

Public Sub Add(NewItem As Variant, Optional Description As String)
    Err.clear
    Select Case RestrictionTypename
        Case ""
            myCollection.Add NewItem
        Case Else
            If TypeName(NewItem) <> RestrictionTypename Then
                MsgBox "TypeName does not match restriction: " & RestrictionTypename
            Else
                On Error Resume Next
                myCollection.Add NewItem, Description
                On Error GoTo 0
                If Err.Number <> 0 Then Debug.Print "Item " & Description & " already contained"
            End If
    End Select
End Sub

Public Property Get Count() As Long
    Count = myCollection.Count
End Property

Public Sub Remove(NameOrNumber As Variant)
    myCollection.Remove NameOrNumber
End Sub

Public Function ToString(delim As String) As String
    Dim element
    Dim out         As String
    For Each element In myCollection
        out = IIf(out = "", element, out & delim & element)
    Next
    ToString = out
End Function

Public Function Distinct() As aCollection
    Dim result      As Collection: Set result = New Collection
    Dim eachItem    As Variant
    On Error Resume Next
    For Each eachItem In myCollection
        result.Add eachItem, CStr(eachItem)
    Next
    On Error GoTo 0
    Set myCollection = result
    Set Distinct = Me
End Function

Public Function Unique() As aCollection
    '-----------------------------------------------------------------------------------------------------------
    ' CollectionUnique     - Returns a collection of unique values from a full collection
    '                                   - In : myCollection As Collection
    '                                   - Out: Result of values, or error
    '                                   - Last Updated: 8/7/11 by AJS
    '-----------------------------------------------------------------------------------------------------------
    Dim result      As New Collection
    Dim eachItem As Variant, eachUnique As Variant
    Dim MatchFound  As Boolean
    '    On Error GoTo IsError:
    For Each eachItem In myCollection
        MatchFound = False
        For Each eachUnique In result
            If eachItem = eachUnique Then
                MatchFound = True
                Exit For
            End If
        Next
        If MatchFound = False Then result.Add eachItem
    Next
    Set myCollection = result
    Set Unique = Me
    '    Exit Function
    'IsError:
    '    Unique = CVErr(xlErrNA)
    '    Debug.Print "Error in aCollection.Unique: " & Err.Number & ": " & Err.Description
End Function

Public Function Sort() As aCollection
    Dim iCounter    As Integer
    Dim iCounter2   As Integer
    Dim Temp        As Variant
    For iCounter = 1 To myCollection.Count - 1
        For iCounter2 = iCounter + 1 To myCollection.Count
            If myCollection(iCounter) > myCollection(iCounter2) Then
                Temp = myCollection(iCounter2)
                myCollection.Remove iCounter2
                myCollection.Add Temp, , iCounter
            End If
        Next iCounter2
    Next iCounter
    Set Sort = Me
End Function

Public Function Contains( _
        Optional Key As Variant, _
        Optional item As Variant) As Boolean
    Dim strKey      As String
    Dim var         As Variant
    If Not IsMissing(Key) Then
        strKey = CStr(Key)
        On Error Resume Next
        Contains = True
        var = myCollection(strKey)
        If Err.Number = 91 Then GoTo CheckForObject
        If Err.Number = 5 Then GoTo NotFound
        On Error GoTo 0
        Exit Function
CheckForObject:
        If IsObject(myCollection(strKey)) Then
            Contains = True
            On Error GoTo 0
            Exit Function
        End If
NotFound:
        Contains = False
        On Error GoTo 0
        Exit Function
    ElseIf Not IsMissing(item) Then
        Contains = False
        For Each var In myCollection
            If var = item Then
                Contains = True
                Exit Function
            End If
        Next var
    Else
        Contains = False
    End If
End Function

Function ToArray() As Variant
    Dim a()         As Variant: ReDim a(0 To myCollection.Count - 1)
    Dim i           As Long
    For i = 1 To myCollection.Count
        a(i - 1) = myCollection.item(i)
    Next
    ToArray = a
End Function

Public Function Reverse() As aCollection
    Dim Output      As New Collection
    Dim i           As Long
    For i = myCollection.Count To 1 Step -1
        Output.Add myCollection.item(i)
    Next i
    Set myCollection = Output
    Set Reverse = Me
End Function

'------------------------------------------------------------------------'
'Function Mid : returns subset of a collection                       '
'  Similar to Mid$() on strings.                                         '
'See also: FromToColl, LeftColl, RightColl, ButLastColl                  '
'------------------------------------------------------------------------'
Public Function Mid(ByVal Start As Long, Optional ByVal Length As Variant) As aCollection
    Dim result      As New Collection
    Dim Count       As Long
    Dim c           As Long

    Count = myCollection.Count
    If Start < 1 Then Error 5
    If Start > Count Then
        Set result = result
    Else
        If IsMissing(Length) Then
            For c = Start To Count
                result.Add myCollection(c)
            Next
        ElseIf (Length >= (Count + 1 - Start)) Then
            For c = Start To Count
                result.Add myCollection(c)
            Next
        ElseIf Length < 0 Then
            Error 5
        Else
            For c = Start To Start + Count - 1
                result.Add myCollection(c)
            Next
        End If
    End If
    Set myCollection = result
    Set Mid = Me
End Function

'------------------------------------------------------------------------'
'Function FromTo : returns subset of a collection                    '
'See also: MidColl, LeftColl, RightColl                                  '
'------------------------------------------------------------------------'
Public Function FromTo(ByVal FromOffset As Long, ByVal ToOffset As Long) As aCollection
    Dim result      As New Collection
    Dim c           As Long

    If FromOffset > myCollection.Count Then
        Set FromTo = result
        Exit Function
    ElseIf FromOffset < 1 Then
        Error 5
    End If

    If ToOffset > myCollection.Count Then
        ToOffset = myCollection.Count
    ElseIf ToOffset < 1 Then
        Error 5
    End If

    If ToOffset < FromOffset Then
        Set FromTo = result
        Exit Function
    Else
        For c = FromOffset To ToOffset
            result.Add myCollection(c)
        Next
    End If

    Set myCollection = result
    Set FromTo = Me
End Function

'------------------------------------------------------------------------'
'Function LeftColl : returns left-most elements of a collection          '
'  Similar to Left$() on strings.                                        '
'See also: MidColl, RightColl, ButLastColl                               '
'------------------------------------------------------------------------'
Public Function Left(ByVal Length As Long) As aCollection
    Dim result      As New Collection
    Dim c           As Long

    If Length > myCollection.Count Then Length = myCollection.Count
    For c = 1 To Length
        result.Add myCollection(c)
    Next
    Set myCollection = result
    Set Left = Me
End Function

'------------------------------------------------------------------------'
'Function RightColl : returns right-most elements of a collection        '
'  Similar to Right$() on strings.                                       '
'See also: MidColl, LeftColl                                             '
'------------------------------------------------------------------------'
Public Function Right(ByVal Length As Long) As aCollection
    Dim result      As New Collection
    Dim c           As Long

    If Length > myCollection.Count Then Length = myCollection.Count
    For c = myCollection.Count - Length + 1 To myCollection.Count
        result.Add myCollection(c)
    Next
    Set myCollection = result
    Set Right = Me

End Function

Function Filter( _
        Match As String, _
        IgnoreCase As Boolean, _
        Include As Boolean) As aCollection
    Dim result      As New Collection
    If IgnoreCase Then Match = UCase(Match)
    Dim element
    For Each element In myCollection
        If IgnoreCase Then
            If Include Then
                If UCase(element) Like Match Then result.Add element
            Else
                If Not UCase(element) Like Match Then result.Add element
            End If
        Else
            If Include Then
                If UCase(element) Like Match Then result.Add element
            Else
                If UCase(element) Like Match Then result.Add element
            End If
        End If
    Next
    Set myCollection = result
    Set Filter = Me
End Function


Public Function CollectionsToArray2D(collections As Collection) As Variant
    If collections.Count = 0 Then Exit Function
    Dim columnCount As Long: columnCount = collections.Count
    Dim rowCount    As Long: rowCount = collections.item(1).Count
    Dim var         As Variant
    ReDim var(1 To rowCount, 1 To columnCount)
    Dim cols        As Long
    Dim rows        As Long
    For rows = 1 To rowCount
        For cols = 1 To collections.Count
            var(rows, cols) = collections(cols).item(rows)
        Next cols
    Next rows
    CollectionsToArray2D = var
End Function

'M_Notify	Module

Option Explicit

#If VBA7 Then
Private Declare PtrSafe Function Shell_NotifyIconW Lib "shell32.dll" (ByVal dwMessage As Long, ByRef nfIconData As NOTIFYICONDATAW) As Long
Private Declare PtrSafe Sub CopyMemory Lib "kernel32.dll" Alias "RtlMoveMemory" (ByRef Destination As Any, ByRef Source As Any, ByVal Length As Long)
#Else
Private Declare Function Shell_NotifyIconW Lib "shell32.dll" (ByVal dwMessage As Long, ByRef nfIconData As NOTIFYICONDATAW) As Long
Private Declare Sub CopyMemory Lib "kernel32.dll" Alias "RtlMoveMemory" (ByRef Destination As Any, ByRef source As Any, ByVal Length As Long)
#End If

Private Type NOTIFYICONDATAW
    cbSize          As Long

#If Win64 Then
    padding1        As Long
#End If

    hwnd            As LongPtr
    uID             As Long
    uFlags          As Long
    uCallbackMessage As Long

#If Win64 Then
    padding2        As Long
#End If

    hIcon           As LongPtr
    szTip(1 To 128 * 2) As Byte
    dwState         As Long
    dwStateMask     As Long
    szInfo(1 To 256 * 2) As Byte
    uTimeout        As Long
    szInfoTitle(1 To 64 * 2) As Byte
    dwInfoFlags     As Long
End Type

Private Const NIM_ADD As Long = &H0&
Private Const NIM_MODIFY As Long = &H1&
Private Const NIF_INFO As Long = &H10&

Private Function Min(ByVal a As Long, ByVal b As Long) As Long
    '@AssignedModule M_Notify
    If a < b Then Min = a Else Min = b
End Function

Public Sub Toast(Optional ByVal Title As String, Optional ByVal info As String, Optional ByVal flag As Long)
    Rem toast "Hello World", "from Excel",1
    Rem https://github.com/rfl808/Notify
    '@INCLUDE Min
    '@AssignedModule M_Notify
    '@INCLUDE PROCEDURE Min
    '@INCLUDE DECLARATION NIF_INFO
    '@INCLUDE DECLARATION NIM_ADD
    '@INCLUDE DECLARATION NIM_MODIFY
    '@INCLUDE DECLARATION Shell_NotifyIconW
    '@INCLUDE DECLARATION CopyMemory
    '@INCLUDE DECLARATION NOTIFYICONDATAW
    Dim nfIconData  As NOTIFYICONDATAW
    info = info & " "
    Title = Title & " "
    With nfIconData
        .cbSize = Len(nfIconData)
        .uFlags = NIF_INFO
        .dwInfoFlags = flag
        If Len(Title) > 0 Then
            CopyMemory ByVal VarPtr(.szInfoTitle(LBound(.szInfoTitle))), ByVal StrPtr(Title), Min(Len(Title) * 2, UBound(.szInfoTitle) - LBound(.szInfoTitle) + 1 - 2)
        End If
        If Len(info) > 0 Then
            CopyMemory ByVal VarPtr(.szInfo(LBound(.szInfo))), ByVal StrPtr(info), Min(Len(info) * 2, UBound(.szInfo) - LBound(.szInfo) + 1 - 2)
        End If
    End With
    Shell_NotifyIconW NIM_ADD, nfIconData
    Shell_NotifyIconW NIM_MODIFY, nfIconData
End Sub

Rem Flags for the balloon message..
Rem None = 0
Rem Information = 1
Rem Exclamation = 2
Rem Critical = 3

'clsEditOpenXML	Class

Option Explicit
Private mbCreateBackup As Boolean
Private mvSourceFile As Variant
Private msSheet2Change As String
Private msSheetId   As String
Private msSheetFileName As String
Private mbAddedZip  As Boolean
Private mvXMLFolderRoot As Variant
Private mvxmlfolder As Variant
Public Enum XMLFolder
    XMLFolder_root = 1
    XMLFolder_rels = 2
    XMLFolder_xl = 3
    XMLFolder_customUI = 4
    XMLFolder_docProps = 5
End Enum

Public Sub ExtractRibbonX(sFullFile As String, sSaveFile As String)
    '@AssignedModule clsEditOpenXML
    '@INCLUDE CLASS clsEditOpenXML
    Dim cEditOpenXML As clsEditOpenXML
    Dim sXML        As String
    Dim oxmldoc     As MSXML2.DOMDocument
    Set cEditOpenXML = New clsEditOpenXML
    With cEditOpenXML
        .CreateBackup = False
        .SourceFile = sFullFile
        .UnzipFile
        sXML = .GetXMLFromFile("customUI.xml", XMLFolder_customUI)
        If Len(sXML) > 0 Then
            Set oxmldoc = New DOMDocument
            oxmldoc.LoadXML sXML
            oxmldoc.Save sSaveFile
        End If
        sXML = .GetXMLFromFile("customUI14.xml", XMLFolder_customUI)
        If Len(sXML) > 0 Then
            Set oxmldoc = New DOMDocument
            oxmldoc.LoadXML sXML
            oxmldoc.Save Replace(sSaveFile, ".xml", "14.xml")
        End If
    End With
    Set cEditOpenXML = Nothing
End Sub

Public Sub WriteRibbonXML2File(sFile As String, sXML As String)
    '@AssignedModule clsEditOpenXML
    '@INCLUDE CLASS clsEditOpenXML
    Dim cEditOpenXML As clsEditOpenXML

    Set cEditOpenXML = New clsEditOpenXML

    With cEditOpenXML
        .SourceFile = sFile

        .UnzipFile

        .WriteXML2File sXML, "customUI.xml", XMLFolder_customUI

        .ZipAllFilesInFolder
    End With

    Set cEditOpenXML = Nothing
End Sub

Public Function GetXMLFromFile(sFileName As String, sXMLFolder As XMLFolder) As String
    '@AssignedModule clsEditOpenXML
    '@INCLUDE CLASS clsEditOpenXML
    Dim oxmldoc     As MSXML2.DOMDocument
    If Len(XMLFolder(sXMLFolder)) = 0 Then
        GetXMLFromFile = ""
    Else
        Set oxmldoc = New MSXML2.DOMDocument
        oxmldoc.Load XMLFolder(sXMLFolder) & sFileName
        GetXMLFromFile = oxmldoc.xml
        Set oxmldoc = Nothing
    End If
End Function

Public Sub WriteXML2File(sXML As String, sFileName As String, sXMLFolder As XMLFolder)
    '@AssignedModule clsEditOpenXML
    '@INCLUDE PROCEDURE FolderExists
    '@INCLUDE CLASS clsEditOpenXML
    Dim oxmldoc     As MSXML2.DOMDocument
    Set oxmldoc = New MSXML2.DOMDocument
    If sXMLFolder = XMLFolder_customUI Then
        If Not FolderExists(XMLFolder(XMLFolder_customUI)) Then
            MkDir XMLFolder(XMLFolder_customUI)
            oxmldoc.LoadXML sXML
            oxmldoc.Save XMLFolder(sXMLFolder) & sFileName
            AddCustomUIToRels
        End If
    End If
    oxmldoc.LoadXML sXML
    oxmldoc.Save XMLFolder(sXMLFolder) & sFileName
End Sub

Public Sub AddCustomUIToRels()
    '@AssignedModule clsEditOpenXML
    '@INCLUDE CLASS clsEditOpenXML
    Dim oxmldoc     As MSXML2.DOMDocument
    Dim oXMLElement As MSXML2.IXMLDOMNode
    Dim oXMLAttrib  As MSXML2.IXMLDOMAttribute
    Dim oNamedNodeMap As MSXML2.IXMLDOMNamedNodeMap
    Dim oXMLRelsList As MSXML2.IXMLDOMNodeList
    Set oxmldoc = New MSXML2.DOMDocument
    oxmldoc.Load XMLFolder(XMLFolder_rels) & ".rels"
    Set oXMLElement = oxmldoc.createNode(1, "Relationship", "http://schemas.openxmlformats.org/package/2006/relationships")
    Set oNamedNodeMap = oXMLElement.Attributes
    Set oXMLAttrib = oxmldoc.createAttribute("Id")
    oXMLAttrib.NodeValue = "cuID"
    oNamedNodeMap.setNamedItem oXMLAttrib
    Set oXMLAttrib = oxmldoc.createAttribute("Type")
    oXMLAttrib.NodeValue = "http://schemas.microsoft.com/office/2006/relationships/ui/extensibility"
    oNamedNodeMap.setNamedItem oXMLAttrib
    Set oXMLAttrib = oxmldoc.createAttribute("Target")
    oXMLAttrib.NodeValue = "customUI/customUI.xml"
    oNamedNodeMap.setNamedItem oXMLAttrib
    Set oXMLRelsList = oxmldoc.SelectNodes("/Relationships")
    oXMLRelsList.item(0).appendChild oXMLElement
    oxmldoc.Save XMLFolder(XMLFolder_rels) & ".rels"
    Set oXMLAttrib = Nothing
    Set oXMLElement = Nothing
    Set oxmldoc = Nothing
End Sub

Private Function GetSheetIdFromSheetName(sSheetName) As String
    '@AssignedModule clsEditOpenXML
    '@INCLUDE CLASS clsEditOpenXML
    Dim oxmldoc     As MSXML2.DOMDocument
    Dim oxmlNode    As MSXML2.IXMLDOMNode
    Dim oXMLChildNode As MSXML2.IXMLDOMNode
    Dim oXMLTemp    As MSXML2.IXMLDOMNode
    If XMLFolder(XMLFolder_xl) <> "" And Sheet2Change <> "" Then
        Set oxmldoc = New MSXML2.DOMDocument
        oxmldoc.Load XMLFolder(XMLFolder_xl) & "workbook.xml"
        For Each oxmlNode In oxmldoc.ChildNodes
            For Each oXMLChildNode In oxmlNode.ChildNodes
                If oXMLChildNode.BaseName = "sheets" Then
                    For Each oXMLTemp In oXMLChildNode.ChildNodes
                        If oXMLTemp.Attributes.getNamedItem("name").NodeValue = sSheetName Then
                            GetSheetIdFromSheetName = oXMLTemp.Attributes.getNamedItem("r:id").NodeValue
                            Exit Function
                        End If
                    Next
                End If
            Next
        Next
    End If
End Function

Public Function GetSheetFileNameFromId(sSheetId As String) As String
    '@AssignedModule clsEditOpenXML
    '@INCLUDE CLASS clsEditOpenXML
    Dim oxmldoc     As MSXML2.DOMDocument
    Dim oxmlNode    As MSXML2.IXMLDOMNode
    Dim oXMLChildNode As MSXML2.IXMLDOMNode
    If XMLFolder(XMLFolder_xl) <> "" And Sheet2Change <> "" Then
        Set oxmldoc = New MSXML2.DOMDocument
        oxmldoc.Load XMLFolder(XMLFolder_xl) & "_rels\workbook.xml.rels"
        For Each oxmlNode In oxmldoc.ChildNodes
            For Each oXMLChildNode In oxmlNode.ChildNodes
                If oXMLChildNode.Attributes.getNamedItem("Id").NodeValue = sSheetId Then
                    GetSheetFileNameFromId = oXMLChildNode.Attributes.getNamedItem("Target").NodeValue
                    Exit Function
                End If
            Next
        Next
    End If
End Function

Private Function GetSheetNameFromId(sId As String) As String
    '@AssignedModule clsEditOpenXML
    '@INCLUDE CLASS clsEditOpenXML
    Dim oxmldoc     As MSXML2.DOMDocument
    Dim oxmlNode    As MSXML2.IXMLDOMNode
    Dim oXMLChildNode As MSXML2.IXMLDOMNode
    Dim oXMLChildChildNode As MSXML2.IXMLDOMNode
    If mvxmlfolder(XMLFolder_xl) <> "" Then
        Set oxmldoc = New MSXML2.DOMDocument
        oxmldoc.Load XMLFolder(XMLFolder_xl) & "workbook.xml"
        For Each oxmlNode In oxmldoc.ChildNodes
            For Each oXMLChildNode In oxmlNode.ChildNodes
                If oXMLChildNode.nodename = "sheets" Then
                    For Each oXMLChildChildNode In oXMLChildNode.ChildNodes
                        If oXMLChildChildNode.Attributes.getNamedItem("r:id").NodeValue = "rId" & val(sId) + 1 Then
                            GetSheetNameFromId = oXMLChildChildNode.Attributes.getNamedItem("name").NodeValue
                            Exit Function
                        End If
                    Next
                    Exit Function
                End If
            Next
        Next
    End If
End Function

Public Sub ZipAllFilesInFolder()
    '@AssignedModule clsEditOpenXML
    '@INCLUDE CLASS clsEditOpenXML
    Dim oShellApp   As Object
    Dim sDate       As String
    Dim sDefPath    As String
    Dim vFileNameZip As Variant
    Dim FSO         As Object
    Dim lFileCt     As Long
    Set FSO = CreateObject("scripting.filesystemobject")
    sDate = Format(Now, " dd-mmm-yy h-mm-ss")
    vFileNameZip = SourceFile & sDate & ".zip"
    NewZip vFileNameZip
    Set oShellApp = CreateObject("Shell.Application")
    lFileCt = oShellApp.Namespace(FolderName & "Unzipped " & fileName & Application.PathSeparator).items.Count
    oShellApp.Namespace(vFileNameZip).CopyHere oShellApp.Namespace(FolderName & "Unzipped " & fileName & Application.PathSeparator).items
    On Error Resume Next
    Do Until oShellApp.Namespace(vFileNameZip).items.Count = lFileCt
        Application.Wait (Now + TimeValue("0:00:01"))
    Loop
    DoEvents
    Kill SourceFile
    Name vFileNameZip As SourceFile
    On Error Resume Next
    FSO.DeleteFolder FolderName & "Unzipped " & fileName, True
    On Error GoTo 0
    Set oShellApp = Nothing
End Sub

Public Sub UnzipFile()
    '@AssignedModule clsEditOpenXML
    '@INCLUDE PROCEDURE FolderExists
    '@INCLUDE CLASS clsEditOpenXML
    Dim FSO         As Object
    Dim oShellApp   As Object
    Set FSO = CreateObject("scripting.filesystemobject")
    XMLFolderRoot = FolderName
    If Right(XMLFolderRoot, 1) <> Application.PathSeparator Then
        XMLFolderRoot = XMLFolderRoot & "\UnZipped " & fileName & Application.PathSeparator
    Else
        XMLFolderRoot = XMLFolderRoot & "UnZipped " & fileName & Application.PathSeparator
    End If
    On Error Resume Next
    FSO.DeleteFolder XMLFolderRoot & "*", True
    Kill XMLFolderRoot & "*.*"
    If FolderExists(XMLFolderRoot) = False Then
        MkDir XMLFolderRoot
    End If
    Set oShellApp = CreateObject("Shell.Application")
    oShellApp.Namespace(XMLFolderRoot).CopyHere oShellApp.Namespace(SourceFile).items
    On Error Resume Next
    FSO.DeleteFolder Environ("Temp") & "\Temporary Directory*", True
    Set oShellApp = Nothing
    Set FSO = Nothing
    Exit Sub
End Sub

Sub NewZip(sPath)
    '@AssignedModule clsEditOpenXML
    '@INCLUDE CLASS clsEditOpenXML
    If Len(Dir(sPath)) > 0 Then Kill sPath
    Open sPath For Output As #1
    Print #1, Chr$(80) & Chr$(75) & Chr$(5) & Chr$(6) & String(18, 0)
    Close #1
End Sub

Public Property Get CreateBackup() As Boolean
    CreateBackup = mbCreateBackup
End Property

Public Property Let CreateBackup(ByVal bCreateBackup As Boolean)
    mbCreateBackup = bCreateBackup
End Property

Private Sub Class_Initialize()
    CreateBackup = True
End Sub

Public Property Get SourceFile() As Variant
    SourceFile = mvSourceFile
End Property

Public Property Let SourceFile(ByVal vSourceFile As Variant)
    mvSourceFile = vSourceFile
    If CreateBackup Then
        If Len(Dir(vSourceFile & "(backup)")) > 0 Then
            Kill vSourceFile & "(backup)"
        End If
        FileCopy vSourceFile, vSourceFile & "(backup)"
    End If
    If Not vSourceFile Like "*.zip" Then
        Name vSourceFile As vSourceFile & ".zip"
        mvSourceFile = mvSourceFile & ".zip"
        AddedZip = True
    End If
End Property

Public Property Get FolderName() As Variant
    FolderName = Mid(SourceFile, 1, InStrRev(SourceFile, Application.PathSeparator))
End Property

Public Property Get fileName() As Variant
    If SourceFile <> "" Then
        fileName = Mid(SourceFile, InStrRev(SourceFile, Application.PathSeparator) + 1, Len(SourceFile))
    End If
End Property

Public Property Get XMLFolder(sXMLFolder As XMLFolder) As String
    Select Case sXMLFolder
        Case Is = XMLFolder_root
            XMLFolder = mvXMLFolderRoot
        Case Is = XMLFolder_customUI
            XMLFolder = mvXMLFolderRoot & "customUI" & Application.PathSeparator
        Case Is = XMLFolder_docProps
            XMLFolder = mvXMLFolderRoot & "docProps" & Application.PathSeparator
        Case Is = XMLFolder_rels
            XMLFolder = mvXMLFolderRoot & "_rels" & Application.PathSeparator
        Case Is = XMLFolder_xl
            XMLFolder = mvXMLFolderRoot & "xl" & Application.PathSeparator
    End Select
End Property

Public Property Get Sheet2Change() As String
    Sheet2Change = msSheet2Change
End Property

Public Property Let Sheet2Change(ByVal sSheet2Change As String)
    msSheet2Change = sSheet2Change
    SheetId = GetSheetIdFromSheetName(sSheet2Change)
    If SheetId <> "" Then
        SheetFileName = GetSheetFileNameFromId(SheetId)
    End If
End Property

Public Property Get SheetId() As String
    SheetId = msSheetId
End Property

Public Property Let SheetId(ByVal sSheetId As String)
    msSheetId = sSheetId
End Property

Public Property Get SheetFileName() As String
    SheetFileName = msSheetFileName
End Property

Public Property Let SheetFileName(ByVal sSheetFileName As String)
    msSheetFileName = sSheetFileName
End Property

Private Property Get AddedZip() As Boolean
    AddedZip = mbAddedZip
End Property

Private Property Let AddedZip(ByVal bAddedZip As Boolean)
    mbAddedZip = bAddedZip
End Property

Private Sub Class_Terminate()
    Dim FSO         As Object
    If AddedZip Then
        Name SourceFile As Left(SourceFile, Len(SourceFile) - 4)
    End If
    On Error Resume Next
    FSO.DeleteFolder XMLFolderRoot, True
End Sub

Private Property Get XMLFolderRoot() As Variant
    XMLFolderRoot = mvXMLFolderRoot
End Property

Private Property Let XMLFolderRoot(ByVal vXMLFolderRoot As Variant)
    mvXMLFolderRoot = vXMLFolderRoot
End Property


'aListBox	Class


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Class      : aListBox
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 04-05-2023 12:18    Alex
'* Modified   : 21-07-2023 08:28    Alex
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit



Public WithEvents Emitter As EventListenerEmitter

Public WithEvents DoubleClickEvents As MSForms.ListBox

Public WithEvents ExtendedSelectionEvents As MSForms.ListBox
Private ItemsSelected As Variant


Public WithEvents DragSource As MSForms.ListBox
Public WithEvents DragTarget As MSForms.ListBox
Private from_lb_index As Long
Private to_lb_index As Long
Private dragindexes As Collection
Private dragArray
Private isUpdatingSelection As Boolean



Private oListBox    As MSForms.ListBox
Private oList
Private oForm       As Object
Private previousFilterLength As Long

Private isDoubleClick As Boolean

#If VBA7 Then
Private Declare PtrSafe Function GetSystemMetrics Lib "user32" (ByVal nIndex As Long) As Long
Private Declare PtrSafe Function GetKeyState Lib "user32" (ByVal nVirtKey As Long) As Integer
#Else
Private Declare Function  GetSystemMetrics Lib "user32" (ByVal nIndex As Long) As Long
Private Declare Function GetKeyState Lib "user32" (ByVal nVirtKey As Long) As Integer
#End If

Private Type POINTAPI
    X               As Long
    Y               As Long
End Type

#If VBA7 Then

Private Type msg
    hwnd            As LongPtr
    message         As Long
    wParam          As LongPtr
    lParam          As LongPtr
    time            As Long
    pt              As POINTAPI
End Type

#If Win64 Then
Private Declare PtrSafe Function WindowFromPoint Lib "user32" (ByVal POINT As LongPtr) As LongPtr
#Else
Private Declare PtrSafe Function WindowFromPoint Lib "user32" (ByVal xPoint As Long, ByVal yPoint As Long) As LongPtr
#End If

Private Declare PtrSafe Function GetMessage Lib "user32" Alias "GetMessageA" (lpMsg As msg, ByVal hwnd As LongPtr, ByVal wMsgFilterMin As Long, ByVal wMsgFilterMax As Long) As Long
Private Declare PtrSafe Function DispatchMessage Lib "user32" Alias "DispatchMessageA" (lpMsg As msg) As LongPtr
Private Declare PtrSafe Function TranslateMessage Lib "user32" (lpMsg As msg) As Long
Private Declare PtrSafe Function WindowFromAccessibleObject Lib "oleacc" (ByVal pacc As IAccessible, phwnd As LongPtr) As Long
Private Declare PtrSafe Function IsWindow Lib "user32" (ByVal hwnd As LongPtr) As Long
Private Declare PtrSafe Sub DragAcceptFiles Lib "shell32.dll" (ByVal hwnd As LongPtr, ByVal fAccept As Long)
Private Declare PtrSafe Sub DragFinish Lib "shell32.dll" (ByVal HDROP As LongPtr)
Private Declare PtrSafe Function DragQueryFile Lib "shell32.dll" Alias "DragQueryFileA" (ByVal HDROP As LongPtr, ByVal UINT As Long, ByVal lpStr As String, ByVal ch As Long) As Long
Private Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal Length As LongPtr)

#Else

Private Type msg
    hwnd            As Long
    message         As Long
    wParam          As Long
    lParam          As Long
    time            As Long
    pt              As POINTAPI
End Type

Private Declare Function WindowFromPoint Lib "user32" (ByVal xPoint As Long, ByVal yPoint As Long) As Long
Private Declare Function GetMessage Lib "user32" Alias "GetMessageA" (lpMsg As MSG, ByVal hwnd As Long, ByVal wMsgFilterMin As Long, ByVal wMsgFilterMax As Long) As Long
Private Declare Function DispatchMessage Lib "user32" Alias "DispatchMessageA" (lpMsg As MSG) As Long
Private Declare Function TranslateMessage Lib "user32" (lpMsg As MSG) As Long
Private Declare Function WindowFromAccessibleObject Lib "oleacc" (ByVal pacc As IAccessible, phwnd As Long) As Long
Private Declare Function IsWindow Lib "user32" (ByVal hwnd As Long) As Long
Private Declare Sub DragAcceptFiles Lib "shell32.dll" (ByVal hwnd As Long, ByVal fAccept As Long)
Private Declare Sub DragFinish Lib "shell32.dll" (ByVal HDROP As Long)
Private Declare Function DragQueryFile Lib "shell32.dll" Alias "DragQueryFileA" (ByVal HDROP As Long, ByVal UINT As Long, ByVal lpStr As String, ByVal ch As Long) As Long
Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal Length As Long)
#End If


Public Function Init(ByRef TargetListBox As MSForms.ListBox) As aListBox
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    Set oListBox = TargetListBox
    Set oForm = oListBox.Parent
    Set Init = Me
End Function

Public Function Parent()
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    Set Parent = oForm
End Function
Sub RememberList()
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    oList = oListBox.list
End Sub



Private Sub Emitter_Click(control As Object)
    '@AssignedModule aListBox
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS aListBox
    If control.Name Like "lblHeader-*" Then
        Dim col     As Long
        col = Split(control.Name, "-")(1)
        Me.SortOnColumn col - 1
    End If
End Sub
Private Sub Emitter_Keyup(control As Object, KeyCode As MSForms.ReturnInteger, Shift As Integer)
    '@AssignedModule aListBox
    '@INCLUDE PROCEDURE ArrayAllocated
    '@INCLUDE PROCEDURE ArrayFilter2D
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS aListBox
    If Not ArrayAllocated(oList) Then RememberList
    If control.Name = "txtFilter" Then
        If Len(control.TEXT) = 0 Then
            oListBox.list = oList
        ElseIf Len(control.TEXT) > previousFilterLength Then
            oListBox.list = ArrayFilter2D(oListBox.list, control.TEXT, oForm.Controls("cbxFilter").TEXT)
        ElseIf Len(control.TEXT) < previousFilterLength Then
            oListBox.list = ArrayFilter2D(oList, control.TEXT, oForm.Controls("cbxFilter").TEXT)
        End If
        previousFilterLength = Len(control.TEXT)
    End If

    If control.Name = "cbxFilter" Then
        oForm.Controls("txtFilter").TEXT = ""
        previousFilterLength = 0
    End If
End Sub


Public Sub ListenToDragDrop(Optional ToLbx As MSForms.ListBox)
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    Set DragSource = oListBox
    If Not ToLbx Is Nothing Then
        Set DragTarget = ToLbx
    Else
        Set DragTarget = oListBox
    End If
    DragTarget.columnCount = DragSource.columnCount
    DragSource.MousePointer = 5
End Sub


Private Sub DragSource_Change()
    '@AssignedModule aListBox
    '@INCLUDE PROCEDURE ArrayAllocated
    '@INCLUDE CLASS aListBox
    Dim AltPressed  As Boolean: AltPressed = CBool(GetKeyState(&H12) And &H8000)
    Dim CtrlPressed As Boolean: CtrlPressed = CBool(GetKeyState(&H11) And &H8000)
    Dim ShiftPressed As Boolean: ShiftPressed = CBool(GetKeyState(&HA0) And &HFF80)

    If AltPressed Then Exit Sub

    If Not isUpdatingSelection _
            And ArrayAllocated(ItemsSelected) _
            And Not CtrlPressed _
            And Not ShiftPressed Then
        isUpdatingSelection = True
        With DragSource
            Dim i   As Long
            For i = 0 To .ListCount - 1
                If ItemsSelected(i) <> .Selected(i) Then
                    .Selected(i) = ItemsSelected(i)
                End If
            Next i
        End With
        isUpdatingSelection = False
    End If
End Sub
Private Sub DragSource_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    '@AssignedModule aListBox
    '@INCLUDE PROCEDURE ArrayAllocated
    '@INCLUDE CLASS aListBox
    Dim AltPressed  As Boolean: AltPressed = CBool(GetKeyState(&H12) And &H8000)
    Dim CtrlPressed As Boolean: CtrlPressed = CBool(GetKeyState(&H11) And &H8000)
    Dim ShiftPressed As Boolean: ShiftPressed = CBool(GetKeyState(&HA0) And &HFF80)

    If AltPressed Then Exit Sub

    If Not CtrlPressed And Not ShiftPressed And ArrayAllocated(ItemsSelected) Then
        Dim index   As Long: index = Int(Y * 0.85 / DragSource.Font.Size)
        If index > UBound(ItemsSelected) Then Exit Sub
        ItemsSelected(index) = True
        With DragSource
            Dim i   As Long
            For i = 0 To .ListCount - 1
                ItemsSelected(i) = .Selected(i)
            Next i
        End With
    End If

End Sub
Private Sub DragSource_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    With DragSource
        ReDim ItemsSelected(0 To .ListCount - 1) As Boolean
        Dim i       As Long
        For i = 0 To .ListCount - 1
            ItemsSelected(i) = .Selected(i)
        Next i
    End With
End Sub

Private Sub DragTarget_BeforeDragOver(ByVal Cancel As MSForms.ReturnBoolean, ByVal Data As MSForms.DataObject, ByVal X As Single, ByVal Y As Single, ByVal DragState As MSForms.fmDragState, ByVal Effect As MSForms.ReturnEffect, ByVal Shift As Integer)
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    Effect = fmDropEffectMove
    Cancel = True
End Sub
Private Sub DragTarget_BeforeDropOrPaste(ByVal Cancel As MSForms.ReturnBoolean, ByVal Action As MSForms.fmAction, ByVal Data As MSForms.DataObject, ByVal X As Single, ByVal Y As Single, ByVal Effect As MSForms.ReturnEffect, ByVal Shift As Integer)
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    '@INCLUDE DECLARATION Action
    With DragTarget
        to_lb_index = Int(Y * 0.85 / .Font.Size)
        If to_lb_index >= .ListCount Then to_lb_index = .ListCount
        Cancel = True
        Effect = fmDropEffectMove
        Dim difIndexes As Long
        Dim indexesCounter As Long
        For indexesCounter = dragindexes.Count To 1 Step -1
            DragSource.RemoveItem dragindexes(indexesCounter)
            If dragindexes(indexesCounter) < to_lb_index Then to_lb_index = to_lb_index - 1
        Next

        For indexesCounter = 1 To dragindexes.Count    'To 1 Step -1
            If DragTarget.ListCount = 0 Then
                .AddItem
            Else
                .AddItem , to_lb_index    'Data.GetText, to_lb_index
            End If
            Dim i   As Long

            Dim cellTxt As String
            For i = 1 To UBound(dragArray, 2)
                cellTxt = IIf( _
                        IsNull(dragArray(indexesCounter, i)), _
                        "", _
                        dragArray(indexesCounter, i))
                DragTarget.list(to_lb_index, i - 1) = cellTxt
            Next
            to_lb_index = to_lb_index + 1
        Next
    End With

    ClearSelection
    DoEvents
    oForm.Repaint
End Sub
Private Sub DragSource_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    Dim obj         As DataObject
    Dim drageff     As Long
    If Button = 1 Then
        Set obj = New DataObject
        '        obj.SetText DragSource.text

        from_lb_index = DragSource.ListIndex

        Set dragindexes = selectedIndexes  'test
        dragArray = SelectedRowsArray

        drageff = obj.StartDrag
        Set obj = Nothing
    End If
End Sub




Public Sub ListenToExtendedSelection()
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    Set ExtendedSelectionEvents = oListBox
End Sub
Private Sub ExtendedSelectionEvents_Change()
    'author: Petr Radimersky
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    Dim i           As Long
    If CBool(GetKeyState(&HA0) And &HFF80) Then
        With ExtendedSelectionEvents
            For i = 0 To .ListCount - 1
                If ItemsSelected(i) = False And .Selected(i) = True Then
                    ItemsSelected(i) = True
                End If
            Next i
        End With
    End If
End Sub
Private Sub ExtendedSelectionEvents_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    Dim i           As Long
    If CBool(GetKeyState(&HA0) And &HFF80) Then
        With ExtendedSelectionEvents
            ReDim ItemsSelected(0 To .ListCount - 1) As Boolean
            For i = 0 To .ListCount - 1
                ItemsSelected(i) = .Selected(i)
            Next i
        End With
    End If
End Sub
Private Sub ExtendedSelectionEvents_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    Dim i           As Long
    If CBool(GetKeyState(&HA0) And &HFF80) Then
        With ExtendedSelectionEvents
            For i = 0 To .ListCount - 1
                .Selected(i) = ItemsSelected(i)
            Next i
        End With
    End If
End Sub



Public Sub ListenToDoubleClick()
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    Set DoubleClickEvents = oListBox
End Sub

Private Sub DoubleClickEvents_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    isDoubleClick = True
End Sub

Public Sub DoubleClickEvents_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    If Not isDoubleClick Then Exit Sub
    MsgBox oListBox.list(oListBox.ListIndex, targetColumn(X, Y) - 1)
    isDoubleClick = False
End Sub

Public Function targetColumn(X, Y)
    ' Calculate the column index based on the X-coordinate
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    Dim ColumnIndex As Long
    Dim columnWidth As Long
    Dim totalWidth  As Long
    Dim totalColumns As Long

    totalColumns = oListBox.columnCount

    ' Calculate the total width of all columns
    For ColumnIndex = 1 To totalColumns
        columnWidth = Replace(Split(oListBox.ColumnWidths, ";")(ColumnIndex - 1), " pt", "")
        totalWidth = totalWidth + columnWidth
    Next ColumnIndex

    ' Calculate the approximate column index based on the X-coordinate
    Dim clickedX    As Long
    clickedX = X

    If clickedX > 0 Then
        Dim cumulativeWidth As Long
        Dim lastColumnIndex As Long

        For ColumnIndex = 1 To totalColumns
            columnWidth = Replace(Split(oListBox.ColumnWidths, ";")(ColumnIndex - 1), " pt", "")
            cumulativeWidth = cumulativeWidth + columnWidth

            If clickedX < cumulativeWidth Then
                ' The mouse click is within this column
                lastColumnIndex = ColumnIndex
                Exit For
            End If
        Next ColumnIndex

        ' Display the clicked column index
        targetColumn = lastColumnIndex
    End If
End Function


Public Sub AutofitColumns(ResizeListbox As Boolean)
    '@AssignedModule aListBox
    '@INCLUDE PROCEDURE Min
    '@INCLUDE CLASS aListBox
    '@INCLUDE CLASS aUserform
    oListBox.Font.Name = "consolas"    '<---!
    Dim lRowCt      As Long
    Dim lColCt      As Long
    Dim lLengths()
    Dim mvTable: mvTable = oListBox.list
    ReDim lLengths(UBound(mvTable, 2))
    With oListBox
        For lRowCt = LBound(mvTable, 1) To UBound(mvTable, 1)
            For lColCt = LBound(mvTable, 2) To UBound(mvTable, 2)
                lLengths(lColCt) = Application.Max(4, lLengths(lColCt), Len(mvTable(lRowCt, lColCt)))
            Next
        Next
    End With

    Dim lCt         As Long
    Dim sWidths     As String
    Dim dTotWidth   As Double
    Dim lblHidden   As MSForms.control
    Set lblHidden = oForm.Controls.Add("Forms.commandbutton.1")
    With lblHidden
        .Caption = "Measure size"
        .Font.Size = oListBox.Font.Size
        .Font.Name = oListBox.Font.Name
        .WordWrap = False
        .AutoSize = True
    End With
    For lCt = LBound(lLengths) To UBound(lLengths)
        lblHidden.Caption = String(lLengths(lCt), "M")
        dTotWidth = dTotWidth + lblHidden.Width
        If Len(sWidths) = 0 Then
            sWidths = CStr(Int(lblHidden.Width))  '+ 12)
        Else
            sWidths = sWidths & ";" & CStr(Int(lblHidden.Width))  '+ 12)
        End If
    Next

    'Now set the widths of the columns
    oListBox.ColumnWidths = sWidths

    If Not ResizeListbox Then GoTo TidyUp

    'Adjust the dimensions of the listbox itself. You may want to adjust the constants I hard coded here.

    'Listbox will always be at least 200 wide
    '    oListBox.Width = Application.Min(Application.Max(200, dTotWidth + 12), oListBox.Width)
    oListBox.Width = Application.Max(TotalColumnsWidth, 200)
    aUserform.Init(oForm).ResizeToFitControls marginRight:=10, marginBottom:=10
    'Listbox will always be at least 48 high.
    '    oListBox.Height = Application.Min(Application.Max((oListBox.ListCount + 1) * 12, 48), oListBox.Height)
TidyUp:
    oForm.Controls.Remove lblHidden.Name
    On Error GoTo 0
End Sub

Function TotalColumnsWidth()
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    If oListBox.ColumnWidths = "" Then
        MsgBox "Column widths not set"
        TotalColumnsWidth = oListBox.Width
    End If
    TotalColumnsWidth = Evaluate(Replace(Join(Split(oListBox.ColumnWidths, ";"), "+"), "pt", "")) + 10
End Function

Sub AddFilter()
    '@AssignedModule aListBox
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS aListBox
    '@INCLUDE DECLARATION Emitter
    If oListBox.ColumnWidths = "" Then
        MsgBox "Column widths not set"
        Exit Sub
    End If
    Dim var: var = Split(Replace(oListBox.ColumnWidths, "pt", ""), ";")
    Dim txt         As MSForms.Textbox
    Dim i           As Long
    Set txt = oForm.Controls.Add("Forms.Textbox.1")
    txt.Name = "txtFilter"
    txt.Top = oListBox.Top - txt.Height - 2
    txt.Width = 150

    Set Emitter = New EventListenerEmitter
    Emitter.AddEventListenerAll oForm

    Dim cbx         As MSForms.ComboBox
    Set cbx = oForm.Controls.Add("Forms.ComboBox.1")
    cbx.Name = "cbxFilter"
    cbx.Height = txt.Height
    cbx.Width = 50
    cbx.Left = oListBox.Left
    cbx.Top = txt.Top
    For i = -1 To oListBox.columnCount - 1
        cbx.AddItem i
    Next
    cbx.ListIndex = 0

    txt.Left = oListBox.Left + cbx.Width + 6
End Sub

Public Sub FilterByColumn(this As String, _
        Optional ColumnIndexZeroBased As Long = -1, _
        Optional CaseSensitive As Boolean = False)
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    Dim i           As Long
    Dim N           As Long
    Dim sTemp       As String
    If ColumnIndexZeroBased > oListBox.columnCount - 1 Or ColumnIndexZeroBased < 0 Then
        ColumnIndexZeroBased = -1
    End If
    N = oListBox.ListCount
    If ColumnIndexZeroBased <> -1 Then
        For i = N - 1 To 0 Step -1
            If CaseSensitive = True Then
                sTemp = oListBox.list(i, ColumnIndexZeroBased)
            Else
                this = LCase(this)
                sTemp = LCase(oListBox.list(i, ColumnIndexZeroBased))
            End If
            If InStr(1, sTemp, this) = 0 Then
                oListBox.RemoveItem (i)
            End If
        Next i
    Else
        Dim columnCount As Long
        N = oListBox.ListCount
        For i = N - 1 To 0 Step -1
            For columnCount = 0 To oListBox.columnCount - 1
                If CaseSensitive = True Then
                    sTemp = oListBox.list(i, columnCount)
                Else
                    this = LCase(this)
                    sTemp = LCase(oListBox.list(i, columnCount))
                End If
                If InStr(1, sTemp, this) > 0 Then
                Else
                    If columnCount = oListBox.columnCount - 1 Then
                        oListBox.RemoveItem (i)
                    End If
                End If
            Next columnCount
        Next i
    End If
End Sub


Function LoadCSV(TargetFile As String, clear As Boolean)
    '@AssignedModule aListBox
    '@INCLUDE PROCEDURE TxtRead
    '@INCLUDE CLASS aListBox
    If clear Then oListBox.clear
    Dim ArrayOfElements
    Dim S: S = TxtRead(TargetFile)
    Dim arr
    arr = Split(S, vbLf)
    Dim iCols, iRows
    iRows = UBound(arr) + 1
    iCols = UBound(Split(arr(0), ",")) + 1
    ReDim ArrayOfElements(1 To iRows, 1 To iCols)
    Dim X, Y
    For X = 1 To iRows
        For Y = 1 To iCols
            ArrayOfElements(X, Y) = Split(arr(X - 1), ",")(Y - 1)
        Next
    Next
    oListBox.columnCount = iCols
    oListBox.list = ArrayOfElements
End Function

Sub ToRange(cell As Range)
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    cell.Resize(oListBox.ListCount, oListBox.columnCount) = oListBox.list
End Sub

Sub ClearSelection()
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    On Error Resume Next
    Dim i           As Long
    For i = 0 To oListBox.ListCount
        oListBox.Selected(i) = False
    Next i
End Sub


Public Sub AcceptFiles(Optional sExpansion As String = "*.xlsm;*.xlsb;*.xlsx", Optional iDeepSubPath As Integer = 999)
    'eg on userform_activate:
    'aListBox.Init(ListBox1).AcceptFiles sExpansion:="*.xlsm;*.xlsb;*.xlsx",iDeepSubPath:=999
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    '@INCLUDE CLASS aUserform

    'you can use .[_GethWnd] with controls which support it
    Dim ctr         As control: Set ctr = oListBox
    Dim lGethWnd    As LongPtr: lGethWnd = ctr.[_GethWnd]

#If VBA7 Then
    Dim hwnd As LongPtr, HDROP As LongPtr
#Else
    Dim hwnd As Long, HDROP As Long
#End If

    Const WM_DROPFILES = &H233
    Dim tMsg As msg, sFileName As String * 1000
    Dim lFilesCount As Long, i As Long
    hwnd = aUserform.Init(oForm).hwnd
    Call DragAcceptFiles(lGethWnd, True)

    Dim sPathFile   As String

    Do While GetMessage(tMsg, 0, 0, 0) And IsWindow(hwnd)
        If tMsg.message = WM_DROPFILES Then
            HDROP = tMsg.wParam
            lFilesCount = DragQueryFile(HDROP, &HFFFFFFFF, 0, 0)
            If lFilesCount Then
                For i = 0 To lFilesCount - 1
                    sPathFile = VBA.Trim$(VBA.Left(sFileName, DragQueryFile(HDROP, i, sFileName, VBA.Len(sFileName))))
                    Call getFilesFromPath(sPathFile, sExpansion, iDeepSubPath)
                Next i
            End If
            Call DragFinish(HDROP)
        End If
        Call TranslateMessage(tMsg)
        Call DispatchMessage(tMsg)
    Loop
End Sub
Private Sub getFilesFromPath(ByVal sPathFile As String, ByVal sExpansion As String, ByVal iDeepSubPath As Integer)
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    Dim sExp        As String
    sExp = sGetExtensionName(sPathFile)
    If sExp = vbNullString Then
        Dim oCol    As Collection
        Set oCol = GetFiles(sPathFile, iDeepSubPath)
        Dim i       As Integer
        Dim iCount  As Integer
        iCount = oCol.Count
        Dim sFile   As String
        For i = 1 To iCount
            sFile = oCol.item(i).path
            sExp = sGetExtensionName(sFile)
            Call filterFiles(sFile, sExpansion, sExp)
        Next i
    Else
        Call filterFiles(sPathFile, sExpansion, sExp)
    End If
End Sub
Private Sub filterFiles(ByVal sPathFile As String, ByVal sExpansion As String, ByVal sExp As String)
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    sExp = "*." & sExp
    If sExpansion = vbNullString Or sExpansion = "*.*" Then
    ElseIf Not likeExp(sExpansion, sExp) Then
        Exit Sub
    End If
    oListBox.AddItem sPathFile
End Sub
Private Function likeExp(ByVal sExpansion As String, ByVal sExp As String) As Boolean
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    Dim arr         As Variant
    arr = VBA.Split(sExpansion, ";")
    Dim i           As Long
    Dim iCount      As Long
    iCount = UBound(arr, 1)
    For i = 0 To iCount
        If sExp Like arr(i) Then
            likeExp = True
            Exit For
        End If
    Next i
End Function
Private Function sGetExtensionName(ByVal sPathFile As String) As String
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    Dim FSO         As Object
    Set FSO = CreateObject("Scripting.FileSystemObject")
    sGetExtensionName = FSO.GetExtensionName(sPathFile)
    Set FSO = Nothing
End Function
Private Function GetFiles(ByVal path As String, ByVal iDeepSubPath As Integer) As Collection
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    Dim MainFolder  As Object
    Dim iFolder     As Object
    Dim iFile       As Object
    Dim FSO         As Object
    Dim MainColl    As New Collection
    Dim iColl       As Collection
    Dim i           As Long

    Set FSO = CreateObject("Scripting.FileSystemObject")
    Set MainFolder = FSO.GetFolder(path)
    If MainFolder Is Nothing Then Exit Function

    For Each iFile In MainFolder.Files
        If VBA.InStr(1, iFile.Name, "~") = 0 Then
            MainColl.Add iFile, iFile.path
        End If
    Next

    If iDeepSubPath > 0 Then
        For Each iFolder In MainFolder.SubFolders
            Set iColl = GetFiles(iFolder.path, iDeepSubPath - 1)
            For i = 1 To iColl.Count
                MainColl.Add iColl(i)
            Next
        Next
    End If
    Set GetFiles = MainColl
End Function

Public Sub HeightToEntries(ByVal NumberOfEntries As Long)
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    '@INCLUDE DECLARATION GetSystemMetrics
    Const SM_CYEDGE = 46&
    With oListBox
        NumberOfEntries = IIf(NumberOfEntries > .ListCount, .ListCount, NumberOfEntries)
        .Height = ((9.75 * NumberOfEntries) _
                + IIf(oListBox.Width < TotalColumnsWidth, 18, 0) _
                + IIf(.SpecialEffect = fmSpecialEffectFlat, 0, GetSystemMetrics(SM_CYEDGE)))
    End With
End Sub

Public Sub LoadVBProjects()
    '@AssignedModule aListBox
    '@INCLUDE PROCEDURE WorkbookProjectProtected
    '@INCLUDE CLASS aListBox
    oListBox.clear
    oListBox.columnCount = 1
    Dim coll        As New Collection
    Dim wb          As Workbook
    For Each wb In Workbooks
        If Len(wb.path) > 0 Then
            If WorkbookProjectProtected(wb) = False Then
                On Error Resume Next
                coll.Add wb.Name, wb.Name
                On Error GoTo 0
            End If
        End If
    Next
    Rem list addins
    Dim vbProj      As VBProject
    Dim wbPath      As String
    For Each vbProj In Application.VBE.VBProjects
        On Error GoTo ErrorHandler
        wbPath = vbProj.fileName
        If Right(wbPath, 4) = "xlam" Or Right(wbPath, 3) = "xla" Then
            Dim wbName As String
            wbName = Mid(wbPath, InStrRev(wbPath, "\") + 1)
            If WorkbookProjectProtected(Workbooks(wbName)) = False Then
                On Error Resume Next
                coll.Add wbName, wbName
                On Error GoTo 0
            End If
        End If
SKIP:
    Next vbProj

    Dim el          As Variant
    For Each el In coll
        oListBox.AddItem el
    Next

    Exit Sub
ErrorHandler:
    If Err.Number = 76 Then GoTo SKIP
End Sub

Public Sub SelectItems(this As Variant, Optional ByIndex As Boolean)
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    Dim i           As Long
    Select Case TypeName(this)
        Case Is = "String", "Long", "Integer"
            For i = 0 To oListBox.ListCount - 1
                If oListBox.list(i) = CStr(this) Then
                    oListBox.Selected(i) = True
                    DoEvents
                    If oListBox.multiSelect = fmMultiSelectSingle Then Exit Sub
                End If
            Next
        Case Else
            Dim el  As Variant
            If ByIndex Then
                For Each el In this
                    oListBox.Selected(el) = True
                Next
            Else
                For Each el In this
                    For i = 0 To oListBox.ListCount - 1
                        If oListBox.list(i) = el Then
                            oListBox.Selected(i) = True
                            DoEvents
                        End If
                    Next
                Next
            End If
    End Select
End Sub

Public Sub AddHeader(Optional arrHeaders)
    '@AssignedModule aListBox
    '@INCLUDE PROCEDURE ArrayDimensions
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS aListBox
    '@INCLUDE DECLARATION Emitter
    If oListBox.ColumnWidths = "" Then Exit Sub
    Dim i           As Long

    If IsMissing(arrHeaders) Then
        ReDim arrHeaders(0 To oListBox.columnCount - 1)
        For i = 1 To oListBox.columnCount
            arrHeaders(i - 1) = i
        Next
    End If

    Dim Header      As MSForms.Label
    For i = 1 To oListBox.columnCount
        Set Header = oForm.Controls.Add("Forms.Label.1")
        If i = 1 Then
            Header.Left = oListBox.Left
        Else
            Header.Left = oForm.Controls("lblHeader-" & i - 1).Left + oForm.Controls("lblHeader-" & i - 1).Width
        End If
        Header.Name = "lblHeader-" & i
        Header.SpecialEffect = fmSpecialEffectFlat
        Header.BackColor = RGB(200, 200, 200)
        Header.Width = Trim(Replace(Split(oListBox.ColumnWidths, ";")(i - 1), "pt", ""))
        Header.Height = 12
        Header.Font.Bold = True
        Header.Font.Name = "Segoe UI"
        Header.Top = oListBox.Top - Header.Height - 1
        Header.TextAlign = fmTextAlignCenter
        If ArrayDimensions(arrHeaders) = 1 Then
            Header.Caption = arrHeaders(i - 1)
        Else
            Header.Caption = arrHeaders(0, i)
        End If
    Next

    Set Emitter = New EventListenerEmitter
    Emitter.AddEventListenerAll oForm

    '    oListBox.ZOrder (1)
    '    Header.ZOrder (0)

End Sub
Sub removeHeaders()
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    Dim ctl         As MSForms.control
    For Each ctl In oForm.Controls
        If ctl.Name Like "lblHeader-*" Then oForm.Controls.Remove ctl.Name
    Next
End Sub
Public Function Contains(this As String, _
        Optional ColumnIndexZeroBased As Long = -1, _
        Optional CaseSensitive As Boolean = False) As Boolean
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    Dim i           As Long
    Dim N           As Long
    Dim sTemp       As String
    If ColumnIndexZeroBased > oListBox.columnCount - 1 Or ColumnIndexZeroBased < 0 Then
        ColumnIndexZeroBased = -1
    End If
    N = oListBox.ListCount
    If ColumnIndexZeroBased <> -1 Then
        For i = N - 1 To 0 Step -1
            If CaseSensitive = True Then
                sTemp = oListBox.list(i, ColumnIndexZeroBased)
            Else
                this = LCase(this)
                sTemp = LCase(oListBox.list(i, ColumnIndexZeroBased))
            End If
            If InStr(1, sTemp, this) > 0 Then
                Contains = True
                Exit Function
            End If
        Next i
    Else
        Dim columnCount As Long
        N = oListBox.ListCount
        For i = N - 1 To 0 Step -1
            For columnCount = 0 To oListBox.columnCount - 1
                If CaseSensitive = True Then
                    sTemp = oListBox.list(i, columnCount)
                Else
                    this = LCase(this)
                    sTemp = LCase(oListBox.list(i, columnCount))
                End If
                If InStr(1, sTemp, this) > 0 Then
                    Contains = True
                    Exit Function
                End If
            Next columnCount
        Next i
    End If
End Function

Public Sub SortOnColumn(OnColumn As Long)
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox

    Dim vntData     As Variant
    Dim vntTempItem As Variant
    Dim lngOuterIndex As Long
    Dim lngInnerIndex As Long
    Dim lngSubItemIndex As Long
    vntData = oListBox.list

    For lngOuterIndex = LBound(vntData, 1) To UBound(vntData, 1) - 1
        For lngInnerIndex = lngOuterIndex + 1 To UBound(vntData, 1)
            ' Use StrComp with vbTextCompare option to compare strings case-insensitively
            If StrComp(vntData(lngOuterIndex, OnColumn), vntData(lngInnerIndex, OnColumn), vbTextCompare) > 0 Then
                For lngSubItemIndex = 0 To oListBox.columnCount - 1
                    vntTempItem = vntData(lngOuterIndex, lngSubItemIndex)
                    vntData(lngOuterIndex, lngSubItemIndex) = vntData(lngInnerIndex, lngSubItemIndex)
                    vntData(lngInnerIndex, lngSubItemIndex) = vntTempItem
                Next lngSubItemIndex
            End If
        Next lngInnerIndex
    Next lngOuterIndex

    oListBox.clear
    oListBox.list = vntData
End Sub

'Public Sub SortOnColumn(OnColumn As Long)
'
'    Dim vntData As Variant
'    Dim vntTempItem As Variant
'    Dim lngOuterIndex As Long
'    Dim lngInnerIndex As Long
'    Dim lngSubItemIndex As Long
'    vntData = oListBox.List
'    For lngOuterIndex = LBound(vntData, 1) To UBound(vntData, 1) - 1
'        For lngInnerIndex = lngOuterIndex + 1 To UBound(vntData, 1)
'            If vntData(lngOuterIndex, OnColumn) > vntData(lngInnerIndex, OnColumn) Then
'                For lngSubItemIndex = 0 To oListBox.columnCount - 1
'                    vntTempItem = vntData(lngOuterIndex, lngSubItemIndex)
'                    vntData(lngOuterIndex, lngSubItemIndex) = vntData(lngInnerIndex, lngSubItemIndex)
'                    vntData(lngInnerIndex, lngSubItemIndex) = vntTempItem
'                Next
'            End If
'        Next lngInnerIndex
'    Next lngOuterIndex
'    oListBox.Clear
'    oListBox.List = vntData
'End Sub

Public Function selectedIndexes() As Collection
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    Dim i           As Long
    Dim coll        As New Collection
    If oListBox.ListCount > 0 Then
        For i = 0 To oListBox.ListCount - 1
            If oListBox.Selected(i) Then coll.Add i
        Next i
    End If
    Set selectedIndexes = coll
End Function

Public Function SelectedValues() As Collection    'single column
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    Dim i           As Long
    Dim ListItem    As Long
    Dim selectedCollection As Collection
    Set selectedCollection = New Collection
    Dim listboxCount As Long

    If oListBox.ListCount > 0 Then
        For i = 0 To oListBox.ListCount - 1
            If oListBox.Selected(i) Then
                selectedCollection.Add oListBox.list(i, oListBox.BoundColumn - 1)
            End If
        Next i
    End If

    Set SelectedValues = selectedCollection
End Function


Public Function SelectedRowsArray()
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    Dim X As Long, Y As Long
    Dim ListItem    As Long

    Dim indexColl   As New Collection
    Set indexColl = selectedIndexes
    If indexColl.Count = 0 Then SelectedRowsArray = Array(): Exit Function
    Dim out()       As Variant
    ReDim out(1 To indexColl.Count, 1 To oListBox.columnCount)
    For X = 1 To indexColl.Count
        For Y = 1 To oListBox.columnCount
            out(X, Y) = oListBox.list(indexColl(X), Y - 1)
        Next
    Next
    SelectedRowsArray = out
End Function

Public Function SelectedRowsText() As String
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    Dim X As Long, Y As Long
    Dim ListItem    As Long
    Dim out         As String
    Dim indexColl   As New Collection
    Set indexColl = selectedIndexes
    For X = 1 To indexColl.Count
        For Y = 0 To oListBox.columnCount - 1
            out = out & IIf(Y > 0, "|", "") & oListBox.list(indexColl(X), Y)
        Next
        If X < indexColl.Count Then out = out & vbNewLine
    Next
    SelectedRowsText = out
End Function


Public Function SelectedCount() As Long
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    Dim i           As Long
    Dim ListItem    As Long
    Dim selectedCollection As Collection
    Set selectedCollection = New Collection
    Dim listboxCount As Long
    Dim counter     As Long

    If oListBox.ListCount > 0 Then
        For i = 0 To oListBox.ListCount - 1
            If oListBox.Selected(i) = True Then
                counter = counter + 1
            End If
        Next i
    End If
    SelectedCount = counter
End Function

Public Sub DeselectAll()
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    If oListBox.ListCount <> 0 Then
        Dim i       As Long
        For i = 0 To oListBox.ListCount - 1
            oListBox.Selected(i) = False
        Next i
    End If
End Sub

Public Sub SelectAll()
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    If oListBox.ListCount <> 0 Then
        Dim i       As Long
        For i = 0 To oListBox.ListCount - 1
            oListBox.Selected(i) = True
        Next i
    End If
End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 24-10-2023 20:05    Alex                (aListBox.cls > SelectLike)

Public Sub SelectLike(this As String, casteSensitive As Boolean, Optional targetColumn = 1)
'@LastModified 2310242005
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    DeselectAll
    If targetColumn < 1 Or targetColumn > oListBox.columnCount Then Stop
    If this = "" Then Exit Sub
    If oListBox.ListCount = 0 Then Exit Sub
    Dim val1
    Dim i           As Long
    For i = 0 To oListBox.ListCount - 1
        val1 = oListBox.list(i, targetColumn - 1)
        If casteSensitive Then val1 = UCase(val1): this = UCase(this)
        If val1 Like this Then
            oListBox.Selected(i) = True
        End If
    Next i
End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 24-10-2023 20:05    Alex                (aListBox.cls > DeselectLike)

Public Sub DeselectLike(this As String, casteSensitive As Boolean, Optional targetColumn = 1)
'@LastModified 2310242005
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    DeselectAll
    If targetColumn < 1 Or targetColumn > oListBox.columnCount Then Stop
    If this = "" Then Exit Sub
    If oListBox.ListCount = 0 Then Exit Sub
    Dim val1
    Dim i           As Long
    For i = 0 To oListBox.ListCount - 1
        val1 = oListBox.list(i, targetColumn - 1)
        If casteSensitive Then val1 = UCase(val1): this = UCase(this)
        If UCase(oListBox.list(i, targetColumn)) Like UCase(this) Then
            oListBox.Selected(i) = False
        End If
    Next i
End Sub
Public Sub SortAZ()    '1D
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    Dim j           As Long
    Dim i           As Long
    Dim Temp        As Variant
    With oListBox
        For j = 0 To .ListCount - 2
            For i = 0 To .ListCount - 2
                If LCase(.list(i)) > LCase(.list(i + 1)) Then
                    Temp = .list(i)
                    .list(i) = .list(i + 1)
                    .list(i + 1) = Temp
                End If
            Next i
        Next j
    End With
End Sub

Public Sub SortZA()    '1D
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    Dim j           As Long
    Dim i           As Long
    Dim Temp        As Variant
    With oListBox
        For j = 0 To .ListCount - 2
            For i = 0 To .ListCount - 2
                If LCase(.list(i)) < LCase(.list(i + 1)) Then
                    Temp = .list(i)
                    .list(i) = .list(i + 1)
                    .list(i + 1) = Temp
                End If
            Next i
        Next j
    End With
End Sub

'Sub ToRangeSelect(cell As Range)
'    cell.RESIZE(lBox.ListCount, oListBox.ColumnCount) = CollectionsToArray2D(SelectedValues)
'End Sub

Public Sub SelectedToRange()
    '@AssignedModule aListBox
    '@INCLUDE PROCEDURE CollectionsToArray2D
    '@INCLUDE PROCEDURE GetInputRange
    '@INCLUDE CLASS aCollection
    '@INCLUDE CLASS aListBox
    Dim rng         As Range
    If GetInputRange(rng, "Range picker", "Select range to output listbox' list") = False Then Exit Sub
    Dim var: var = aCollection.CollectionsToArray2D(SelectedValues)
    rng.Resize(UBound(var, 1), oListBox.columnCount) = var
End Sub

Public Sub RemoveSelected()
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    Dim coll        As New Collection: Set coll = selectedIndexes
    If coll.Count = 0 Then Exit Sub
    Dim i           As Long
    For i = coll.Count To 1 Step -1
        oListBox.RemoveItem coll(i)
    Next
End Sub

Public Sub ShowTheseColumns(targetColumns As Variant)
    'targetColumns is array of integers, base 1
    '@AssignedModule aListBox
    '@INCLUDE CLASS aListBox
    Dim RetVal()    As Variant
    ReDim RetVal(1 To oListBox.columnCount)
    If oListBox.ColumnWidths = "" Then Exit Sub    ' AutofitColumns (False)
    Dim i As Long, ii As Long
    For i = 1 To oListBox.columnCount
        For ii = LBound(targetColumns) To UBound(targetColumns)
            If i = targetColumns(ii) Then
                RetVal(i) = Split(Replace(oListBox.ColumnWidths, "pt", ""), ";")(i - 1)
                GoTo resumeNext
            End If
        Next
        RetVal(i) = 0
resumeNext:
    Next
    oListBox.ColumnWidths = Join(RetVal, ";")
End Sub

'aUserform	Class


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Class      : aUserform
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 04-05-2023 12:19    Alex
'* Modified   : 30-06-2023 10:01    Alex                modified save/load options/position to use ini
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Option Compare Text

Private oForm       As Object
Public WithEvents DockResize As UserForm
Public WithEvents lblResize As MSForms.Label
Public lblResizer As MSForms.Label

Private Const minHeight = 125
Private Const minWidth = 125
Private resizeEnabled As Boolean
Private mouseX As Double
Private mouseY As Double

Private ActiveWindowHWnd As Long
Private ApplicationHWnd As Long
Private Const C_ALPHA_FULL_OPAQUE As Byte = 255
Private Const C_ALPHA_FULL_TRANSPARENT As Byte = 0
Private Const C_EXCEL_APP_CLASSNAME = "XLMain"
Private Const C_EXCEL_APP_WINDOWCLASS = "XLMAIN"
Private Const C_EXCEL_DESK_CLASSNAME = "XLDesk"
Private Const C_EXCEL_DESK_WINDOWCLASS = "XLDESK"
Private Const C_EXCEL_WINDOW_CLASSNAME = "Excel7"
Private Const C_EXCEL_WINDOW_WINDOWCLASS = "EXCEL7"
Private Const C_USERFORM_CLASSNAME = "ThunderDFrame"
Private Const C_VBA_USERFORM_WINDOWCLASS = "ThunderDFrame"
Private Const FORMAT_MESSAGE_ALLOCATE_BUFFER = &H100
Private Const FORMAT_MESSAGE_ARGUMENT_ARRAY = &H2000
Private Const FORMAT_MESSAGE_FROM_HMODULE = &H800
Private Const FORMAT_MESSAGE_FROM_STRING = &H400
Private Const FORMAT_MESSAGE_FROM_SYSTEM = &H1000
Private Const FORMAT_MESSAGE_IGNORE_INSERTS = &H200
Private Const FORMAT_MESSAGE_MAX_WIDTH_MASK = &HFF
Private Const FORMAT_MESSAGE_TEXT_LEN = 160
Private Const GA_PARENT As Long = 1
Private Const GA_ROOT As Long = 2
Private Const GA_ROOTOWNER As Long = 3
Private Const GWL_EXSTYLE = (-20)
Private Const GWL_HWNDPARENT = (-8)
Private Const GWL_STYLE = (-16)
Private Const GW_OWNER = 4
Private Const HWND_BOTTOM = 1
Private Const HWND_NOTOPMOST = -2
Private Const HWND_TOP = 0
Private Const HWND_TOPMOST = -1
Private Const LWA_ALPHA = &H2&
Private Const LWA_COLORKEY = &H1
Private Const MAX_PATH = 260
Private Const MF_BYPOSITION = &H400
Private Const MF_DISABLED = &H2&
Private Const MF_ENABLED = &H0&
Private Const MF_GRAYED = &H1&
Private Const MF_REMOVE = &H1000
Private Const SWP_NOMOVE = &H2
Private Const SWP_NOSIZE = &H1
Private Const SW_SHOW As Long = 5
Private Const USERFORM_WINDOW_CLASS = "ThunderDFrame"
Private Const WS_CAPTION = &HC00000
Private Const WS_DLGFRAME = &H400000
Private Const WS_EX_DLGMODALFRAME As Long = &H1
Private Const WS_EX_LAYERED = &H80000
Private Const WS_MAXIMIZEBOX = &H10000
Private Const WS_MINIMIZEBOX = &H20000
Private Const WS_SIZEBOX = &H40000
Private Const WS_SYSMENU = &H80000
Private Const WS_THICKFRAME = &H40000
Private Const black As Long = &H80000012
Private Const red   As Long = &HFF&
Private ExcelDeskHWnd As Long
Private UserFormHWnd As Long
Private VBEditorHWnd As Long
Private WindowsDesktopHWnd As Long
Private m_sngDownX  As Single
Private m_sngDownY  As Single
Private mdHeight    As Double
Private mdWidth     As Double

Public Enum FORM_PARENT_WINDOW_TYPE
    FORM_PARENT_NONE = 0
    FORM_PARENT_APPLICATION = 1
    FORM_PARENT_WINDOW = 2
End Enum

Private Enum CloseBy
    User = 0
    Code = 1
    WindowsOS = 2
    TaskManager = 3
End Enum

#If VBA7 Then
Private Declare PtrSafe Function DrawMenuBar Lib "user32" (ByVal hwnd As Long) As Long
Private Declare PtrSafe Function EnableMenuItem Lib "user32" (ByVal hMenu As Long, ByVal wIDEnableItem As Long, ByVal wEnable As Long) As Long
Private Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Private Declare PtrSafe Function FindWindowA Lib "user32" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Private Declare PtrSafe Function FindWindowEx Lib "user32" Alias "FindWindowExA" (ByVal hWnd1 As Long, ByVal hWnd2 As Long, ByVal lpsz1 As String, ByVal lpsz2 As String) As Long
Private Declare PtrSafe Function FormatMessage Lib "kernel32" Alias "FormatMessageA" (ByVal dwFlags As Long, lpSource As Any, ByVal dwMessageId As Long, ByVal dwLanguageId As Long, ByVal lpBuffer As String, ByVal nSize As Long, Arguments As LongPtr) As Long
Private Declare PtrSafe Function GetActiveWindow Lib "user32" () As Long
Private Declare PtrSafe Function GetAncestor Lib "user32.dll" (ByVal hwnd As Long, ByVal gaFlags As Long) As Long
Private Declare PtrSafe Function GetClassName Lib "user32" Alias "GetClassNameA" (ByVal hwnd As Long, ByVal lpClassName As String, ByVal nMaxCount As Long) As Long
Private Declare PtrSafe Function GetDesktopWindow Lib "user32" () As Long
Private Declare PtrSafe Function GetMenuItemCount Lib "user32" (ByVal hMenu As Long) As Long
Private Declare PtrSafe Function GetParent Lib "user32.dll" (ByVal hwnd As Long) As Long
Private Declare PtrSafe Function GetSystemMenu Lib "user32" (ByVal hwnd As Long, ByVal bRevert As Long) As Long
Private Declare PtrSafe Function GetWindow Lib "user32" (ByVal hwnd As Long, ByVal wCmd As Long) As Long
Private Declare PtrSafe Function GetWindowLong Lib "user32.dll" Alias "GetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long) As Long
Private Declare PtrSafe Function GetWindowLongA Lib "user32" (ByVal hwnd As Long, ByVal nIndex As Long) As Long
Private Declare PtrSafe Function GetWindowText Lib "user32.dll" Alias "GetWindowTextA" (ByVal hwnd As Long, ByVal lpString As String, ByVal cch As Long) As Long
Private Declare PtrSafe Function GetWindowTextLength Lib "user32" Alias "GetWindowTextLengthA" (ByVal hwnd As Long) As Long
Private Declare PtrSafe Function IUnknown_GetWindow Lib "shlwapi" Alias "#172" (ByVal pIUnk As IUnknown, ByVal hwnd As LongPtr) As Long
Private Declare PtrSafe Function RemoveMenu Lib "user32" (ByVal hMenu As Long, ByVal nPosition As Long, ByVal wFlags As Long) As Long
Private Declare PtrSafe Function SetFocus Lib "user32" (ByVal hwnd As Long) As Long
Private Declare PtrSafe Function SetForegroundWindow Lib "user32" (ByVal hwnd As LongPtr) As Long
Private Declare PtrSafe Function SetLayeredWindowAttributes Lib "user32" (ByVal hwnd As Long, ByVal crKey As Long, ByVal bAlpha As Byte, ByVal dwFlags As Long) As Long
Private Declare PtrSafe Function SetParent Lib "user32" (ByVal hWndChild As LongPtr, ByVal hWndNewParent As LongPtr) As LongPtr
Private Declare PtrSafe Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Private Declare PtrSafe Function SetWindowLongA Lib "user32" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Private Declare PtrSafe Function SetWindowPos Lib "user32" (ByVal hwnd As LongPtr, ByVal hWndInsertAfter As LongPtr, ByVal X As LongPtr, ByVal Y As LongPtr, ByVal cx As LongPtr, ByVal cy As LongPtr, ByVal uFlags As LongPtr) As Long
Private Declare PtrSafe Function ShowWindow Lib "user32" (ByVal hwnd As Long, ByVal nCmdShow As Long) As Long
Private Declare PtrSafe Function WindowFromAccessibleObject Lib "oleacc" (ByVal pacc As IAccessible, phwnd As LongPtr) As Long
Private Declare PtrSafe Function getFrequency Lib "kernel32" Alias "QueryPerformanceFrequency" (cyFrequency As Currency) As Long
Private Declare PtrSafe Function getTickCount Lib "kernel32" Alias "QueryPerformanceCounter" (cyTickCount As Currency) As Long
#Else
Private Declare Function DrawMenuBar Lib "user32" (ByVal hWnd As Long) As Long
Private Declare Function EnableMenuItem Lib "user32" (ByVal hMenu As Long,ByVal wIDEnableItem As Long,ByVal wEnable As Long) As Long
Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Private Declare Function FindWindowA Lib "user32" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Private Declare Function FindWindowEx Lib "user32" Alias "FindWindowExA" (ByVal hWnd1 As Long, ByVal hWnd2 As Long, ByVal lpsz1 As String, ByVal lpsz2 As String) As Long
Private Declare Function FormatMessage Lib "kernel32.dll" Alias "FormatMessageA" (ByVal dwFlags As Long, ByRef lpSource As Any, ByVal dwMessageId As Long, ByVal dwLanguageId As Long, ByVal lpBuffer As String, ByVal nSize As Long, ByRef Arguments As Long) As Long
Private Declare Function GetActiveWindow Lib "user32" () As Long
Private Declare Function GetAncestor Lib "user32.dll" (ByVal hWnd As Long, ByVal gaFlags As Long) As Long
Private Declare Function GetClassName Lib "user32" Alias "GetClassNameA" (ByVal hWnd As Long, ByVal lpClassName As String, ByVal nMaxCount As Long) As Long
Private Declare Function GetDesktopWindow Lib "user32" () As Long
Private Declare Function GetMenuItemCount Lib "user32" (ByVal hMenu As Long) As Long
Private Declare Function GetParent Lib "user32.dll" (ByVal hWnd As Long) As Long
Private Declare Function GetSystemMenu Lib "user32" (ByVal hwnd As Long,ByVal bRevert As Long) As Long
Private Declare Function GetWindow Lib "user32" (ByVal hWnd As Long, ByVal wCmd As Long) As Long
Private Declare Function GetWindowLong Lib "user32.dll" Alias "GetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
Private Declare Function GetWindowLongA Lib "user32" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
Private Declare Function GetWindowText Lib "user32.dll" Alias "GetWindowTextA" (ByVal hWnd As Long, ByVal lpString As String, ByVal cch As Long) As Long
Private Declare Function GetWindowTextLength Lib "user32" Alias "GetWindowTextLengthA" (ByVal hwnd As Long) As Long
Private Declare Function IUnknown_GetWindow Lib "shlwapi" Alias "#172" (ByVal pIUnk As IUnknown, ByVal hwnd As Long) As Long
Private Declare Function RemoveMenu Lib "user32" (ByVal hMenu As Long,ByVal nPosition As Long,ByVal wFlags As Long) As Long
Private Declare Function SetFocus Lib "user32" (ByVal hwnd As Long) As Long
Private Declare Function SetForegroundWindow Lib "user32" (ByVal hwnd As Long) As Long
Private Declare Function SetLayeredWindowAttributes Lib "user32" (ByVal hWnd As Long, ByVal crKey As Long, ByVal bAlpha As Byte, ByVal dwFlags As Long) As Long
Private Declare Function SetParent Lib "user32" (ByVal hWndChild As Long,ByVal hWndNewParent As Long) As Long
Private Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Private Declare Function SetWindowLongA Lib "user32" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Private Declare Function SetWindowPos Lib "user32" (ByVal hWnd As LongPtr, ByVal hWndInsertAfter As LongPtr, ByVal X As LongPtr, ByVal Y As LongPtr, ByVal cx As LongPtr, ByVal cy As LongPtr, ByVal uFlags As LongPtr) As Long
Private Declare Function ShowWindow Lib "user32" (ByVal hwnd As Long, ByVal nCmdShow As Long) As Long
Private Declare Function WindowFromAccessibleObject Lib "oleacc" (ByVal pacc As IAccessible, phwnd As Long) As Long
Private Declare Function getFrequency Lib "kernel32" Alias "QueryPerformanceFrequency" (cyFrequency As Currency) As Long
Private Declare Function getTickCount Lib "kernel32" Alias "QueryPerformanceCounter" (cyTickCount As Currency) As Long
#End If


Public Function ShowMaximizeButton(Optional HideButton As Boolean) As Boolean
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' ShowMaximizeButton
    ' Displays (if HideButton is False) or hides (if HideButton is True)
    ' a maximize window button.
    ' NOTE: If EITHER a Minimize or Maximize button is displayed,
    ' BOTH buttons are visible but may be disabled.
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'@AssignedModule modFormControl
'@INCLUDE PROCEDURE HWndOfUserForm
'@INCLUDE DECLARATION GWL_STYLE
'@INCLUDE DECLARATION WS_MAXIMIZEBOX
'@INCLUDE DECLARATION GetWindowLong
'@INCLUDE DECLARATION SetWindowLong

    Dim UFHWnd As Long
    Dim WinInfo As Long
    Dim R As Long

    UFHWnd = HWndOfUserForm
    If UFHWnd = 0 Then
        ShowMaximizeButton = False
        Exit Function
    End If

    WinInfo = GetWindowLong(UFHWnd, GWL_STYLE)
    If HideButton = False Then
        WinInfo = WinInfo Or WS_MAXIMIZEBOX
    Else
        WinInfo = WinInfo And (Not WS_MAXIMIZEBOX)
    End If
    R = SetWindowLong(UFHWnd, GWL_STYLE, WinInfo)

    ShowMaximizeButton = (R <> 0)

End Function

Public Function ShowMinimizeButton(Optional HideButton As Boolean) As Boolean
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' ShowMinimizeButton
    ' Displays (if HideButton is False) or hides (if HideButton is True)
    ' a minimize window button.
    ' NOTE: If EITHER a Minimize or Maximize button is displayed,
    ' BOTH buttons are visible but may be disabled.
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'@AssignedModule modFormControl
'@INCLUDE PROCEDURE HWndOfUserForm
'@INCLUDE DECLARATION GWL_STYLE
'@INCLUDE DECLARATION WS_MINIMIZEBOX
'@INCLUDE DECLARATION GetWindowLong
'@INCLUDE DECLARATION SetWindowLong

    Dim UFHWnd As Long
    Dim WinInfo As Long
    Dim R As Long

    UFHWnd = HWndOfUserForm
    If UFHWnd = 0 Then
        ShowMinimizeButton = False
        Exit Function
    End If

    WinInfo = GetWindowLong(UFHWnd, GWL_STYLE)
    If HideButton = False Then
        WinInfo = WinInfo Or WS_MINIMIZEBOX
    Else
        WinInfo = WinInfo And (Not WS_MINIMIZEBOX)
    End If
    R = SetWindowLong(UFHWnd, GWL_STYLE, WinInfo)

    ShowMinimizeButton = (R <> 0)

End Function

Private Function HasMinimizeButton() As Boolean
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' HasMinimizeButton
    ' Returns True if the userform has a minimize button, False
    ' otherwise.
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'@AssignedModule modFormControl
'@INCLUDE PROCEDURE HWndOfUserForm
'@INCLUDE DECLARATION GWL_STYLE
'@INCLUDE DECLARATION WS_MINIMIZEBOX
'@INCLUDE DECLARATION GetWindowLong

    Dim UFHWnd As Long
    Dim WinInfo As Long
    Dim R As Long

    UFHWnd = HWndOfUserForm
    If UFHWnd = 0 Then
        HasMinimizeButton = False
        Exit Function
    End If

    WinInfo = GetWindowLong(UFHWnd, GWL_STYLE)

    If WinInfo And WS_MINIMIZEBOX Then
        HasMinimizeButton = True
    Else
        HasMinimizeButton = False
    End If

End Function

Private Function HasMaximizeButton() As Boolean
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' HasMaximizeButton
    ' Returns True if the userform has a maximize button, False
    ' otherwise.
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'@AssignedModule modFormControl
'@INCLUDE PROCEDURE HWndOfUserForm
'@INCLUDE DECLARATION GWL_STYLE
'@INCLUDE DECLARATION WS_MAXIMIZEBOX
'@INCLUDE DECLARATION GetWindowLong

    Dim UFHWnd As Long
    Dim WinInfo As Long
    Dim R As Long

    UFHWnd = HWndOfUserForm
    If UFHWnd = 0 Then
        HasMaximizeButton = False
        Exit Function
    End If

    WinInfo = GetWindowLong(UFHWnd, GWL_STYLE)

    If WinInfo And WS_MAXIMIZEBOX Then
        HasMaximizeButton = True
    Else
        HasMaximizeButton = False
    End If

End Function


Public Function SetFormParent(Parent As FORM_PARENT_WINDOW_TYPE) As Boolean
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' SetFormParent
    ' Set the UserForm UF as a child of (1) the Application, (2) the
    ' Excel ActiveWindow, or (3) no parent. Returns TRUE if successful
    ' or FALSE if unsuccessful.
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'@AssignedModule modFormControl
'@INCLUDE PROCEDURE HWndOfUserForm
'@INCLUDE PROCEDURE WindowHWnd
'@INCLUDE DECLARATION FORM_PARENT_WINDOW_TYPE
'@INCLUDE DECLARATION SetParent

    Dim UFHWnd As Long
    Dim WindHWnd As Long
    #If VBA7 Then
    Dim R As LongPtr
    #Else
    Dim R As Long
    #End If

    UFHWnd = HWndOfUserForm
    If UFHWnd = 0 Then
        SetFormParent = False
        Exit Function
    End If

    Select Case Parent
    Case FORM_PARENT_APPLICATION
        R = SetParent(UFHWnd, Application.hwnd)
    Case FORM_PARENT_NONE
        R = SetParent(UFHWnd, 0&)
    Case FORM_PARENT_WINDOW
        If Application.ActiveWindow Is Nothing Then
            SetFormParent = False
            Exit Function
        End If
        WindHWnd = WindowHWnd(Application.ActiveWindow)
        If WindHWnd = 0 Then
            SetFormParent = False
            Exit Function
        End If
        R = SetParent(UFHWnd, WindHWnd)
    Case Else
        SetFormParent = False
        Exit Function
    End Select
    SetFormParent = (R <> 0)

End Function


Private Function IsCloseButtonVisible() As Boolean
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' IsCloseButtonVisible
    ' Returns TRUE if UserForm UF has a close button, FALSE if there
    ' is no close button.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'@AssignedModule modFormControl
'@INCLUDE PROCEDURE HWndOfUserForm
'@INCLUDE DECLARATION GWL_STYLE
'@INCLUDE DECLARATION WS_SYSMENU
'@INCLUDE DECLARATION GetWindowLong

    Dim UFHWnd As Long
    Dim WinInfo As Long
    Dim R As Long

    UFHWnd = HWndOfUserForm
    If UFHWnd = 0 Then
        IsCloseButtonVisible = False
        Exit Function
    End If

    WinInfo = GetWindowLong(UFHWnd, GWL_STYLE)
    IsCloseButtonVisible = (WinInfo And WS_SYSMENU)

End Function

Public Function ShowCloseButton(Optional HideButton As Boolean) As Boolean
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' ShowCloseButton
    ' This displays (if HideButton is FALSE) or hides (if HideButton is
    ' TRUE) the Close button on the userform
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'@AssignedModule modFormControl
'@INCLUDE PROCEDURE HWndOfUserForm
'@INCLUDE DECLARATION GWL_STYLE
'@INCLUDE DECLARATION WS_SYSMENU
'@INCLUDE DECLARATION GetWindowLong
'@INCLUDE DECLARATION SetWindowLong

    Dim UFHWnd As Long
    Dim WinInfo As Long
    Dim R As Long

    UFHWnd = HWndOfUserForm
    If UFHWnd = 0 Then
        Exit Function
    End If

    WinInfo = GetWindowLong(UFHWnd, GWL_STYLE)
    If HideButton = False Then
        ' set the SysMenu bit
        WinInfo = WinInfo Or WS_SYSMENU
    Else
        ' clear the SysMenu bit
        WinInfo = WinInfo And (Not WS_SYSMENU)
    End If

    R = SetWindowLong(UFHWnd, GWL_STYLE, WinInfo)
    ShowCloseButton = (R <> 0)

End Function


Private Function IsCloseButtonEnabled() As Boolean
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' IsCloseButtonEnabled
    ' This returns TRUE if the close button is enabled or FALSE if
    ' the close button is disabled.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'@AssignedModule modFormControl
'@INCLUDE PROCEDURE EnableCloseButton
'@INCLUDE PROCEDURE HWndOfUserForm
'@INCLUDE DECLARATION MF_BYPOSITION
'@INCLUDE DECLARATION MF_DISABLED
'@INCLUDE DECLARATION MF_ENABLED
'@INCLUDE DECLARATION DrawMenuBar
'@INCLUDE DECLARATION EnableMenuItem
'@INCLUDE DECLARATION GetMenuItemCount
'@INCLUDE DECLARATION GetSystemMenu

    Dim UFHWnd As Long
    Dim hMenu As Long
    Dim ItemCount As Long
    Dim PrevState As Long

    UFHWnd = HWndOfUserForm
    If UFHWnd = 0 Then
        IsCloseButtonEnabled = False
        Exit Function
    End If
    ' Get the menu handle
    hMenu = GetSystemMenu(UFHWnd, 0&)
    If hMenu = 0 Then
        IsCloseButtonEnabled = False
        Exit Function
    End If

    ItemCount = GetMenuItemCount(hMenu)
    ' Disable the button. This returns MF_DISABLED or MF_ENABLED indicating
    ' the previous state of the item.
    PrevState = EnableMenuItem(hMenu, ItemCount - 1, MF_DISABLED Or MF_BYPOSITION)

    If PrevState = MF_DISABLED Then
        IsCloseButtonEnabled = False
    Else
        IsCloseButtonEnabled = True
    End If
    ' restore the previous state
    EnableCloseButton (PrevState = MF_DISABLED)

    DrawMenuBar UFHWnd

End Function


Public Function EnableCloseButton(Disable As Boolean) As Boolean
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' EnableCloseButton
    ' This function enables (if Disable is False) or disables (if
    ' Disable is True) the "X" button on a UserForm UF.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'@AssignedModule modFormControl
'@INCLUDE PROCEDURE HWndOfUserForm
'@INCLUDE DECLARATION MF_BYPOSITION
'@INCLUDE DECLARATION MF_DISABLED
'@INCLUDE DECLARATION MF_ENABLED
'@INCLUDE DECLARATION DrawMenuBar
'@INCLUDE DECLARATION EnableMenuItem
'@INCLUDE DECLARATION GetMenuItemCount
'@INCLUDE DECLARATION GetSystemMenu

    Dim UFHWnd As Long
    Dim hMenu As Long
    Dim ItemCount As Long
    Dim Res As Long

    ' Get the HWnd of the UserForm.
    UFHWnd = HWndOfUserForm
    If UFHWnd = 0 Then
        EnableCloseButton = False
        Exit Function
    End If
    ' Get the menu handle
    hMenu = GetSystemMenu(UFHWnd, 0&)
    If hMenu = 0 Then
        EnableCloseButton = False
        Exit Function
    End If

    ItemCount = GetMenuItemCount(hMenu)
    If Disable = True Then
        Res = EnableMenuItem(hMenu, ItemCount - 1, MF_DISABLED Or MF_BYPOSITION)
    Else
        Res = EnableMenuItem(hMenu, ItemCount - 1, MF_ENABLED Or MF_BYPOSITION)
    End If
    If Res = -1 Then
        EnableCloseButton = False
        Exit Function
    End If
    DrawMenuBar UFHWnd

    EnableCloseButton = True


End Function

Public Function ShowTitleBar(HideTitle As Boolean) As Boolean
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' ShowTitleBar
    ' Displays (if HideTitle is FALSE) or hides (if HideTitle is TRUE) the
    ' title bar of the userform UF.
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'@AssignedModule modFormControl
'@INCLUDE PROCEDURE HWndOfUserForm
'@INCLUDE DECLARATION GWL_STYLE
'@INCLUDE DECLARATION WS_CAPTION
'@INCLUDE DECLARATION GetWindowLong
'@INCLUDE DECLARATION SetWindowLong

    Dim UFHWnd As Long
    Dim WinInfo As Long
    Dim R As Long

    UFHWnd = HWndOfUserForm
    If UFHWnd = 0 Then
        ShowTitleBar = False
        Exit Function
    End If

    WinInfo = GetWindowLong(UFHWnd, GWL_STYLE)

    If HideTitle = False Then
        ' turn on the Caption bit
        WinInfo = WinInfo Or WS_CAPTION
    Else
        ' turn off the Caption bit
        WinInfo = WinInfo And (Not WS_CAPTION)
    End If
    R = SetWindowLong(UFHWnd, GWL_STYLE, WinInfo)
    ShowTitleBar = (R <> 0)
End Function

Function IsTitleBarVisible() As Boolean
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' IsTitleBarVisible
    ' Returns TRUE if the title bar of UF is visible or FALSE if the
    ' title bar is not visible.
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'@AssignedModule modFormControl
'@INCLUDE PROCEDURE HWndOfUserForm
'@INCLUDE DECLARATION GWL_STYLE
'@INCLUDE DECLARATION WS_CAPTION
'@INCLUDE DECLARATION GetWindowLong
    Dim UFHWnd As Long
    Dim WinInfo As Long
    Dim R As Long

    UFHWnd = HWndOfUserForm
    If UFHWnd = 0 Then
        IsTitleBarVisible = False
        Exit Function
    End If

    WinInfo = GetWindowLong(UFHWnd, GWL_STYLE)

    IsTitleBarVisible = (WinInfo And WS_CAPTION)

End Function

Function MakeFormResizable(Sizable As Boolean) As Boolean
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' MakeFormResizable
    ' This makes the userform UF resizable (if Sizable is TRUE) or not
    ' resizable (if Sizalbe is FALSE). Returns TRUE if successful or FALSE
    ' if an error occurred.
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'@AssignedModule modFormControl
'@INCLUDE PROCEDURE HWndOfUserForm
'@INCLUDE DECLARATION GWL_STYLE
'@INCLUDE DECLARATION WS_SIZEBOX
'@INCLUDE DECLARATION GetWindowLong
'@INCLUDE DECLARATION SetWindowLong
    Dim UFHWnd As Long
    Dim WinInfo As Long
    Dim R As Long

    UFHWnd = CLng(hwnd) 'HWndOfUserForm
    If UFHWnd = 0 Then
        MakeFormResizable = False
        Exit Function
    End If

    WinInfo = GetWindowLong(UFHWnd, GWL_STYLE)
    If Sizable = True Then
        WinInfo = WinInfo Or WS_SIZEBOX
    Else
        WinInfo = WinInfo And (Not WS_SIZEBOX)
    End If

    R = SetWindowLong(UFHWnd, GWL_STYLE, WinInfo)
    MakeFormResizable = (R <> 0)

    If Sizable Then
        mdWidth = oForm.Width
        mdHeight = oForm.Height
        Set DockResize = oForm
    Else
        Set DockResize = Nothing
    End If
End Function

Function IsFormResizable() As Boolean
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' IsFormResizable
    ' Returns TRUE if UF is resizable, FALSE if UF is not resizable.
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'@AssignedModule modFormControl
'@INCLUDE PROCEDURE HWndOfUserForm
'@INCLUDE DECLARATION GWL_STYLE
'@INCLUDE DECLARATION WS_SIZEBOX
'@INCLUDE DECLARATION GetWindowLong

    Dim UFHWnd As Long
    Dim WinInfo As Long
    Dim R As Long

    UFHWnd = HWndOfUserForm
    If UFHWnd = 0 Then
        IsFormResizable = False
        Exit Function
    End If

    WinInfo = GetWindowLong(UFHWnd, GWL_STYLE)

    IsFormResizable = (WinInfo And WS_SIZEBOX)

End Function


Public Function SetFormOpacity(Opacity As Byte) As Boolean
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' SetFormOpacity
    ' This function sets the opacity of the UserForm referenced by the
    ' UF parameter. Opacity specifies the opacity of the form, from
    ' 0 = fully transparent (invisible) to 255 = fully opaque. The function
    ' returns True if successful or False if an error occurred. This
    ' requires Windows 2000 or later -- it will not work in Windows
    ' 95, 98, or ME.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'@AssignedModule modFormControl
'@INCLUDE PROCEDURE HWndOfUserForm
'@INCLUDE DECLARATION GWL_EXSTYLE
'@INCLUDE DECLARATION LWA_ALPHA
'@INCLUDE DECLARATION WS_EX_LAYERED
'@INCLUDE DECLARATION GetWindowLong
'@INCLUDE DECLARATION SetLayeredWindowAttributes
'@INCLUDE DECLARATION SetWindowLong
    Dim UFHWnd As Long
    Dim WinL As Long
    Dim Res As Long

    SetFormOpacity = False

    UFHWnd = HWndOfUserForm
    If UFHWnd = 0 Then
        Exit Function
    End If

    WinL = GetWindowLong(UFHWnd, GWL_EXSTYLE)
    If WinL = 0 Then
        Exit Function
    End If

    Res = SetWindowLong(UFHWnd, GWL_EXSTYLE, WinL Or WS_EX_LAYERED)
    If Res = 0 Then
        Exit Function
    End If

    Res = SetLayeredWindowAttributes(UFHWnd, 0, Opacity, LWA_ALPHA)
    If Res = 0 Then
        Exit Function
    End If

    SetFormOpacity = True

End Function


Function HWndOfUserForm() As Long
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' HWndOfUserForm
    ' This returns the window handle (HWnd) of the userform referenced
    ' by UF. It first looks for a top-level window, then a child
    ' of the Application window, then a child of the ActiveWindow.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'@AssignedModule modFormControl
'@INCLUDE PROCEDURE WindowHWnd
'@INCLUDE DECLARATION C_USERFORM_CLASSNAME
'@INCLUDE DECLARATION FindWindow
'@INCLUDE DECLARATION FindWindowEx
    Dim AppHWnd As Long
    Dim DeskHWnd As Long
    Dim WinHWnd As Long
    Dim UFHWnd As Long
    Dim Cap As String
    Dim WindowCap As String

    Cap = oForm.Caption

    ' First, look in top level windows
    UFHWnd = FindWindow(C_USERFORM_CLASSNAME, Cap)
    If UFHWnd <> 0 Then
        HWndOfUserForm = UFHWnd
        Exit Function
    End If
    ' Not a top level window. Search for child of application.
    AppHWnd = Application.hwnd
    UFHWnd = FindWindowEx(AppHWnd, 0&, C_USERFORM_CLASSNAME, Cap)
    If UFHWnd <> 0 Then
        HWndOfUserForm = UFHWnd
        Exit Function
    End If
    ' Not a child of the application.
    ' Search for child of ActiveWindow (Excel's ActiveWindow, not
    ' Window's ActiveWindow).
    If Application.ActiveWindow Is Nothing Then
        HWndOfUserForm = 0
        Exit Function
    End If
    WinHWnd = WindowHWnd(Application.ActiveWindow)
    UFHWnd = FindWindowEx(WinHWnd, 0&, C_USERFORM_CLASSNAME, Cap)
    HWndOfUserForm = UFHWnd

End Function


Function ClearBit(Value As Long, ByVal BitNumber As Long) As Long
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' ClearBit
    ' Clears the specified bit in Value and returns the result. Bits are
    ' numbered, right (most significant) 31 to left (least significant) 0.
    ' BitNumber is made positive and then MOD 32 to get a valid bit number.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'@AssignedModule modFormControl

    Dim SetMask As Long
    Dim ClearMask As Long

    BitNumber = Abs(BitNumber) Mod 32

    SetMask = Value
    If BitNumber < 30 Then
        ClearMask = Not (2 ^ (BitNumber - 1))
        ClearBit = SetMask And ClearMask
    Else
        ClearBit = Value And &H7FFFFFFF
    End If

End Function



#If VBA7 Then
Function hwnd() As LongPtr
    '@AssignedModule aUserform
    '@INCLUDE CLASS aUserform
#Else
Function hwnd() As Long
#End If
    WindowFromAccessibleObject oForm, hwnd
End Function


Public Sub Transition(ParamArray Elements() As Variant)
    Rem By Robert Todaer
    '__usage__
    'with aUserform
    '    .Transition .Effect(Box, "Top", Me.InsideHeight - Box.Height, 1000) _
         , .Effect(box2, "Top", 0, 100) _
         , .Effect(GoButton, "fontsize", 12, 1000) _
         , .Effect(Me, "Top", 20, 2000)
    'End with
    '@AssignedModule aUserform
    '@INCLUDE CLASS aUserform
    '@INCLUDE DECLARATION Sleep

    If IsArray(Elements(LBound(Elements, 1))) Then
        Dim Temp    As Variant
        Temp = Elements(LBound(Elements, 1))
        Elements = Temp
    End If
    Dim Form        As MSForms.UserForm
    Set Form = Elements(LBound(Elements, 1))("form")
    MicroTimer True
    Do
        Dim index   As Integer
        For index = LBound(Elements, 1) To UBound(Elements, 1)
            IncRementElement Elements(index), MicroTimer
        Next index
        Sleep 40
        Form.Repaint
    Loop Until AllTransitionsComplete(CVar(Elements))
End Sub

Public Function Effect(obj As Object, Property As String, Destination As Double, MilSecs As Double) As Scripting.Dictionary
    '@AssignedModule aUserform
    '@INCLUDE CLASS aUserform
    Dim Temp        As New Scripting.Dictionary
    Set Temp("obj") = obj
    Temp("property") = Property
    Temp("startValue") = CallByName(obj, Property, VbGet)
    Temp("destination") = Destination
    Temp("travel") = Destination - Temp("startValue")
    Temp("milSec") = MilSecs
    Temp("complete") = False
    On Error GoTo catch:
    Set Temp("form") = obj.Parent
    Set Effect = Temp
    Exit Function
catch:
    Set Temp("form") = obj
    Resume Next
End Function

Private Function MicroTimer(Optional StartTime As Boolean = False) As Double
    '@AssignedModule aUserform
    '@INCLUDE CLASS aUserform
    '@INCLUDE DECLARATION getTickCount
    Static dTime    As Double
    Dim cyTicks1    As Currency
    Dim cyTicks2    As Currency
    Static cyFrequency As Currency
    MicroTimer = 0
    If cyFrequency = 0 Then getFrequency cyFrequency
    getTickCount cyTicks1
    getTickCount cyTicks2
    If cyTicks2 < cyTicks1 Then cyTicks2 = cyTicks1
    If cyFrequency Then MicroTimer = cyTicks2 / cyFrequency
    If StartTime = True Then
        dTime = MicroTimer
        MicroTimer = 0
    Else
        MicroTimer = (MicroTimer - dTime) * 1000
    End If
End Function

Private Function AllTransitionsComplete(Elements As Variant) As Boolean
    '@INCLUDE TransitionComplete
    '@AssignedModule aUserform
    '@INCLUDE CLASS aUserform
    Dim el          As Object
    Dim index       As Integer
    For index = LBound(Elements, 1) To UBound(Elements, 1)
        Set el = Elements(index)
        If Not TransitionComplete(el) Then
            AllTransitionsComplete = False
            Exit Function
        End If
    Next index
    AllTransitionsComplete = True
End Function

Private Function TransitionComplete(ByVal el As Scripting.Dictionary) As Boolean
    '@AssignedModule aUserform
    '@INCLUDE CLASS aUserform
    If Math.Round(el("destination")) = Math.Round(CallByName(el("obj"), el("property"), VbGet)) Then
        TransitionComplete = True
    End If
End Function

Private Function IncRementElement(ByVal el As Scripting.Dictionary, CurrentTime As Double) As Boolean
    '@INCLUDE TransitionComplete
    '@INCLUDE easeInAndOut
    '@AssignedModule aUserform
    '@INCLUDE CLASS aUserform
    Dim IncRementValue As Double
    Dim CurrentValue As Double
    If TransitionComplete(el) Then
        Exit Function
    End If
    Dim o           As Object
    Dim p           As String
    Dim Value       As Double
    Dim d           As Double
    IncRementValue = easeInAndOut(CurrentTime, el("startValue"), el("travel"), el("milSec"))
    If el("travel") < 0 Then
        If Math.Round(IncRementValue, 4) < el("destination") Then
            CallByName el("obj"), el("property"), VbLet, el("destination")
        Else
            CallByName el("obj"), el("property"), VbLet, IncRementValue
        End If
    Else
        If Math.Round(IncRementValue, 4) > el("destination") Then
            CallByName el("obj"), el("property"), VbLet, el("destination")
        Else
            CallByName el("obj"), el("property"), VbLet, IncRementValue
        End If
    End If
End Function

Private Function easeInAndOut(ByVal t As Double, ByVal b As Double, ByVal c As Double, ByVal d As Double) As Double
    '@AssignedModule aUserform
    '@INCLUDE CLASS aUserform
    d = d / 2
    t = t / d
    If (t < 1) Then
        easeInAndOut = c / 2 * t * t * t + b
    Else
        t = t - 2
        easeInAndOut = c / 2 * (t * t * t + 2) + b
    End If
End Function

Public Sub Resizable(Optional Enable As Boolean = True)
    Dim hWndForm As Long, iStyle As Long
    If val(Application.version) < 9 Then
        hWndForm = FindWindow("ThunderXFrame", oForm.Caption)
    Else
        hWndForm = FindWindow("ThunderDFrame", oForm.Caption)
    End If
    iStyle = GetWindowLong(hWndForm, GWL_STYLE)

    If Enable Then
        iStyle = iStyle Or WS_THICKFRAME
    Else
        iStyle = iStyle And Not WS_THICKFRAME
    End If

    SetWindowLong hWndForm, GWL_STYLE, iStyle
    ShowWindow hWndForm, SW_SHOW
    DrawMenuBar hWndForm
    SetFocus hWndForm

    mdWidth = oForm.Width
    mdHeight = oForm.Height

    Set DockResize = oForm
End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 30-10-2023 17:56    Alex                (aUserform.cls > Resizable2 : new method )

Public Sub Resizable2(Optional Enable As Boolean = True)
'@LastModified 2310301756
'use icon at bottom right corner
    If Enable Then
        On Error Resume Next
        Set lblResizer = oForm.Controls.Add("forms.label.1")
        On Error GoTo 0
        With lblResizer
            .MousePointer = fmMousePointerSizeNWSE
            .AutoSize = True
        End With
        IconDesign lblResizer, "F169"
        lblResizer.Left = oForm.InsideWidth - lblResizer.Width
        lblResizer.Top = oForm.InsideHeight - lblResizer.Height
        Set DockResize = oForm
        Set lblResize = lblResizer
    Else
      Set lblResizer = Nothing
    End If
End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 30-10-2023 17:56    Alex                (aUserform.cls > lblResize_MouseDown : new method)

Private Sub lblResize_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, _
    ByVal X As Single, ByVal Y As Single)
'@LastModified 2310301756
    'The user clicked on the lblResizer
    resizeEnabled = True
    'Capture the mouse position on click
    mouseX = X
    mouseY = Y
End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 30-10-2023 17:56    Alex                (aUserform.cls > lblResize_MouseMove : new method)

Private Sub lblResize_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, _
    ByVal X As Single, ByVal Y As Single)
'@LastModified 2310301756

    'Check if the UserForm is not resized too small
    Dim allowResize As Boolean

    allowResize = True

    If oForm.Width + X - mouseX < minWidth Then allowResize = False
    If oForm.Height + Y - mouseY < minHeight Then allowResize = False

    'Check if the mouse clicked on the lblResizer and above minimum size
    If resizeEnabled = True And allowResize = True Then
        'Resize the UserForm
        oForm.Width = oForm.Width + X - mouseX
        oForm.Height = oForm.Height + Y - mouseY
        'Move the Resizer icon
        lblResizer.Left = oForm.InsideWidth - lblResizer.Width
        lblResizer.Top = oForm.InsideHeight - lblResizer.Height
    End If

End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 30-10-2023 17:56    Alex                (aUserform.cls > lblResize_MouseUp : new method)

Private Sub lblResize_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, _
    ByVal X As Single, ByVal Y As Single)
'@LastModified 2310301756
    'The user un-clicked on the lblResizer
    resizeEnabled = False

End Sub


'* Modified   : Date and Time       Author              Description
'* Updated    : 30-10-2023 17:55    Alex                (aUserform.cls > IconDesign : init )

Public Sub IconDesign(ctrl As control, IconCode As String)
'@LastModified 2310301755
    '@AssignedModule aUserform
    With ctrl
        .Font.Name = "Segoe MDL2 Assets"
        .Caption = ChrW("&H" & IconCode)
        .Font.Size = 12
        .ForeColor = RGB(191, 191, 191)
        .TextAlign = fmTextAlignLeft
        .BorderStyle = fmBorderStyleNone
        .BackStyle = fmBackStyleTransparent
    End With
End Sub

Public Sub DockResize_Layout()
    '@AssignedModule aUserform
    '@INCLUDE CLASS aUserform
    DockControls
End Sub

Public Sub DockControls()

    '* @TODO Created: 30-10-2023 08:08 Author: Anastasiou Alex
    '* @TODO pass arguments instead of ctrl.tag
    'eg
    'Public TrackHeight  As New Collection
    'Public TrackWidth   As New Collection
    'Public TrackTop     As New Collection
    'Public TrackLeft    As New Collection
    
    'from STEPHEN BULLEN's USERFORM RESIZER CLASS
    '
    ' _______IN USERFORM_________________
    '
    ' Private Sub UserForm_Resize()
    '     auserform.init(me).DockControls
    ' End Sub
    '
    ' _______Instructions_______
    '
    ' To specify which control(s) to resize (and how), you set the control's .Tag property at design time to
    ' indicate that the control's top, left, width and height should be adjusted as the form's size changes.
    '
    ' Use the letters t, l, w and h in any order (or not at all) to state that the property should change as the form
    ' is resized.  Follow the property by a decimal to indicate that the control should change by a percentage of the
    ' form's change.
    '
    ' For example:
    '   hw           Sets the control's height and width to change with the form (e.g. if there's a single list box on the form)
    '   tl           Sets the contol's top and left to change in line with the form (e.g. to keep it in the bottom-right corner)
    '   w0.5         Sets the control's width to change by 0.5 that of the form's width change
    '   w0.5l0.5     Sets the control's width and position to change by 0.5 that of the form's width change
    '@AssignedModule aUserform
    '@INCLUDE CLASS aUserform

    Dim dWidthAdj As Double, dHeightAdj As Double, sTag As String
    Dim oCtl        As MSForms.control
    If mdWidth = 0 Then mdWidth = oForm.Width
    If mdHeight = 0 Then mdHeight = oForm.Height
    dWidthAdj = oForm.Width - mdWidth
    dHeightAdj = oForm.Height - mdHeight
    For Each oCtl In oForm.Controls
        '        If TypeName(oCtl) = "ListView" Then Stop
        With oCtl
            sTag = UCase(.Tag)
            If InStr(1, sTag, "L", vbBinaryCompare) Then
                If .Left + dWidthAdj <= 0 Then oForm.Width = mdWidth
            End If
            If InStr(1, sTag, "W", vbBinaryCompare) Then
                If .Width + dWidthAdj <= 0 Then oForm.Width = mdWidth
            End If
            If InStr(1, sTag, "T", vbBinaryCompare) Then
                If .Top + dHeightAdj <= 0 Then oForm.Height = mdHeight
            End If
            If InStr(1, sTag, "H", vbBinaryCompare) Then
                If .Height + dHeightAdj <= 0 Then oForm.Height = mdHeight
            End If
        End With
    Next
    dWidthAdj = oForm.Width - mdWidth
    dHeightAdj = oForm.Height - mdHeight
    For Each oCtl In oForm.Controls
        With oCtl
            sTag = UCase(.Tag)
            If InStr(1, sTag, "L", vbBinaryCompare) Then .Left = .Left + dWidthAdj * ResizeFactor(sTag, "L")
            If InStr(1, sTag, "T", vbBinaryCompare) Then .Top = .Top + dHeightAdj * ResizeFactor(sTag, "T")
            If InStr(1, sTag, "W", vbBinaryCompare) Then .Width = .Width + dWidthAdj * ResizeFactor(sTag, "W")
            If InStr(1, sTag, "H", vbBinaryCompare) Then .Height = .Height + dHeightAdj * ResizeFactor(sTag, "H")

        End With
    Next
    mdWidth = oForm.Width
    mdHeight = oForm.Height
End Sub

Private Function ResizeFactor(sTag As String, sChange As String)
    '@AssignedModule aUserform
    '@INCLUDE CLASS aUserform
    Dim i As Integer, d As Double
    i = InStr(1, sTag, sChange, vbBinaryCompare)
    If i > 0 Then
        d = val(Mid$(sTag, i + 1))
        If d = 0 Then d = 1
    End If
    ResizeFactor = d
End Function

Public Function Init(Form As Object) As aUserform
    '@AssignedModule aUserform
    '@INCLUDE CLASS aUserform
    Set oForm = Form
    Set Init = Me
End Function

Private Sub Class_Initialize()
    'do something
    '@AssignedModule aUserform
    '@INCLUDE CLASS aUserform
End Sub

'Function GetUserformHwnd(Form As Object)
'    GetUserformHwnd = FindWindow(vbNullString, Form.Caption)
'End Function

Public Sub TRANSPARENT(Optional color As Variant)
    '@INCLUDE MakeFormBorderless
    '@AssignedModule aUserform
    '@INCLUDE CLASS aUserform
    '@INCLUDE DECLARATION GWL_EXSTYLE
    '@INCLUDE DECLARATION LWA_COLORKEY
    '@INCLUDE DECLARATION WS_EX_LAYERED
    '@INCLUDE DECLARATION FindWindow
    '@INCLUDE DECLARATION GetWindowLong
    '@INCLUDE DECLARATION SetLayeredWindowAttributes
    '@INCLUDE DECLARATION SetWindowLong
    Dim formhandle  As Long
    Dim bytOpacity  As Byte
    formhandle = CLng(FindWindow(vbNullString, oForm.Caption))
    If IsMissing(color) Then color = vbWhite
    bytOpacity = 100
    SetWindowLong formhandle, GWL_EXSTYLE, GetWindowLong(formhandle, GWL_EXSTYLE) Or WS_EX_LAYERED
    oForm.BackColor = color
    SetLayeredWindowAttributes formhandle, color, bytOpacity, LWA_COLORKEY
End Sub

Public Sub Borderless()
    '@AssignedModule aUserform
    '@INCLUDE CLASS aUserform
    '@INCLUDE DECLARATION GWL_EXSTYLE
    '@INCLUDE DECLARATION GWL_STYLE
    '@INCLUDE DECLARATION WS_CAPTION
    '@INCLUDE DECLARATION WS_EX_DLGMODALFRAME
    '@INCLUDE DECLARATION DrawMenuBar
    '@INCLUDE DECLARATION FindWindow
    '@INCLUDE DECLARATION GetWindowLong
    '@INCLUDE DECLARATION SetWindowLong
    Dim lngWindow   As Long
    Dim lFrmHdl     As Long
    lFrmHdl = CLng(FindWindow(vbNullString, oForm.Caption))
    lngWindow = GetWindowLong(lFrmHdl, GWL_STYLE)
    lngWindow = lngWindow And (Not WS_CAPTION)
    SetWindowLong lFrmHdl, GWL_STYLE, lngWindow
    lngWindow = GetWindowLong(lFrmHdl, GWL_EXSTYLE)
    lngWindow = lngWindow And Not WS_EX_DLGMODALFRAME
    SetWindowLong lFrmHdl, GWL_EXSTYLE, lngWindow
    DrawMenuBar lFrmHdl
End Sub

Public Sub OnTop()
    '@AssignedModule aUserform
    '@INCLUDE CLASS aUserform
    '@INCLUDE DECLARATION HWND_TOPMOST
    '@INCLUDE DECLARATION SWP_NOMOVE
    '@INCLUDE DECLARATION SWP_NOSIZE
    '@INCLUDE DECLARATION FindWindow
    '@INCLUDE DECLARATION SetWindowPos
    Const C_VBA6_USERFORM_CLASSNAME = "ThunderDFrame"
    Dim ret         As Long
    Dim formHWnd    As Long
    formHWnd = CLng(FindWindow(C_VBA6_USERFORM_CLASSNAME, oForm.Caption))
    If formHWnd = 0 Then
        Debug.Print Err.LastDllError
    End If
    ret = SetWindowPos(formHWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE Or SWP_NOSIZE)
    If ret = 0 Then
        Debug.Print Err.LastDllError
    End If
End Sub

Sub ParentIsVBE()
    '@INCLUDE DisplayErrorText
    '@AssignedModule aUserform
    '@INCLUDE CLASS aUserform
    '@INCLUDE DECLARATION USERFORM_WINDOW_CLASS
    '@INCLUDE DECLARATION FindWindow
    '@INCLUDE DECLARATION SetForegroundWindow
    '@INCLUDE DECLARATION SetParent
    Dim GivenFormCaption As String
    GivenFormCaption = oForm.Caption
#If VBA7 Then
    Dim VBEWindowPointer As LongPtr
    Dim UserFormWindowPointer As LongPtr
    Dim ReturnOfSetParentAPI As LongPtr
#Else
    Dim VBEWindowPointer As Long
    Dim UserFormWindowPointer As Long
    Dim ReturnOfSetParentAPI As Long
#End If
    Dim ErrorNumber As Long
    VBEWindowPointer = Application.VBE.MainWindow.hwnd
    UserFormWindowPointer = FindWindow(lpClassName:=USERFORM_WINDOW_CLASS, lpWindowName:=GivenFormCaption)
    Const ERROR_NUMBER_FOR_SETPARENT_API = 0
    ReturnOfSetParentAPI = SetParent(hWndChild:=UserFormWindowPointer, hWndNewParent:=VBEWindowPointer)
    If ReturnOfSetParentAPI = ERROR_NUMBER_FOR_SETPARENT_API Then
        ErrorNumber = Err.LastDllError
        DisplayErrorText "Error With SetParent", ErrorNumber
    Else
        '        Debug.Print GivenFormCaption & " is child of VBE Window."
    End If
    SetForegroundWindow UserFormWindowPointer
    Application.VBE.MainWindow.SetFocus
End Sub

Private Sub DisplayErrorText(Context As String, ErrNum As Long)
    Rem  Displays a standard error message box. For this
    Rem  procedure, ErrNum should be the number returned
    Rem  by the GetLastError API function or the value
    Rem  of Err.LastDllError. It is NOT the number
    Rem  returned by Err.Number.
    '@INCLUDE GetSystemErrorMessageText
    '@AssignedModule aUserform
    '@INCLUDE CLASS aUserform
    Dim ErrText     As String
    ErrText = GetSystemErrorMessageText(ErrNum)
    Debug.Print Context & vbCrLf & _
            "Error Number: " & CStr(ErrNum) & vbCrLf & _
            "Error Text:   " & ErrText, vbOKOnly
End Sub

Private Function GetSystemErrorMessageText(ErrorNumber As Long) As String
    Rem  This function gets the system error message text that corresponds to the error code returned by the
    Rem  GetLastError API function or the Err.LastDllError property. It may be used ONLY for these error codes.
    Rem  These are NOT the error numbers returned by Err.Number (for these errors, use Err.Description to get the description of the message).
    Rem  The error number MUST be the value returned by GetLastError or Err.LastDLLError.
    Rem
    Rem  In general, you should use Err.LastDllError rather than GetLastError because under some circumstances the value of
    Rem  GetLastError will be reset to 0 before the value is returned to VB. Err.LastDllError will always reliably return
    Rem  the last error number raised in a DLL.
    '@AssignedModule aUserform
    '@INCLUDE CLASS aUserform
    '@INCLUDE DECLARATION FORMAT_MESSAGE_FROM_SYSTEM
    '@INCLUDE DECLARATION FORMAT_MESSAGE_IGNORE_INSERTS
    '@INCLUDE DECLARATION FORMAT_MESSAGE_TEXT_LEN
    '@INCLUDE DECLARATION FormatMessage
    Dim ErrorText   As String
    Dim ErrorTextLength As Long
    Dim FormatMessageResult As Long
    Dim LanguageID  As Long
    LanguageID = 0&
    ErrorText = String$(FORMAT_MESSAGE_TEXT_LEN, " ")
    ErrorTextLength = Len(ErrorText)
    FormatMessageResult = 0&
#If VBA7 Then
    Dim FormatMessageAPILastArgument As LongPtr
    FormatMessageAPILastArgument = 0
#Else
    Dim FormatMessageAPILastArgument As Long
    FormatMessageAPILastArgument = 0
#End If
    FormatMessageResult = FormatMessage( _
            dwFlags:=FORMAT_MESSAGE_FROM_SYSTEM Or FORMAT_MESSAGE_IGNORE_INSERTS, _
            lpSource:=0&, _
            dwMessageId:=ErrorNumber, _
            dwLanguageId:=0&, _
            lpBuffer:=ErrorText, _
            nSize:=ErrorTextLength, _
            Arguments:=FormatMessageAPILastArgument)
    If FormatMessageResult > 0 Then
        ErrorText = TrimToNull(ErrorText)
        GetSystemErrorMessageText = ErrorText
    Else
        GetSystemErrorMessageText = "NO ERROR DESCRIPTION AVAILABLE"
    End If
End Function

Private Function TrimToNull(TEXT As String) As String
    Rem  Returns all the text in Text to the left of the vbNullChar
    '@AssignedModule aUserform
    '@INCLUDE CLASS aUserform
    Dim NullCharIndex As Integer
    NullCharIndex = InStr(1, TEXT, vbNullChar, vbTextCompare)
    If NullCharIndex > 0 Then
        TrimToNull = Left(TEXT, NullCharIndex - 1)
    Else
        TrimToNull = TEXT
    End If
End Function
'
'Public Sub MinimizeButton() 'replaced by ShowMinimizedButton
'    '@AssignedModule aUserform
'    '@INCLUDE CLASS aUserform
'    '@INCLUDE DECLARATION FindWindowA
'    '@INCLUDE DECLARATION GetWindowLongA
'    '@INCLUDE DECLARATION SetWindowLongA
'    Dim Cap         As String: Cap = oForm.Caption
'    Dim hwnd        As Long: hwnd = FindWindowA(vbNullString, Cap)
'    Dim exLong      As Long: exLong = GetWindowLongA(hwnd, -16)
'
'    If (exLong And &H20000) = 0 Then SetWindowLongA hwnd, -16, exLong Or &H20000
'End Sub

Public Sub SaveOptions( _
        Optional includeCheckbox As Boolean = True, _
        Optional includeOptionButton As Boolean = True, _
        Optional includeTextBox As Boolean = True, _
        Optional includeListbox As Boolean = True, _
        Optional includeToggleButton As Boolean = True, _
        Optional includeCombobox As Boolean = True, _
        Optional includeMultipage As Boolean = True)
    '@AssignedModule aUserform
    '@INCLUDE PROCEDURE FoldersCreate
    '@INCLUDE PROCEDURE IniWrite
    '@INCLUDE CLASS aCollection
    '@INCLUDE CLASS aListBox
    '@INCLUDE CLASS aUserform

    Dim configFolder As String: configFolder = ThisWorkbook.path & "\Lib\config\"
    FoldersCreate configFolder
    Dim iniFile     As String: iniFile = configFolder & "UserformSettings.ini"
    Dim Key, Value
    Dim c           As MSForms.control
    For Each c In oForm.Controls
        If TypeName(c) Like "CheckBox" Then
            If Not includeCheckbox Then GoTo SKIP
        ElseIf TypeName(c) Like "OptionButton" Then
            If Not includeOptionButton Then GoTo SKIP
        ElseIf TypeName(c) Like "TextBox" Then
            If Not includeTextBox Then GoTo SKIP
        ElseIf TypeName(c) = "ListBox" Then
            If Not includeListbox Then GoTo SKIP
        ElseIf TypeName(c) Like "ToggleButton" Then
            If Not includeToggleButton Then GoTo SKIP
        ElseIf TypeName(c) Like "ComboBox" Then
            If Not includeCombobox Then GoTo SKIP
        ElseIf TypeName(c) = "MultiPage" Then
            If Not includeMultipage Then GoTo SKIP
        Else
            GoTo SKIP
        End If
        Key = c.Name
        Dim coll    As New Collection
        Select Case TypeName(c)
            Case "CheckBox", "OptionButton", "ToggleButton", "ComboBox", "MultiPage"
                IniWrite iniFile, oForm.Name, Key, c.Value
            Case "TextBox"
                IniWrite iniFile, oForm.Name, Key, VBA.Replace(c.Value, vbNewLine, "||")
            Case "ListBox"
                Set coll = aListBox.Init(c).selectedIndexes
                If coll.Count > 0 Then
                    IniWrite iniFile, oForm.Name, Key, aCollection.Init(coll).ToString(",")
                Else
                    IniWrite iniFile, oForm.Name, Key, -1
                End If
        End Select
SKIP:
    Next

End Sub

Public Sub LoadOptions(ParamArray ExcludeThese() As Variant)
    'ExcludeThese:="ListBox1","TextBox1"     '<--control names
    '@AssignedModule aUserform
    '@INCLUDE PROCEDURE ArrayAllocated
    '@INCLUDE PROCEDURE FileExists
    '@INCLUDE PROCEDURE FoldersCreate
    '@INCLUDE PROCEDURE TxtOverwrite
    '@INCLUDE PROCEDURE ArrayContains
    '@INCLUDE PROCEDURE CreateOrSetSheet
    '@INCLUDE PROCEDURE IniSectionKeys
    '@INCLUDE PROCEDURE IniReadKey
    '@INCLUDE CLASS aListBox
    '@INCLUDE CLASS aUserform
    Dim configFolder As String: configFolder = ThisWorkbook.path & "\Lib\config\"
    FoldersCreate configFolder
    Dim iniFile     As String: iniFile = configFolder & "UserformSettings.ini"
    If Not FileExists(iniFile) Then TxtOverwrite iniFile, ""
    Dim Key, Value
    Dim c           As MSForms.control
    Dim keyArray: keyArray = IniSectionKeys(iniFile, oForm.Name)
    If Not ArrayAllocated(keyArray) Then Exit Sub
    For Each Key In keyArray
        On Error Resume Next
        Set c = oForm.Controls(Key)
        Value = IniReadKey(iniFile, oForm.Name, Key)
        If Not TypeName(c) = "Nothing " Then
            If Not ArrayContains(Key, ExcludeThese) Then
                Select Case TypeName(c)
                    Case "CheckBox", "OptionButton", "ToggleButton", "ComboBox", "MultiPage"
                        c.Value = Value
                    Case "TextBox"
                        c.Value = VBA.Replace(Value, "||", vbNewLine)
                    Case "ListBox"
                        If InStr(1, Value, ",") > 0 Then
                            aListBox.Init(c).SelectItems Split(Value, ","), True
                        Else
                            c.Selected(CInt(Value)) = True
                        End If
                End Select
            End If
        End If
    Next

    '=== OBSOLETE
    '
    '    Dim ws As Worksheet
    '    Set ws = CreateOrSetSheet(oForm.Name & "_Settings", ThisWorkbook)
    '    If ws.Range("A1") = "" Then Exit Sub
    '    Dim cell As Range
    '    Set cell = ws.Cells(1, 1)
    '    Dim c As MSForms.control
    '    Dim v
    '    On Error Resume Next
    '    Do While cell <> ""
    '        Set c = oForm.Controls(cell.TEXT)
    '        If Not TypeName(c) = "Nothing " Then
    '            If Not ArrayContains(cell, ExcludeThese) Then
    '                Select Case TypeName(c)
    '                Case "TextBox", "CheckBox", "OptionButton", "ToggleButton", "ComboBox"
    '                    c.Value = cell.OFFSET(0, 1)
    '                Case "ListBox"
    '                    If InStr(1, cell.OFFSET(0, 1), ",") > 0 Then
    '                        aListBox.Init(c).SelectItems Split(cell.OFFSET(0, 1), ","), True
    '                    Else
    '                        c.Selected(CInt(cell.OFFSET(0, 1))) = True
    '                    End If
    '                End Select
    '            End If
    '        End If
    '        Set cell = cell.OFFSET(1, 0)
    '    Loop
End Sub

Public Sub SavePosition()
    '@AssignedModule aUserform
    '@INCLUDE PROCEDURE FoldersCreate
    '@INCLUDE PROCEDURE IniWrite
    '@INCLUDE CLASS aUserform
    Dim configFolder As String: configFolder = ThisWorkbook.path & "\Lib\config\"
    FoldersCreate configFolder
    Dim iniFile     As String: iniFile = configFolder & "UserformSettings.ini"
    IniWrite iniFile, oForm.Name, "StartupTop", oForm.Top
    IniWrite iniFile, oForm.Name, "StartupLeft", oForm.Left

    '=== OBSOLETE
    '    SaveSetting "My Settings Folder", oForm.Name, "Left Position", oForm.Left
    '    SaveSetting "My Settings Folder", oForm.Name, "Top Position", oForm.Top
End Sub

Public Sub LoadPosition()
    '@AssignedModule aUserform
    '@INCLUDE PROCEDURE FileExists
    '@INCLUDE PROCEDURE FoldersCreate
    '@INCLUDE PROCEDURE TxtOverwrite
    '@INCLUDE PROCEDURE IniReadKey
    '@INCLUDE CLASS aUserform
    Dim configFolder As String: configFolder = ThisWorkbook.path & "\Lib\config\"
    FoldersCreate configFolder
    Dim iniFile     As String: iniFile = configFolder & "UserformSettings.ini"
    If Not FileExists(iniFile) Then TxtOverwrite iniFile, ""
    Dim myLeft, myTop
    myLeft = IniReadKey(iniFile, oForm.Name, "StartupLeft")
    myTop = IniReadKey(iniFile, oForm.Name, "StartupTop")
    If myLeft = "" Or myTop = "" Then
        oForm.startupposition = 1
    Else
        oForm.startupposition = 0
        oForm.Top = myTop
        oForm.Left = myLeft
    End If

    'Setting         Value   Description
    'Manual          0       No initial setting specified.
    'CenterOwner     1       Center on the item to which the UserForm belongs.
    'CenterScreen    2       Center on the whole screen.
    'WindowsDefault  3       Position in upper-left corner of screen.

    '=== OBSOLETE
    '    If GetSetting("My Settings Folder", oForm.Name, "Left Position") = "" _
         '        And GetSetting("My Settings Folder", oForm.Name, "Top Position") = "" Then
    '        oForm.startupposition = 1
    '    Else
    '        oForm.Left = GetSetting("My Settings Folder", oForm.Name, "Left Position")
    '        oForm.Top = GetSetting("My Settings Folder", oForm.Name, "Top Position")
    '    End If
End Sub

Public Sub ResizeToFitControls(Optional marginRight = 0, Optional marginBottom = 0)
    '@AssignedModule aUserform
    '@INCLUDE CLASS aUserform
    oForm.Width = 0
    oForm.Height = 0
    Dim ctr         As MSForms.control
    Dim myWidth: myWidth = 0    'oForm.InsideWidth
    Dim myHeight: myHeight = 0    'oForm.InsideHeight
    For Each ctr In oForm.Controls
        If ctr.Parent.Name = oForm.Name Then
            If ctr.Visible = True Then
                If ctr.Left + ctr.Width > myWidth Then myWidth = ctr.Left + ctr.Width
                If ctr.Top + ctr.Height > myHeight Then myHeight = ctr.Top + ctr.Height
            End If
        End If
    Next
    oForm.Width = myWidth + (oForm.Width - oForm.InsideWidth) + marginRight
    oForm.Height = myHeight + (oForm.Height - oForm.InsideHeight) + marginBottom
End Sub


Public Sub MouseOnControl(ctrl As Object)
    '@INCLUDE PointsPerPixelX
    '@INCLUDE PointsPerPixelY
    '@AssignedModule aUserform
    '@INCLUDE CLASS aUserform
    '@INCLUDE DECLARATION ClientToScreen
    '@INCLUDE DECLARATION FindWindow
    '@INCLUDE DECLARATION SetCursorPos
    '@INCLUDE DECLARATION Ctrl
    '@INCLUDE DECLARATION tCursor
    Dim p           As tCursor
    Dim lngHwnd     As Long
    lngHwnd = CLng(FindWindow(vbNullString, oForm.Caption))
    p.Left = (ctrl.Left + (ctrl.Width \ 2)) / PointsPerPixelX
    p.Top = (ctrl.Top + (ctrl.Height \ 2)) / PointsPerPixelY
    ClientToScreen lngHwnd, p
    SetCursorPos p.Left, p.Top
End Sub

Private Function PointsPerPixelX() As Double
    '@AssignedModule aUserform
    '@INCLUDE CLASS aUserform
    '@INCLUDE DECLARATION LOGPIXELSX
    '@INCLUDE DECLARATION GetDC
    '@INCLUDE DECLARATION GetDeviceCaps
    '@INCLUDE DECLARATION ReleaseDC
    Dim hdc         As Long
    hdc = GetDC(0)
    PointsPerPixelX = 72 / GetDeviceCaps(hdc, LOGPIXELSX)
    ReleaseDC 0, hdc
End Function

Private Function PointsPerPixelY() As Double
    '@AssignedModule aUserform
    '@INCLUDE CLASS aUserform
    '@INCLUDE DECLARATION LOGPIXELSY
    '@INCLUDE DECLARATION GetDC
    '@INCLUDE DECLARATION GetDeviceCaps
    '@INCLUDE DECLARATION ReleaseDC
    Dim hdc         As Long
    hdc = GetDC(0)
    PointsPerPixelY = 72 / GetDeviceCaps(hdc, LOGPIXELSY)
    ReleaseDC 0, hdc
End Function

Private Function WhereIsTheMouseAt() As tCursor
    '@AssignedModule aUserform
    '@INCLUDE CLASS aUserform
    '@INCLUDE DECLARATION GetCursorPos
    '@INCLUDE DECLARATION tCursor
    Dim mPos        As tCursor
    GetCursorPos mPos
    WhereIsTheMouseAt = mPos
End Function

Private Function convertMouseToForm() As tCursor
    '@AssignedModule aUserform
    '@INCLUDE CLASS aUserform
    '@INCLUDE DECLARATION tCursor
    Dim mPos        As tCursor
    mPos = WhereIsTheMouseAt
    mPos.Left = PointsPerPixelY * mPos.Left
    mPos.Top = PointsPerPixelX * mPos.Top
    convertMouseToForm = mPos
End Function

Public Sub ShowAtCursor()
    '@AssignedModule aUserform
    '@INCLUDE CLASS aUserform
    oForm.Left = convertMouseToForm.Left
    oForm.Top = convertMouseToForm.Top
End Sub

'README	Document

Option Explicit

'aTreeView	Class


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Class      : aTreeView
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 04-05-2023 12:19    Alex
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Private TV          As TreeView

Private Enum tvImages
    tvProject = 1
    tvSheet = 2
    tvForm = 3
    tvModule = 4
    tvClass = 5
    tvMacro = 6
    tvText = 7
End Enum
Const iTvProject = 1

Public Function Init(TargetTreeview) As aTreeView
    '@AssignedModule aTreeView
    '@INCLUDE CLASS aTreeView
    Set TV = TargetTreeview
    Set Init = Me
End Function

'Sub TVTestVarious()
'    zTest.Show
'    Dim nod As Node
'    Dim tv As TreeView
'    Set tv = zTest.TreeView1
'    TreeviewPopulateFromRange tv, ActiveSheet.Range("A1"), True, False
'    For Each nod In tv.Nodes
'        dp nod.TEXT & vbTab & TreeviewGetLevel(nod)
'    Next
'    dp TreeviewArray(tv)
'    Stop
'    dp TreeviewArrayPaths(tv)
'    Stop
'    TreeviewFilter tv, "*\*\*\*", True
'    dp TreeviewArrayPaths(tv)
'    TreeviewFoldingExpandAll tv
'End Sub

Public Sub RemoveEmpty(ColumnLevel As Long)
    '@AssignedModule aTreeView
    '@INCLUDE PROCEDURE dp
    '@INCLUDE CLASS aTreeView
    Dim i           As Long
    Dim nod         As Node
    For i = TV.Nodes.Count To 1 Step -1
        Set nod = TV.Nodes(i)
        If GetLevel(nod) = ColumnLevel Then
            If nod.Children = 0 Then
                TV.Nodes.Remove nod.index
            End If
        End If
    Next
End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 20-12-2022 07:43    Alex                (TreeviewFilter)

Public Sub FilterTV(txtLike As String, MatchCase As Boolean)
    'example
    'TreeviewFilter tv, "*\*\*\*", True
    'each \ indicates a sublevel
    '@AssignedModule aTreeView
    '@INCLUDE PROCEDURE ArrayFilterLike
    '@INCLUDE CLASS aTreeView

    Dim var
    var = ArrayFilterLike(TreeviewArrayPaths(TV), txtLike, MatchCase)
    clear
    Dim element
    Dim nod         As Node
    On Error Resume Next
    Dim i           As Long
    For Each element In var
        For i = 0 To UBound(Split(element, "\"))
            If i = 0 Then
                Set nod = TV.Nodes.Add(, , , Split(element, "\")(i))
            Else
                Set nod = TV.Nodes.Add(nod, tvwChild, , Split(element, "\")(i))
            End If
        Next
    Next
    On Error GoTo 0
End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 19-12-2022 15:09    Alex                (TVColumnsCount)

Public Function columnCount()
    '@AssignedModule aTreeView
    '@INCLUDE CLASS aTreeView
    Dim Output      As Long
    Dim counter     As Long
    Dim nod         As Node
    For Each nod In TV.Nodes
        counter = GetLevel(nod)
        If counter > Output Then Output = Output + 1
    Next
    columnCount = Output
End Function

Public Function rowCount()
    '@AssignedModule aTreeView
    '@INCLUDE CLASS aTreeView
    rowCount = TV.Nodes.Count
End Function

'* Modified   : Date and Time       Author              Description
'* Updated    : 19-07-2023 10:23    Alex                added base 1 : ReDim output(1 To rowCount, 1 To ColumnCount)

Function ToArray() As Variant
    '@LastModified 2307191023
    'Modified from https://www.excelforum.com/excel-programming-vba-macros/1102518-transfer-all-nodes-from-a-userform-treeview-into-a-treeview-on-a-worksheet-with-vba.html
    '@AssignedModule aTreeView
    '@INCLUDE CLASS aTreeView
    Dim nROOT       As Node
    Dim nX          As Node
    Dim irow        As Integer

    On Error GoTo catch

    If TV.Nodes.Count = 0 Then
        MsgBox "No nodes to export...", vbExclamation, "Nothing to do"
        Stop
    End If

    ' Start at first node
    Set nX = TV.Nodes(1)
    ' Get the first root node
    Set nROOT = nX.Root.FirstSibling
    'Create array placeholder
    Dim Output()
    ReDim Output(1 To rowCount, 1 To columnCount)
    'Drill down and export
    Do
        TreeviewArrayAppend 0, irow, nROOT, Output, True
        Set nROOT = nROOT.Next
    Loop While Not (nROOT Is Nothing)

    ToArray = Output
Finally:
    'Cleanup

    'Exit
    On Error GoTo 0
    Exit Function
catch:
    MsgBox "ERROR: " & Err.Description, vbExclamation, "Error"
    Resume Finally
End Function

Private Sub TreeviewArrayAppend(ByVal lngLevel As Integer, _
        ByRef lngRow As Integer, _
        ByRef N As Node, _
        ByRef TargetArray As Variant, _
        ByVal includeChildren As Boolean)
    '@AssignedModule aTreeView
    '@INCLUDE CLASS aTreeView

    TargetArray(lngRow + 1, lngLevel + 1) = N.TEXT
    lngRow = lngRow + 1
    ' If there are child nodes then call recusively
    lngLevel = lngLevel + 1
    If includeChildren Then
        If N.Children > 0 Then
            Dim nC  As Node
            Set nC = N.child
            Do
                TreeviewArrayAppend lngLevel, lngRow, nC, TargetArray, True
                Set nC = nC.Next
            Loop While Not (nC Is Nothing)
        End If
    End If
End Sub
'--------------------------------------------

Public Function TreeviewArrayPaths() As Variant  '1d
    'Modified from https://www.excelforum.com/excel-programming-vba-macros/1102518-transfer-all-nodes-from-a-userform-treeview-into-a-treeview-on-a-worksheet-with-vba.html
    '@AssignedModule aTreeView
    '@INCLUDE CLASS aTreeView
    Dim nROOT       As Node
    Dim nX          As Node
    Dim irow        As Integer

    On Error GoTo catch

    If TV.Nodes.Count = 0 Then
        MsgBox "No nodes to export...", vbExclamation, "Nothing to do"
        Stop
    End If

    ' Start at first node
    Set nX = TV.Nodes(1)
    ' Get the first root node
    Set nROOT = nX.Root.FirstSibling
    'Create array placeholder
    Dim Output()
    ReDim Output(rowCount)
    'Drill down and export
    Do
        TreeviewArrayAppendPaths 0, irow, nROOT, Output
        Set nROOT = nROOT.Next
    Loop While Not (nROOT Is Nothing)

    TreeviewArrayPaths = Output
Finally:
    'Cleanup

    'Exit
    On Error GoTo 0
    Exit Function
catch:
    MsgBox "ERROR: " & Err.Description, vbExclamation, "Error"
    Resume Finally
End Function

Public Sub TreeviewArrayAppendPaths(ByVal lngLevel As Integer, _
        ByRef lngRow As Integer, _
        ByRef N As Node, _
        ByRef TargetArray As Variant)
    '@AssignedModule aTreeView
    '@INCLUDE CLASS aTreeView

    TargetArray(lngRow) = N.fullPath
    lngRow = lngRow + 1
    ' If there are child nodes then call recusively
    lngLevel = lngLevel + 1
    If N.Children > 0 Then
        Dim nC      As Node
        Set nC = N.child
        Do
            TreeviewArrayAppendPaths lngLevel, lngRow, nC, TargetArray
            Set nC = nC.Next
        Loop While Not (nC Is Nothing)
    End If
End Sub

Public Sub SelectNextNode()
    '@AssignedModule aTreeView
    '@INCLUDE CLASS aTreeView
    If Not TV.SelectedItem.child Is Nothing Then
        TV.SelectedItem.child.Selected = True
    ElseIf Not TV.SelectedItem.Next Is Nothing Then
        TV.SelectedItem.Next.Selected = True
    Else
        If Not TV.SelectedItem.Parent.Next Is Nothing Then
            TV.SelectedItem.Parent.Next.Selected = True
        Else
            TV.SelectedItem.Parent.Parent.Next.Selected = True
        End If
    End If
End Sub

Public Sub SelectPreviousNode()
    '@AssignedModule aTreeView
    '@INCLUDE CLASS aTreeView
    If Not TV.SelectedItem.Previous Is Nothing Then
        If Not TV.SelectedItem.Previous.child Is Nothing Then
            TV.SelectedItem.Previous.child.LastSibling.Selected = True
            Do While Not TV.SelectedItem.child Is Nothing
                TV.SelectedItem.child.LastSibling.Selected = True
            Loop
        Else
            TV.SelectedItem.Previous.Selected = True
        End If
    ElseIf Not TV.SelectedItem.Parent Is Nothing Then
        TV.SelectedItem.Parent.Selected = True
    End If
End Sub

Public Sub SelectNodes(SingleSelect As Boolean, lvl1crit As String, Optional CriteriaByLevel As Variant)
    '@AssignedModule aTreeView
    '@INCLUDE CLASS aTreeView
    Dim nd          As Node
    For Each nd In TV.Nodes
        If nd.TEXT = lvl1crit Then
            nd.Selected = True
            nd.Expanded = True
            If SingleSelect = True Then Exit For
        End If
    Next
    Dim X           As Long
    X = nd.index + 1
    Dim crit
    Dim i           As Long
    For Each crit In CriteriaByLevel
        For i = X To TV.Nodes.Count
            If TV.Nodes.item(i).TEXT = crit Then
                TV.Nodes.item(i).Selected = True
                TV.Nodes.item(i).Expanded = True
                If SingleSelect = True Then Exit For
            End If
        Next
        X = i + 1
    Next
End Sub

Public Sub ApplyStandardStyle()
    '@AssignedModule aTreeView
    '@INCLUDE CLASS aTreeView
    With TV
        .Sorted = False
        .Appearance = ccFlat
        .LineStyle = tvwRootLines
        .Style = tvwTreelinesPlusMinusPictureText
        .Font.Size = 10
        .indentation = 2
    End With
End Sub

Sub ExpandAll()
    '@AssignedModule aTreeView
    '@INCLUDE CLASS aTreeView
    Dim i           As Long
    For i = 1 To TV.Nodes.Count
        TV.Nodes(i).Expanded = True
    Next
End Sub

Sub CollapseAll()
    '@AssignedModule aTreeView
    '@INCLUDE CLASS aTreeView

    Dim i           As Long
    For i = 1 To TV.Nodes.Count
        TV.Nodes(i).Expanded = False
    Next
End Sub

Sub clear()
    '@AssignedModule aTreeView
    '@INCLUDE CLASS aTreeView
    Dim i           As Long
    For i = TV.Nodes.Count To 1 Step -1
        TV.Nodes.Remove i
    Next
End Sub
Public Sub ChildrenCheck(Parent As MSComctlLib.Node, check As Boolean)
    ' In userform:
    ' Sub treeview1_NodeCheck(ByVal node As MSComctlLib.Node)
    '     TreeviewNodeCheck node, node.Checked
    ' End Sub
    '@AssignedModule aTreeView
    '@INCLUDE CLASS aTreeView

    Dim child       As MSComctlLib.Node
    Parent.Checked = check

    ' Recursively check child nodes
    Set child = Parent.child
    While Not child Is Nothing
        ChildrenCheck child, check
        Set child = child.Next
    Wend
End Sub

Public Function GetLevel(ByVal theNode As Node) As Integer
    '@AssignedModule aTreeView
    '@INCLUDE CLASS aTreeView
    GetLevel = 1
    Do Until theNode.Root = theNode.FirstSibling
        GetLevel = GetLevel + 1
        Set theNode = theNode.Parent
    Loop
End Function

Sub LoadRange( _
        FirstCell As Range, _
        ClearPreviousNodes As Boolean, _
        Expanded As Boolean)
    Rem example use
    Rem    LoadRange me.Treeview1,thisworkbook.sheets("TreeviewHierarchy").range("A1"),true,false
    Rem example of sheet structure
    Rem  |1|2|3
    Rem 1|A| |
    Rem 2| |1|
    Rem 3| | |1.1
    Rem 4| | |1.2
    Rem 5|B| |
    Rem 6| |2|
    Rem 7| | |2.1
    Rem 8| | |2.2
    '@AssignedModule aTreeView
    '@INCLUDE CLASS aTreeView
    Dim nP          As Node
    Dim c           As Excel.Range
    On Error Resume Next
    Dim childRange  As Range
    Set childRange = FirstCell.CurrentRegion.offset(0, 1)
    Set childRange = childRange.Resize(, childRange.Columns.Count - 1)
    Set childRange = childRange.SpecialCells(xlCellTypeConstants)
    With TV
        If ClearPreviousNodes = True Then .Nodes.clear
        For Each c In FirstCell.Parent.Columns(FirstCell.Column).SpecialCells(xlCellTypeConstants)
            Set nP = .Nodes.Add(, , c.Address, c.Value)
        Next
        For Each c In childRange
            If c.offset(, -1) = "" Then  'c.Value <> vbNullString And c.Address <> FirstCell.Address And
                Set nP = .Nodes(c.offset(, -1).End(xlUp).Address)
                If nP Is Nothing Then
                    MsgBox "ERROR: Parent node " & c.offset(, -1).End(xlUp).Value & " not found...", vbExclamation, "Error"
                    Exit Sub
                End If
                .Nodes.Add nP, tvwChild, c.Address, c.Value
                If Err.Number <> 0 Then
                    MsgBox "ERROR: The node " & c.Value & " is a duplicate. All node descrptions must be unique", vbExclamation, "Error"
                    Exit Sub
                End If
                nP.Expanded = Expanded
            End If
        Next
        With .Nodes(FirstCell.Address)
            .Selected = True
            .EnsureVisible
        End With
    End With
End Sub

Public Sub LoadTreeArray( _
        arr, _
        ClearPreviousNodes As Boolean, _
        Expanded As Boolean)
    '@AssignedModule aTreeView
    '@INCLUDE PROCEDURE ArrayToRange2D
    '@INCLUDE PROCEDURE CreateOrSetSheet
    '@INCLUDE CLASS aTreeView

    Application.ScreenUpdating = False
    Application.DisplayAlerts = False
    Dim tmpSheet    As Worksheet
    Set tmpSheet = CreateOrSetSheet("TempOps", ThisWorkbook)
    tmpSheet.Cells.clear
    ArrayToRange2D arr, tmpSheet.Cells(1, 1)
    LoadRange tmpSheet.Cells(1, 1), ClearPreviousNodes, Expanded
    tmpSheet.Delete

    Application.ScreenUpdating = True
    Application.DisplayAlerts = True
End Sub

Sub LoadVBProjects()
    '@AssignedModule aTreeView
    '@INCLUDE PROCEDURE ProceduresOfModule
    '@INCLUDE PROCEDURE WorkbookProjectProtected
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aTreeView
    Me.clear
    Dim nP          As Node
    Dim nM          As Node
    Dim nS          As Node
    Dim X, Y, S, p  As Variant
    Dim module      As VBComponent
    On Error Resume Next
    Dim element
    For Each X In Array(Workbooks, AddIns)
        For Each Y In X
            If Not WorkbookProjectProtected(Workbooks(Y.Name)) Then
                If Err.Number = 0 Then
                    Set nP = TV.Nodes.Add(, , , Y.Name)
                    For Each element In Array(vbext_ct_Document, vbext_ct_MSForm, vbext_ct_StdModule, vbext_ct_ClassModule)
                        For Each module In Workbooks(Y.Name).VBProject.VBComponents
                            If module.Type = element Then
                                Set nM = TV.Nodes.Add(nP, tvwChild, , aModule.Init(module).Name)
                                For Each p In ProceduresOfModule(module)
                                    Set nS = TV.Nodes.Add(nM, tvwChild, , CStr(p))
                                Next p
                            End If
                        Next module
                    Next
                End If
            End If
            Err.clear
        Next Y
    Next X
End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 18-08-2023 10:07    Alex                select search item (aTreeView.cls > ActivateProjectElement)

Sub ActivateProjectElement()
    '@AssignedModule aTreeView
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aTreeView
    '@INCLUDE USERFORM uCodeFinder
    Dim TargetWorkbook As Workbook

    Dim module      As VBComponent
    Dim i           As Long
    Select Case GetLevel(TV.SelectedItem)
        Case Is = 1
        Case Is = 2
            With TV.SelectedItem
                Set TargetWorkbook = Workbooks(.Parent.TEXT)
                On Error Resume Next
                Set module = Workbooks(.Parent.TEXT).VBProject.VBComponents(.TEXT)
                On Error GoTo 0
                If module Is Nothing Then Set module = TargetWorkbook.VBProject.VBComponents(Workbooks(.Parent.TEXT).Sheets(.TEXT).codeName)
                aModule.Init(module).Activate
            End With
        Case Is = 3
            With TV.SelectedItem
                Set TargetWorkbook = Workbooks(.Parent.Parent.TEXT)
                On Error Resume Next
                Set module = TargetWorkbook.VBProject.VBComponents(.Parent.TEXT)
                On Error GoTo 0
                If module Is Nothing Then
                    'get worksheet module instead
                    Set module = TargetWorkbook.VBProject.VBComponents(TargetWorkbook.Sheets(.Parent.TEXT).codeName)
                End If
                aModule.Init(module).Activate
                For i = 1 To module.CodeModule.CountOfLines
                    If InStr(1, module.CodeModule.Lines(i, 1), "Sub " & .TEXT) > 0 Or _
                            InStr(1, module.CodeModule.Lines(i, 1), "Function " & .TEXT) > 0 Then
                        module.CodeModule.CodePane.SetSelection i, 1, i, 1
                        Exit Sub
                    End If
                Next
            End With
        Case Is = 4
            With TV.SelectedItem
                Set TargetWorkbook = Workbooks(.Parent.Parent.Parent.TEXT)
                Set module = TargetWorkbook.VBProject.VBComponents(.Parent.Parent.TEXT)
                Dim Procedure As String
                Procedure = .Parent.TEXT
                Dim ap As New aProcedure
                ap.Init TargetWorkbook, module, Procedure
                ap.Activate

                For i = ap.Line_Declaration_First To ap.Line_Last
                    Dim startPos As Long
                    startPos = InStr(1, module.CodeModule.Lines(i, 1), uCodeFinder.TextBox1.Value, vbTextCompare)
                    If startPos > 0 Then
                        Dim endPos As Long: endPos = startPos + Len(uCodeFinder.TextBox1.Value)
                        module.CodeModule.CodePane.SetSelection i, startPos, i, endPos
                        Exit Sub
                    End If
                Next
            End With
    End Select
End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 18-08-2023 12:48    Alex                changed unnecessary condition check to removing childless nodes (aTreeView.cls > FindCodeEverywhere)

Public Sub FindCodeEverywhere(F As String)
    '@LastModified 2308181248
    '@AssignedModule aTreeView
    '@INCLUDE PROCEDURE WorkbookProjectProtected
    '@INCLUDE CLASS aProcedure
    '@INCLUDE CLASS aWorkbook
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aModules
    '@INCLUDE CLASS aTreeView
    Dim nP          As Node
    Dim nM          As Node
    Dim nS          As Node
    Dim nF          As Node
    Dim X, Y, S, p  As Variant
    Dim module      As VBComponent
    Dim am          As aModule
    Dim ap          As aProcedure
    Dim aw          As aWorkbook
    Dim i           As Long
    On Error Resume Next
    For Each X In Array(Workbooks, AddIns)
        For Each Y In X
            If Not WorkbookProjectProtected(Workbooks(Y.Name)) Then
                If Err.Number = 0 Then
                    Set aw = aWorkbook.Init(Workbooks(Y.Name))
                    'Dim ub As Long
                    'ub = UBound(Filter(Split(aw.Code, vbNewLine), F, True, vbTextCompare))
                    'Dim proceed As Boolean: proceed = InStr(1, aw.Code, F, vbTextCompare) > 0 'ub > -1 '
                    'If proceed Then
                    Set nP = TV.Nodes.Add(, , , Y.Name)
                    For Each am In aModules.Init(aw.item).items
                        If am.Contains(F, False, False, True) Then
                            Set nM = TV.Nodes.Add(nP, tvwChild, , am.Name)
                            For Each ap In am.Procedures
                                If UBound(Filter(Split(ap.Code_All, vbNewLine), F, True, vbTextCompare)) > -1 Then
                                    Set nS = TV.Nodes.Add(nM, tvwChild, , CStr(ap.Name))
                                    S = Filter(Split(ap.Code_All, vbNewLine), F, True, vbTextCompare)
                                    For i = 0 To UBound(S)
                                        Set nF = TV.Nodes.Add(nS, tvwChild, , Trim(S(i)))
                                    Next i
                                End If
                            Next ap
                        End If
                    Next am
                    '                    End If
                    If nP.Children = 0 Then TV.Nodes.Remove nP.index
                End If
            End If
            Err.clear
        Next Y
    Next X
End Sub

Sub ImageListLoadProjectIcons(imgList As ImageList)
    '@AssignedModule aTreeView
    '@INCLUDE CLASS aTreeView
    Dim strPath     As String
    strPath = ThisWorkbook.path & "\Lib\img\treeviewicons\"    ' "C:\Users\acer\Dropbox\SOFTWARE\EXCEL\0 Alex\treeviewicons\"
    With imgList.ListImages
        .Add , "Project", LoadPicture(strPath & "Project.jpg")
        .Add , "Sheet", LoadPicture(strPath & "Sheet.jpg")
        .Add , "Form", LoadPicture(strPath & "Form.jpg")
        .Add , "Module", LoadPicture(strPath & "Module.jpg")
        .Add , "Class", LoadPicture(strPath & "Class.jpg")
        .Add , "Macro", LoadPicture(strPath & "Macro.jpg")
        .Add , "Text", LoadPicture(strPath & "Text.jpg")
    End With
    TV.ImageList = imgList
End Sub

Sub TreeviewAssignProjectImages()
    '@AssignedModule aTreeView
    '@INCLUDE PROCEDURE ModuleTypeToString
    '@INCLUDE PROCEDURE ModuleOfWorksheet
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aTreeView
    Dim sModuleName As String
    Dim i           As Long
    Dim module      As VBComponent
    Dim TargetWorkbook As Workbook
    For i = 1 To TV.Nodes.Count
        Select Case GetLevel(TV.Nodes.item(i))
            Case 1
                If InStr(1, TV.Nodes.item(i).TEXT, ".") = 0 Then GoTo SKIP
                TV.Nodes.item(i).Image = 1    'tvImages.tvProject
            Case 2
                Set TargetWorkbook = Workbooks(TV.Nodes.item(i).Parent.TEXT)
                If InStr(1, TargetWorkbook.Name, ".") = 0 Then GoTo SKIP
                sModuleName = TV.Nodes.item(i).TEXT
                Set module = Nothing
                On Error Resume Next
                Set module = TargetWorkbook.VBProject.VBComponents(sModuleName)
                On Error GoTo 0
                If module Is Nothing Then
                    Set module = ModuleOfWorksheet(TargetWorkbook.Worksheets(TV.Nodes.item(i).TEXT))
                End If
                Select Case aModule.Init(module).TypeToString
                    Case "Document"
                        TV.Nodes.item(i).Image = 2    'tvImages.tvSheet
                    Case "UserForm"
                        TV.Nodes.item(i).Image = 3    'tvImages.tvForm
                    Case "Module"
                        TV.Nodes.item(i).Image = 4    'tvImages.tvModule
                    Case "Class"
                        TV.Nodes.item(i).Image = 5    'tvImages.tvClass
                End Select
            Case 3
                TV.Nodes.item(i).Image = 6    'tvImages.tvMacro
            Case 4
                TV.Nodes.item(i).Image = 7    'tvImages.tvText
        End Select
SKIP:
    Next i
End Sub



'uCodeFinder	UserForm

'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Userform   : uCodeFinder
'* Created    : 06-10-2022 10:34
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Dim AT              As aTreeView

Dim CalledFromModule As VBComponent
Dim CalledFromProcedure As String

Private Sub CommandButton2_Click()
    '@AssignedModule uCodeFinder
    '@INCLUDE USERFORM uCodeFinder
    ReturnToCaller
End Sub

Private Sub GetInfo_Click()
    '@AssignedModule uCodeFinder
    '@INCLUDE PROCEDURE PlayTheSound
    '@INCLUDE CLASS aUserform
    '@INCLUDE USERFORM uCodeFinder
    '@INCLUDE USERFORM uAuthor
    With aUserform.Init(Me)
        .Transition .Effect(GetInfo, "Top", GetInfo.Top - 10, 150)

        .Transition .Effect(GetInfo, "Top", GetInfo.Top + 10, 150)
    End With
    uAuthor.Show
End Sub

Private Sub Label2_Click()
    Me.TextBox1.Value = Replace(uCalendar.Datepicker, ".", "-")
End Sub

Private Sub TreeView1_BeforeLabelEdit(Cancel As Integer)
    '@AssignedModule uCodeFinder
    '@INCLUDE USERFORM uCodeFinder
    Cancel = True
End Sub

Private Sub UserForm_Activate()
    '@AssignedModule uCodeFinder
    '@INCLUDE CLASS aUserform
    '@INCLUDE USERFORM uCodeFinder
    With aUserform.Init(Me)
        .Resizable
        .ParentIsVBE
    End With

End Sub

Private Sub UserForm_Initialize()
    '@AssignedModule uCodeFinder
    '@INCLUDE PROCEDURE ActiveProcedure
    '@INCLUDE PROCEDURE ActiveModule
    '@INCLUDE CLASS aTreeView
    '@INCLUDE USERFORM uCodeFinder
    '@INCLUDE DECLARATION AT
    '@INCLUDE DECLARATION CalledFromModule
    '@INCLUDE DECLARATION CalledFromProcedure
    aUserform.Init(Me).LoadPosition
    With TreeView1
        .Sorted = True
        .Appearance = ccFlat
        .LineStyle = tvwRootLines
        .Style = tvwTreelinesPlusMinusPictureText
        .Font.Size = 10
        .indentation = 2
    End With
    Set AT = aTreeView.Init(TreeView1)
    With AT
        .ImageListLoadProjectIcons ImageList1
        '        .CollapseAll
    End With
    Set CalledFromModule = ActiveModule
    CalledFromProcedure = ActiveProcedure
    TextBox1.SetFocus

End Sub

Private Sub ReturnToCaller()
    '@AssignedModule uCodeFinder
    '@INCLUDE CLASS aModule
    '@INCLUDE USERFORM uCodeFinder
    '@INCLUDE DECLARATION CalledFromModule
    '@INCLUDE DECLARATION CalledFromProcedure
    On Error GoTo HELL
    aModule.Init(CalledFromModule).Activate
    Dim i           As Long
    For i = 1 To CalledFromModule.CodeModule.CountOfLines
        If InStr(1, CalledFromModule.CodeModule.Lines(i, 1), "Sub " & CalledFromProcedure) > 0 Or _
                InStr(1, CalledFromModule.CodeModule.Lines(i, 1), "Function " & CalledFromProcedure) > 0 Then
            CalledFromModule.CodeModule.CodePane.SetSelection i, 1, i, 1
            Exit Sub
        End If
    Next
HELL:
End Sub

Private Sub CommandButton1_Click()
    DoSearch
End Sub

Public Sub DoSearch()
    '@LastModified 2308180711
    '@AssignedModule uCodeFinder
    '@INCLUDE CLASS aTreeView
    '@INCLUDE USERFORM uCodeFinder
    '@INCLUDE DECLARATION AT
    Dim tvtop As Long, tvleft As Long

    Me.Hide
    AT.clear
    AT.FindCodeEverywhere TextBox1.TEXT
    AT.ExpandAll
    If TreeView1.Nodes.Count > 0 Then
        TreeView1.Nodes(1).Expanded = True
        AT.TreeviewAssignProjectImages
    End If
    Me.Show
End Sub

Private Sub TextBox1_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    '@AssignedModule uCodeFinder
    '@INCLUDE USERFORM uCodeFinder
    If KeyCode = 13 Then
        DoSearch
    End If
End Sub

Private Sub TreeView1_Click()
    '@LastModified 2308181007
    '@AssignedModule uCodeFinder
    '@INCLUDE CLASS aTreeView
    '@INCLUDE USERFORM uCodeFinder
    '@INCLUDE DECLARATION AT
    If TreeView1.Nodes.Count > 0 Then AT.ActivateProjectElement
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    aUserform.Init(Me).SavePosition
End Sub

'uProjectExplorer	UserForm

'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Userform   : uProjectExplorer
'* Created    : 06-10-2022 10:39
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


Option Explicit


Private Sub GetInfo_Click()
    '@AssignedModule uProjectExplorer
    '@INCLUDE PROCEDURE PlayTheSound
    '@INCLUDE CLASS aUserform
    '@INCLUDE USERFORM uProjectExplorer
    '@INCLUDE USERFORM uAuthor
    With aUserform.Init(Me)
        .Transition .Effect(GetInfo, "Top", GetInfo.Top - 10, 150)

        .Transition .Effect(GetInfo, "Top", GetInfo.Top + 10, 150)
    End With
    uAuthor.Show
End Sub



Private Sub TreeView1_Click()
    '@AssignedModule uProjectExplorer
    '@INCLUDE CLASS aTreeView
    '@INCLUDE USERFORM uProjectExplorer
    aTreeView.Init(TreeView1).ActivateProjectElement
End Sub

Private Sub UserForm_Initialize()
    '@AssignedModule uProjectExplorer
    '@INCLUDE USERFORM uProjectExplorer
    InitializeProjectExplorer
End Sub

Sub InitializeProjectExplorer()
    '@AssignedModule uProjectExplorer
    '@INCLUDE PROCEDURE ActiveModule
    '@INCLUDE PROCEDURE ActiveCodepaneWorkbook
    '@INCLUDE CLASS aUserform
    '@INCLUDE CLASS aTreeView
    '@INCLUDE USERFORM uProjectExplorer
    Application.VBE.MainWindow.Visible = True
    aUserform.Init(Me).ParentIsVBE
    aTreeView.Init(TreeView1).LoadVBProjects
    With TreeView1
        .Sorted = True
        .Appearance = ccFlat
        .LineStyle = tvwRootLines
        .Style = tvwTreelinesPlusMinusPictureText
        .Font.Size = 10
        .indentation = 2
    End With
    aTreeView.Init(TreeView1).ImageListLoadProjectIcons ImageList1
    Dim TargetWorkbook As Workbook
    If Application.VBE.MainWindow.Visible = False Then
        Set TargetWorkbook = ActiveWorkbook
    Else
        Set TargetWorkbook = ActiveCodepaneWorkbook
    End If
    aTreeView.Init(TreeView1).SelectNodes True, TargetWorkbook.Name, Array(ActiveModule.Name)
End Sub


'uReferences	UserForm




'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Userform   : uReferences
'* Created    : 06-10-2022 10:40
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Private Sub cADD_Click()
    '@AssignedModule uReferences
    '@INCLUDE USERFORM uReferences
    If ListBox1.ListIndex = -1 Then
        MsgBox "Select target workbook first"
        Exit Sub
    End If
    Dim TargetWorkbook As Workbook
    Set TargetWorkbook = Workbooks(ListBox1.list(ListBox1.ListIndex))
    On Error Resume Next
    TargetWorkbook.VBProject.REFERENCES.AddFromGuid LReferences.list(LReferences.ListIndex, 1), 0, 0

    Call PopulateLRefActive

End Sub

Private Sub cClearFilter_Click()
    '    LReferences.Clear
    '    Call PopulateLReferences
    '@AssignedModule uReferences
    '@INCLUDE USERFORM uReferences
    tFilterReferences.TEXT = ""
End Sub

Private Sub cRemove_Click()
    '@AssignedModule uReferences
    '@INCLUDE CLASS aWorkbook
    '@INCLUDE USERFORM uReferences
    If ListBox1.ListIndex = -1 Then
        MsgBox "Select target workbook first"
        Exit Sub
    End If
    Dim TargetWorkbook As Workbook
    Set TargetWorkbook = Workbooks(ListBox1.list(ListBox1.ListIndex))
    On Error Resume Next
    aWorkbook.Init(TargetWorkbook).RemoveReferenceByGUID LRefActive.list(LReferences.ListIndex, 2)
    PopulateLRefActive
End Sub

Private Sub GetInfo_Click()
    '@AssignedModule uReferences
    '@INCLUDE PROCEDURE PlayTheSound
    '@INCLUDE CLASS aUserform
    '@INCLUDE USERFORM uReferences
    '@INCLUDE USERFORM uAuthor
    With aUserform.Init(Me)
        .Transition .Effect(GetInfo, "Top", GetInfo.Top - 10, 150)

        .Transition .Effect(GetInfo, "Top", GetInfo.Top + 10, 150)
    End With
    uAuthor.Show
End Sub


Private Sub listbox1_change()
    '@AssignedModule uReferences
    '@INCLUDE USERFORM uReferences
    Call PopulateLRefActive
End Sub

Private Sub tFilterReferences_Change()
    'Reload list so if you type and delete you'll get the items back
    '@AssignedModule uReferences
    '@INCLUDE USERFORM uReferences
    LReferences.clear
    Call PopulateLReferences

    Dim i           As Long
    Dim N           As Long
    Dim str         As String
    Dim sTemp       As String

    'Equals is always case sensitive
    'Remove LCase if you want it to be case sensitive
    str = LCase(tFilterReferences.TEXT)

    N = LReferences.ListCount

    'Work backwards when deleting items
    For i = N - 1 To 0 Step -1
        'Equals is always case sensitive
        'Remove LCase if you want it to be case sensitive
        sTemp = LCase(LReferences.list(i, 0))

        If InStr(sTemp, str) = 0 Then
            LReferences.RemoveItem (i)
            'Exit Sub   'Uncomment to Exit if value found
        End If
    Next i
End Sub

Private Sub UserForm_Activate()
    'MakeUserFormChildOfVBEditor Me.Caption
    '@AssignedModule uReferences
    '@INCLUDE USERFORM uReferences
End Sub

Private Sub UserForm_Initialize()
    '@AssignedModule uReferences
    '@INCLUDE PROCEDURE WorkbookProjectProtected
    '@INCLUDE CLASS aListBox
    '@INCLUDE USERFORM uReferences
    aListBox.Init(ListBox1).LoadVBProjects
    Call PopulateLReferences

    '    Dim x, y As Variant
    '    On Error Resume Next
    '    For Each x In Array(Workbooks, AddIns)
    '        For Each y In x
    '            If Not WorkbookProjectProtected(Workbooks(y.Name)) Then
    '                If Err.Number = 0 Then
    '                    ListBox1.AddItem y.Name
    '                End If
    '            End If
    '            Err.Clear
    '        Next
    '    Next
End Sub

Function PopulateLRefActive()
    '@INCLUDE SortListboxOnColumn
    '@INCLUDE DP
    '@AssignedModule uReferences
    '@INCLUDE CLASS aListBox
    '@INCLUDE USERFORM uReferences
    '@INCLUDE DECLARATION GUID
    Dim FromWorkbook As Workbook
    Set FromWorkbook = Workbooks(ListBox1.list(ListBox1.ListIndex))
    Dim i           As Long
    i = 0
    LRefActive.clear
    Dim myRef       As Reference
    For Each myRef In FromWorkbook.VBProject.REFERENCES
        LRefActive.AddItem
        LRefActive.list(i, 0) = myRef.IsBroken
        LRefActive.list(i, 1) = IIf(myRef.Description <> "", myRef.Description, myRef.Name)
        LRefActive.list(i, 2) = myRef.GUID
        i = i + 1
    Next myRef
    aListBox.Init(LRefActive).SortOnColumn 1
End Function

Sub PopulateLReferences()
    '@AssignedModule uReferences
    '@INCLUDE USERFORM uReferences
    Dim i           As Long
    i = 0
    Dim rng         As Range
    Set rng = ThisWorkbook.Sheets("REFERENCES").Range("A1").CurrentRegion
    Set rng = rng.offset(1).Resize(rng.rows.Count - 1)
    Dim cell        As Range
    For Each cell In rng.Columns(1).Cells
        LReferences.AddItem
        LReferences.list(i, 0) = cell.TEXT
        LReferences.list(i, 1) = cell.offset(0, 1).TEXT
        LReferences.list(i, 2) = cell.offset(0, 2).TEXT
        LReferences.list(i, 3) = cell.offset(0, 3).TEXT
        i = i + 1
    Next cell

End Sub


'uCodeOnTheFly	UserForm


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* UserForm   : uCodeOnTheFly
'* Purpose    :
'* Copyright  :
'*
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 30-06-2023 11:53    Alex
'* Modified   : 18-07-2023 08:14    Alex                modified from frame method to aMultipage class
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Private CodeOnTheFlyTextbox As MSForms.Textbox

Private Sub GetInfo_Click()
    '@AssignedModule uCodeOnTheFly
    '@INCLUDE PROCEDURE PlayTheSound
    '@INCLUDE CLASS aUserform
    '@INCLUDE USERFORM uCodeOnTheFly
    '@INCLUDE USERFORM uAuthor
    With aUserform.Init(Me)
        .Transition .Effect(GetInfo, "Top", GetInfo.Top - 10, 150)

        .Transition .Effect(GetInfo, "Top", GetInfo.Top + 10, 150)
    End With
    uAuthor.Show
End Sub

Private Sub labelRun_Click()
    '@AssignedModule uCodeOnTheFly
    '@INCLUDE PROCEDURE ShowUserformCodeOnTheFly
    '@INCLUDE PROCEDURE EvaluateQuestion
    '@INCLUDE PROCEDURE RunCodeOnTheFly
    '@INCLUDE PROCEDURE TextOfControl
    '@INCLUDE PROCEDURE appRunOnTime
    '@INCLUDE PROCEDURE PlayTheSound
    '@INCLUDE CLASS aUserform
    '@INCLUDE USERFORM uCodeOnTheFly
    '@INCLUDE DECLARATION CodeOnTheFlyTextbox
    aUserform.Init(Me).SaveOptions
    Dim Code        As String
    Code = TextOfControl(CodeOnTheFlyTextbox)
    If Left(Code, 1) <> "?" Then
        'if pointer width=0 then code=all text, else code=selection
        appRunOnTime Now, "ShowUserformCodeOnTheFly"
        RunCodeOnTheFly Code
    Else
        Dim qAsked  As Long
        qAsked = Len(Code) - Len(Replace(Code, "?", ""))
        If qAsked > 1 Then
            MsgBox qAsked & " questions detected. I can only answer one."
            Exit Sub
        End If
        
        appRunOnTime Now, "ShowUserformCodeOnTheFly"
        appRunOnTime Now, _
                "RunCodeOnTheFly", _
                Me.Name & "." & CodeOnTheFlyTextbox.Name & ".text=" & _
                Me.Name & "." & CodeOnTheFlyTextbox.Name & ".text & vbNewLine & "" & ""  " & Mid(Code, 2)
        '        EvaluateQuestion Mid(code, 2)
    End If
End Sub


Private Sub MultiPage1_Change()
    '@AssignedModule uCodeOnTheFly
    '@INCLUDE USERFORM uCodeOnTheFly
    '@INCLUDE DECLARATION CodeOnTheFlyTextbox
    Set CodeOnTheFlyTextbox = Me.Controls("Textbox" & MultiPage1.Value + 1)
End Sub


Private Sub UserForm_Activate()
    '@AssignedModule uCodeOnTheFly
    '@INCLUDE USERFORM uCodeOnTheFly
    With labelRun
        .BorderStyle = fmBorderStyleNone
        .Picture = LoadPicture(ThisWorkbook.path & "\Lib\img\MagicHat.bmp")
        .MouseIcon = LoadPicture(ThisWorkbook.path & "\Lib\img\wand.ico")
        .MousePointer = fmMousePointerCustom
    End With
End Sub

Private Sub UserForm_Initialize()
    '@AssignedModule uCodeOnTheFly
    '@INCLUDE CLASS aUserform
    '@INCLUDE CLASS aMultiPage
    '@INCLUDE USERFORM uCodeOnTheFly
    '@INCLUDE DECLARATION MyColors
    '@INCLUDE DECLARATION CodeOnTheFlyTextbox

    Me.Caption = "if pointer width=0 then code=all text, else code=selection"
    Dim i           As Long
    For i = 1 To 9
        With Me.Controls("Textbox" & i)
            .Width = 1500
            .Height = 1500
            .Left = 0
            .Top = 0
            .Font.Size = 10
            .Font.Name = "Consolas"
        End With
    Next

    aUserform.Init(Me).ShowMinimizeButton

    Me.Height = 200
    Me.Width = 430


    aUserform.Init(Me).LoadOptions
    Set CodeOnTheFlyTextbox = Me.Controls("Textbox" & MultiPage1.Value + 1)
    aMultiPage.Init(MultiPage1).BuildMenu createSidebarMinimizers:=False
    Dim ctl         As MSForms.control
    For Each ctl In Me.Controls("sidebarleft").Controls
        If ctl.Name = "sidebarLabel" & MultiPage1.SelectedItem.Name Then
            ctl.BackColor = MyColors.FormSelectedGreen
        Else
            ctl.BackColor = Me.Controls("sidebarleft").BackColor
        End If
    Next
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    '@AssignedModule uCodeOnTheFly
    '@INCLUDE CLASS aUserform
    '@INCLUDE USERFORM uCodeOnTheFly
    aUserform.Init(Me).SaveOptions
End Sub


'uSkeleton	UserForm

'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Userform   : uSkeleton
'* Created    : 06-10-2022 10:40
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


Option Explicit


Dim skellyBook      As Workbook
Dim skellyModule    As VBComponent
Dim skellyProcName

Private Sub exportDeclarationsAndCalls_Click()
    '@AssignedModule uSkeleton
    '@INCLUDE PROCEDURE ArrayToRange2D
    '@INCLUDE PROCEDURE CollectionsToArray2D
    '@INCLUDE PROCEDURE getDeclarations
    '@INCLUDE CLASS aWorkbook
    '@INCLUDE CLASS aCollection
    '@INCLUDE USERFORM uSkeleton
    '@INCLUDE DECLARATION skellyBook
    setUp
    Dim var         As Variant
    Dim collections As New Collection
    Set collections = FindCalls(skellyBook)
    If collections(1).Count > 0 Then
        var = aCollection.CollectionsToArray2D(collections)
        ArrayToRange2D var, dataToSheet(skellyBook, "exportCalls", "A2")
        With skellyBook.Sheets("exportCalls").Range("A1:B1")
            .Value = Array("Procedure", "Calls")
            .Font.Bold = True
            .Font.Size = 14
        End With
        With skellyBook.Sheets("exportCalls").Cells
            .WrapText = False
            .Columns.AutoFit
            .WrapText = True
            .Columns.AutoFit
            .VerticalAlignment = xlVAlignCenter
        End With
    End If
    Set collections = aWorkbook.Init(skellyBook).getDeclarations(True, True, True, True, True, True)
    If collections(1).Count > 0 Then
        var = aCollection.CollectionsToArray2D(collections)
        ArrayToRange2D var, dataToSheet(skellyBook, "exportDeclarations", "A2")
        With skellyBook.Sheets("exportDeclarations").Range("A1:F1")
            .Value = Array("Component Type", "Component Name", "Declaration Scope", "Declaration Type", "Declaration Keyword", "Declaration Code")
            .Font.Bold = True
            .Font.Size = 14
        End With
        With skellyBook.Sheets("exportDeclarations").Cells
            .WrapText = False
            .Columns.AutoFit
            .WrapText = True
            .Columns.AutoFit
            .VerticalAlignment = xlVAlignCenter
        End With
    End If
End Sub

Function AddProcedureCallsToCollectionSkeleton(skellyBook As Workbook, skellyModule As VBComponent, ProcName As String) As Collection
    '@AssignedModule uSkeleton
    '@INCLUDE PROCEDURE ProcedureCode
    '@INCLUDE PROCEDURE ProceduresOfWorkbook
    '@INCLUDE USERFORM uSkeleton
    '@INCLUDE DECLARATION skellyBook
    '@INCLUDE DECLARATION skellyModule
    Dim coll        As Collection
    Set coll = New Collection
    Dim WorkbookProcedure As Variant
    Dim AllProcs    As Collection
    Set AllProcs = ProceduresOfWorkbook(skellyBook)
    Dim procText    As String
    procText = ProcedureCode(skellyBook, skellyModule, ProcName)
    For Each WorkbookProcedure In AllProcs
        If CStr(WorkbookProcedure) <> ProcName Then
            If InStr(1, procText, CStr(WorkbookProcedure)) Then
                coll.Add CStr(WorkbookProcedure)
            End If
        End If
    Next WorkbookProcedure
    Set AddProcedureCallsToCollectionSkeleton = coll
End Function



Private Sub UserForm_Initialize()
    '@AssignedModule uSkeleton
    '@INCLUDE USERFORM uSkeleton
    LoadProjects
End Sub
Private Sub GetInfo_Click()
    '@AssignedModule uSkeleton
    '@INCLUDE PROCEDURE PlayTheSound
    '@INCLUDE CLASS aUserform
    '@INCLUDE USERFORM uSkeleton
    '@INCLUDE USERFORM uAuthor
    With aUserform.Init(Me)
        .Transition .Effect(GetInfo, "Top", GetInfo.Top - 10, 150)

        .Transition .Effect(GetInfo, "Top", GetInfo.Top + 10, 150)
    End With
    uAuthor.Show
End Sub

Sub LoadProjects()
    '@INCLUDE WorkbookProjectProtected
    '@AssignedModule uSkeleton
    '@INCLUDE PROCEDURE WorkbookProjectProtected
    '@INCLUDE USERFORM uSkeleton
    '@INCLUDE DECLARATION skellyBook
    For Each skellyBook In Workbooks
        If Not WorkbookProjectProtected(skellyBook) Then LProjects.AddItem skellyBook.Name
    Next
    On Error Resume Next
    Dim ad
    For Each ad In AddIns
        If Not WorkbookProjectProtected(Workbooks(ad.Name)) Then
            If Err = 0 Then LProjects.AddItem ad.Name
            Err.clear
        End If
    Next
End Sub

Private Sub LProjects_Click()
    '@AssignedModule uSkeleton
    '@INCLUDE USERFORM uSkeleton
    loadComponents
End Sub

Sub loadComponents()
    '@INCLUDE ModuleTypeToString
    '@INCLUDE SortListboxOnColumn
    '@INCLUDE setUp
    '@INCLUDE ReleaseMe
    '@INCLUDE ControlsResizeColumns
    '@AssignedModule uSkeleton
    '@INCLUDE PROCEDURE ModuleTypeToString
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aListBox
    '@INCLUDE USERFORM uSkeleton
    '@INCLUDE DECLARATION skellyBook
    '@INCLUDE DECLARATION skellyModule
    LComponents.clear: LProcedures.clear: TPROCS.TEXT = "": LCalls.clear: TCalls.TEXT = "": LDeclarations.clear: TDeclarations.TEXT = "":
    setUp
    For Each skellyModule In skellyBook.VBProject.VBComponents
        LComponents.AddItem
        LComponents.list(LComponents.ListCount - 1, 0) = aModule.Init(skellyModule).TypeToString
        LComponents.list(LComponents.ListCount - 1, 1) = skellyModule.Name
    Next
    ReleaseMe
    aListBox.Init(LComponents).SortOnColumn 0
    ControlsResizeColumns LComponents
End Sub

Private Sub LComponents_Click()
    '@AssignedModule uSkeleton
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aListBox
    '@INCLUDE USERFORM uSkeleton
    '@INCLUDE DECLARATION skellyModule
    LProcedures.clear: TPROCS.TEXT = "": LCalls.clear: TCalls.TEXT = "": LDeclarations.clear: TDeclarations.TEXT = "":
    setUp
    For Each skellyProcName In ProcList(skellyModule)
        LProcedures.AddItem skellyProcName
    Next
    TComps.TEXT = aModule.Init(skellyModule).Code
    aListBox.Init(LProcedures).SortOnColumn 0
End Sub

Private Sub LProcedures_Click()
    '@AssignedModule uSkeleton
    '@INCLUDE PROCEDURE tmp
    '@INCLUDE PROCEDURE ModuleOfProcedure
    '@INCLUDE PROCEDURE ProcedureCode
    '@INCLUDE PROCEDURE getDeclarations
    '@INCLUDE CLASS aWorkbook
    '@INCLUDE CLASS aListBox
    '@INCLUDE USERFORM uSkeleton
    '@INCLUDE DECLARATION skellyBook
    '@INCLUDE DECLARATION skellyModule
    LCalls.clear: TCalls.TEXT = "": LDeclarations.clear: TDeclarations.TEXT = "":
    setUp
    TPROCS.TEXT = ProcedureCode(skellyBook, skellyModule, CStr(skellyProcName))
    Do While InStr(1, TPROCS.TEXT, "  ") > 0
        TPROCS.TEXT = Replace(TPROCS.TEXT, "  ", " ")
    Loop
    Dim element
    For Each element In AddProcedureCallsToCollectionSkeleton(skellyBook, ModuleOfProcedure(skellyBook, CStr(skellyProcName)), CStr(skellyProcName))
        LCalls.AddItem element
    Next
    aListBox.Init(LCalls).SortOnColumn 1
    'test
    Dim coll        As Collection: Set coll = aWorkbook.Init(skellyBook).getDeclarations(True, True, True, True, True, True)
    Dim keyCol      As Collection: Set keyCol = coll.item(5)
    Dim decCol      As Collection: Set decCol = coll.item(6)
    Dim i           As Long
    Dim tmp         As String
    For i = 1 To keyCol.Count
        'if the DECLARATION keyword exists inside the procedure
        If InStr(1, TPROCS.TEXT, keyCol.item(i)) > 0 Then
            'and if it is not a VARIABLE inside the procedure
            If InStr(1, TPROCS.TEXT, keyCol.item(i) & " As") = 0 Then
                'avoid duplicates

                If aListBox.Init(LDeclarations).Contains(keyCol.item(i)) = False Then
                    LDeclarations.AddItem keyCol.item(i)
                End If
            End If
        End If
    Next i
    aListBox.Init(LDeclarations).SortOnColumn 0
    aListBox.Init(LCalls).SortOnColumn 0
    ReleaseMe
End Sub

Private Sub LCalls_Click()
    '@AssignedModule uSkeleton
    '@INCLUDE PROCEDURE ModuleOfProcedure
    '@INCLUDE PROCEDURE ProcedureCode
    '@INCLUDE USERFORM uSkeleton
    '@INCLUDE DECLARATION skellyBook
    '@INCLUDE DECLARATION skellyModule
    setUp
    skellyProcName = LCalls.list(LCalls.ListIndex)
    Set skellyModule = ModuleOfProcedure(skellyBook, CStr(skellyProcName))
    TCalls.TEXT = ProcedureCode(skellyBook, skellyModule, CStr(skellyProcName))
    ReleaseMe
End Sub

Private Sub LDeclarations_Click()
    '@AssignedModule uSkeleton
    '@INCLUDE PROCEDURE getDeclarations
    '@INCLUDE CLASS aWorkbook
    '@INCLUDE USERFORM uSkeleton
    '@INCLUDE DECLARATION skellyBook
    setUp
    Dim coll        As Collection: Set coll = aWorkbook.Init(skellyBook).getDeclarations(True, True, True, True, True, True)
    Dim keyCol      As Collection: Set keyCol = coll.item(5)
    Dim decCol      As Collection: Set decCol = coll.item(6)
    Dim i           As Long
    For i = 1 To keyCol.Count
        If keyCol.item(i) = LDeclarations.list(LDeclarations.ListIndex) Then
            TDeclarations.TEXT = decCol.item(i)
        End If
    Next i
End Sub

Sub setUp()
    '@AssignedModule uSkeleton
    '@INCLUDE USERFORM uSkeleton
    '@INCLUDE DECLARATION skellyBook
    '@INCLUDE DECLARATION skellyModule
    On Error Resume Next
    Set skellyBook = Workbooks(LProjects.list(LProjects.ListIndex))
    Set skellyModule = skellyBook.VBProject.VBComponents(LComponents.list(LComponents.ListIndex, 1))
    skellyProcName = LProcedures.list(LProcedures.ListIndex)
End Sub

Sub ReleaseMe()
    '@AssignedModule uSkeleton
    '@INCLUDE USERFORM uSkeleton
    '@INCLUDE DECLARATION skellyBook
    '@INCLUDE DECLARATION skellyModule
    Set skellyModule = Nothing
    Set skellyBook = Nothing
End Sub

Function FindCalls(skellyBook As Workbook) As Collection
    '@INCLUDE ProceduresOfWorkbook
    '@INCLUDE ModuleOfProcedure
    '@INCLUDE CollectionToArray
    '@INCLUDE AddProcedureCallsToCollectionSkeleton
    '@AssignedModule uSkeleton
    '@INCLUDE PROCEDURE tmp
    '@INCLUDE PROCEDURE ModuleOfProcedure
    '@INCLUDE PROCEDURE ProceduresOfWorkbook
    '@INCLUDE CLASS aCollection
    '@INCLUDE USERFORM uSkeleton
    '@INCLUDE DECLARATION skellyBook
    Dim Procedure   As Variant
    Dim Output      As New Collection
    Dim Procedures  As New Collection
    Dim calls       As New Collection
    Dim element     As Variant
    Dim tmp         As New Collection
    For Each Procedure In ProceduresOfWorkbook(skellyBook)
        Set tmp = AddProcedureCallsToCollectionSkeleton(skellyBook, ModuleOfProcedure(skellyBook, CStr(Procedure)), CStr(Procedure))
        If tmp.Count > 0 Then
            Procedures.Add Procedure
            calls.Add aCollection.Init(tmp).ToString(vbNewLine)
        End If
    Next
    Output.Add Procedures
    Output.Add calls
    Set FindCalls = Output
End Function

Function dataToSheet(Optional skellyBook As Workbook, Optional wsName As String, Optional rngAddress As String, Optional confirmClear As Boolean) As Range
    '@INCLUDE answer
    '@INCLUDE sheetExists
    '@AssignedModule uSkeleton
    '@INCLUDE USERFORM uSkeleton
    '@INCLUDE DECLARATION skellyBook
    If skellyBook Is Nothing Then Set skellyBook = Workbooks.Add
    Dim ws          As Worksheet
    If sheetExists(wsName, skellyBook) Then
        If confirmClear = True Then
            Dim Answer As Integer
            Answer = MsgBox("Sheet " & wsName & " already exists. Cells will be cleared. Proceed?", vbYesNo)
            If Answer = vbNo Then Exit Function
        End If
        Set ws = skellyBook.Sheets(wsName)
        ws.Cells.clear
    Else
        If wsName = "" Then
            Set ws = skellyBook.Sheets(1)
        Else
            Set ws = skellyBook.Sheets.Add
            ws.Name = wsName
        End If
    End If
    If rngAddress <> "" Then
        Set dataToSheet = ws.Range(rngAddress)
    Else
        Set dataToSheet = ws.Range("A1")
    End If
End Function

Function ProcList(skellyModule As VBComponent) As Collection
    '@AssignedModule uSkeleton
    '@INCLUDE USERFORM uSkeleton
    '@INCLUDE DECLARATION skellyModule
    Dim codeMod     As CodeModule
    Set codeMod = skellyModule.CodeModule
    Dim coll        As Collection
    Set coll = New Collection
    Dim lineNum     As Long
    Dim NumLines    As Long
    Dim ProcName    As String
    Dim ProcKind    As VBIDE.vbext_ProcKind
    lineNum = codeMod.CountOfDeclarationLines + 1
    Do Until lineNum >= codeMod.CountOfLines
        ProcName = codeMod.ProcOfLine(lineNum, ProcKind)
        coll.Add ProcName
        lineNum = codeMod.procStartLine(ProcName, ProcKind) + codeMod.ProcCountLines(ProcName, ProcKind) + 1
    Loop
    Set ProcList = coll
End Function

Function ControlsResizeColumns(LBox As MSForms.control, Optional ResizeListbox As Boolean)
    '@INCLUDE sheetExists
    '@AssignedModule uSkeleton
    '@INCLUDE USERFORM uSkeleton
    If LBox.ListCount = 0 Then Exit Function
    Application.ScreenUpdating = False
    Dim ws          As Worksheet
    If sheetExists("ListboxColumnWidth", ThisWorkbook) = False Then
        Set ws = ThisWorkbook.Worksheets.Add
        ws.Name = "ListboxColumnwidth"
    Else
        Set ws = ThisWorkbook.Worksheets("ListboxColumnwidth")
        ws.Cells.clear
    End If
    ws.Cells.Font.Size = 12
    ws.Cells.Font.Name = "Calibri"
    '---Listbox to range-----
    Dim rng         As Range
    Set rng = ThisWorkbook.Sheets("ListboxColumnwidth").Range("A1")
    Set rng = rng.Resize(UBound(LBox.list) + 1, LBox.columnCount)
    rng = LBox.list
    '---Get ColumnWidths------
    rng.Columns.AutoFit
    Dim sWidth      As String
    Dim vR()        As Variant
    Dim N           As Integer
    Dim cell        As Range
    For Each cell In rng.Resize(1)
        N = N + 1
        ReDim Preserve vR(1 To N)
        vR(N) = cell.EntireColumn.Width
    Next cell
    sWidth = Join(vR, ";")
    'Debug.Print sWidth
    '---assign ColumnWidths----
    With LBox
        .ColumnWidths = sWidth
        '.RowSource = "A1:A3"
        .BorderStyle = fmBorderStyleSingle
    End With
    'Remove worksheet
    Application.DisplayAlerts = False
    ws.Delete
    Application.DisplayAlerts = True
    Application.ScreenUpdating = True
    '----Resize Listbox--------
    If ResizeListbox = False Then Exit Function
    Dim W           As Long
    Dim i           As Long
    For i = LBound(vR) To UBound(vR)
        W = W + vR(i)
    Next
    DoEvents
    LBox.Width = W + 10
End Function

Function sheetExists(sheetToFind As String, Optional InWorkbook As Workbook) As Boolean
    '@AssignedModule uSkeleton
    '@INCLUDE USERFORM uSkeleton
    If InWorkbook Is Nothing Then Set InWorkbook = ThisWorkbook
    On Error Resume Next
    sheetExists = Not InWorkbook.Sheets(sheetToFind) Is Nothing
End Function


'uSnippets	UserForm


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* UserForm   : uSnippets
'* Purpose    :
'* Copyright  :
'*
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 17-08-2023 13:28    Alex
'* Modified   : 17-08-2023 13:28    Alex                added roundabout way to inject directly
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Private SnippetsFolder As String


Private Sub SNIP_Click()
    If Len(LSnippetsPreview.TEXT) = 0 Then Exit Sub
    Dim S           As String
    If LSnippetsPreview.SelLength = 0 Then
        S = LSnippetsPreview.TEXT
    Else
        S = LSnippetsPreview.SelText
    End If

    SaveSettings

    If ShowInVBE Then
        Application.OnTime Now, "uShow_SnippetsVBE"
    Else
        Application.OnTime Now, "uShow_SnippetsWorkbook"
    End If

    aCodeModule.Active.Inject S
    '    cResize_Click
End Sub

Sub SaveSettings()
    IniWrite ThisWorkbook.path & "config\UserformSettings.ini", Me.Name, "SelStart", LSnippetsPreview.selStart
    IniWrite ThisWorkbook.path & "config\UserformSettings.ini", Me.Name, "SelLength", LSnippetsPreview.SelLength
    IniWrite ThisWorkbook.path & "config\UserformSettings.ini", Me.Name, "Filter", Me.tFilterSnippets.Value
    If LSnippets.ListIndex = -1 Then
        IniWrite ThisWorkbook.path & "config\UserformSettings.ini", Me.Name, "File", ""
    Else
        IniWrite ThisWorkbook.path & "config\UserformSettings.ini", Me.Name, "File", LSnippets.list(LSnippets.ListIndex)
    End If
End Sub

Private Sub UserForm_Activate()
    With aUserform.Init(Me)
        .Resizable True
        If ShowInVBE Then .ParentIsVBE
    End With
End Sub

Private Sub UserForm_Initialize()
    '@AssignedModule uSnippets
    '@INCLUDE PROCEDURE FoldersCreate
    '@INCLUDE CLASS aListBox
    '@INCLUDE CLASS aUserform
    '@INCLUDE USERFORM uSnippets
    '@INCLUDE DECLARATION ShowInVBE
    '@INCLUDE DECLARATION SnippetsFolder

    SnippetsFolder = LOCAL_LIBRARY_PROCEDURES

    FoldersCreate SnippetsFolder

    If Right(SnippetsFolder, 1) <> "\" Then SnippetsFolder = SnippetsFolder & "\"
    GetFilesUSnippets

    tFilterSnippets.TEXT = IniReadKey(ThisWorkbook.path & "config\UserformSettings.ini", Me.Name, "Filter")
    Dim fileName    As String
    fileName = IniReadKey(ThisWorkbook.path & "config\UserformSettings.ini", Me.Name, "File")
    Dim i           As Long
    For i = LBound(LSnippets.list) To UBound(LSnippets.list)
        If LSnippets.list(i) = fileName Then
            LSnippets.ListIndex = i
            Exit For
        End If
    Next

    LSnippetsPreview.selStart = IniReadKey(ThisWorkbook.path & "config\UserformSettings.ini", Me.Name, "SelStart", 0)
    LSnippetsPreview.SelLength = IniReadKey(ThisWorkbook.path & "config\UserformSettings.ini", Me.Name, "SelLength", 0)
    
End Sub

Sub SwitchParent()
    '@AssignedModule uSnippets
    '@INCLUDE USERFORM uSnippets
    '@todo

End Sub

Sub GetFilesUSnippets()
    '@AssignedModule uSnippets
    '@INCLUDE PROCEDURE LoopThroughFiles
    '@INCLUDE USERFORM uSnippets
    '@INCLUDE DECLARATION SnippetsFolder
    LSnippets.clear
    Dim Files       As Collection: Set Files = LoopThroughFiles(SnippetsFolder, "*.txt")
    Dim File
    For Each File In Files
        LSnippets.AddItem File
    Next
End Sub

Private Sub CommandButton1_Click()
    '@AssignedModule uSnippets
    '@INCLUDE USERFORM uSnippets
    tFilterSnippets.TEXT = ""
    LSnippets.ListIndex = -1
End Sub

Private Sub cResize_Click()
    '@AssignedModule uSnippets
    '@INCLUDE USERFORM uSnippets
    If Me.Height < 429 Then
        Me.Height = 429
    Else
        Me.Height = 60
        Me.Width = 100
    End If

    Me.Show
End Sub

Private Sub cSnippetFolder_Click()
    '@AssignedModule uSnippets
    '@INCLUDE PROCEDURE FollowLink
    '@INCLUDE USERFORM uSnippets
    '@INCLUDE DECLARATION SnippetsFolder
    FollowLink SnippetsFolder
End Sub

Private Sub GetInfo_Click()
    '@AssignedModule uSnippets
    '@INCLUDE PROCEDURE PlayTheSound
    '@INCLUDE CLASS aUserform
    '@INCLUDE USERFORM uSnippets
    '@INCLUDE USERFORM uAuthor
    With aUserform.Init(Me)
        .Transition .Effect(GetInfo, "Top", GetInfo.Top - 10, 150)

        .Transition .Effect(GetInfo, "Top", GetInfo.Top + 10, 150)
    End With
    uAuthor.Show
End Sub


Private Sub LSnippets_Click()
    '@AssignedModule uSnippets
    '@INCLUDE PROCEDURE TxtRead
    '@INCLUDE USERFORM uSnippets
    '@INCLUDE DECLARATION SnippetsFolder
    Dim sPath       As String
    sPath = SnippetsFolder & LSnippets.list(LSnippets.ListIndex)
    LSnippetsPreview.TEXT = TxtRead(sPath)
End Sub

Private Sub cCopySnippet_Click()
    '@AssignedModule uSnippets
    '@INCLUDE PROCEDURE CLIP
    '@INCLUDE USERFORM uSnippets
    If Len(LSnippetsPreview.TEXT) = 0 Then Exit Sub
    Dim S           As String
    If LSnippetsPreview.SelLength = 0 Then
        S = LSnippetsPreview.TEXT
    Else
        S = LSnippetsPreview.SelText
    End If
    CLIP S
    cResize_Click
    MsgBox "Snipet copied"
End Sub

Private Sub cOverwriteSnippet_Click()
    '@AssignedModule uSnippets
    '@INCLUDE PROCEDURE TxtOverwrite
    '@INCLUDE PROCEDURE InputboxString
    '@INCLUDE USERFORM uSnippets
    '@INCLUDE DECLARATION SnippetsFolder
    Dim sPath       As String
    Dim isNew       As Boolean
    Dim wasResized  As Boolean
    If LSnippets.ListIndex = -1 Then
        Dim ans     As String
        cResize_Click
        ans = InputboxString(, "Select name for new file")
        If Len(ans) = 0 Then GoTo ExitHandler
        sPath = SnippetsFolder & ans & ".txt"
        isNew = True
        wasResized = True
    Else
        sPath = SnippetsFolder & LSnippets.list(LSnippets.ListIndex)
    End If
    TxtOverwrite sPath, LSnippetsPreview.TEXT
    If isNew = True Then
        LSnippets.AddItem ans & ".txt"
        LSnippets.ListIndex = LSnippets.ListCount - 1
    End If
ExitHandler:
    If wasResized = True Then cResize_Click
End Sub

Private Sub cSnippetDelete_Click()
    '@AssignedModule uSnippets
    '@INCLUDE USERFORM uSnippets
    '@INCLUDE DECLARATION SnippetsFolder
    cResize_Click
    Dim proceed     As Long
    proceed = MsgBox("Delete " & LSnippets.list(LSnippets.ListIndex) & "?", vbYesNo)
    If proceed = vbNo Then Exit Sub
    Dim sPath       As String
    sPath = SnippetsFolder & LSnippets.list(LSnippets.ListIndex)
    Dim FSO         As Scripting.FileSystemObject
    Set FSO = New Scripting.FileSystemObject
    FSO.DeleteFile sPath
    LSnippets.RemoveItem LSnippets.ListIndex
    LSnippetsPreview.TEXT = ""
    LSnippets.ListIndex = -1
    cResize_Click
End Sub

Private Sub cSnippetStartNew_Click()
    '@AssignedModule uSnippets
    '@INCLUDE PROCEDURE FileExists
    '@INCLUDE PROCEDURE TxtOverwrite
    '@INCLUDE USERFORM uSnippets
    '@INCLUDE DECLARATION SnippetsFolder
    Dim NewName     As String
    cResize_Click
    NewName = InputBox("New Snippet Name")
    If NewName = "" Then GoTo ExitHandler
    Dim sPath       As String
    sPath = SnippetsFolder & NewName & ".txt"
    If FileExists(sPath) Then Exit Sub
    LSnippets.ListIndex = -1
    LSnippetsPreview.TEXT = ""
    TxtOverwrite sPath, ""
    LSnippets.AddItem NewName & ".txt"
    LSnippets.ListIndex = LSnippets.ListCount - 1
    LSnippetsPreview.SetFocus
ExitHandler:
    cResize_Click
End Sub

Private Sub LSnippetsPreview_Enter()
    '@AssignedModule uSnippets
    '@INCLUDE USERFORM uSnippets
    LSnippetsPreview.selStart = 0
End Sub

Private Sub tFilterSnippets_Change()
    '@AssignedModule uSnippets
    '@INCLUDE CLASS aListBox
    '@INCLUDE USERFORM uSnippets
    GetFilesUSnippets
    aListBox.Init(LSnippets).FilterByColumn tFilterSnippets.TEXT
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    SaveSettings
End Sub

'EventListenerEmitter	Class

'------------------------
'userform declararations
'------------------------
'   Private WithEvents Emitter As EventListeneRemitter

'------------------------
'in userform_initialise
'------------------------
'   Set Emitter = New EventListeneRemitter
'   Emitter.AddEventListenerAll Me

Rem Author Robert Todar

Option Explicit
Option Compare Text

' Array of all the different event listeners for every userform control and the form itself
Private EventList() As New EventListenerItem

' All the current possible events that can be emitted.
' Note, EmittedEvent is sent for all events!
Public Event EmittedEvent(ByRef control As Object, ByVal EventType As EmittedEvent, ByRef EventParameters As Collection)
Public Event Click(ByRef control As Object)
Public Event DblClick(ByRef control As Object, ByRef Cancel As MSForms.ReturnBoolean)
Public Event KeyUp(ByRef control As Object, ByRef KeyCode As MSForms.ReturnInteger, ByRef Shift As Integer)
Public Event KeyDown(ByRef control As Object, ByRef KeyCode As MSForms.ReturnInteger, ByRef Shift As Integer)
Public Event MouseOver(ByRef control As Object)
Public Event MouseOut(ByRef control As Object)
Public Event MouseMove(ByRef control As Object, ByRef Shift As Integer, ByRef X As Single, ByRef Y As Single)
Public Event Focus(ByRef control As Object)
Public Event Blur(ByRef control As Object)
Public Event Change(ByRef control As Object)

' Events to Labels
Public Event LabelMouseOver(ByRef Label As MSForms.Label)
Public Event LabelMouseOut(ByRef Label As MSForms.Label)
Public Event LabelClick(ByRef Label As MSForms.Label)
Public Event LabelDoubleClick(ByRef Label As MSForms.Label, ByRef Cancel As MSForms.ReturnBoolean)
Public Event LabelMouseMove(ByRef Label As MSForms.Label, ByRef Shift As Integer, ByRef X As Single, ByRef Y As Single)

' Events to Textboxes
Public Event TextboxFocus(ByRef Textbox As MSForms.Textbox)
Public Event TextboxBlur(ByRef Textbox As MSForms.Textbox)
Public Event TextboxMouseOver(ByRef Textbox As MSForms.Textbox)
Public Event TextboxMouseOut(ByRef Textbox As MSForms.Textbox)
Public Event TextboxClick(ByRef Textbox As MSForms.Textbox)
Public Event TextboxDoubleClick(ByRef Textbox As MSForms.Textbox, ByRef Cancel As MSForms.ReturnBoolean)
Public Event TextboxMouseMove(ByRef Textbox As MSForms.Textbox, ByRef Shift As Integer, ByRef X As Single, ByRef Y As Single)

' Events to CommandButtons
Public Event CommandButtonMouseOver(ByRef CommandButton As MSForms.CommandButton)
Public Event CommandButtonMouseOut(ByRef CommandButton As MSForms.CommandButton)
Public Event CommandButtonClick(ByRef CommandButton As MSForms.CommandButton)
Public Event CommandButtonDoubleClick(ByRef CommandButton As MSForms.CommandButton, ByRef Cancel As MSForms.ReturnBoolean)
Public Event CommandButtonMouseMove(ByRef CommandButton As MSForms.CommandButton, ByRef Shift As Integer, ByRef X As Single, ByRef Y As Single)

' Events to Images
Public Event ImageMouseDown(ByRef Image As MSForms.Image, ByRef Button As Integer, ByRef Shift As Integer, ByRef X As Single, ByRef Y As Single)

' Types of events that can occur
Public Enum EmittedEvent
    Change
    Click
    DoubleClick
    MouseMove
    MouseOut
    MouseOver
    MouseDown
    MouseUp
    KeyUp
    KeyDown
    Focus
    Blur
End Enum

' Called by EventListenerItem class - main entryway of emitting all events
Public Sub EmitEvent(ByRef control As Object, ByVal EventType As EmittedEvent, Optional ByRef EventParameters As Collection)
    ' Event raised for all events. This is a way for the user to collect from a single location.
    '@AssignedModule EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    RaiseEvent EmittedEvent(control, EventType, EventParameters)

    ' Specific events
    Select Case EventType

        Case Click
            RaiseEvent Click(control)

        Case DoubleClick
            RaiseEvent DblClick(control, EventParameters("Cancel"))

        Case KeyUp
            RaiseEvent KeyUp(control, EventParameters("KeyCode"), EventParameters("Shift"))

        Case KeyDown
            RaiseEvent KeyDown(control, EventParameters("KeyCode"), EventParameters("Shift"))

        Case MouseOver
            RaiseEvent MouseOver(control)

        Case MouseOut
            RaiseEvent MouseOut(control)

        Case Focus
            RaiseEvent Focus(control)

        Case Blur
            RaiseEvent Blur(control)

        Case MouseMove
            RaiseEvent MouseMove(control, EventParameters("Shift"), EventParameters("X"), EventParameters("Y"))

    End Select

    ' Call the specific control type events
    Select Case TypeName(control)
        Case "Label"
            EmitLabelEvent control, EventType, EventParameters

        Case "Textbox"
            EmitTextboxEvent control, EventType, EventParameters

        Case "CommandButton"
            EmitCommandButtonEvent control, EventType, EventParameters
        Case "Image"
            EmitCommandButtonEvent control, EventType, EventParameters

    End Select
End Sub

' Events for Labels
Private Sub EmitLabelEvent(ByRef Label As MSForms.Label, ByVal EventType As String, ByRef EventParameters As Collection)
    '@AssignedModule EventListenerEmitter
    '@INCLUDE CLASS EventListenerEmitter
    Select Case EventType
        Case EmittedEvent.Click
            RaiseEvent LabelClick(Label)

        Case EmittedEvent.DoubleClick
            RaiseEvent LabelDoubleClick(Label, EventParameters("Cancel"))

        Case EmittedEvent.MouseOver
            RaiseEvent LabelMouseOver(Label)

        Case EmittedEvent.MouseOut
            RaiseEvent LabelMouseOut(Label)

        Case EmittedEvent.MouseMove
            RaiseEvent MouseMove(Label, EventParameters("Shift"), EventParameters("X"), EventParameters("Y"))
    End Select
End Sub

' Events for Textboxes
Private Sub EmitTextboxEvent(ByRef Textbox As MSForms.Textbox, ByVal EventType As String, ByRef EventParameters As Collection)
    '@AssignedModule EventListenerEmitter
    '@INCLUDE CLASS EventListenerEmitter
    Select Case EventType
        Case EmittedEvent.Blur
            RaiseEvent TextboxBlur(Textbox)

        Case EmittedEvent.Focus
            RaiseEvent TextboxFocus(Textbox)

        Case EmittedEvent.Click
            RaiseEvent TextboxClick(Textbox)

        Case EmittedEvent.DoubleClick
            RaiseEvent TextboxDoubleClick(Textbox, EventParameters("Cancel"))

        Case EmittedEvent.MouseOver
            RaiseEvent TextboxMouseOver(Textbox)

        Case EmittedEvent.MouseOut
            RaiseEvent TextboxMouseOut(Textbox)

        Case EmittedEvent.MouseMove
            RaiseEvent MouseMove(Textbox, EventParameters("Shift"), EventParameters("X"), EventParameters("Y"))
    End Select
End Sub

' Events for CommandButton
Private Sub EmitCommandButtonEvent(ByRef CommandButton As MSForms.CommandButton, ByVal EventType As String, ByRef EventParameters As Collection)
    '@AssignedModule EventListenerEmitter
    '@INCLUDE CLASS EventListenerEmitter
    Select Case EventType
        Case EmittedEvent.Click
            RaiseEvent CommandButtonClick(CommandButton)

        Case EmittedEvent.DoubleClick
            RaiseEvent CommandButtonDoubleClick(CommandButton, EventParameters("Cancel"))

        Case EmittedEvent.MouseOver
            RaiseEvent CommandButtonMouseOver(CommandButton)

        Case EmittedEvent.MouseOut
            RaiseEvent CommandButtonMouseOut(CommandButton)

        Case EmittedEvent.MouseMove
            RaiseEvent MouseMove(CommandButton, EventParameters("Shift"), EventParameters("X"), EventParameters("Y"))
    End Select
End Sub

' MUST CALL THIS IF YOU WANT TO programmatically SET CONTROL! OTHERWISE, EVENT'S WILL BE OFF!
Public Sub SetFocusToControl(ByRef control As Object)
    'If the user was to set focus through VBA then this code will fall apart considering
    'it is unaware of that event occurring.
    '@AssignedModule EventListenerEmitter
    '@INCLUDE CLASS EventListenerEmitter
    If Not control Is Nothing Then
        control.SetFocus
        EmitEvent control, Focus
    End If
End Sub

' ADD EVENT Listeners ON SPECIFIC CONTROLS - ALSO CALLED BY AddEventListenerAll
Public Sub AddEventListener(ByRef control As Object)
    ' Events are stored in a private EventListenerItem array
    '@AssignedModule EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    If IsArrayEmpty(EventList) Then
        ReDim EventList(0 To 0)
    Else
        ReDim Preserve EventList(0 To UBound(EventList) + 1)
    End If

    'CALL AddEventListener IN EventListenerItem. THIS IS KEPT IN
    EventList(UBound(EventList)).AddEventListener control, Me
End Sub

'ADD EVENT Listener TO ALL CONTROLS INCLUDING THE FORM
Public Sub AddEventListenerAll(ByRef Form As Object)
    '@AssignedModule EventListenerEmitter
    '@INCLUDE CLASS EventListenerEmitter
    AddEventListener Form

    Dim control     As MSForms.control
    For Each control In Form.Controls
        AddEventListener control
    Next control
End Sub

Private Function IsArrayEmpty(arr As Variant) As Boolean
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' CPEARSON: http://www.cpearson.com/excel/VBAArrays.htm
    ' This function tests whether the array is empty (unallocated). Returns TRUE or FALSE.
    '
    ' The VBA IsArray function indicates whether a variable is an array, but it does not
    ' distinguish between allocated and unallocated arrays. It will return TRUE for both
    ' allocated and unallocated arrays. This function tests whether the array has actually
    ' been allocated.
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    '@AssignedModule EventListenerEmitter
    '@INCLUDE CLASS EventListenerEmitter

    Err.clear
    On Error Resume Next
    If IsArray(arr) = False Then
        ' we weren't passed an array, return True
        IsArrayEmpty = True
    End If

    ' Attempt to get the UBound of the array. If the array is
    ' unallocated, an error will occur.
    Dim ub          As Long
    ub = UBound(arr, 1)
    If (Err.Number <> 0) Then
        IsArrayEmpty = True
    Else
        ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        ' On rare occasion, under circumstances I cannot reliably replicate, Err.Number
        ' will be 0 for an unallocated, empty array. On these occasions, LBound is 0 and
        ' UBound is -1. To accommodate the weird behavior, test to see if LB > UB.
        ' If so, the array is not allocated.
        ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        Err.clear
        Dim LB      As Long
        LB = LBound(arr)
        If LB > ub Then
            IsArrayEmpty = True
        Else
            IsArrayEmpty = False
        End If
    End If
End Function


'M_RunCodeOnTheFly	Module

Option Explicit
Function NamelessCodeOnTheFly()
uCodeOnTheFly.TextBox1.TEXT = uCodeOnTheFly.TextBox1.TEXT & vbNewLine & ThisWorkbook.path

End Function

Public Sub ShowUserformCodeOnTheFly()
    '@AssignedModule M_RunCodeOnTheFly
    '@INCLUDE USERFORM uCodeOnTheFly
    uCodeOnTheFly.Show
End Sub
Function EvaluateQuestion(str As String)
    'use in immediate window:
    '
    '   ?EvaluateQuestion("now")
    '@AssignedModule M_RunCodeOnTheFly
    '@INCLUDE PROCEDURE ClearClipboard
    '@INCLUDE PROCEDURE NamelessCodeOnTheFly
    '@INCLUDE PROCEDURE RunCodeOnTheFly
    '@INCLUDE USERFORM uCodeOnTheFly

    Dim var
    Dim Code        As String
    '    code = "on error resume next" & vbnewlilne
    Code = Code & "ClearClipboard" & vbNewLine
    Code = Code & "dim var" & vbNewLine
    Code = Code & "var=" & str & vbNewLine
    Code = Code & "clip cstr(var)" & vbNewLine
    Code = Code & "namelesscodeonthefly=cstr(var)" & vbNewLine

    '    code = code & "uCodeOnTheFly.Controls(ThisWorkbook.Sheets(""uCodeOnTheFly_Settings"").Range(""D1"").Value).text= _" & vbNewLine
    '    code = code & "ThisWorkbook.Sheets(""uCodeOnTheFly_Settings"").columns(1).find( _" & vbNewLine
    '    code = code & "ThisWorkbook.Sheets(""uCodeOnTheFly_Settings"").Range(""D1"").Value).offset(0,1).value & vbNewLine & cstr(var)"
    '
    RunCodeOnTheFly Code

    EvaluateQuestion = NamelessCodeOnTheFly
End Function

Function EvaluateString(strTextString As String)
    '@AssignedModule M_RunCodeOnTheFly
    Application.Volatile
    EvaluateString = Application.Caller.Parent.Evaluate(strTextString)
    Debug.Print strTextString & vbTab & ":" & vbTab & EvaluateString
End Function

Sub RunCodeFromRange()
    '@INCLUDE RunCodeOnTheFly
    '@AssignedModule M_RunCodeOnTheFly
    '@INCLUDE PROCEDURE RunCodeOnTheFly
    If TypeName(Selection) <> "Range" Then Exit Sub
    If Selection.Columns.Count <> 1 Then Exit Sub
    Dim Code        As String
    If Selection.Cells.Count = 1 Then
        Code = Selection.Value
    Else
        Dim var
        var = WorksheetFunction.Transpose(Selection.Value)
        Code = Join(var, vbNewLine)
    End If
    RunCodeOnTheFly Code
End Sub

Sub RunMacroFromSelection()
    '@AssignedModule M_RunCodeOnTheFly
    '@INCLUDE PROCEDURE ActiveModule
    '@INCLUDE PROCEDURE ActiveCodepaneWorkbook
    '@INCLUDE PROCEDURE ProcedureExists
    '@INCLUDE PROCEDURE RunCodeOnTheFly
    '@INCLUDE CLASS aCodeModule
    Dim Code        As String
    Code = aCodeModule.Init(ActiveModule).CodemoduleSelection
    If ProcedureExists(ActiveCodepaneWorkbook, Code) Then
        Application.Run Code
    Else
        RunCodeOnTheFly Code
    End If
End Sub

Sub RunMacroFromClipboard()
    '@AssignedModule M_RunCodeOnTheFly
    '@INCLUDE PROCEDURE ActiveCodepaneWorkbook
    '@INCLUDE PROCEDURE ProcedureExists
    '@INCLUDE PROCEDURE CLIP
    '@INCLUDE PROCEDURE RunCodeOnTheFly
    Dim Code        As String
    Code = CLIP
    If ProcedureExists(ActiveCodepaneWorkbook, Code) Then
        Application.Run Code
    Else
        RunCodeOnTheFly Code
    End If
End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 18-11-2022 18:22    Alex                (RunCodeOnTheFly) Initial Release

Public Sub RunCodeOnTheFly(CodeOnTheFly As String)
    Rem Do not move this procedure !!!
    Rem All lines after this procedure will be deleted and replaced.
    '@AssignedModule M_RunCodeOnTheFly
    '@INCLUDE PROCEDURE ModuleOfProcedure
    '@INCLUDE PROCEDURE ProcedureLinesLast
    '@INCLUDE PROCEDURE ProcedureReplace
    '@INCLUDE PROCEDURE NamelessCodeOnTheFly
    '@INCLUDE PROCEDURE appRunOnTime
    '@INCLUDE CLASS aProcedure

    'The following are considered true
    '1. If the CodeOnTheFly you pass as an argument contains multiple macros,
    '   then the first macro is the main one, which calls the subsequent ones
    '2. No declarations (@TODO use a helper module to overcome this) or missing references are needed
    '3. Make sure your manually typed code is able to run, it's up to you

    On Error GoTo ErrorHandler
    CodeOnTheFly = Replace(CodeOnTheFly, "Public", "Private")
    Dim module      As VBComponent
    Set module = ModuleOfProcedure(ThisWorkbook, "RunCodeOnTheFly")

    Dim subName     As String
    Dim SubStart    As Long
    SubStart = InStr(1, CodeOnTheFly, "Sub ", vbTextCompare)
    Dim FunctionStart As Long
    FunctionStart = InStr(1, CodeOnTheFly, "Function ", vbTextCompare)
    If SubStart > 0 Or FunctionStart > 0 Then
        If (SubStart > 0 And SubStart < FunctionStart) Or _
                (SubStart > 0 And FunctionStart = 0) Then
            subName = Mid(CodeOnTheFly, SubStart)
            subName = Split(subName, "Sub ", , vbTextCompare)(1)
            subName = Split(subName, "(")(0)
        ElseIf FunctionStart > 0 And FunctionStart < SubStart Or _
                (SubStart = 0 And FunctionStart > 0) Then
            subName = Mid(CodeOnTheFly, FunctionStart)
            subName = Split(subName, "Function ", , vbTextCompare)(1)
            subName = Split(subName, "(")(0)
        Else
            Stop
        End If
    Else
        subName = "NamelessCodeOnTheFly"
        ProcedureReplace module, "NamelessCodeOnTheFly", _
                "Function NamelessCodeOnTheFly()" & vbLf & _
                CodeOnTheFly & vbLf & _
                "End Function"
    End If

    If subName <> "NamelessCodeOnTheFly" Then
        Dim procEndLine As Long
        procEndLine = aProcedure.Init(ThisWorkbook, module, "RunCodeOnTheFly").Line_Last
        With module.CodeModule
            .DeleteLines procEndLine + 1, .CountOfLines - procEndLine
            .InsertLines .CountOfLines + 1, vbNewLine & CodeOnTheFly
        End With
    End If
    appRunOnTime Now + TimeSerial(0, 0, 1), subName
    Exit Sub
ErrorHandler:
    MsgBox "An error occured"
End Sub


'F_Userform_Controls	Module

Option Explicit

Function CreateOrSetFrame( _
                         Form As Object, _
                         Optional FrameName As String, _
                         Optional LTWH As Variant) As MSForms.Frame
    '@AssignedModule F_Userform_Controls
    Dim cFrame      As MSForms.Frame
    On Error Resume Next
    Set cFrame = Form.Controls(FrameName)
    On Error GoTo 0
    If cFrame Is Nothing Then
        If TypeName(Form) = "VBComponent" Then
            Set cFrame = Form.Designer.Controls.Add("Forms.Frame.1")
        Else
            Set cFrame = Form.Controls.Add("Forms.Frame.1")
        End If
    End If
    If Not IsMissing(FrameName) Then cFrame.Name = FrameName
    If Not IsMissing(LTWH) Then
        cFrame.Left = LTWH(0)
        cFrame.Top = LTWH(1)
        cFrame.Width = LTWH(2)
        cFrame.Height = LTWH(3)
    End If
    Set CreateOrSetFrame = cFrame
End Function

Function AvailableFormOrFrameRow( _
                                FormOrFrame As Object, _
                                Optional AfterWidth As Long = 0, _
                                Optional AfterHeight As Long = 0, _
                                Optional AddMargin As Long = 0) As Long
    '@LastModified 2307171805
    '@AssignedModule F_Userform_Controls
    Dim ctr         As MSForms.control
    Dim myHeight
    For Each ctr In FormOrFrame.Controls
        If ctr.Visible = True Then
            If ctr.Left >= AfterWidth And ctr.Top >= AfterHeight Then
                If ctr.Top + ctr.Height > myHeight Then myHeight = ctr.Top + ctr.Height
            End If
        End If
    Next
    AvailableFormOrFrameRow = myHeight + AddMargin    '6
End Function

Function AvailableFormOrFrameColumn( _
                                   FormOrFrame As Object, _
                                   Optional AfterWidth As Long = 0, _
                                   Optional AfterHeight As Long = 0, _
                                   Optional AddMargin As Long = 0) As Long
    '@LastModified 2307171805
    '@AssignedModule F_Userform_Controls
    Dim ctr         As MSForms.control
    Dim myWidth
    For Each ctr In FormOrFrame.Controls
        If ctr.Visible = True Then
            If ctr.Left >= AfterWidth And ctr.Top >= AfterHeight Then
                If ctr.Left + ctr.Width > myWidth Then myWidth = ctr.Left + ctr.Width
            End If
        End If
    Next
    AvailableFormOrFrameColumn = myWidth + AddMargin    '6
End Function

Sub AddFormControls( _
                   controlID As String, _
                   CountOrArrayOfNames As Variant, _
                   Optional Captions As Variant = 0, _
                   Optional Vertical As Boolean = True, _
                   Optional offset As Long = 0, _
                   Optional Form As Object)
    '@AssignedModule F_Userform_Controls
    '@INCLUDE PROCEDURE ActiveModule
    If IsNumeric(CountOrArrayOfNames) And IsArray(Captions) Then
        If UBound(Captions) + 1 <> CLng(CountOrArrayOfNames) Then Exit Sub
    End If
    Dim module      As VBComponent
    If Form Is Nothing Then
        Set module = ActiveModule
        If module.Type <> vbext_ct_MSForm Then Exit Sub
    End If
    Dim c           As MSForms.control
    Dim i           As Long
    If IsNumeric(CountOrArrayOfNames) Then
        For i = 1 To CLng(CountOrArrayOfNames)
            If Form Is Nothing Then
                Set c = module.Designer.Controls.Add(controlID)
            Else
                Set c = Form.Controls.Add(controlID)
            End If
            If Vertical Then
                c.Top = i * c.Height + i * 5 - c.Height
                c.Left = offset
            Else
                c.Top = offset
                c.Left = i * c.Width + i * 5 - c.Width
            End If
            If IsArray(Captions) Then
                c.Caption = Captions(i - 1)
            Else
                On Error Resume Next
                c.Caption = CountOrArrayOfNames(i - 1)
                If c.Caption = "" Then c.Caption = c.Name
                On Error GoTo 0
            End If
        Next
    Else
        For i = 1 To UBound(CountOrArrayOfNames) + 1
            If Form Is Nothing Then
                Set c = module.Designer.Controls.Add(controlID)
            Else
                Set c = Form.Controls.Add(controlID)
            End If
            If Vertical Then
                c.Top = i * c.Height + i * 5 - c.Height
                c.Left = offset
            Else
                c.Top = offset
                c.Left = i * c.Width + i * 5 - c.Width
            End If
            c.Name = CountOrArrayOfNames(i - 1)
            If IsArray(Captions) Then
                c.Caption = Captions(i - 1)
            Else
                On Error Resume Next
                c.Caption = CountOrArrayOfNames(i - 1)
                If c.Caption = "" Then c.Caption = c.Name
                On Error GoTo 0
            End If
        Next
    End If
End Sub

Sub AddMultipleControls( _
                       ControlTypes As Variant, _
                       Count As Long, _
                       Optional Vertical As Boolean = True, _
                       Optional Form As Object = Nothing)
    '@AssignedModule F_Userform_Controls
    '@INCLUDE PROCEDURE ActiveModule
    '@INCLUDE PROCEDURE AddFormControls
    Dim i           As Long
    For i = 1 To UBound(ControlTypes) + 1
        If Vertical Then
            AddFormControls CStr(ControlTypes(i - 1)), Count, , Vertical, i * 60 - 50, Form
        Else
            AddFormControls CStr(ControlTypes(i - 1)), Count, , Vertical, i * 20 - 20, Form
        End If
    Next
    Dim c           As MSForms.control
    On Error Resume Next
    If Form Is Nothing Then
        For Each c In ActiveModule.Designer.Controls
            If Not TypeName(c) Like "TextBox" Then c.AutoSize = True
        Next
    Else
        For Each c In Form.Controls
            If Not TypeName(c) Like "TextBox" Then c.AutoSize = True
        Next
    End If
End Sub


Public Sub flashControl(ctr As MSForms.control, blinkCount As Integer)
    Rem if blinkCount = odd then the control will become hidden
    '@AssignedModule F_Userform_Controls
    '@INCLUDE DECLARATION getTickCount
    Dim lngTime     As Long
    Dim i           As Integer
    If blinkCount Mod 2 <> 0 Then blinkCount = blinkCount + 1
    For i = 1 To blinkCount * 2
        lngTime = getTickCount
        If ctr.Visible = True Then
            ctr.Visible = False
        Else
            ctr.Visible = True
        End If
        DoEvents
        Do While getTickCount - lngTime < 200
        Loop
    Next
End Sub

Public Function TextOfControl(c As control) As Variant
    Rem Text of Textbox, Selection of Combobox, Selected items (2d) of Listbox
    '@AssignedModule F_Userform_Controls
    '@INCLUDE CLASS aCollection
    '@INCLUDE CLASS aListBox
    Dim out         As New Collection
    If TypeName(c) = "TextBox" Then
        If c.SelLength = 0 Then
            TextOfControl = c.TEXT
        Else
            TextOfControl = c.SelText
        End If
    ElseIf TypeName(c) = "ComboBox" Then
        If c.Style < 2 Then
            TextOfControl = c.TEXT
        Else
            TextOfControl = ""
        End If
    ElseIf TypeName(c) = "ListBox" Then
        Set out = aListBox.Init(c).SelectedValues
        If out.Count > 0 Then
            TextOfControl = aCollection.Init(out).ToArray
        Else
            TextOfControl = ""
        End If
    End If
End Function

'F_Userform	Module


Option Explicit
Option Compare Text

Rem @Subfolder Userforms>Transparent Declarations
Rem Private Declare PtrSafe Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long) As Long
#If VBA7 Then
Private Declare PtrSafe Function DrawMenuBar Lib "user32" (ByVal hwnd As Long) As Long
Private Declare PtrSafe Function SetLayeredWindowAttributes Lib "user32" (ByVal hwnd As Long, ByVal crKey As Long, ByVal bAlpha As Byte, ByVal dwFlags As Long) As Long
#Else
Private Declare Function DrawMenuBar Lib "user32" (ByVal hWnd As Long) As Long
Private Declare Function SetLayeredWindowAttributes Lib "user32" (ByVal hWnd As Long, ByVal crKey As Long, ByVal bAlpha As Byte, ByVal dwFlags As Long) As Long
#End If

Private Const GWL_STYLE As Long = (-16)
Private Const GWL_EXSTYLE As Long = (-20)
Private Const WS_CAPTION As Long = &HC00000
Private Const WS_EX_DLGMODALFRAME As Long = &H1

Private Const WS_EX_LAYERED = &H80000
Private Const LWA_COLORKEY = &H1
Private Const LWA_ALPHA = &H2

Private m_sngDownX  As Single
Private m_sngDownY  As Single

Rem Private Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Rem Private Declare PtrSafe Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long

Rem @Subfolder Userforms>Parent Declarations
Public Const FORMAT_MESSAGE_ALLOCATE_BUFFER = &H100
Public Const FORMAT_MESSAGE_ARGUMENT_ARRAY = &H2000
Public Const FORMAT_MESSAGE_FROM_HMODULE = &H800
Public Const FORMAT_MESSAGE_FROM_STRING = &H400
Public Const FORMAT_MESSAGE_FROM_SYSTEM = &H1000
Public Const FORMAT_MESSAGE_IGNORE_INSERTS = &H200
Public Const FORMAT_MESSAGE_MAX_WIDTH_MASK = &HFF
Public Const FORMAT_MESSAGE_TEXT_LEN = 160
Public Const MAX_PATH = 260
Public Const GWL_HWNDPARENT As Long = -8
Public Const GW_OWNER = 4

#If VBA7 Then
Private Declare PtrSafe Function GetWindowText Lib "user32.dll" Alias "GetWindowTextA" (ByVal hwnd As Long, ByVal lpString As String, ByVal cch As Long) As Long
Public Declare PtrSafe Function GetClassName Lib "user32" Alias "GetClassNameA" (ByVal hwnd As Long, ByVal lpClassName As String, ByVal nMaxCount As Long) As Long
Public Declare PtrSafe Function GetWindowLong Lib "user32.dll" Alias "GetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long) As Long
#Else
Private Declare Function GetWindowText Lib "user32.dll" Alias "GetWindowTextA" (ByVal hWnd As Long, ByVal lpString As String, ByVal cch As Long) As Long
Public Declare Function GetClassName Lib "user32" Alias "GetClassNameA" (ByVal hWnd As Long, ByVal lpClassName As String, ByVal nMaxCount As Long) As Long
Public Declare Function GetWindowLong Lib "user32.dll" Alias "GetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
#End If

Public VBEditorHWnd As Long
Public ApplicationHWnd As Long
Public ExcelDeskHWnd As Long
Public ActiveWindowHWnd As Long
Public UserFormHWnd As Long
Public WindowsDesktopHWnd As Long
Public Const GA_ROOT As Long = 2
Public Const GA_ROOTOWNER As Long = 3
Public Const GA_PARENT As Long = 1

#If VBA7 Then
Private Declare PtrSafe Function GetWindow Lib "user32" (ByVal hwnd As Long, ByVal wCmd As Long) As Long
Public Declare PtrSafe Function FindWindowEx Lib "user32" Alias "FindWindowExA" (ByVal hWnd1 As Long, ByVal hWnd2 As Long, ByVal lpsz1 As String, ByVal lpsz2 As String) As Long
Public Declare PtrSafe Function GetAncestor Lib "user32.dll" (ByVal hwnd As Long, ByVal gaFlags As Long) As Long
Public Declare PtrSafe Function GetDesktopWindow Lib "user32" () As Long
Public Declare PtrSafe Function GetParent Lib "user32.dll" (ByVal hwnd As Long) As Long
Public Declare PtrSafe Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
#Else
Private Declare Function GetWindow Lib "user32" (ByVal hWnd As Long, ByVal wCmd As Long) As Long
Public Declare Function FindWindowEx Lib "user32" Alias "FindWindowExA" (ByVal hWnd1 As Long, ByVal hWnd2 As Long, ByVal lpsz1 As String, ByVal lpsz2 As String) As Long
Public Declare Function GetAncestor Lib "user32.dll" (ByVal hWnd As Long, ByVal gaFlags As Long) As Long
Public Declare Function GetDesktopWindow Lib "user32" () As Long
Public Declare Function GetParent Lib "user32.dll" (ByVal hWnd As Long) As Long
Public Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
#End If

Public Const C_EXCEL_APP_WINDOWCLASS = "XLMAIN"
Public Const C_EXCEL_DESK_WINDOWCLASS = "XLDESK"
Public Const C_EXCEL_WINDOW_WINDOWCLASS = "EXCEL7"
Public Const USERFORM_WINDOW_CLASS = "ThunderDFrame"
Public Const C_VBA_USERFORM_WINDOWCLASS = "ThunderDFrame"

Rem Window position and more
Public Const SWP_NOMOVE = &H2
Public Const SWP_NOSIZE = &H1
Public Const HWND_TOP = 0
Public Const HWND_BOTTOM = 1
Public Const HWND_TOPMOST = -1
Public Const HWND_NOTOPMOST = -2

#If VBA7 Then
Public Declare PtrSafe Function SetWindowPos Lib "user32" (ByVal hwnd As LongPtr, ByVal hWndInsertAfter As LongPtr, ByVal X As LongPtr, ByVal Y As LongPtr, ByVal cx As LongPtr, ByVal cy As LongPtr, ByVal uFlags As LongPtr) As Long
#Else
Public Declare Function SetWindowPos Lib "user32" (ByVal hWnd As LongPtr, ByVal hWndInsertAfter As LongPtr, ByVal X As LongPtr, ByVal Y As LongPtr, ByVal cx As LongPtr, ByVal cy As LongPtr, ByVal uFlags As LongPtr) As Long
#End If

Rem ---
#If VBA7 Then
Public Declare PtrSafe Function SetParent Lib "user32" (ByVal hWndChild As LongPtr, ByVal hWndNewParent As LongPtr) As LongPtr
Public Declare PtrSafe Function SetForegroundWindow Lib "user32" (ByVal hwnd As LongPtr) As Long
Public Declare PtrSafe Function FormatMessage Lib "kernel32" Alias "FormatMessageA" (ByVal dwFlags As Long, lpSource As Any, ByVal dwMessageId As Long, ByVal dwLanguageId As Long, ByVal lpBuffer As String, ByVal nSize As Long, Arguments As LongPtr) As Long
#Else
Public Declare Function SetParent Lib "user32" (ByVal hWndChild As Long, ByVal hWndNewParent As Long) As Long
Public Declare Function SetForegroundWindow Lib "user32" (ByVal hwnd As Long) As Long
Public Declare Function FormatMessage Lib "kernel32.dll" Alias "FormatMessageA" (ByVal dwFlags As Long, ByRef lpSource As Any, ByVal dwMessageId As Long, ByVal dwLanguageId As Long, ByVal lpBuffer As String, ByVal nSize As Long, ByRef Arguments As Long) As Long
#End If

Rem Closeby
Public Enum CloseBy
    User = 0
    Code = 1
    WindowsOS = 2
    TaskManager = 3
End Enum

Rem FlashControl
#If VBA7 Then
Public Declare PtrSafe Function getTickCount Lib "kernel32" Alias "GetTickCount" () As Long
#Else
Public Declare Function getTickCount Lib "kernel32" Alias "GetTickCount" () As Long
#End If

Public Const black  As Long = &H80000012
Public Const red    As Long = &HFF&
Rem ControlID
Public Const ControlIDCheckBox = "Forms.CheckBox.1"
Public Const ControlIDComboBox = "Forms.ComboBox.1"
Public Const ControlIDCommandButton = "Forms.CommandButton.1"
Public Const ControlIDFrame = "Forms.Frame.1"
Public Const ControlIDImage = "Forms.Image.1"
Public Const ControlIDLabel = "Forms.Label.1"
Public Const ControlIDListBox = "Forms.ListBox.1"
Public Const ControlIDMultiPage = "Forms.MultiPage.1"
Public Const ControlIDOptionButton = "Forms.OptionButton.1"
Public Const ControlIDScrollBar = "Forms.ScrollBar.1"
Public Const ControlIDSpinButton = "Forms.SpinButton.1"
Public Const ControlIDTabStrip = "Forms.TabStrip.1"
Public Const ControlIDTextBox = "Forms.TextBox.1"
Public Const ControlIDToggleButton = "Forms.ToggleButton.1"

Rem other
#If VBA7 Then
Private Declare PtrSafe Function FindWindowA Lib "user32" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Private Declare PtrSafe Function GetWindowLongA Lib "user32" (ByVal hwnd As Long, ByVal nIndex As Long) As Long
Private Declare PtrSafe Function SetWindowLongA Lib "user32" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
#Else
Private Declare Function FindWindowA Lib "user32" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Private Declare Function GetWindowLongA Lib "user32" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
Private Declare Function SetWindowLongA Lib "user32" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
#End If

Rem userform hwnd
#If Win64 Then
Private Declare PtrSafe Function IUnknown_GetWindow Lib "shlwapi" Alias "#172" (ByVal pIUnk As IUnknown, ByVal hwnd As LongPtr) As Long
#Else
Private Declare Function IUnknown_GetWindow Lib "shlwapi" Alias "#172" (ByVal pIUnk As IUnknown, ByVal hwnd As Long) As Long
#End If


Public Function IsLoaded(FormName As String) As Boolean
    '@AssignedModule F_Userform
    Dim frm         As Object
    For Each frm In VBA.Userforms
        If frm.Name = FormName Then
            IsLoaded = True
            Exit Function
        End If
    Next frm
    IsLoaded = False
End Function

Sub UserformPersist(FormName As String)
    'In userform put:
    '
    'Private Sub UserForm_Initialize()
    '    setUserformLostStateTrue Me.name
    '    UserformPersist Me.name
    'End Sub
    '
    'Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    '    setUserformLostStateFalse Me.name
    'End Sub

    '@AssignedModule F_Userform
    '@INCLUDE PROCEDURE UserformLostState
    '@INCLUDE PROCEDURE setUserformLostStateTrue
    '@INCLUDE PROCEDURE setUserformLostStateFalse
    '@INCLUDE PROCEDURE ShowUserform
    '@INCLUDE PROCEDURE appRunOnTime

    appRunOnTime Now() + TimeSerial(0, 0, 5), "UserformPersist", FormName

    If UserformLostState(FormName) Then
        ShowUserform FormName
    Else
        On Error Resume Next
        Application.OnTime Now, "UserformPersist", , False
        On Error GoTo 0
    End If
End Sub

Function UserformLostState(FormName As String) As Boolean
    '@INCLUDE CreateOrSetSheet
    '@AssignedModule F_Userform
    '@INCLUDE PROCEDURE CreateOrSetSheet
    UserformLostState = CBool(CreateOrSetSheet(FormName & "_Settings", ThisWorkbook).Range("Z1").Value)
End Function

Sub setUserformLostStateTrue(FormName As String)
    '@INCLUDE CreateOrSetSheet
    '@AssignedModule F_Userform
    '@INCLUDE PROCEDURE CreateOrSetSheet
    CreateOrSetSheet(FormName & "_Settings", ThisWorkbook).Range("Z1").Value = True
End Sub

Sub setUserformLostStateFalse(FormName As String)
    '@INCLUDE CreateOrSetSheet
    '@AssignedModule F_Userform
    '@INCLUDE PROCEDURE CreateOrSetSheet
    CreateOrSetSheet(FormName & "_Settings", ThisWorkbook).Range("Z1").Value = False
End Sub

Rem var
Public Sub ShowUserform(FormName As String)
    '@INCLUDE IsLoaded
    '@AssignedModule F_Userform
    Dim frm         As Object
    If IsLoaded(FormName) = True Then
        For Each frm In VBA.Userforms
            If frm.Name = FormName Then
                On Error Resume Next
                frm.Show
                Exit Sub
            End If
        Next frm
    Else
        Dim oUserForm As Object
        On Error GoTo Err
        Set oUserForm = Userforms.Add(FormName)
        oUserForm.Show    '(vbModeless)
        Exit Sub
    End If
Err:
    Select Case Err.Number
        Case 424:
            Debug.Print "The Userform with the name " & FormName & " was not found.", vbExclamation, "Load userforn by name"
        Case Else:
            Debug.Print Err.Number & ": " & Err.Description, vbCritical, "Load userforn by name"
    End Select
End Sub


Public Sub Reframe(Form As Object, control As MSForms.control)
    'TODO obsolete, replaced with amultipage.init(..).buildmenu
    Dim c           As MSForms.control
    For Each c In Form.Controls
        If TypeName(c) = "Frame" Then
            If Not InStr(1, c.Tag, "skip", vbTextCompare) > 0 Then
                If c.Name <> control.Parent.Parent.Name Then c.Visible = False
            End If
        End If
    Next
    Form.Controls(control.Caption).Visible = True
    For Each c In Form.Controls
        If TypeName(c) = "Label" Then
            If Not InStr(1, c.Tag, "skip", vbTextCompare) > 0 Then
                c.BackColor = &H534848
            End If
        End If
    Next
    control.BackColor = &H80B91E
End Sub

'vbArcImports	Module

Option Explicit

Enum MyColors
    FormBackgroundDarkGray = 4208182        ' BACKGROUND DARK GRAY
    FormSidebarMediumGray = 5457992        ' TILE COLORS LIGHTER GRAY
    FormSidebarMouseOverLightGray = &H808080        ' lighter light gray
    FormSelectedGreen = 8435998        ' green tile
End Enum

Public Type tCursor
    Left            As Long
    Top             As Long
End Type

Public Const LOGPIXELSX = 88
Public Const LOGPIXELSY = 90

#If VBA7 Then
    Public Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
    Private Declare PtrSafe Function InternetGetConnectedState Lib "wininet.dll" (ByRef dwFlags As Long, ByVal dwReserved As Long) As Long
    Public Declare PtrSafe Sub mouse_event Lib "user32" (ByVal dwFlags As Long, ByVal dX As Long, ByVal dy As Long, ByVal cbuttons As Long, ByVal dwExtraInfo As Long)
    Public Declare PtrSafe Function GetAsyncKeyState Lib "user32" (ByVal vKey As Long) As Integer
    Public Declare PtrSafe Function ClientToScreen Lib "user32" (ByVal hwnd As Long, lpPoint As tCursor) As Long
    Public Declare PtrSafe Function GetCursorPos Lib "user32" (p As tCursor) As Long
    Public Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    Public Declare PtrSafe Function GetDC Lib "user32" (ByVal hwnd As Long) As Long
    Public Declare PtrSafe Function GetDeviceCaps Lib "gdi32" (ByVal hdc As Long, ByVal nIndex As Long) As Long
    Public Declare PtrSafe Function ReleaseDC Lib "user32" (ByVal hwnd As Long, ByVal hdc As Long) As Long
    Public Declare PtrSafe Function SetCursorPos Lib "user32" (ByVal X As Long, ByVal Y As Long) As Long
#Else
    Public Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
    Private Declare Function InternetGetConnectedState Lib "wininet.dll" (ByRef dwFlags As Long, ByVal dwReserved As Long) As Long
    Public Declare Sub mouse_event Lib "user32" (ByVal dwFlags As Long, ByVal dX As Long, ByVal dy As Long, ByVal cbuttons As Long, ByVal dwExtraInfo As Long)
    Public Declare Function GetAsyncKeyState Lib "user32" (ByVal vKey As Long) As Integer
    public Declare Function ClientToScreen Lib "user32" (ByVal hWnd As Long, lpPoint As tCursor) As Long
    public Declare Function GetCursorPos Lib "user32" (p As tCursor) As Long
    Public Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    Public Declare Function GetDC Lib "user32" (ByVal hWnd As Long) As Long
    Public Declare Function GetDeviceCaps Lib "gdi32" (ByVal hdc As Long, ByVal nIndex As Long) As Long
    Public Declare Function ReleaseDC Lib "user32" (ByVal hWnd As Long, ByVal hdc As Long) As Long
    Public Declare Function SetCursorPos Lib "user32" (ByVal X As Long, ByVal Y As Long) As Long
#End If


Rem DspErrMsg Constants and Variables
Global Const success        As Boolean = True
Global Const Failure        As Boolean = False
Global Const NoError        As Long = 0
Global Const LogError       As Long = 997
Global Const RtnError       As Long = 998
Global Const DspError       As Long = 999
Public bLogOnly     As Boolean
Public bDebug       As Boolean

Rem timer constants
Public Const mblncTimer As Boolean = True
Public mvarTimerName
Public mvarTimerStart

Function CanCreateAndEditWorksheet() As Boolean
    Dim ws As Worksheet
    Dim canCreate As Boolean
    Dim canEdit As Boolean
    Application.ScreenUpdating = False
    ' Try to create a new worksheet
    On Error Resume Next
    Set ws = ThisWorkbook.Worksheets.Add
    On Error GoTo 0
    
    If Not ws Is Nothing Then
        ' You can create a worksheet
        canCreate = True
        ' Try to edit the new worksheet
        On Error Resume Next
        ws.Cells(1, 1).Value = "Test"
        ws.rows(1).Delete
        If Err.Number = 0 Then
            ' You can edit the worksheet
            canEdit = True
        End If
        On Error GoTo 0
        ' Delete the new worksheet
        Application.DisplayAlerts = False
        ws.Delete
        Application.DisplayAlerts = True
    End If
    Application.ScreenUpdating = False
    ' Check if you can create and edit the worksheet
    CanCreateAndEditWorksheet = canCreate And canEdit
End Function

Sub FolderDelete(targetFolder As String)
'@LastModified 2310251324
'@INCLUDE PROCEDURE FolderExists
    Dim FSO
    Set FSO = CreateObject("Scripting.FileSystemObject")
    targetFolder = targetFolder
    If Right(targetFolder, 1) = "\" Then targetFolder = Left(targetFolder, Len(targetFolder) - 1)
    'Delete specified folder
    If FSO.FolderExists(targetFolder) Then FSO.DeleteFolder targetFolder
'    'Delete all subfolders
'    FSO.DeleteFolder targetFolder & "\*"
End Sub

Public Sub ArraySortByLength(list As Variant, first As Long, last As Long)
    '@INCLUDE PROCEDURE ArraySortByLengthHelper
    Dim Pivot As String
    Dim Low As Long
    Dim High As Long
    Low = first
    High = last
    Pivot = list((first + last) \ 2)
    Do While Low <= High
        Do While Low < last And ArraySortByLengthHelper(list(Low), Pivot)
            Low = Low + 1
        Loop
        Do While High > first And ArraySortByLengthHelper(Pivot, list(High))
            High = High - 1
        Loop
        If Low <= High Then
            Dim Swap As String
            Swap = list(Low)
            list(Low) = list(High)
            list(High) = Swap
            Low = Low + 1
            High = High - 1
        End If
    Loop
    If (first < High) Then ArraySortByLength list, first, High
    If (Low < last) Then ArraySortByLength list, Low, last
End Sub

Private Function ArraySortByLengthHelper(one As Variant, two As Variant) As Boolean
    Select Case True
    Case Len(one) < Len(two)
        ArraySortByLengthHelper = True
    Case Len(one) > Len(two)
        ArraySortByLengthHelper = False
    Case Len(one) = Len(two)
        ArraySortByLengthHelper = LCase$(one) < LCase$(two)
    End Select
End Function

Function RandomStringArray(ByVal rowCount As Long, ByVal columnCount As Long, maxStringLength) As Variant
    '@AssignedModule vbArcImports
    Dim resultArray() As Variant
    ReDim resultArray(1 To rowCount, 1 To columnCount)

    Dim i As Long, j As Long
    Dim alphabet    As String
    alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"

    ' Seed the random number generator
    Randomize

    ' Generate random strings
    For i = 1 To rowCount
        For j = 1 To columnCount
            Dim randomString As String
            randomString = ""

            ' Length of each random string (you can adjust as needed)
            Dim stringLength As Long
            stringLength = WorksheetFunction.RandBetween(1, maxStringLength)

            Dim k   As Long
            For k = 1 To stringLength
                ' Generate a random index to pick a character from the alphabet
                Dim randomIndex As Long
                randomIndex = Int((Len(alphabet) * Rnd) + 1)

                ' Append the random character to the string
                randomString = randomString & Mid(alphabet, randomIndex, 1)
            Next k

            resultArray(i, j) = randomString
        Next j
    Next i

    RandomStringArray = resultArray
End Function

'* Modified   : Date and Time       Author              Description
'* Updated    : 21-07-2023 11:49    Alex                (ArrayFilter2D)

Function ArrayFilter2D(inputArray As Variant, matchString As String, Optional targetColumn As Long = -1) As Variant
    '@LastModified 2307211149
    '@INCLUDE PROCEDURE ArraySubSet
    '@AssignedModule vbArcImports
    Dim numRows As Long, numCols As Long
    numRows = UBound(inputArray, 1)
    numCols = UBound(inputArray, 2)

    Dim resultArray() As Variant
    Dim resultIndex As Long
    ReDim resultArray(LBound(inputArray, 1) To numRows, LBound(inputArray, 2) To numCols)
    resultIndex = LBound(resultArray, 1) - 1

    Dim i As Long, j As Long
    For i = LBound(resultArray, 1) To numRows
        Dim rowMatches As Boolean
        rowMatches = False

        If targetColumn = -1 Then
            ' Match any cell in the row using Like operator (case-insensitive)
            For j = LBound(resultArray, 2) To numCols
                If LCase(inputArray(i, j)) Like "*" & LCase(matchString) & "*" Then
                    rowMatches = True
                    Exit For
                End If
            Next j
        ElseIf targetColumn >= LBound(resultArray, 2) And targetColumn <= numCols Then
            ' Match the specified column using Like operator (case-insensitive)
            If LCase(inputArray(i, targetColumn)) Like "*" & LCase(matchString) & "*" Then
                rowMatches = True
            End If
        End If

        ' Copy the matching row to the result array
        If rowMatches Then
            resultIndex = resultIndex + 1
            For j = LBound(resultArray, 2) To numCols
                resultArray(resultIndex, j) = inputArray(i, j)
            Next j
        End If
    Next i

    ' Resize the result array to remove any empty rows
    If resultIndex = -1 Then
        ArrayFilter2D = Array()
    Else
        resultArray = ArraySubSet(resultArray, LBound(resultArray, 1), LBound(resultArray, 2), resultIndex, numCols)
        ' Return the filtered array
        ArrayFilter2D = resultArray
    End If
End Function

Sub PrintConditionalFormatting(TargetWorksheet As Worksheet)
    '@AssignedModule vbArcImports
    '@INCLUDE PROCEDURE ArrayCombine
    '@INCLUDE PROCEDURE ArrayToStringTable
    '@INCLUDE PROCEDURE dp
    Dim ws          As Worksheet
    Dim CFrule      As FormatCondition
    Dim Output()
    ReDim Output(1 To 1, 1 To 4)
    Dim i           As Long
    For i = 1 To 4
        Output(1, i) = Choose(i, "Sheet", "Formula", "Range", "Fill")
    Next
    Dim arr(1 To 1, 1 To 4)

    For Each CFrule In TargetWorksheet.Cells.FormatConditions
        For i = 1 To 4

            arr(1, i) = Choose(i, _
                    TargetWorksheet.Name, _
                    "'" & CFrule.Formula1, _
                    CFrule.AppliesTo.Address, _
                    CFrule.Interior.color)



        Next
        ArrayCombine Output, arr, True
    Next CFrule
    dp ArrayToStringTable(Output)
End Sub

Public Function ArraySubSet(vIn As Variant, Optional ByVal iStartRow As Integer = -1, Optional ByVal iStartCol As Integer = -1, Optional ByVal iHeight As Integer = -1, Optional ByVal iWidth As Integer = -1) As Variant
    '@LastModified 2307201044
    '@AssignedModule vbArcImports
    Dim vReturn     As Variant
    Dim iInRowLower As Integer
    Dim iInRowUpper As Integer
    Dim iInColLower As Integer
    Dim iInColUpper As Integer
    Dim iEndRow     As Integer
    Dim iEndCol     As Integer
    Dim irow        As Integer
    Dim iCol        As Integer

    iInRowLower = LBound(vIn, 1)
    iInRowUpper = UBound(vIn, 1)
    iInColLower = LBound(vIn, 2)
    iInColUpper = UBound(vIn, 2)

    If iStartRow = -1 Then
        iStartRow = iInRowLower
    End If
    If iStartCol = -1 Then
        iStartCol = iInColLower
    End If

    If iHeight = -1 Then
        iHeight = iInRowUpper - iStartRow + 1
    End If
    If iWidth = -1 Then
        iWidth = iInColUpper - iStartCol + 1
    End If

    iEndRow = iStartRow + iHeight - IIf(iStartRow = 0, 0, 1)
    iEndCol = iStartCol + iWidth - IIf(iStartCol = 0, 0, 1)

    ReDim vReturn(iStartRow To iEndRow, iStartCol To iEndCol)

    For irow = iStartRow To iEndRow
        For iCol = iStartCol To iEndCol
            vReturn(irow, iCol) = vIn(irow, iCol)
        Next
    Next

    ArraySubSet = vReturn
End Function

Public Function ArrayCombine(ByRef a As Variant, b As Variant, Optional stacked As Boolean = True) As Boolean
    'assumes that A and B are 2-dimensional variant arrays
    'if stacked is true then A is placed on top of B    in this case the number of rows must be the same,
    'otherwise they are placed side by side A|B         in which case the number of columns are the same
    'LBound can be anything but is assumed to be the SAME for A and B (in both dimensions)
    '@AssignedModule vbArcImports

    'False is returned if a clash, so use: If not arraycombe(a,b,true) then goto errorHandler

    Dim LB As Long, m_A As Long, n_A As Long
    Dim m_B As Long, n_B As Long
    Dim M As Long, N As Long
    Dim i As Long, j As Long, k As Long
    Dim c           As Variant

    If TypeName(a) = "Range" Then a = a.Value
    If TypeName(b) = "Range" Then b = b.Value

    LB = LBound(a, 1)
    m_A = UBound(a, 1)
    n_A = UBound(a, 2)
    m_B = UBound(b, 1)
    n_B = UBound(b, 2)

    If stacked Then
        M = m_A + m_B + 1 - LB
        N = n_A
        If n_B <> N Then
            ArrayCombine = False
            Exit Function
        End If
    Else
        M = m_A
        If m_B <> M Then
            ArrayCombine = False
            Exit Function
        End If
        N = n_A + n_B + 1 - LB
    End If

    ReDim c(LB To M, LB To N)
    For i = LB To M
        For j = LB To N
            If stacked Then
                If i <= m_A Then
                    c(i, j) = a(i, j)
                Else
                    c(i, j) = b(LB + i - m_A - 1, j)
                End If
            Else
                If j <= n_A Then
                    c(i, j) = a(i, j)
                Else
                    c(i, j) = b(i, LB + j - n_A - 1)
                End If
            End If
        Next j
    Next i
    a = c

End Function

Public Function ArrayToStringTable(ByVal Hairetu, Optional HyoujiMaxNagasa%, Optional SikiriMoji$ = "|") As String
    'https://gist.github.com/YujiFukami/15c922d41ff06c9b12ad450a14131080#file-
    '@AssignedModule vbArcImports
    '@INCLUDE PROCEDURE ShortenToByteCharacters
    Dim i&, j&, k&, M&, N&
    Dim TateMin&, TateMax&, YokoMin&, YokoMax&
    Dim WithTableHairetu
    Dim NagasaList, MaxNagasaList
    Dim NagasaOnajiList
    Dim OutputList
    '    Const SikiriMoji$ = "|"
    Dim Jigen2%
    On Error Resume Next
    Jigen2 = UBound(Hairetu, 2)
    '    On Error GoTo 0
    If Jigen2 = 0 Then
        Hairetu = Application.Transpose(Hairetu)
    End If
    TateMin = LBound(Hairetu, 1)
    TateMax = UBound(Hairetu, 1)
    YokoMin = LBound(Hairetu, 2)
    YokoMax = UBound(Hairetu, 2)
    ReDim WithTableHairetu(1 To TateMax - TateMin + 1 + 1, 1 To YokoMax - YokoMin + 1 + 1)
    For i = 1 To TateMax - TateMin + 1
        WithTableHairetu(i + 1, 1) = TateMin + i - 1
        For j = 1 To YokoMax - YokoMin + 1
            WithTableHairetu(1, j + 1) = YokoMin + j - 1
            WithTableHairetu(i + 1, j + 1) = Hairetu(i - 1 + TateMin, j - 1 + YokoMin)
        Next j
    Next i
    N = UBound(WithTableHairetu, 1)
    M = UBound(WithTableHairetu, 2)
    ReDim NagasaList(1 To N, 1 To M)
    ReDim MaxNagasaList(1 To M)
    Dim tmpStr$
    For j = 1 To M
        For i = 1 To N
            If j > 1 And HyoujiMaxNagasa <> 0 Then
                tmpStr = WithTableHairetu(i, j)
                WithTableHairetu(i, j) = ShortenToByteCharacters(tmpStr, HyoujiMaxNagasa)
            End If
            NagasaList(i, j) = LenB(StrConv(WithTableHairetu(i, j), vbFromUnicode))
            MaxNagasaList(j) = WorksheetFunction.Max(MaxNagasaList(j), NagasaList(i, j))
        Next i
    Next j
    ReDim NagasaOnajiList(1 To N, 1 To M)
    Dim TmpMaxNagasa&
    For j = 1 To M
        TmpMaxNagasa = MaxNagasaList(j)
        For i = 1 To N
            NagasaOnajiList(i, j) = WithTableHairetu(i, j) & WorksheetFunction.Rept(" ", TmpMaxNagasa - NagasaList(i, j))
        Next i
    Next j
    ReDim OutputList(1 To N)
    For i = 1 To N
        For j = 1 To M
            If j = 1 Then
                OutputList(i) = NagasaOnajiList(i, j)
            Else
                OutputList(i) = OutputList(i) & SikiriMoji & NagasaOnajiList(i, j)
            End If
        Next j
    Next i
    ArrayToStringTable = Join(OutputList, vbNewLine)
End Function

Public Function isUserform(obj As Object) As Boolean
    '@AssignedModule vbArcImports
    '@INCLUDE PROCEDURE UserformNames
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aModules
    Dim formNames   As New Collection
    Set formNames = aModules.Init(ThisWorkbook).UserformNames
    Dim FormName
    For Each FormName In formNames
        If FormName = obj.Name Then
            isUserform = True
            Exit For
        End If
    Next
End Function
Function IsFileFolderURL(path) As String
    '@AssignedModule vbArcImports
    '@INCLUDE PROCEDURE FileExists
    '@INCLUDE PROCEDURE FolderExists
    '@INCLUDE PROCEDURE URLExists
    Dim RetVal      As String
    RetVal = "I"
    If (RetVal = "I") And FileExists(path) Then RetVal = "F"
    If (RetVal = "I") And FolderExists(path) Then RetVal = "D"
    If (RetVal = "I") And URLExists(path) Then RetVal = "U"
    ' I => Invalid | F => File | D => Directory | U => Valid Url
    IsFileFolderURL = RetVal
End Function

Public Function PadRight(ByVal str As String, ByVal Length As Long, Optional Character As String = " ", Optional RemoveExcess As Boolean)
    '@AssignedModule vbArcImports
    If Len(str) < Length Then
        PadRight = str & String$(Length - Len(str), Character)
    ElseIf RemoveExcess = True Then
        PadRight = Left$(str, Length)
    Else
        PadRight = str
    End If
End Function

Public Function PadLeft(ByVal str As String, ByVal Length As Long, Optional Character As String = " ", Optional RemoveExcess As Boolean)
    '@AssignedModule vbArcImports
    If Len(str) < Length Then
        PadLeft = String$(Length - Len(str), Character) + str
    ElseIf RemoveExcess = True Then
        PadLeft = Right$(str, Length)
    Else
        PadLeft = str
    End If
End Function

Public Function aSwitch(checkThis, ParamArray OptionPairs() As Variant)
    '@LastModified 2307171814
    '@AssignedModule vbArcImports
    Dim i           As Long
    For i = LBound(OptionPairs) To UBound(OptionPairs) Step 2
        If UCase(checkThis) = UCase(OptionPairs(i)) Then
            aSwitch = OptionPairs(i + 1)
            Exit Function
        End If
    Next
End Function

Sub test_ArrayReplace()
    Dim arr
    arr = Selection.Value
    ArrayReplace arr, 1, 2
    dp arr
End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 25-10-2023 14:33    Alex                (vbArcImports.bas > ArrayReplace) ok for 2d, added start/end Row/Column

Sub ArrayReplace( _
                    ByRef inputArray As Variant, _
                    this As String, _
                    That As String, _
                        Optional startSearchAt As Long = 1, _
                        Optional countChanges As Long = -1, _
                        Optional compareMethod As VbCompareMethod = vbTextCompare, _
                        Optional StartRow As Long, _
                        Optional StartCol As Long, _
                        Optional rowCount As Long = -1, _
                        Optional colCount As Long = -1)
'@LastModified 2310251433
    If StartRow = 0 Then StartRow = LBound(inputArray, 1)
    If StartCol = 0 Then StartCol = LBound(inputArray, 2)
    
    Dim endRow As Long
    If rowCount = -1 Then endRow = UBound(inputArray, 1) - LBound(inputArray, 1) + 1
    Dim endCol As Long
    If colCount = -1 Then endCol = UBound(inputArray, 2) - LBound(inputArray, 2) + 1
    
    Dim X As Long, Y As Long
    For X = StartRow To endRow
        For Y = StartCol To endCol
            inputArray(X, Y) = Replace(inputArray(X, Y), this, That, startSearchAt, countChanges, compareMethod)
        Next
    Next
    
End Sub

Public Sub ArraySort(vArray As Variant, Optional inLow As Long = -1, Optional inHi As Long = -1)
    '@BlogPosted
    '@AssignedModule vbArcImports
'    If inLow = -1 Then inLow = LBound(vArray)
'    If inHi = -1 Then inHi = UBound(vArray)
    Dim Pivot       As Variant
    Dim tmpSwap     As Variant
    Dim tmpLow      As Long
    Dim tmpHi       As Long
    tmpLow = inLow
    tmpHi = inHi
    Pivot = vArray((inLow + inHi) \ 2)
    While (tmpLow <= tmpHi)
        While (vArray(tmpLow) < Pivot And tmpLow < inHi)
            tmpLow = tmpLow + 1
        Wend
        While (Pivot < vArray(tmpHi) And tmpHi > inLow)
            tmpHi = tmpHi - 1
        Wend
        If (tmpLow <= tmpHi) Then
            tmpSwap = vArray(tmpLow)
            vArray(tmpLow) = vArray(tmpHi)
            vArray(tmpHi) = tmpSwap
            tmpLow = tmpLow + 1
            tmpHi = tmpHi - 1
        End If
    Wend
    If (inLow < tmpHi) Then ArraySort vArray, inLow, tmpHi
    If (tmpLow < inHi) Then ArraySort vArray, tmpLow, inHi
End Sub
Sub appRunOnTime(timeToRun, macroToRun As String, Optional arg1, Optional arg2, Optional arg3, Optional arg4, Optional arg5)
    '@LastModified 2305250729
    '@AssignedModule vbArcImports

    If TypeName(arg5) <> "Error" Then
        Application.OnTime timeToRun, "'" & macroToRun & """" & arg1 & """ ,""" & arg2 & """ ,""" & arg3 & """ ,""" & arg4 & """ ,""" & arg5 & " '"
    ElseIf TypeName(arg4) <> "Error" Then
        Application.OnTime timeToRun, "'" & macroToRun & """" & arg1 & """ ,""" & arg2 & """ ,""" & arg3 & """ ,""" & arg4 & " '"
    ElseIf TypeName(arg3) <> "Error" Then
        Application.OnTime timeToRun, "'" & macroToRun & """" & arg1 & """ ,""" & arg2 & """ ,""" & arg3 & " '"
    ElseIf TypeName(arg2) <> "Error" Then
        Application.OnTime timeToRun, "'" & macroToRun & """" & arg1 & """ ,""" & arg2 & " '"
    ElseIf TypeName(arg1) <> "Error" Then
        Application.OnTime timeToRun, "'" & macroToRun & """" & arg1 & """ '"
    Else
        Application.OnTime timeToRun, macroToRun
    End If
End Sub

Sub appRun(ProcedureName As String, Optional TargetWorkbook As Workbook, Optional arg1, Optional arg2, Optional arg3, Optional arg4, Optional arg5, Optional arg6, Optional arg7, Optional arg8, Optional arg9, Optional arg10)
    '@LastModified 2305250729
    '@INCLUDE PROCEDURE ActiveCodepaneWorkbook
    '@AssignedModule vbArcImports
    If TypeName(TargetWorkbook) = "Nothing" Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim WorkbookName As String
    WorkbookName = "'" & TargetWorkbook.Name & "'!"

    If TypeName(arg10) <> "Error" Then
        Application.Run WorkbookName & ProcedureName, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10
    ElseIf TypeName(arg9) <> "Error" Then
        Application.Run WorkbookName & ProcedureName, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9
    ElseIf TypeName(arg8) <> "Error" Then
        Application.Run WorkbookName & ProcedureName, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8
    ElseIf TypeName(arg7) <> "Error" Then
        Application.Run WorkbookName & ProcedureName, arg1, arg2, arg3, arg4, arg5, arg6, arg7
    ElseIf TypeName(arg6) <> "Error" Then
        Application.Run WorkbookName & ProcedureName, arg1, arg2, arg3, arg4, arg5, arg6
    ElseIf TypeName(arg5) <> "Error" Then
        Application.Run WorkbookName & ProcedureName, arg1, arg2, arg3, arg4, arg5
    ElseIf TypeName(arg4) <> "Error" Then
        Application.Run WorkbookName & ProcedureName, arg1, arg2, arg3, arg4
    ElseIf TypeName(arg3) <> "Error" Then
        Application.Run WorkbookName & ProcedureName, arg1, arg2, arg3
    ElseIf TypeName(arg2) <> "Error" Then
        Application.Run WorkbookName & ProcedureName, arg1, arg2
    ElseIf TypeName(arg1) <> "Error" Then
        Application.Run WorkbookName & ProcedureName, arg1
    Else: Application.Run WorkbookName & ProcedureName
    End If
End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 26-10-2023 01:06    Alex                (vbArcImports.bas > InputboxString : )

Function InputboxString(Optional sTitle As String = "Select String", Optional sPrompt As String = "Select String", Optional DefaultValue = "") As String
'@LastModified 2310260106
    '@AssignedModule vbArcImports
    Dim stringVariable As String
    stringVariable = Application.InputBox( _
            Title:=sTitle, _
            Prompt:=sPrompt, _
            Type:=2, _
            Default:=DefaultValue)
    InputboxString = IIf(CStr(stringVariable) <> "False", CStr(stringVariable), "")
End Function

Function LoopThroughFiles(Folder, criteria) As Collection
    '@AssignedModule vbArcImports
    If Right(Folder, 1) <> "\" Then Folder = Folder & "\"
    Dim out         As Collection: Set out = New Collection
    Dim strFile     As String
    strFile = Dir(Folder & criteria)
    Do While Len(strFile) > 0
        out.Add strFile
        strFile = Dir
    Loop
    Set LoopThroughFiles = out
End Function

Function ModuleOfWorksheet(TargetSheet As Worksheet) As VBComponent
    '@LastModified 2305231030
    '@AssignedModule vbArcImports
    Set ModuleOfWorksheet = TargetSheet.Parent.VBProject.VBComponents(TargetSheet.codeName)
End Function

Rem This displays a message box formatted
'based on what the Err object contains and if we want to put our project in debug mode.
'It returns the button the user clicks: vbAbort, vbCancel, vbIgnore, vbRetry

Public Function DspErrMsg(ByVal sRoutineName As String, _
        Optional ByVal sAddText As String = "") As VbMsgBoxResult
    '@AssignedModule vbArcImports
    '@INCLUDE DECLARATION bDebug
    '@INCLUDE DECLARATION bLogOnly
    If bLogOnly Then
        Debug.Print Now(), ThisWorkbook.Name & "!" & sRoutineName, Err.Description, sAddText
    Else
        DspErrMsg = MsgBox( _
                Prompt:="Error#" & Err.Number & vbLf & Err.Description & vbLf & sAddText, _
                Buttons:=IIf(bDebug, vbAbortRetryIgnore, vbCritical) + _
                IIf(Err.Number < 1, 0, vbMsgBoxHelpButton), _
                Title:=sRoutineName, _
                HelpFile:=Err.HelpFile, _
                Context:=Err.HelpContext)
    End If
End Function

Public Function StartTimer(TimerName)
    '@AssignedModule vbArcImports
    '@INCLUDE DECLARATION mblncTimer
    On Error GoTo ERR_HANDLER
    If mblncTimer Then
        mvarTimerName = TimerName
        mvarTimerStart = Timer
    End If
    On Error Resume Next
    Exit Function
ERR_HANDLER:
    MsgBox Err.Number & " " & Err.Description, vbCritical, "StartTimer()"
End Function

Public Function EndTimer()
    '@AssignedModule vbArcImports
    '@INCLUDE PROCEDURE FoldersCreate
    '@INCLUDE PROCEDURE TxtAppend
    '@INCLUDE DECLARATION mblncTimer
    On Error GoTo ERR_HANDLER
    Dim strFile     As String
    Dim strContent  As String
    If mblncTimer Then
        Dim strPath As String
        strPath = Environ$("USERPROFILE") & "\Documents\vbArc\Timers\"
        FoldersCreate strPath
        strFile = strPath & mvarTimerName & ".txt"
        Rem strFile = ThisWorkbook.path & "\" _
            & Left(ThisWorkbook.Name, InStr(1, ThisWorkbook.Name, ".") - 1) _
            & "TimerLog.txt"
        If Len(Dir(strFile)) = 0 Then
            strContent = _
                    "Timestamp" & vbTab & vbTab & vbTab & vbTab & _
                    "ElapsedTime" & vbTab & vbTab & _
                    "TimerName"
            TxtAppend strFile, strContent
        End If
        strContent = Now() & vbTab & vbTab & _
                Format(Timer - mvarTimerStart, "0.00") & vbTab & vbTab & vbTab & _
                mvarTimerName
        TxtAppend strFile, strContent
    End If
    On Error Resume Next
    Exit Function
ERR_HANDLER:
    MsgBox Err.Number & " " & Err.Description, vbCritical, "EndTimer()"
End Function

Function GetInputRange(ByRef rInput As Excel.Range, _
        sPrompt As String, _
        sTitle As String, _
        Optional ByVal sDefault As String, _
        Optional ByVal bActivate As Boolean, _
        Optional X, _
        Optional Y) As Boolean
    '@AssignedModule vbArcImports

    'assigns range to variable passed
    'GetInputRange(rng, "Range picker", "Select range to output listbox' list") = False Then Exit Sub
    Dim bGotRng     As Boolean
    Dim bEvents     As Boolean
    Dim nAttempt    As Long
    Dim sAddr       As String
    Dim vReturn
    On Error Resume Next
    If Len(sDefault) = 0 Then
        If TypeName(Application.Selection) = "Range" Then
            sDefault = "=" & Application.Selection.Address
            If Len(sDefault) > 240 Then
                sDefault = "=" & Application.ActiveCell.Address
            End If
        ElseIf TypeName(Application.ActiveSheet) = "Chart" Then
            sDefault = " first select a Worksheet"
        Else
            sDefault = " Select Cell(s) or type address"
        End If
    End If
    Set rInput = Nothing
    For nAttempt = 1 To 3
        vReturn = False
        vReturn = Application.InputBox(sPrompt, sTitle, sDefault, X, Y, Type:=0)
        If False = vReturn Or Len(vReturn) = 0 Then
            Exit For
        Else
            sAddr = vReturn
            If Left$(sAddr, 1) = "=" Then sAddr = Mid$(sAddr, 2, 256)
            If Left$(sAddr, 1) = Chr(34) Then sAddr = Mid$(sAddr, 2, 255)
            If Right$(sAddr, 1) = Chr(34) Then sAddr = Left$(sAddr, Len(sAddr) - 1)
            Set rInput = Application.Range(sAddr)
            If rInput Is Nothing Then
                sAddr = Application.ConvertFormula(sAddr, xlR1C1, xlA1)
                Set rInput = Application.Range(sAddr)
                bGotRng = Not rInput Is Nothing
            Else
                bGotRng = True
            End If
        End If
        If bGotRng Then
            If bActivate Then
                On Error GoTo ErrH
                bEvents = Application.EnableEvents
                Application.EnableEvents = False
                If Not Application.ActiveWorkbook Is rInput.Parent.Parent Then
                    rInput.Parent.Parent.Activate
                End If
                If Not Application.ActiveSheet Is rInput.Parent Then
                    rInput.Parent.Activate
                End If
                rInput.Select
            End If
            Exit For
        ElseIf nAttempt < 3 Then
            If MsgBox("Invalid reference, do you want to try again ?", _
                    vbOKCancel, sTitle) <> vbOK Then
                Exit For
            End If
        End If
    Next
CLEANUP:
    On Error Resume Next
    If bEvents Then
        Application.EnableEvents = True
    End If
    GetInputRange = bGotRng
    Exit Function
ErrH:
    Set rInput = Nothing
    bGotRng = False
    Resume CLEANUP
End Function
Public Function ArrayContains( _
        ByVal value1 As Variant, _
        ByVal array1 As Variant, _
        Optional CaseSensitive As Boolean) _
        As Boolean
    '@Description: This function checks if a value is in an array
    '@Author: Anthony Mancini
    '@Version: 1.0.0
    '@License: MIT
    '@Param: value1 is the value that will be checked if its in the array
    '@Param: array1 is the array
    '@Returns: Returns boolean True if the value is in the array, and false otherwise
    '@Example: =IsInArray("hello", {"one", 2, "hello"}) -> True
    '@Example: =IsInArray("hello", {1, "two", "three"}) -> False
    '@AssignedModule vbArcImports
    Dim individualElement As Variant
    If CaseSensitive = True Then value1 = UCase(value1)
    For Each individualElement In array1
        If CaseSensitive = True Then individualElement = UCase(individualElement)
        If individualElement = value1 Then
            ArrayContains = True
            Exit Function
        End If
    Next
    ArrayContains = False
End Function
Function OutlookCheck() As Boolean
    '@LastModified 2305220937
    '@AssignedModule vbArcImports
    Dim xOLApp      As Object
    Set xOLApp = CreateObject("Outlook.Application")
    If Not xOLApp Is Nothing Then
        OutlookCheck = True
        Set xOLApp = Nothing
        Exit Function
    End If
    OutlookCheck = False
End Function

Public Function GetInternetConnectedState() As Boolean
    '@LastModified 2305220934
    '@INCLUDE DECLARATION InternetGetConnectedState
    '@AssignedModule vbArcImports
    GetInternetConnectedState = InternetGetConnectedState(0&, 0&)
End Function
Function PickExcelFile()
    '@AssignedModule vbArcImports
    Dim strFile     As String
    Dim fd          As Office.FileDialog
    Set fd = Application.FileDialog(msoFileDialogFilePicker)
    With fd
        .Filters.clear
        .Filters.Add "Excel Files", "*.xl*", 1
        .Title = "Choose an Excel file"
        .AllowMultiSelect = False
        .InitialFileName = Environ("USERprofile") & "\Desktop\"
        If .Show = True Then
            strFile = .SelectedItems(1)
            PickExcelFile = strFile
        End If
    End With
End Function
Function PickFolder(Optional initFolder As String) As String
    '@AssignedModule vbArcImports
    With Application.FileDialog(msoFileDialogFolderPicker)
        .InitialFileName = IIf(initFolder <> "" And FolderExists(initFolder), initFolder, Environ("USERprofile") & "\Desktop\")
        If .Show = -1 Then
            PickFolder = .SelectedItems(1) & "\"
        Else
            Exit Function
        End If
    End With
End Function
Public Function SelectFolder(Optional initFolder As String) As String
    '@AssignedModule vbArcImports
    '@INCLUDE PROCEDURE FolderExists
    With Application.FileDialog(msoFileDialogFolderPicker)
        .AllowMultiSelect = False
        .Title = "Select a folder"
        If FolderExists(initFolder) Then .InitialFileName = initFolder
        .Show
        If .SelectedItems.Count > 0 Then
            SelectFolder = .SelectedItems.item(1)
        Else
        End If
    End With
End Function
Public Function RoundUp(dblNumToRound As Long, lMultiple As Long) As Double
    '@AssignedModule vbArcImports
    Dim asDec       As Variant
    Dim Rounded     As Variant

    asDec = CDec(dblNumToRound) / lMultiple
    Rounded = Int(asDec)

    If Rounded <> asDec Then
        Rounded = Rounded + 1
    End If
    RoundUp = Rounded * lMultiple
End Function
Function StringIndentationNormalize(ByVal txt As String, Optional indentation As Long = 4)
    '@AssignedModule vbArcImports
    '@INCLUDE PROCEDURE RoundUp
    Dim str         As Variant
    str = Split(txt, vbNewLine)
    Dim sLine       As String
    Dim tmpLine     As String
    Dim i           As Long
    Dim iSpaces     As Long
    Dim tmpSpaes    As Long
    For i = LBound(str) To UBound(str)
        sLine = str(i)
        iSpaces = Len(sLine) - Len(LTrim(sLine))
        If iSpaces > 0 Then
            str(i) = Space(RoundUp(iSpaces, indentation)) & Trim(sLine)
        End If
    Next
    If InStr(1, txt, vbNewLine) > 0 Then
        StringIndentationNormalize = Join(str, vbNewLine)
    Else
        StringIndentationNormalize = str
    End If
End Function

Function Parser_Tab(ByVal S As String) As String
    '@LastModified 2305220859
    'https://sites.google.com/site/e90e50/random-topics/tool-for-parsing-formulas-in-excel
    '@AssignedModule vbArcImports
    Dim SS As String, ch As String
    Dim t As Long, z As Long, X As Long

    SS = String(10000, " ")

    t = 1
    z = 1
    For X = 1 To Len(S)
        ch = Mid(S, X, 1)
        If ch = vbCr And X > 1 Then

            If Mid(S, X - 1, 1) = "(" Then
                z = z + 1
            Else
                If Mid(S, X + 1, 1) = ")" Then
                    z = z - 1
                End If
            End If

            Mid(SS, t, z + 1) = ch & Application.Rept(vbTab, z)

            t = t + z
        Else
            Mid(SS, t, 1) = ch
            t = t + 1
        End If
    Next
    S = Left(SS, t - 1)
    Parser_Tab = S

End Function
Function Array_Const_Wrap(ByRef sArraY As String, DelR As String) As String
    '@LastModified 2305220900
    'https://sites.google.com/site/e90e50/random-topics/tool-for-parsing-formulas-in-excel
    '@AssignedModule vbArcImports
    Dim V
    If Len(sArraY) > 1 Then
        V = Split(Mid(sArraY, 2, Len(sArraY) - 2), DelR)
        Array_Const_Wrap = "{" & vbCr & Join(V, DelR & vbCr) & vbCr & "}"
    End If
End Function
Function DataFilePartFolder(fileNameWithExtension, Optional IncludeSlash As Boolean) As String
    '@AssignedModule vbArcImports
    DataFilePartFolder = Left(fileNameWithExtension, InStrRev(fileNameWithExtension, "\") - 1 - IncludeSlash)
End Function

Public Function DataFilePicker(Optional fileType As Variant, Optional multiSelect As Boolean) As Variant
    '@AssignedModule vbArcImports
    Dim blArray     As Boolean
    Dim i           As Long
    Dim strErrMsg As String, strTitle As String
    Dim varItem     As Variant
    If Not IsMissing(fileType) Then
        blArray = IsArray(fileType)
        If Not blArray Then strErrMsg = "Please pass an array in the first parameter of this function!"
    End If
    If strErrMsg = vbNullString Then
        If multiSelect Then strTitle = "Choose one or more files" Else strTitle = "Choose file"
        With Application.FileDialog(msoFileDialogFilePicker)
            .InitialFileName = Environ("USERprofile") & "\Desktop\"
            .AllowMultiSelect = multiSelect
            .Filters.clear
            If blArray Then .Filters.Add "File type", Replace("*." & Join(fileType, ", *."), "..", ".")
            .Title = strTitle
            If .Show <> 0 Then
                ReDim arrResults(1 To .SelectedItems.Count) As Variant
                If blArray Then
                    For Each varItem In .SelectedItems
                        i = i + 1
                        arrResults(i) = varItem
                    Next varItem
                Else
                    arrResults(1) = .SelectedItems(1)
                End If
                DataFilePicker = arrResults
            End If
        End With
    Else
        MsgBox strErrMsg, vbCritical, "Error!"
    End If
End Function

Function DataFilePartExtension(str As String)
    '@AssignedModule vbArcImports
    DataFilePartExtension = Mid(str, InStrRev(str, ".") + 1)
End Function

Function DataFilePartName(fileNameWithExtension As String, Optional IncludeExtension As Boolean) As String
    '@AssignedModule vbArcImports
    If InStr(1, fileNameWithExtension, "\") > 0 Then
        DataFilePartName = Right(fileNameWithExtension, Len(fileNameWithExtension) - InStrRev(fileNameWithExtension, "\"))
    ElseIf InStr(1, fileNameWithExtension, "/") > 0 Then
        DataFilePartName = Right(fileNameWithExtension, Len(fileNameWithExtension) - InStrRev(fileNameWithExtension, "/"))
    Else
        DataFilePartName = fileNameWithExtension
    End If
    If IncludeExtension = False Then DataFilePartName = Left(DataFilePartName, InStr(1, DataFilePartName, ".") - 1)
End Function

Public Function ArrayToString(SourceArray As Variant, Optional Delimiter As String = ",") As String
    '@INCLUDE ArrayDimensionLength
    '@AssignedModule vbArcImports
    '@INCLUDE PROCEDURE ArrayDimensionLength
    Dim Temp        As String
    Select Case ArrayDimensionLength(SourceArray)
        Case 1
            '* @TODO Created: 21-12-2022 19:34 Author: Anastasiou Alex
            '* @TODO find where i put the flattenArray

            Temp = Join(SourceArray, Delimiter)
        Case 2
            Dim rowIndex As Long
            Dim ColIndex As Long
            For rowIndex = LBound(SourceArray, 1) To UBound(SourceArray, 1)
                For ColIndex = LBound(SourceArray, 2) To UBound(SourceArray, 2)
                    Temp = Temp & SourceArray(rowIndex, ColIndex)
                    If ColIndex <> UBound(SourceArray, 2) Then Temp = Temp & Delimiter
                Next ColIndex
                If rowIndex <> UBound(SourceArray, 1) Then Temp = Temp & vbNewLine
            Next rowIndex
    End Select
    ArrayToString = Temp
End Function
Public Function InputBoxRange(Optional sTitle As String, Optional sPrompt As String) As Range
    '@AssignedModule vbArcImports
    On Error Resume Next
    Set InputBoxRange = Application.InputBox(Title:=sTitle, Prompt:=sPrompt, Type:=8, _
            Default:=IIf(TypeName(Selection) = "Range", Selection.Address, ""))
End Function
Function CreateOrSetSheet(SheetName As String, TargetWorkbook As Workbook) As Worksheet
    '@BlogPosted
    '@INCLUDE PROCEDURE WorksheetExists
    '@AssignedModule vbArcImports
    Dim NewSheet    As Worksheet
    If WorksheetExists(SheetName, TargetWorkbook) = True Then
        Set CreateOrSetSheet = TargetWorkbook.Sheets(SheetName)
    Else
        Set CreateOrSetSheet = TargetWorkbook.Sheets.Add
        CreateOrSetSheet.Name = SheetName
    End If
End Function
Function Parser_Formula( _
        ByVal S As String, _
        sListSeparator As String, _
        sRowSeparator As String) As String
    '@LastModified 2305220859
    'https://sites.google.com/site/e90e50/random-topics/tool-for-parsing-formulas-in-excel
    '@AssignedModule vbArcImports
    Const CW        As String = "[^=\-+*/();:,.$<>^]"
    Dim M As Object, RE As Object, SM As Object, SB As Object
    Dim V As Variant, t As String

    Set RE = CreateObject("vbscript.regexp")
    RE.IgnoreCase = True
    RE.Global = True

    V = Array( _
            "(""[^""]*""|'[^']*')", _
            "(\{[^}]+})", _
            "(\" & sListSeparator & ")", _
            "(" & CW & "+(?:\." & CW & "+)*\()", _
            "(\))", _
            "(^=|\()", _
            "(.)")

    RE.pattern = Join(V, "|")
    If RE.test(S) Then
        Set M = RE.Execute(S)
        S = ""
        For Each SM In M
            Set SB = SM.SubMatches
            If Len(SB(0) & SB(6)) Then
                t = SB(0) & SB(6)
            ElseIf Len(SB(1)) Then
                t = Array_Const_Wrap(SB(1), sRowSeparator) & vbCr
            ElseIf Len(SB(2) & SB(5)) Then
                t = SB(2) & SB(5) & vbCr
            ElseIf Len(SB(3)) Then
                t = vbCr & SB(3) & vbCr
            ElseIf Len(SB(4)) Then
                t = vbCr & SB(4)
            End If
            S = S & t
        Next
    End If

    RE.pattern = "\r{2,}"
    S = RE.Replace(S, vbCr)

    If Left(S, 1) = vbCr Then S = Mid(S, 1 + Len(vbCr))
    If Right(S, 1) = vbCr Then S = Left(S, Len(S) - Len(vbCr))
    Parser_Formula = S
End Function
Function StringFormatFunctionNested( _
        str As String, _
        Optional sListSeparator As String = ",", _
        Optional sRowSeparator As String = ",") As String
    '@AssignedModule vbArcImports
    '@INCLUDE PROCEDURE StringIndentationNormalize
    '@INCLUDE PROCEDURE ArrayRemoveEmptyElements
    Dim txt         As String
    txt = _
            Join( _
            ArrayRemoveEmptyElements( _
            Split( _
            Parser_Tab( _
            Parser_Formula( _
            str, _
            sListSeparator, _
            sRowSeparator _
            ) _
            ), _
            vbCr _
            ) _
            ), _
            " _" & vbNewLine _
            )
    StringFormatFunctionNested = StringIndentationNormalize(txt)
End Function
Function IncreaseAllNumbersInString(str As String)
    '@AssignedModule vbArcImports
    Dim Output      As String
    Dim counter     As Long
    counter = Len(str)
    Dim i           As Long
    For i = 1 To Len(str)
        counter = i
        If IsNumeric(Mid(str, i, 1)) Then
            Do
                Output = Output & Mid(str, counter, 1)
                counter = counter + 1
            Loop While IsNumeric(Mid(str, counter, 1))
            i = counter - 1
            IncreaseAllNumbersInString = IncreaseAllNumbersInString & val(Output + 1)
        Else
            Output = Output & Mid(str, i, 1)
            IncreaseAllNumbersInString = IncreaseAllNumbersInString & Output
        End If
        Output = ""
    Next
End Function
Function ArrayRotate(inputArray, Optional ShiftByNum = 1) As Variant
    'ShiftByNum = Positive number
    Rem @TODO - Rotate right
    Rem rotates array left (first element to end of array)
    '@INCLUDE Len2
    '@AssignedModule vbArcImports
    '@INCLUDE PROCEDURE Len2
    Dim ub          As Long: ub = UBound(inputArray)
    Dim LB          As Long: LB = LBound(inputArray)
    Dim dif         As Long: dif = 1 - LB
    Dim NewArray()  As Variant
    Dim element     As Variant
    Dim counter     As Long
    Dim fromStart   As Long: fromStart = LB
    For counter = LB To ub
        ReDim Preserve NewArray(1 To counter + dif)
        If counter + ShiftByNum <= ub Then
            NewArray(UBound(NewArray)) = inputArray(counter + ShiftByNum)
        ElseIf UBound(NewArray) <= Len2(inputArray) Then
            NewArray(UBound(NewArray)) = inputArray(fromStart)
            fromStart = fromStart + 1
        End If
    Next
    ArrayRotate = NewArray
End Function
Public Function SortSelectionArray(ByVal TempArray As Variant) As Variant
    '@AssignedModule vbArcImports
    Dim MaxVal      As Variant
    Dim MaxIndex    As Integer
    Dim i As Integer, j As Integer
    For i = UBound(TempArray) To 0 Step -1
        MaxVal = TempArray(i)
        MaxIndex = i
        For j = 0 To i
            If TempArray(j) > MaxVal Then
                MaxVal = TempArray(j)
                MaxIndex = j
            End If
        Next j
        If MaxIndex < i Then
            TempArray(MaxIndex) = TempArray(i)
            TempArray(i) = MaxVal
        End If
    Next i
    SortSelectionArray = TempArray
End Function
Public Function RegExpReplace( _
        TEXT As String, _
        pattern As String, _
        text_replace As String, _
        Optional instance_num As Integer = 0, _
        Optional match_case As Boolean = True) As String
    '@AssignedModule vbArcImports
    Dim text_result, text_find As String
    Dim matches_index, pos_start As Integer

    On Error GoTo ErrHandle
    text_result = TEXT
    Dim REGEX       As RegExp
    Set REGEX = CreateObject("VBScript.RegExp")

    REGEX.pattern = pattern
    REGEX.Global = True
    REGEX.MultiLine = True

    If True = match_case Then
        REGEX.IgnoreCase = False
    Else
        REGEX.IgnoreCase = True
    End If
    Dim matches     As Object
    Set matches = REGEX.Execute(TEXT)

    If 0 < matches.Count Then
        If (0 = instance_num) Then
            text_result = REGEX.Replace(TEXT, text_replace)
        Else
            If instance_num <= matches.Count Then
                pos_start = 1
                For matches_index = 0 To instance_num - 2
                    pos_start = InStr(pos_start, TEXT, matches.item(matches_index), vbBinaryCompare) + Len(matches.item(matches_index))
                Next matches_index

                text_find = matches.item(instance_num - 1)
                text_result = Left(TEXT, pos_start - 1) & Replace(TEXT, text_find, text_replace, pos_start, 1, vbBinaryCompare)

            End If
        End If
    End If

    RegExpReplace = text_result
    Exit Function

ErrHandle:
    RegExpReplace = CVErr(xlErrValue)
End Function

Function InStrExact( _
        Start As Long, _
        sourceText As String, _
        WordToFind As String, _
        Optional CaseSensitive As Boolean = False, _
        Optional AllowAccentedCharacters As Boolean = False) As Long
    '@BlogPosted
    '@AssignedModule vbArcImports
    Dim X As Long, Str1 As String, str2 As String, pattern As String
    Const UpperAccentsOnly As String = ""
    Const UpperAndLowerAccents As String = ""
    If CaseSensitive Then
        Str1 = sourceText
        str2 = WordToFind
        pattern = "[!A-Za-z0-9]"
        If AllowAccentedCharacters Then pattern = Replace(pattern, "!", "!" & UpperAndLowerAccents)
    Else
        Str1 = UCase(sourceText)
        str2 = UCase(WordToFind)
        pattern = "[!A-Z0-9]"
        If AllowAccentedCharacters Then pattern = Replace(pattern, "!", "!" & UpperAccentsOnly)
    End If
    For X = Start To Len(Str1) - Len(str2) + 1
        If Mid(" " & Str1 & " ", X, Len(str2) + 2) Like pattern & str2 & pattern _
                And Not Mid(Str1, X) Like str2 & "'[" & Mid(pattern, 3) & "*" Then
            InStrExact = X
            Exit Function
        End If
    Next
End Function
Function ArrayFilterLike(inputArray As Variant, MatchThis As String, MatchCase As Boolean)
    '@AssignedModule vbArcImports
    Dim OutputArray As Variant
    ReDim OutputArray(1 To 1)
    Dim counter     As Long
    counter = 0
    Dim element
    Dim doesMatch   As Boolean
    For Each element In inputArray
        doesMatch = IIf(MatchCase, _
                element Like MatchThis, _
                UCase(element) Like UCase(MatchThis))
        If doesMatch Then
            counter = counter + 1
            ReDim Preserve OutputArray(1 To counter)
            OutputArray(UBound(OutputArray)) = element
        End If
    Next
    ArrayFilterLike = OutputArray
End Function


Function StringCommentsRemove(ByVal txt As String, RemoveRem As Boolean) As String
    '@BlogPosted
    'modified from Jacob Hilderbrand's code, found at
    'http://www.vbaexpress.com/kb/getarticle.php?kb_id=266
    '@AssignedModule vbArcImports
    '@INCLUDE PROCEDURE ArrayRemoveEmptyElements
    Dim var         As Variant
    ReDim var(0)
    Dim str
    str = Split(txt, vbNewLine)
    '        str = ArrayRemoveEmptyElements(str)
    Dim N           As Long
    Dim i           As Long
    Dim j           As Long
    Dim k           As Long
    Dim l           As Long
    Dim lineText    As String
    Dim QUOTES      As Long
    Dim q           As Long
    Dim startPos    As Long

    For j = LBound(str) To UBound(str)
        lineText = LTrim(str(j))
        If RemoveRem Then If lineText Like "Rem *" Then GoTo SKIP
        startPos = 1
retry:
        N = InStr(startPos, lineText, "'")
        q = InStr(startPos, lineText, """")
        QUOTES = 0
        If q < N Then
            For l = 1 To N
                If Mid(lineText, l, 1) = """" Then
                    QUOTES = QUOTES + 1
                End If
            Next l
        End If
        If QUOTES = Application.WorksheetFunction.Odd(QUOTES) Then
            startPos = N + 1
            GoTo retry:
        Else
            Select Case N
                Case Is = 0
                    '                    If Len(lineText) > 0 Then
                    var(UBound(var)) = str(j)
                    If j < UBound(str) Then ReDim Preserve var(UBound(var) + 1)
                    '                    End If
                Case Is = 1
                    '
                Case Is > 1
                    var(UBound(var)) = Left(str(j), N - 1)
                    If j < UBound(str) Then ReDim Preserve var(UBound(var) + 1)
            End Select
        End If
SKIP:
    Next j
    '    var = ArrayRemoveEmptyElements(var)
    StringCommentsRemove = Join(var, vbNewLine)
End Function

Public Function IsLineNumberAble( _
        ByVal str As String) As Boolean
    '@AssignedModule vbArcImports
    Dim test        As String
    test = Trim(str)
    If Len(test) = 0 Then Exit Function
    If Right(test, 1) = ":" Then Exit Function
    If IsNumeric(Left(test, 1)) Then Exit Function
    If test Like "'*" Then Exit Function
    If test Like "Rem*" Then Exit Function
    If test Like "Dim*" Then Exit Function
    If test Like "Sub*" Then Exit Function
    If test Like "Public*" Then Exit Function
    If test Like "Private*" Then Exit Function
    If test Like "Function*" Then Exit Function
    If test Like "End Sub*" Then Exit Function
    If test Like "End Function*" Then Exit Function
    If test Like "Debug*" Then Exit Function
    IsLineNumberAble = True
End Function
Public Function NumberOfArrayDimensions(arr As Variant) As Byte
    '@AssignedModule vbArcImports
    Dim Ndx         As Byte
    Dim Res         As Long
    On Error Resume Next
    Do
        Ndx = Ndx + 1
        Res = UBound(arr, Ndx)
    Loop Until Err.Number <> 0
    NumberOfArrayDimensions = Ndx - 1
End Function
Function LargestLength(Optional MyObj As Variant) As Long
    '@LastModified 2305220815
    '@AssignedModule vbArcImports
    LargestLength = 0
    Dim element     As Variant
    If IsMissing(MyObj) Then
        If TypeName(Selection) = "Range" Then
            Set MyObj = Selection
        Else
            Exit Function
        End If
    End If
    Select Case TypeName(MyObj)
        Case Is = "String"
            LargestLength = Len(MyObj)

        Case "Variant", "Variant()", "String()", "Collection"
            For Each element In MyObj
                Select Case TypeName(element)
                    Case Is = "String"
                        If Len(CStr(element)) > LargestLength Then LargestLength = Len(CStr(element))
                    Case "Integer", "Long", "Single", "Date"
                        If element > LargestLength Then LargestLength = element
                    Case Else
                        If element.Width > LargestLength Then LargestLength = element.Width
                End Select
            Next element

        Case Else
    End Select
End Function
Function StringFormatAlignRowsElements( _
                                      txt As String, _
                                      AlignAtString As String, _
                                      SearchFromLeft As Boolean, _
                                      Optional AlignAtColumn As Long)
    '@LastModified 2303171105
    '@AssignedModule vbArcImports
    Dim TextLines: TextLines = Split(txt, vbNewLine)
    Dim elementOriginalColumn As Long
    Dim rightMostColumn As Long
    Dim lineText    As String
    Dim numberOfSpacesToInsert As Long
    Dim i           As Long
    
    For i = LBound(TextLines) To UBound(TextLines)
        TextLines(i) = CleanTrim(TextLines(i), True)
    Next
    If AlignAtColumn = 0 Then
        For i = LBound(TextLines) To UBound(TextLines)
            If SearchFromLeft Then
                elementOriginalColumn = InStr(1, TextLines(i), AlignAtString)
            Else
                elementOriginalColumn = InStrRev(TextLines(i), AlignAtString)
            End If
            If elementOriginalColumn > rightMostColumn Then rightMostColumn = elementOriginalColumn
        Next
        AlignAtColumn = rightMostColumn
    End If

    For i = LBound(TextLines) To UBound(TextLines)
        lineText = TextLines(i)
'        If InStr(1, lineText, "Dependencies.bas", vbTextCompare) > 0 Then Stop
        If SearchFromLeft Then
            elementOriginalColumn = InStr(1, lineText, AlignAtString)
        Else
            elementOriginalColumn = InStrRev(lineText, AlignAtString)
        End If

        If elementOriginalColumn > 0 Then
            numberOfSpacesToInsert = AlignAtColumn - elementOriginalColumn + 1 'IIf(AlignAtString = ":", 1, 0)
            If numberOfSpacesToInsert > 0 And Not numberOfSpacesToInsert = AlignAtColumn Then
            
            '@TODO some colons revert to original position even if moved eg labels like NORMAL_EXIT:
'                If AlignAtString = ":" Then
'                    TextLines(i) = Left(TextLines(i), elementOriginalColumn) & _
'                            Space(numberOfSpacesToInsert) & _
'                            Trim(Mid(TextLines(i), elementOriginalColumn + 1))
'                Else

                    TextLines(i) = RTrim(Left(TextLines(i), elementOriginalColumn - 1)) & _
                            Space(numberOfSpacesToInsert) & _
                            Mid(Trim(TextLines(i)), elementOriginalColumn)
'                End If
            End If
        End If
    Next

    StringFormatAlignRowsElements = Join(TextLines, vbNewLine)

End Function

Public Function Combine2Array(ByVal arr1 As Variant, ByVal arr2 As Variant) As Variant
    '@INCLUDE NumberOfArrayDimensions
    '@AssignedModule vbArcImports
    '@INCLUDE PROCEDURE NumberOfArrayDimensions
    Dim LowRowArr1  As Long
    Dim HighRowArr1 As Long
    Dim LowColumnArr1 As Long
    Dim HighColumnArr1 As Long
    Dim NumOfRowsArr1 As Long
    Dim NumOfColumnsArr1 As Long
    Dim LowRowArr2  As Long
    Dim HighRowArr2 As Long
    Dim LowColumnArr2 As Long
    Dim HighColumnArr2 As Long
    Dim NumOfRowsArr2 As Long
    Dim NumOfColumnsArr2 As Long
    Dim Output      As Variant
    Dim OutputRow   As Long
    Dim OutputColumn As Long
    Dim RowIdx      As Long
    Dim ColIdx      As Long
    If (IsArray(arr1) = False) Or (IsArray(arr2) = False) Then
        Combine2Array = Null
        MsgBox "Both need to be array"
        Exit Function
    End If
    If (NumberOfArrayDimensions(arr1) <> 2) Or (NumberOfArrayDimensions(arr2) <> 2) Then
        Combine2Array = Null
        MsgBox "Both need to be 2D array"
        Exit Function
    End If
    LowRowArr1 = LBound(arr1, 1)
    HighRowArr1 = UBound(arr1, 1)
    LowColumnArr1 = LBound(arr1, 2)
    HighColumnArr1 = UBound(arr1, 2)
    NumOfRowsArr1 = HighRowArr1 - LowRowArr1 + 1
    NumOfColumnsArr1 = HighColumnArr1 - LowColumnArr1 + 1
    LowRowArr2 = LBound(arr2, 1)
    HighRowArr2 = UBound(arr2, 1)
    LowColumnArr2 = LBound(arr2, 2)
    HighColumnArr2 = UBound(arr2, 2)
    NumOfRowsArr2 = HighRowArr2 - LowRowArr2 + 1
    NumOfColumnsArr2 = HighColumnArr2 - LowColumnArr2 + 1
    If NumOfColumnsArr1 <> NumOfColumnsArr2 Then
        Combine2Array = Null
        MsgBox "Both array must have same number of column"
        Exit Function
    End If
    ReDim Output(0 To NumOfRowsArr1 + NumOfRowsArr2 - 1, 0 To NumOfColumnsArr1 - 1)
    For RowIdx = LowRowArr1 To HighRowArr1
        OutputColumn = 0
        For ColIdx = LowColumnArr1 To HighColumnArr1
            Output(OutputRow, OutputColumn) = arr1(RowIdx, ColIdx)
            OutputColumn = OutputColumn + 1
        Next ColIdx
        OutputRow = OutputRow + 1
    Next RowIdx
    For RowIdx = LowRowArr2 To HighRowArr2
        OutputColumn = 0
        For ColIdx = LowColumnArr2 To HighColumnArr2
            Output(OutputRow, OutputColumn) = arr2(RowIdx, ColIdx)
            OutputColumn = OutputColumn + 1
        Next ColIdx
        OutputRow = OutputRow + 1
    Next RowIdx
    Combine2Array = Output
End Function

Public Function IndentationCount(str) As Long
    '@AssignedModule vbArcImports
    IndentationCount = Len(str) - Len(LTrim(str))
End Function

Function WorkbookProjectProtected(ByVal TargetWorkbook As Workbook) As Boolean
    '@BlogPosted
    '@AssignedModule vbArcImports
    WorkbookProjectProtected = (TargetWorkbook.VBProject.Protection = 1)
End Function

Function CountOfCharacters(SearchHere As String, FindThis As String)
    '@AssignedModule vbArcImports
    CountOfCharacters = (Len(SearchHere) - Len(Replace(SearchHere, FindThis, ""))) / Len(FindThis)
End Function

Function IsCommentLine(ByVal str As String) As Boolean
    '@LastModified 2305220757
    '@AssignedModule vbArcImports
    str = Trim(str)
    If str Like "'*" Then IsCommentLine = True
    If str Like "Rem *" Then IsCommentLine = True
End Function

Function CommentsMoveToOwnLine(ByVal txt As String) As String
    '@BlogPosted
    '@INCLUDE PROCEDURE CommentsTrim
    '@AssignedModule vbArcImports

    Dim var         As Variant
    ReDim var(0)
    Dim str         As Variant
    str = Split(txt, vbNewLine)

    Dim N           As Long
    Dim i           As Long
    Dim j           As Long
    Dim k           As Long
    Dim l           As Long
    Dim lineText    As String
    Dim QUOTES      As Long
    Dim q           As Long
    Dim startPos    As Long

    For j = LBound(str) To UBound(str)
        lineText = Trim(str(j))
        startPos = 1
retry:
        N = InStr(startPos, lineText, "'")
        q = InStr(startPos, lineText, """")
        QUOTES = 0
        If q < N Then
            For l = 1 To N
                If Mid(lineText, l, 1) = """" Then
                    QUOTES = QUOTES + 1
                End If
            Next l
        End If
        If QUOTES = Application.WorksheetFunction.Odd(QUOTES) Then
            startPos = N + 1
            GoTo retry:
        Else
            Select Case N
                Case Is = 0
                    var(UBound(var)) = str(j)
                    ReDim Preserve var(UBound(var) + 1)
                Case Is = 1
                    var(UBound(var)) = CommentsTrim(Array(str(j)))
                    ReDim Preserve var(UBound(var) + 1)
                Case Is > 1
                    var(UBound(var)) = Space(Len(str(j)) - Len(LTrim(str(j)))) & Mid(lineText, N)
                    ReDim Preserve var(UBound(var) + 1)
                    var(UBound(var)) = Space(Len(str(j)) - Len(LTrim(str(j)))) & Left(lineText, N - 1)
                    ReDim Preserve var(UBound(var) + 1)
            End Select
        End If
    Next j

    CommentsMoveToOwnLine = Join(var, vbNewLine)
    CommentsMoveToOwnLine = Left(CommentsMoveToOwnLine, Len(CommentsMoveToOwnLine) - Len(vbNewLine))
End Function
Public Function IsBlockEnd(strline As String) As Boolean
    '@BlogPosted
    '@AssignedModule vbArcImports
    strline = Replace(strline, Chr(13), "")
    Dim bOK         As Boolean
    Dim nPos        As Integer
    Dim strTemp     As String
    nPos = InStr(1, strline, " ") - 1
    If nPos < 0 Then nPos = Len(strline)
    strTemp = Left$(strline, nPos)
    Select Case strTemp
        Case "Next", "Loop", "Wend", "Case", "Else", "#Else", "Else:", "#Else:", "ElseIf", "#ElseIf", "#End"
            bOK = True
        Case "End"
            bOK = (Len(strline) > 3)
    End Select
    IsBlockEnd = bOK
End Function

Function TxtAppend(sFile As String, sText As String)
    '@BlogPosted
    '@AssignedModule vbArcImports
    On Error GoTo ERR_HANDLER
    Dim iFileNumber As Integer
    iFileNumber = FreeFile
    Open sFile For Append As #iFileNumber
    Print #iFileNumber, sText
    Close #iFileNumber
Exit_Err_Handler:
    Exit Function
ERR_HANDLER:
    MsgBox "The following error has occurred" & vbCrLf & vbCrLf & _
            "Error Number: " & Err.Number & vbCrLf & _
            "Error Source: Txt_Append" & vbCrLf & _
            "Error Description: " & Err.Description & _
            Switch(Erl = 0, "", Erl <> 0, vbCrLf & "Line No: " & Erl) _
            , vbOKOnly + vbCritical, "An Error has Occurred!"
    GoTo Exit_Err_Handler
End Function

Function CommentsTrim(ByVal txt As String) As String
    '@LastModified 2305220838
    '@BlogPosted
    '@INCLUDE PROCEDURE ArrayRemoveEmptyElements
    '@AssignedModule vbArcImports
    '@INCLUDE PROCEDURE tmp
    Dim var         As Variant
    ReDim var(0)
    Dim str         As Variant
    str = Split(txt, vbNewLine)
    Dim j           As Long
    Dim dif         As Long
    Dim lineText    As String
    Dim tmp         As String
    For j = LBound(str) To UBound(str)
        lineText = Trim(str(j))
        If Left(lineText, 2) = "' " Then
            tmp = Mid(lineText, 2)
            dif = Len(tmp) - Len(LTrim(tmp))
            var(UBound(var)) = Space(dif) & "'" & LTrim(tmp)
            ReDim Preserve var(UBound(var) + 1)
        Else
            var(UBound(var)) = str(j)
            ReDim Preserve var(UBound(var) + 1)
        End If
    Next
    var = ArrayRemoveEmptyElements(var)
    CommentsTrim = Join(var, vbNewLine)
End Function
Public Function ArrayRemoveEmptyElements(varArray As Variant) As Variant
    '@LastModified 2305220838
    '@BlogPosted
    '@AssignedModule vbArcImports
    Dim TempArray() As Variant
    Dim OldIndex    As Integer
    Dim NewIndex    As Integer
    If UBound(varArray) = -1 Then Exit Function
    ReDim TempArray(LBound(varArray) To UBound(varArray))
    For OldIndex = LBound(varArray) To UBound(varArray)
        If Not Trim(varArray(OldIndex) & " ") = "" Then
            TempArray(NewIndex) = varArray(OldIndex)
            NewIndex = NewIndex + 1
        End If
    Next OldIndex
    ReDim Preserve TempArray(LBound(varArray) To NewIndex - 1)
    ArrayRemoveEmptyElements = TempArray
    varArray = TempArray
End Function


Function ArrayTrim(ByVal arr As Variant)
    '@BlogPosted
    '@AssignedModule vbArcImports
    Dim i           As Long
    For i = LBound(arr) To UBound(arr)
        arr(i) = Trim(arr(i))
    Next
    ArrayTrim = arr
End Function


Public Function IsBlockStart(strline As String) As Boolean
    '@BlogPosted
    '@AssignedModule vbArcImports
    strline = Replace(strline, Chr(13), "")
    Dim bOK         As Boolean
    Dim nPos        As Integer
    Dim strTemp     As String
    nPos = InStr(1, strline, " ") - 1
    If nPos < 0 Then nPos = Len(strline)
    strTemp = Left$(strline, nPos)
    Select Case strTemp
        Case "With", "For", "Do", "While", "Select", "Case", "Else", "Else:", "#Else", "#Else:", "Sub", "Function", "Property", "Enum", "Type"
            bOK = True
        Case "If", "#If", "ElseIf", "#ElseIf"
            bOK = (Right(strline, 4) = "Then" Or Right(strline, 1) = "_")
        Case "Private", "Public", "Friend"
            nPos = InStr(1, strline, " Static ")
            If nPos Then
                nPos = InStr(nPos + 7, strline, " ")
            Else
                nPos = InStr(Len(strTemp) + 1, strline, " ")
            End If
            On Error GoTo SKIP
            Select Case Mid$(strline, nPos + 1, InStr(nPos + 1, strline, " ") - nPos - 1)
                Case "Sub", "Function", "Property", "Enum", "Type"
                    bOK = True
            End Select
SKIP:
            On Error GoTo 0
    End Select
    IsBlockStart = bOK
End Function


Public Sub dp(var As Variant)
    '@LastModified 2305220815
    '@BlogPosted
    '@INCLUDE DECLARATION i
    '@INCLUDE PROCEDURE PrintXML
    '@INCLUDE PROCEDURE printRange
    '@INCLUDE PROCEDURE printArray
    '@INCLUDE PROCEDURE printCollection
    '@INCLUDE PROCEDURE printDictionary
    '@AssignedModule vbArcImports
    Dim element     As Variant
    Dim i           As Long
    '    Debug.Print TypeName(var)
    Select Case TypeName(var)
        Case Is = "String", "Long", "Integer", "Double", "Boolean"
            Debug.Print var
        Case Is = "Variant()", "String()", "Long()", "Integer()"
            printArray var
        Case Is = "Collection"
            printCollection var
        Case Is = "Dictionary"
            printDictionary var
        Case Is = "Range"
            printRange var
        Case Is = "Date"
            Debug.Print var
        Case Is = "IXMLDOMElement"
            PrintXML var
        Case Else
    End Select
End Sub

Sub PrintXML(var)
    '@BlogPosted
    '@AssignedModule vbArcImports
    Debug.Print var.xml
End Sub
'Sub PrintXML(NodeList)
''   Parse all levels recursively
'    Dim obj
'    On Error Resume Next
'    Set obj = NodeList.ChildNodes
'    If Err.Number = 0 Then
'
'    Else
'        Err.clear
'        Set obj = NodeList.NodeList
'        If Err.Number <> 0 Then: Err.clear: Exit Sub
'    End If
'    On Error GoTo 0
'    Dim child
'    For Each child In obj
'        If Not Left(child.nodename, 1) = "#" Then Debug.Print child.nodename & ":" & child.TEXT
'        If child.ChildNodes.Length > 0 Then PrintXML child.ChildNodes
'    Next
'End Sub

Public Sub PrintLinesContaining(F)
    '@AssignedModule vbArcImports
    '@INCLUDE PROCEDURE ProcedureCode
    '@INCLUDE PROCEDURE ProceduresOfModule
    '@INCLUDE PROCEDURE collectionToString
    '@INCLUDE PROCEDURE WorkbookProjectProtected
    '@INCLUDE PROCEDURE dp
    '@INCLUDE CLASS aWorkbook
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aCollection
    Dim i           As Long
    Const ModuleString = vbNewLine & "    Mod|"
    Const Procedurestring = "" & vbTab & "Sub" & "|" & "---" & "| "
    Const FoundString = "" & vbTab & "txt" & "|" & vbTab & " |" & "---" & "| "
    Dim X, Y, S, p  As Variant
    Dim module      As VBComponent
    On Error Resume Next
    Dim out         As New Collection
    For Each X In Array(Workbooks, AddIns)
        For Each Y In X
            If Not WorkbookProjectProtected(Workbooks(Y.Name)) Then
                If Err.Number = 0 Then
                    If UBound(Filter(Split(aWorkbook.Init(Workbooks(Y.Name)).Code, vbNewLine), F, True, vbTextCompare)) > -1 Then

                        out.Add ""
                        out.Add String(50, "-")
                        out.Add "| " & Y.Name
                        out.Add String(50, "-")

'                        Debug.Print Y.Name

                        For Each module In Workbooks(Y.Name).VBProject.VBComponents

'                            Debug.Print vbTab & module.Name

                            If UBound(Filter(Split(aModule.Init(module).Code, vbNewLine), F, True, vbTextCompare)) > -1 Then
                                out.Add ModuleString & module.Name
                                If module.CodeModule.CountOfDeclarationLines > 0 Then
                                    S = Filter(Split(module.CodeModule.Lines(1, module.CodeModule.CountOfDeclarationLines), vbNewLine), F, True, vbTextCompare)
                                    out.Add FoundString & Trim(S(i))
                                End If
                                For Each p In ProceduresOfModule(module)
                                    If UBound(Filter(Split(ProcedureCode(Workbooks(Y.Name), module, CStr(p)), vbNewLine), F, True, vbTextCompare)) > -1 Then
                                        out.Add Procedurestring & CStr(p)
                                        S = Filter(Split(ProcedureCode(Workbooks(Y.Name), module, CStr(p)), vbNewLine), F, True, vbTextCompare)
                                        For i = 0 To UBound(S)
                                            out.Add FoundString & Trim(S(i))
                                        Next i
                                    End If
                                Next p
                            End If
                        Next module
                    End If
                End If
            End If
            Err.clear
        Next Y
    Next X
    dp aCollection.Init(out).ToString(vbNewLine)    'collectionToString(out, vbNewLine)
End Sub

Public Sub printRange(var As Variant)
    '@BlogPosted
    '@INCLUDE PROCEDURE Combine2Array
    '@INCLUDE PROCEDURE dp
    '@AssignedModule vbArcImports
    If var.Areas.Count = 1 Then
        dp var.Value
    Else
        Dim out     As Variant
        Dim Temp    As Variant
        Dim i       As Long
        For i = 1 To var.Areas.Count
            Temp = var.Areas(i).Value
            If IsEmpty(out) Then
                out = Temp
            Else
                out = Combine2Array(out, Temp)
            End If
        Next
        dp out
    End If
End Sub

Private Sub printArray(var As Variant)
    '@BlogPosted
    '@INCLUDE PROCEDURE DPH
    '@INCLUDE PROCEDURE ArrayDimensions
    '@AssignedModule vbArcImports
    '@INCLUDE PROCEDURE dp
    Dim element
    If ArrayDimensions(var) = 1 Then
        Debug.Print Join(var, vbNewLine)
        '        For Each element In var
        '            dp element
        '        Next
    ElseIf ArrayDimensions(var) > 1 Then
        DPH var
    End If
End Sub

Private Sub printCollection(var As Variant)
    '@BlogPosted
    '@INCLUDE PROCEDURE dp
    '@AssignedModule vbArcImports
    Dim elem        As Variant
    For Each elem In var
        dp elem
    Next elem
End Sub

Private Sub printDictionary(var As Variant)
    '@BlogPosted
    '@INCLUDE PROCEDURE dp
    '@AssignedModule vbArcImports


    '@TODO detect error cause I met when printing a dic from JSON related modules

    Dim i As Long: Dim iCount As Long
    Dim arrKeys
    Dim sKey        As String
    Dim varItem

    Dim Key         As Variant
    For Each Key In var.Keys
        dp var(Key)

    Next Key

    '    Stop

    '    With var
    '        iCount = .Count
    '        arrKeys = .Keys
    '        iCount = UBound(arrKeys, 1)
    '        For i = 0 To iCount
    '            sKey = arrKeys(i)
    '            Debug.Print "Key " & sKey
    '            Debug.Print String(20, "-")
    '            If IsObject(.item(sKey)) Then
    '                dp (.item(sKey))
    '            Else
    '                Debug.Print "Key " & sKey & " : "
    '                dp .item(sKey)
    '            End If
    '        Next i
    '    End With
End Sub

Private Sub DPH(ByVal Hairetu, Optional HyoujiMaxNagasa%, Optional HairetuName$)
    '@BlogPosted
    'https://gist.github.com/YujiFukami/15c922d41ff06c9b12ad450a14131080#file-
    '@INCLUDE PROCEDURE DebugPrintHairetu
    '@AssignedModule vbArcImports
    Call DebugPrintHairetu(Hairetu, HyoujiMaxNagasa, HairetuName)
End Sub

Public Function ArrayDimensions(ByVal vArray As Variant) As Long
    '@BlogPosted
    '@AssignedModule vbArcImports
    Dim dimnum      As Long
    Dim ErrorCheck  As Long
    On Error GoTo FinalDimension
    For dimnum = 1 To 60000
        ErrorCheck = LBound(vArray, dimnum)
    Next
FinalDimension:
    ArrayDimensions = dimnum - 1
End Function

Private Sub DebugPrintHairetu(ByVal Hairetu, Optional HyoujiMaxNagasa%, Optional HairetuName$)
    '@BlogPosted
    'https://gist.github.com/YujiFukami/15c922d41ff06c9b12ad450a14131080#file-
    '@INCLUDE PROCEDURE ShortenToByteCharacters
    '@AssignedModule vbArcImports


    Dim i&, j&, k&, M&, N&
    Dim TateMin&, TateMax&, YokoMin&, YokoMax&
    Dim WithTableHairetu
    Dim NagasaList, MaxNagasaList
    Dim NagasaOnajiList
    Dim OutputList
    Const SikiriMoji$ = "|"
    Dim Jigen2%
    On Error Resume Next
    Jigen2 = UBound(Hairetu, 2)
    '    On Error GoTo 0

    If Jigen2 = 0 Then
        Hairetu = Application.Transpose(Hairetu)
    End If
    TateMin = LBound(Hairetu, 1)
    TateMax = UBound(Hairetu, 1)
    YokoMin = LBound(Hairetu, 2)
    YokoMax = UBound(Hairetu, 2)
    ReDim WithTableHairetu(1 To TateMax - TateMin + 1 + 1, 1 To YokoMax - YokoMin + 1 + 1)
    For i = 1 To TateMax - TateMin + 1
        WithTableHairetu(i + 1, 1) = TateMin + i - 1
        For j = 1 To YokoMax - YokoMin + 1
            WithTableHairetu(1, j + 1) = YokoMin + j - 1
            WithTableHairetu(i + 1, j + 1) = Hairetu(i - 1 + TateMin, j - 1 + YokoMin)
        Next j
    Next i
    N = UBound(WithTableHairetu, 1)
    M = UBound(WithTableHairetu, 2)
    ReDim NagasaList(1 To N, 1 To M)
    ReDim MaxNagasaList(1 To M)
    Dim tmpStr$
    For j = 1 To M
        For i = 1 To N
            If j > 1 And HyoujiMaxNagasa <> 0 Then
                tmpStr = WithTableHairetu(i, j)
                WithTableHairetu(i, j) = ShortenToByteCharacters(tmpStr, HyoujiMaxNagasa)
            End If
            NagasaList(i, j) = LenB(StrConv(WithTableHairetu(i, j), vbFromUnicode))
            MaxNagasaList(j) = WorksheetFunction.Max(MaxNagasaList(j), NagasaList(i, j))
        Next i
    Next j
    ReDim NagasaOnajiList(1 To N, 1 To M)
    Dim TmpMaxNagasa&
    For j = 1 To M
        TmpMaxNagasa = MaxNagasaList(j)
        For i = 1 To N
            NagasaOnajiList(i, j) = WithTableHairetu(i, j) & WorksheetFunction.Rept(" ", TmpMaxNagasa - NagasaList(i, j))
        Next i
    Next j
    ReDim OutputList(1 To N)
    For i = 1 To N
        For j = 1 To M
            If j = 1 Then
                OutputList(i) = NagasaOnajiList(i, j)
            Else
                OutputList(i) = OutputList(i) & SikiriMoji & NagasaOnajiList(i, j)
            End If
        Next j
    Next i
    Debug.Print HairetuName
    For i = 1 To N
        Debug.Print OutputList(i)
    Next i
End Sub


Public Function ShortenToByteCharacters(Mojiretu$, ByteNum%)
    '@BlogPosted
    'https://gist.github.com/YujiFukami/15c922d41ff06c9b12ad450a14131080#file-
    '@INCLUDE PROCEDURE CalculateByteCharacters
    '@INCLUDE PROCEDURE TextDecomposition
    '@AssignedModule vbArcImports
    Dim OriginByte%
    Dim Output
    OriginByte = LenB(StrConv(Mojiretu, vbFromUnicode))
    If OriginByte <= ByteNum Then
        Output = Mojiretu
    Else
        Dim RuikeiByteList, BunkaiMojiretu
        RuikeiByteList = CalculateByteCharacters(Mojiretu)
        BunkaiMojiretu = TextDecomposition(Mojiretu)
        Dim AddMoji$
        AddMoji = "."
        Dim i&, N&
        N = Len(Mojiretu)
        For i = 1 To N
            If RuikeiByteList(i) < ByteNum Then
                Output = Output & BunkaiMojiretu(i)
            ElseIf RuikeiByteList(i) = ByteNum Then
                If LenB(StrConv(BunkaiMojiretu(i), vbFromUnicode)) = 1 Then
                    Output = Output & AddMoji
                Else
                    Output = Output & AddMoji & AddMoji
                End If
                Exit For
            ElseIf RuikeiByteList(i) > ByteNum Then
                Output = Output & AddMoji
                Exit For
            End If
        Next i
    End If
    ShortenToByteCharacters = Output
End Function

Private Function CalculateByteCharacters(Mojiretu$)
    '@BlogPosted
    'https://gist.github.com/YujiFukami/15c922d41ff06c9b12ad450a14131080#file-
    '@AssignedModule vbArcImports
    Dim MojiKosu%
    MojiKosu = Len(Mojiretu)
    Dim Output
    ReDim Output(1 To MojiKosu)
    Dim i&
    Dim TmpMoji$
    For i = 1 To MojiKosu
        TmpMoji = Mid(Mojiretu, i, 1)
        If i = 1 Then
            Output(i) = LenB(StrConv(TmpMoji, vbFromUnicode))
        Else
            Output(i) = LenB(StrConv(TmpMoji, vbFromUnicode)) + Output(i - 1)
        End If
    Next i
    CalculateByteCharacters = Output
End Function

Private Function TextDecomposition(Mojiretu$)
    '@BlogPosted
    'https://gist.github.com/YujiFukami/15c922d41ff06c9b12ad450a14131080#file-
    '@AssignedModule vbArcImports
    Dim i&, N&
    Dim Output
    N = Len(Mojiretu)
    ReDim Output(1 To N)
    For i = 1 To N
        Output(i) = Mid(Mojiretu, i, 1)
    Next i
    TextDecomposition = Output
End Function

'* Modified   : Date and Time       Author              Description
'* Updated    : 18-08-2023 12:20    Alex                (vbArcImports.bas > FindCode)

Sub FindCode(S As String)
    '@LastModified 2308181220
    '@INCLUDE USERFORM uCodeFinder
    '@AssignedModule vbArcImports
    Load uCodeFinder
    uCodeFinder.TextBox1.TEXT = S
    uCodeFinder.DoSearch
End Sub


'aDesigner	Class


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Class      : aDesigner
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 04-05-2023 12:18    Alex
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


Option Explicit

Private oModule     As VBComponent


'* Modified   : Date and Time       Author              Description
'* Updated    : 30-10-2023 17:55    Alex                (aDesigner.cls > IconDesign : init )

Public Sub IconDesign(IconCode As String)
'@LastModified 2310301755
    '@AssignedModule aUserform
    Dim ctrl As MSForms.control
    For Each ctrl In SelectedControls
        With ctrl
            .Font.Name = "Segoe MDL2 Assets"
            .Caption = ChrW("&H" & IconCode)
            .Font.Size = 12
            .ForeColor = RGB(191, 191, 191)
            .TextAlign = fmTextAlignLeft
            .BorderStyle = fmBorderStyleNone
            .BackStyle = fmBackStyleTransparent
            .AutoFit = True
            .Width = .Height
        End With
    Next
End Sub

Function Active() As aDesigner
    '@AssignedModule aDesigner
    '@INCLUDE CLASS aDesigner
    Set Active = Me
    Class_Initialize
End Function

Private Sub Class_Initialize()
    '@AssignedModule aDesigner
    '@INCLUDE PROCEDURE ActiveModule
    '@INCLUDE CLASS aDesigner
    Set oModule = ActiveModule
    If oModule.Type <> vbext_ct_MSForm Then End
End Sub

Private Sub Class_Terminate()
    'exit
    '@AssignedModule aDesigner
    '@INCLUDE CLASS aDesigner
End Sub

Function SelectedControl() As MSForms.control
    '@AssignedModule aDesigner
    '@INCLUDE CLASS aDesigner
    Dim col         As New Collection
    Set col = SelectedControls
    If col.Count = 1 Then
        Set SelectedControl = col(1)
    End If
End Function

Function SelectedControls() As Collection
    '@AssignedModule aDesigner
    '@INCLUDE CLASS aCollection
    '@INCLUDE CLASS aDesigner
    Dim ctl         As control
    Dim out         As New Collection
    For Each ctl In oModule.Designer.Selected
        out.Add ctl
    Next ctl

    Dim ac          As New aCollection
    Set out = ac.Init(out).Reverse.items
    Set SelectedControls = out
End Function

Function SelectedFrameOrMultipageControl() As MSForms.control
    '@AssignedModule aDesigner
    '@INCLUDE CLASS aDesigner
    Dim col         As New Collection
    Set col = SelectedFrameOrMultipageControls
    If col.Count = 1 Then
        Set SelectedFrameOrMultipageControl = col(1)
    End If
End Function


Function SelectedFrameOrMultipageControls() As Collection
    '@AssignedModule aDesigner
    '@INCLUDE CLASS aCollection
    '@INCLUDE CLASS aDesigner
    Dim ctl         As MSForms.control
    Dim subctl      As MSForms.control
    Dim out         As New Collection
    For Each ctl In SelectedControls
        If InStr("FrameMultiPage", TypeName(ctl)) > 0 Then
            For Each subctl In ctl.Controls
                If InStr("FrameMultiPage", TypeName(subctl)) = 0 And subctl.InSelection Then
                    out.Add subctl
                End If
            Next
        End If
    Next ctl
    Dim ac          As New aCollection
    Set out = ac.Init(out).Reverse.items
    Set SelectedFrameOrMultipageControls = out
End Function

'Function RealActiveControl(oForm As Variant) As MSForms.control
''Jaafar Tribak
'
'    Dim oControl As MSForms.control
'
'    On Error Resume Next
'    Set oControl = oForm.ActiveControl
'    Do
'        Set oControl = CallByName(oControl, "ActiveControl", VbGet)
'    Loop Until TypeName(oControl) <> "Frame"
'    Set RealActiveControl = oControl
'End Function

Sub RemoveCaption()
    '@AssignedModule aDesigner
    '@INCLUDE CLASS aDesigner
    Dim c           As MSForms.control
    For Each c In SelectedControls
        c.Caption = ""
    Next
End Sub

Sub SetHandCursor()
    '@AssignedModule aDesigner
    '@INCLUDE CLASS aDesigner
    Dim ctr As MSForms.control, ctr2 As MSForms.control
    For Each ctr In SelectedControls
        AssignHandCursor ctr
    Next
End Sub

Sub SetHandCursorToSubControls()
    '@AssignedModule aDesigner
    '@INCLUDE CLASS aDesigner
    Dim ctr As MSForms.control, ctr2 As MSForms.control
    For Each ctr In SelectedFrameOrMultipageControls
        AssignHandCursor ctr
    Next
End Sub

Private Sub AssignHandCursor(control As MSForms.control)
    '@AssignedModule aDesigner
    '@INCLUDE CLASS aDesigner
    On Error GoTo catch
    With control
        .MouseIcon = LoadPicture(ThisWorkbook.path & "\Lib\img\Hand Cursor Pointer.ico")
        .MousePointer = fmMousePointerCustom
    End With
catch:
End Sub

Sub SwitchNames()
    '@AssignedModule aDesigner
    '@INCLUDE CLASS aDesigner
    If SelectedControls.Count <> 2 Then Exit Sub

    Dim ctrls       As Collection
    Set ctrls = SelectedControls
    If ctrls.Count <> 2 Then Exit Sub
    Dim tmp1        As String
    tmp1 = ctrls(1).Name
    Dim tmp2        As String
    tmp2 = ctrls(2).Name
    ctrls(1).Name = "tmp1"
    ctrls(2).Name = "tmp2"
    ctrls(1).Name = tmp2
    ctrls(2).Name = tmp1
End Sub

Sub SwitchPositions()
    '@AssignedModule aDesigner
    '@INCLUDE CLASS aDesigner
    If SelectedControls.Count <> 2 Then
        MsgBox "Select exactly 2 controls to swirtch their position"
        Exit Sub
    End If
    Dim ctrls       As Collection
    Set ctrls = SelectedControls
    If ctrls.Count <> 2 Then Exit Sub
    Dim left1 As Long, left2 As Long
    Dim top1 As Long, top2 As Long
    left1 = ctrls(1).Left
    top1 = ctrls(1).Top
    left2 = ctrls(2).Left
    top2 = ctrls(2).Top
    ctrls(1).Left = left2
    ctrls(1).Top = top2
    ctrls(2).Left = left1
    ctrls(2).Top = top1
End Sub


Sub ReplaceCommandButtonWithLabel()
    '@AssignedModule aDesigner
    '@INCLUDE PROCEDURE tmp
    '@INCLUDE CLASS aDesigner
    Dim ctr As MSForms.control, ctr2 As MSForms.control
    Dim lbl         As MSForms.Label
    Dim ctrName     As String
    Dim col         As New Collection: Set col = SelectedControls
    For Each ctr In col
        Set lbl = oModule.Designer.Controls.Add("Forms.label.1")
        ctrName = ctr.Name
        ctr.Name = "tmp" & ctr.Name
        With lbl
            .Name = ctrName
            .Caption = ctr.Caption
            .Tag = ctr.Tag
            .Top = ctr.Top
            .Left = ctr.Left
            .Width = ctr.Width
            .Height = ctr.Height
            .BackColor = ctr.BackColor
            .ForeColor = ctr.ForeColor
            .Font.Size = ctr.Font.Size
            .Font.Name = ctr.Font.Name
        End With
        AssignHandCursor lbl
        oModule.Designer.Controls.Remove ctr.Name
    Next
End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 24-10-2023 19:12    Alex                (aDesigner.cls > CenterLabelCaption)

Sub CenterLabelCaption()
'@LastModified 2310241912
    '@AssignedModule aDesigner
    '@INCLUDE CLASS aDesigner
    Dim lbl         As MSForms.Label
    Set lbl = SelectedControl
    For Each lbl In SelectedControls
        If TypeName(lbl) = "Label" Then
            lbl.Font.Size = IIf(lbl.SpecialEffect = fmSpecialEffectFlat, 18 / 22, 16 / 22) * lbl.Height
            lbl.TextAlign = fmTextAlignCenter
        End If
    Next
End Sub

Sub EditObjectProperties(ParamArray Args() As Variant)
    Rem EditObjectProperties "left",0,"top",0
    '@AssignedModule aDesigner
    '@INCLUDE CLASS aDesigner
    Dim obj         As control: Set obj = SelectedControl
    If obj Is Nothing Or SelectedControls.Count <> 1 Then Exit Sub
    If Not WorksheetFunction.IsEven(UBound(Args)) Then Exit Sub
    Dim i           As Long: i = 0
    Do While i < UBound(Args)
        CallByName obj, Args(i), VbLet, _
                IIf(IsNumeric(Args(i + 1)), _
                CLng(Args(i + 1)), _
                Args(i + 1))
        i = i + 2
    Loop
End Sub

Sub EditObjectsProperty(objProperty As String, ParamArray Args() As Variant)
    '@AssignedModule aDesigner
    '@INCLUDE PROCEDURE Toast
    '@INCLUDE CLASS aDesigner
    Dim obj         As New Collection: Set obj = SelectedControls
    If obj.Count <> UBound(Args) + 1 Then
        Toast "selected controls count <> arguements count"
        Exit Sub
    End If
    Dim ArgItem
    Dim i           As Long
    i = obj.Count
    Dim element     As Variant
    For Each element In obj
        CallByName element, objProperty, VbLet, _
                IIf(IsNumeric(Args(i - 1)), _
                CLng(Args(i - 1)), _
                Args(i - 1))
        i = i - 1
    Next
End Sub

Sub RenameControlAndCode()
    '@AssignedModule aDesigner
    '@INCLUDE PROCEDURE InputboxString
    '@INCLUDE CLASS aDesigner
    Dim ctr         As MSForms.control: Set ctr = SelectedControl
    If ctr Is Nothing Then Exit Sub
    Dim OldName     As String: OldName = ctr.Name
    Dim NewName     As String: NewName = InputboxString
    If NewName = "" Then Exit Sub
    ctr.Name = NewName
    Dim CountOfLines As Long: CountOfLines = oModule.CodeModule.CountOfLines
    If CountOfLines = 0 Then Exit Sub
    Dim strline     As String
    Dim i           As Long
    For i = 1 To CountOfLines
        strline = oModule.CodeModule.Lines(i, 1)
        If InStr(1, strline, " " & OldName & "_") > 0 Then
            oModule.CodeModule.ReplaceLine (i), Replace(strline, OldName, NewName)
        End If
    Next
End Sub

Sub SortControlsHorizontally()
    '@AssignedModule aDesigner
    '@INCLUDE CLASS aDesigner
    SortControls False
End Sub

Sub SortControlsVertically()
    '@AssignedModule aDesigner
    '@INCLUDE CLASS aDesigner
    SortControls True
End Sub

Private Sub SortControls(Optional SortVertically As Boolean = True)
    Rem call from immediate window while looking at userform
    '@AssignedModule aDesigner
    '@INCLUDE CLASS aCollection
    '@INCLUDE CLASS aDesigner
    Dim ctr         As MSForms.control
    Dim coll        As New Collection
    Dim lastTop     As Long
    Dim lastLeft    As Long
    Dim element     As Variant
    For Each element In SelectedControls
        coll.Add element.Name
    Next
    Set coll = aCollection.Init(coll).Sort.items
    lastTop = 2000
    For Each element In coll
        If oModule.Designer.Controls(element).Top < lastTop Then lastTop = oModule.Designer.Controls(element).Top
        If oModule.Designer.Controls(element).Left < lastLeft Then lastLeft = oModule.Designer.Controls(element).Left
    Next
    For Each element In coll
        If SortVertically = True Then
            lastTop = lastTop + oModule.Designer.Controls(element).Height + 6
        Else
            lastLeft = lastLeft + oModule.Designer.Controls(element).Width + 6
        End If
        oModule.Designer.Controls(element).Top = lastTop
        oModule.Designer.Controls(element).Left = lastLeft
    Next
End Sub

Public Sub CopyControlProperties()
    '@AssignedModule aDesigner
    '@INCLUDE PROCEDURE Min
    '@INCLUDE PROCEDURE CreateOrSetSheet
    '@INCLUDE CLASS aDesigner
    If SelectedControls.Count <> 1 Then Exit Sub
    Dim ctr         As control: Set ctr = SelectedControl
    Dim ws          As Worksheet: Set ws = CreateOrSetSheet("CopyControlProperties", ThisWorkbook)
    Dim PropertiesArray As Variant
    PropertiesArray = Array("Accelerator", "Alignment", "AutoSize", "AutoTab", "BackColor", "BackStyle", "BorderColor", "BorderStyle", "BoundColumn", _
            "Caption", "Children", "columnCount", "ColumnHeads", "ColumnWidths", "ControlSource", "ControlTipText", "Cycle", "DrawBuffer", "Enabled", "EnterKeyBehavior", "Expanded", _
            "FirstSibling", "FontBold", "FontSize", "ForeColor", "FullPath", "GroupName", "Height", "HelpContextID", "KeepScrollBarsVisible", "LargeChange", "LastSibling", "LineStyle", "ListRows", "Locked", _
            "Max", "MaxLength", "Min", "MouseIcon", "MousePointer", "MultiLine", "MultiSelect", "Next", "Nodes", "Orientation", _
            "Parent", "PasswordChar", "PathSeparator", "Picture", "PictureAlignment", "PictureSizeMode", "PictureTiling", "Previous", "RightToLeft", "Root", "RowSource", _
            "ScrollBars", "ScrollHeight", "ScrollLeft", "ScrollTop", "ScrollWidth", "Selected", "SelectedItem", "ShowModal", "SmallChange", "Sorted", "SpecialEffect", "StartUpPosition", _
            "Style", "Tag", "Text", "TextColumn", "TripleState", "WhatsThisHelp", "Width", "Zoom")
    If ws.Range("A1") = "" Then ws.Range("A1").Resize(UBound(PropertiesArray) + 1) = WorksheetFunction.Transpose(PropertiesArray)
    Dim PropertiesRange As Range: Set PropertiesRange = ws.Range("A1").CurrentRegion.Resize(, 1)
    Dim Property    As Range
    On Error Resume Next
    For Each Property In PropertiesRange
        Property.offset(0, 1) = CallByName(ctr, Property.Value, VbGet)
    Next
End Sub

Public Sub PasteControlProperties()
    '@AssignedModule aDesigner
    '@INCLUDE PROCEDURE Toast
    '@INCLUDE CLASS aDesigner
    Dim control     As MSForms.control
    Dim Controls    As Collection: Set Controls = SelectedControls
    If Controls.Count = 0 Then Exit Sub
    Dim ws          As Worksheet: Set ws = ThisWorkbook.Sheets("CopyControlProperties")
    If ws.Columns(2).SpecialCells(xlCellTypeConstants).Count = 0 Then
        Toast "You haven't saved properties before"
        Exit Sub
    End If
    Dim PropertiesRange As Range: Set PropertiesRange = ws.Range("A1").CurrentRegion.Resize(, 1)
    Dim Property    As Range
    On Error Resume Next
    For Each control In Controls
        For Each Property In PropertiesRange
            CallByName control, Property.Value, VbLet, Property.offset(0, 1).Value
        Next
    Next
End Sub



Public Sub CopySubControlProperties()
    '@AssignedModule aDesigner
    '@INCLUDE PROCEDURE Min
    '@INCLUDE PROCEDURE CreateOrSetSheet
    '@INCLUDE CLASS aDesigner
    If SelectedFrameOrMultipageControls.Count <> 1 Then Exit Sub
    Dim ctr         As control: Set ctr = SelectedFrameOrMultipageControl
    Dim ws          As Worksheet: Set ws = CreateOrSetSheet("CopyControlProperties", ThisWorkbook)
    Dim PropertiesArray As Variant
    PropertiesArray = Array("Accelerator", "Alignment", "AutoSize", "AutoTab", "BackColor", "BackStyle", "BorderColor", "BorderStyle", "BoundColumn", _
            "Caption", "Children", "columnCount", "ColumnHeads", "ColumnWidths", "ControlSource", "ControlTipText", "Cycle", "DrawBuffer", "Enabled", "EnterKeyBehavior", "Expanded", _
            "FirstSibling", "FontBold", "FontSize", "ForeColor", "FullPath", "GroupName", "Height", "HelpContextID", "KeepScrollBarsVisible", "LargeChange", "LastSibling", "LineStyle", "ListRows", "Locked", _
            "Max", "MaxLength", "Min", "MouseIcon", "MousePointer", "MultiLine", "MultiSelect", "Next", "Nodes", "Orientation", _
            "Parent", "PasswordChar", "PathSeparator", "Picture", "PictureAlignment", "PictureSizeMode", "PictureTiling", "Previous", "RightToLeft", "Root", "RowSource", _
            "ScrollBars", "ScrollHeight", "ScrollLeft", "ScrollTop", "ScrollWidth", "Selected", "SelectedItem", "ShowModal", "SmallChange", "Sorted", "SpecialEffect", "StartUpPosition", _
            "Style", "Tag", "Text", "TextColumn", "TripleState", "WhatsThisHelp", "Width", "Zoom")
    If ws.Range("A1") = "" Then ws.Range("A1").Resize(UBound(PropertiesArray) + 1) = WorksheetFunction.Transpose(PropertiesArray)
    Dim PropertiesRange As Range: Set PropertiesRange = ws.Range("A1").CurrentRegion.Resize(, 1)
    Dim Property    As Range
    On Error Resume Next
    For Each Property In PropertiesRange
        Property.offset(0, 1) = CallByName(ctr, Property.Value, VbGet)
    Next
End Sub

Public Sub PasteSubControlProperties()
    '@AssignedModule aDesigner
    '@INCLUDE PROCEDURE Toast
    '@INCLUDE CLASS aDesigner
    Dim control     As MSForms.control
    Dim Controls    As Collection: Set Controls = SelectedControls
    If Controls.Count = 0 Then Exit Sub
    Dim ws          As Worksheet: Set ws = ThisWorkbook.Sheets("CopyControlProperties")
    If ws.Columns(2).SpecialCells(xlCellTypeConstants).Count = 0 Then
        Toast "You haven't saved properties before"
        Exit Sub
    End If
    Dim PropertiesRange As Range: Set PropertiesRange = ws.Range("A1").CurrentRegion.Resize(, 1)
    Dim Property    As Range
    On Error Resume Next
    For Each control In Controls
        For Each Property In PropertiesRange
            CallByName control, Property.Value, VbLet, Property.offset(0, 1).Value
        Next
    Next
End Sub


Public Sub addFrameFormCode()
    '@AssignedModule aDesigner
    '@INCLUDE PROCEDURE CLIP
    '@INCLUDE PROCEDURE Toast
    '@INCLUDE PROCEDURE Reframe
    '@INCLUDE PROCEDURE dp
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aDesigner
    '@INCLUDE DECLARATION Emitter
    Dim S           As String
    Dim q: q = """"
    S = Join( _
            Array(, _
                "Private WithEvents Emitter As EventListeneRemitter", _
                "", _
                "Private Sub Emitter_LabelMouseOut(Label As MSForms.Label)", _
                "    If InStr(1, Label.Tag, " & q & "reframe" & q & ", vbTextCompare) > 0 Then", _
                "        If Label.BackColor <> &H80B91E Then Label.BackColor = &H534848", _
                "    End If", _
                "End Sub", _
                "", _
                "Private Sub Emitter_LabelMouseOver(Label As MSForms.Label)", _
                "    If InStr(1, Label.Tag, " & q & "reframe" & q & ", vbTextCompare) > 0 Then", _
                "        If Label.BackColor <> &H80B91E Then Label.BackColor = &H808080", _
                "    End If", _
                "End Sub", _
                "", _
                "Sub Emitter_LabelClick(ByRef Label As MSForms.Label)", _
                "    If InStr(1, Label.Tag, " & q & "reframe" & q & ", vbTextCompare) > 0 Then Reframe Me, Label", _
                "End Sub", _
                "", _
                "Private Sub UserForm_Initialize()", _
                "    startFrameForm Me", _
                "End Sub"), _
            vbLf)
    If InStr(1, aModule.Init(oModule).Code, oModule.Name & "_Initialize") Then
        Toast "Threre is already _Initialize_ code in this form. Code will be put in cilpboard and immediate window."
        dp S
        CLIP S
    Else
        oModule.CodeModule.AddFromString S
    End If
End Sub


Public Sub CreateFrameMenu()
    '@AssignedModule aDesigner
    '@INCLUDE PROCEDURE ActiveModule
    '@INCLUDE CLASS aDesigner
    '@INCLUDE DECLARATION MyColors
    Select Case SelectedControls.Count
        Case Is = 0
            ActiveModule.Designer.BackColor = MyColors.FormBackgroundDarkGray
            addFrameSidebar ActiveModule
            addFrameFormCode
        Case Is = 1
            addFrameSidebar SelectedControl
    End Select
End Sub

Private Sub addFrameSidebar(Form As Object, Optional dockRight As Boolean)
    '@INCLUDE askFormMenuElements
    '@INCLUDE UnderlineFrameName
    '@INCLUDE CreateOrSetFrame
    '@AssignedModule aDesigner
    '@INCLUDE PROCEDURE CreateOrSetFrame
    '@INCLUDE CLASS aDesigner
    '@INCLUDE DECLARATION ControlIDLabel
    Dim F           As MSForms.control
    Dim l           As MSForms.control
    Set F = CreateOrSetFrame(Form, "SideBar" & Form.Name)
    F.Tag = "skip"
    F.BackColor = 5457992
    F.ForeColor = vbWhite
    F.BorderStyle = 1
    F.BorderStyle = 0
    F.Width = 80
    If TypeName(Form) = "VBComponent" Then
        F.Height = 800
    Else
        F.Height = Form.Height
    End If
    dockRight = IIf(TypeName(Form) = "VBComponent", False, True)
    If dockRight = True Then
        F.Left = Form.Width - F.Width
    Else
        F.Left = 0
    End If
    UnderlineFrameName Form, F
    If TypeName(Form) = "VBComponent" Then
        Set l = Form.Designer.Controls.Add(ControlIDLabel, "Anchor" & Form.Name)
    Else
        Set l = Form.Controls.Add(ControlIDLabel, "Anchor" & Form.Name)
    End If
    l.Visible = False
    l.Left = IIf(TypeName(Form) = "VBComponent", F.Left + F.Width + 9, 1)
    l.Top = 12
    l.Width = 1
    l.BackColor = vbWhite
    l.Visible = False
    askFormMenuElements Form
End Sub

Private Sub askFormMenuElements(Form As Object)
    '@INCLUDE InputboxString
    '@INCLUDE addFrameMenu
    '@AssignedModule aDesigner
    '@INCLUDE PROCEDURE InputboxString
    '@INCLUDE CLASS aDesigner
    Dim FormElements As String
    FormElements = InputboxString("Form Menus", "Type comma delimited menu names")
    If FormElements = "" Then Exit Sub
    Dim var
    var = Split(FormElements, ",")
    Dim i           As Long
    For i = LBound(var) To UBound(var)
        var(i) = Trim(var(i))
    Next
    Dim coll        As New Collection
    Dim element
    On Error Resume Next
    For Each element In var
        If Not IsNumeric(Left(element, 1)) _
                And InStr(1, element, " ") = 0 Then
            coll.Add CStr(element), CStr(element)
        End If
    Next
    On Error GoTo 0
    For Each element In coll
        addFrameMenu Form, CStr(element)
    Next
End Sub

Private Sub addFrameMenu(Form As Object, FrameCaptionNoSpace As String)
    '@INCLUDE Reframe
    '@INCLUDE UnderlineFrameName
    '@INCLUDE CreateOrSetFrame
    '@INCLUDE AvailableFormOrFrameRow
    '@INCLUDE AvailableFormOrFrameColumn
    '@AssignedModule aDesigner
    '@INCLUDE PROCEDURE CreateOrSetFrame
    '@INCLUDE PROCEDURE AvailableFormOrFrameRow
    '@INCLUDE PROCEDURE AvailableFormOrFrameColumn
    '@INCLUDE PROCEDURE Reframe
    '@INCLUDE CLASS aDesigner
    '@INCLUDE DECLARATION ControlIDFrame
    '@INCLUDE DECLARATION ControlIDLabel
    Dim F           As MSForms.control
    Dim l           As MSForms.control
    Dim module      As VBComponent
    If TypeName(Form) = "VBComponent" Then
        Set module = Form
        Set F = module.Designer.Controls.Add(ControlIDFrame, FrameCaptionNoSpace)
    Else
        Set module = ThisWorkbook.VBProject.VBComponents(Form.Parent.Name)
        Set F = CreateOrSetFrame(module.Designer.Controls(Form.Name), FrameCaptionNoSpace)
    End If
    F.Tag = "anchor" & Form.Name
    F.Caption = FrameCaptionNoSpace
    F.ForeColor = vbWhite
    F.Visible = False
    If TypeName(Form) = "VBComponent" Then
        F.Left = AvailableFormOrFrameColumn(Form.Designer)
    Else
        F.Left = 0
    End If
    F.Visible = True
    F.BorderStyle = 1
    F.BorderStyle = 0
    F.Top = 12
    F.Width = 100
    UnderlineFrameName Form, F
    If TypeName(Form) = "VBComponent" Then
        Set l = module.Designer.Controls("SideBar" & Form.Name).Controls.Add(ControlIDLabel)
    Else
        Set l = module.Designer.Controls("SideBar" & Form.Name).Add(ControlIDLabel)
    End If
    l.Caption = FrameCaptionNoSpace
    l.ForeColor = vbWhite
    l.Visible = False
    l.Top = AvailableFormOrFrameRow(module.Designer.Controls("SideBar" & Form.Name))
    l.Left = l.Left + 3
    l.Visible = True
    l.Tag = "reframe"
    l.Width = F.Width
End Sub

Private Sub AddControlsToFrame(isSubFrame As Boolean)
    '@INCLUDE SelectedControl
    '@INCLUDE SelectedControls
    '@INCLUDE SelectedFrameControl
    '@INCLUDE ActiveModule
    '@INCLUDE InputboxString
    '@AssignedModule aDesigner
    '@INCLUDE PROCEDURE ActiveModule
    '@INCLUDE PROCEDURE InputboxString
    '@INCLUDE CLASS aDesigner
    '@INCLUDE DECLARATION ControlIDCommandButton
    If ActiveModule.Type <> vbext_ct_MSForm Then Exit Sub
    Dim ad          As New aDesigner
    If ad.SelectedControls.Count <> 1 Then Exit Sub
    If TypeName(ad.SelectedControl) <> "Frame" Then Exit Sub
    Dim module      As VBComponent
    Dim TargetFrame As MSForms.control
    If isSubFrame = False Then
        Set TargetFrame = ad.SelectedControl
        Set module = ActiveModule
    Else
        Set TargetFrame = ad.SelectedFrameOrMultipageControl
        Set module = ThisWorkbook.VBProject.VBComponents(TargetFrame.Parent.Parent.Name)
    End If
    Dim ControlNames As String
    ControlNames = InputboxString("Form Menus", "Type comma delimited menu names")
    If ControlNames = "" Then Exit Sub
    Dim var
    var = Split(ControlNames, ",")
    Dim i           As Long
    For i = LBound(var) To UBound(var)
        var(i) = Trim(var(i))
    Next
    Dim coll        As New Collection
    Dim element
    On Error Resume Next
    For Each element In var
        If Not IsNumeric(Left(element, 1)) _
                And InStr(1, element, " ") = 0 Then
            coll.Add CStr(element), CStr(element)
        End If
    Next
    On Error GoTo 0
    Dim l           As MSForms.control
    For Each element In coll
        Set l = module.Designer.Controls(TargetFrame.Name).Controls.Add(ControlIDCommandButton, element)
        l.Top = 7 + ((TargetFrame.Controls.Count - 1) * l.Height)
        l.BackColor = vbWhite
    Next
End Sub

Private Sub UnderlineFrameName(Form As Object, F As MSForms.control)
    '@AssignedModule aDesigner
    '@INCLUDE CLASS aDesigner
    '@INCLUDE DECLARATION ControlIDLabel
    Dim module      As VBComponent
    If TypeName(Form) = "VBComponent" Then
        Set module = Form
    Else
        Set module = ThisWorkbook.VBProject.VBComponents(Form.Parent.Name)
    End If
    Dim l           As MSForms.Label
    Set l = module.Designer.Controls(F.Name).Controls.Add(ControlIDLabel)
    l.Top = 6
    l.Height = 1
    l.Width = 100
    l.BackColor = vbWhite
    l.Tag = "skip"
End Sub


'M_Bookmarks	Module


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Module     : F_Bookmarks
'* Purpose    : per workbook vbe bookmarks
'* Copyright  :
'*
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 19-07-2023 10:08    Alex                per workbook vbe bookmarks
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Public Sub BmSave1(): SaveBookmark 1: End Sub
Public Sub BmSave2(): SaveBookmark 2: End Sub
Public Sub BmSave3(): SaveBookmark 3: End Sub
Public Sub BmSave4(): SaveBookmark 4: End Sub
Public Sub BmSave5(): SaveBookmark 5: End Sub
Public Sub BmSave6(): SaveBookmark 6: End Sub
Public Sub BmSave7(): SaveBookmark 7: End Sub
Public Sub BmSave8(): SaveBookmark 8: End Sub
Public Sub BmSave9(): SaveBookmark 9: End Sub
Public Sub BmSave10(): SaveBookmark 10: End Sub
Public Sub BmSave11(): SaveBookmark 11: End Sub
Public Sub BmSave12(): SaveBookmark 12: End Sub
Public Sub BmSave13(): SaveBookmark 13: End Sub
Public Sub BmSave14(): SaveBookmark 14: End Sub
Public Sub BmSave15(): SaveBookmark 15: End Sub
Public Sub BmSave16(): SaveBookmark 16: End Sub
Public Sub BmSave17(): SaveBookmark 17: End Sub
Public Sub BmSave18(): SaveBookmark 18: End Sub
Public Sub BmSave19(): SaveBookmark 19: End Sub
Public Sub BmSave20(): SaveBookmark 20: End Sub

Public Sub bmload1(): LoadBookmark 1: End Sub
Public Sub bmload2(): LoadBookmark 2: End Sub
Public Sub bmload3(): LoadBookmark 3: End Sub
Public Sub bmload4(): LoadBookmark 4: End Sub
Public Sub bmload5(): LoadBookmark 5: End Sub
Public Sub bmload6(): LoadBookmark 6: End Sub
Public Sub bmload7(): LoadBookmark 7: End Sub
Public Sub bmload8(): LoadBookmark 8: End Sub
Public Sub bmload9(): LoadBookmark 9: End Sub
Public Sub bmload10(): LoadBookmark 10: End Sub
Public Sub bmload11(): LoadBookmark 11: End Sub
Public Sub bmload12(): LoadBookmark 12: End Sub
Public Sub bmload13(): LoadBookmark 13: End Sub
Public Sub bmload14(): LoadBookmark 14: End Sub
Public Sub bmload15(): LoadBookmark 15: End Sub
Public Sub bmload16(): LoadBookmark 16: End Sub
Public Sub bmload17(): LoadBookmark 17: End Sub
Public Sub bmload18(): LoadBookmark 18: End Sub
Public Sub bmload19(): LoadBookmark 19: End Sub
Public Sub bmload20(): LoadBookmark 20: End Sub


'* Modified   : Date and Time       Author              Description
'* Updated    : 18-08-2023 09:42    Alex                add @Bookmark comment (F_Bookmarks.bas > SaveBookmark)

Sub SaveBookmark(index As Long)
    '@LastModified 2308180942

    Dim TargetWorkbook As Workbook: Set TargetWorkbook = ActiveCodepaneWorkbook

    If IniReadKey(BookmarkFile, ActiveCodepaneWorkbook.Name, "Initialized") = "" Then
        IniWrite BookmarkFile, TargetWorkbook.Name, "Initialized", "True"
        ResetBookmarks
    End If

    Dim delim       As String: delim = " | "
    Dim module      As VBComponent: Set module = ActiveModule
    Dim Procedure   As String: Procedure = ActiveProcedure: If Procedure = "" Then Procedure = "N/A"
    Dim BookmarkLine As String
    Dim lineIndex   As Long: lineIndex = aCodeModule.Init(module).RowFirst
    BookmarkLine = TargetWorkbook.Name & delim & _
            module.Name & delim & _
            Procedure & delim & _
            module.CodeModule.Lines(lineIndex, 1)
    module.CodeModule.InsertLines lineIndex, "'@Bookmark" & index
    IniWrite BookmarkFile, TargetWorkbook.Name, CStr(index), BookmarkLine
End Sub

Function BookmarkFile() As String
    BookmarkFile = ThisWorkbook.path & "\Lib\config\bookmarks.ini"
End Function

Sub ListBookmarks()
    dp IniReadSection(BookmarkFile, ActiveCodepaneWorkbook.Name)
    FindCode "@Bookmark"
    '* @TODO Created: 17-08-2023 08:42 Author: Anastasiou Alex
    '* @TODO show on userform - use uCodeFinder? add '@BOOKMARK comment instead?
End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 18-08-2023 09:41    Alex                remove @bookmark comment (F_Bookmarks.bas > RemoveBookmark)

Sub RemoveBookmark(index As Long)
    '@LastModified 2308180941
    Dim BookmarkLine As String: BookmarkLine = IniReadKey(BookmarkFile, ActiveCodepaneWorkbook.Name, CStr(index))
    If BookmarkLine = vbNullString Then Exit Sub
    Dim delim       As String: delim = " | "
    Dim var: var = Split(BookmarkLine, delim)
    Dim targetworkbookname As String: targetworkbookname = var(0)
    Dim ComponentName As String: ComponentName = var(1)
    Dim Procedure   As String: Procedure = var(2)
    BookmarkLine = var(3)

    Dim wb          As Workbook
    Dim module      As VBComponent
    On Error Resume Next
    Set wb = Workbooks(targetworkbookname)
    Set module = wb.VBProject.VBComponents(ComponentName)
    If module Is Nothing Then Set module = ModuleOfProcedure(wb, Procedure)
    On Error GoTo 0
    If module Is Nothing Then Exit Sub
    Dim i           As Long
    Dim ap          As New aProcedure
    ap.Init wb, module, Procedure
    For i = ap.Line_Last To ap.Line_First Step -1
        If InStr(1, ap.Parent.CodeModule.Lines(i, 1), "'@Bookmark" & index, vbTextCompare) > 0 Then
            ap.Parent.CodeModule.DeleteLines i, 1
            Exit For
        End If
    Next

    IniWrite BookmarkFile, ActiveCodepaneWorkbook.Name, CStr(index), ""

End Sub

Sub ResetBookmarks()
    Dim index       As Long
    For index = 1 To 20
        IniWrite BookmarkFile, ActiveCodepaneWorkbook.Name, CStr(index), ""
    Next
    'IniWrite BookmarkFile, ActiveCodepaneWorkbook.Name, vbNullString, vbNullString
End Sub

Sub LoadBookmark(index As Long)
    Dim BookmarkLine As String: BookmarkLine = IniReadKey(BookmarkFile, ActiveCodepaneWorkbook.Name, CStr(index))
    If BookmarkLine = vbNullString Then Exit Sub
retry:
    Dim delim       As String: delim = " | "
    Dim var: var = Split(BookmarkLine, delim)
    Dim targetworkbookname As String: targetworkbookname = var(0)
    Dim ComponentName As String: ComponentName = var(1)
    Dim Procedure   As String: Procedure = var(2)
    BookmarkLine = var(3)

    Dim wb          As Workbook
    Dim module      As VBComponent
    On Error Resume Next
    Set wb = Workbooks(targetworkbookname)
    Set module = wb.VBProject.VBComponents(ComponentName)
    If module Is Nothing Then Set module = ModuleOfProcedure(wb, Procedure)
    On Error GoTo 0
    If module Is Nothing Then Exit Sub
    aModule.Init(module).Activate
    module.CodeModule.CodePane.SetSelection 1, 1, 1, 1
    Dim ProcFirstline As Long
    If Procedure = "N/A" Then Exit Sub
    If Not ProcedureExists(wb, Procedure) Then
        Debug.Print "Procedure " & Procedure & " not found in workbook " & targetworkbookname
        Exit Sub
    End If
    Dim ap          As New aProcedure: ap.Init wb, module, Procedure
    ProcFirstline = ap.Line_First
    module.CodeModule.CodePane.SetSelection ProcFirstline, 1, ProcFirstline, 1
    If BookmarkLine <> "" Then
        If ap.Contains(BookmarkLine, False, False, False) Then
            Dim i   As Long
            For i = ProcFirstline To ap.Line_Last
                If InStr(1, module.CodeModule.Lines(i, 1), BookmarkLine, vbTextCompare) > 0 Then
                    module.CodeModule.CodePane.SetSelection i, 1, i, 10000
                    module.CodeModule.CodePane.TopLine = i
                    Exit Sub
                End If
            Next
        End If
    End If
End Sub


'M_Settings_INI	Module


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Module     : F_Settings_INI
'* Purpose    :
'* Copyright  :
'*
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 30-06-2023 14:11    Alex
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

'____API METHOD______

#If VBA7 Then
Public Declare PtrSafe Function GetPrivateProfileString Lib "kernel32" Alias "GetPrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As Any, ByVal lpDefault As String, ByVal lpReturnedString As String, ByVal nSize As Long, ByVal lpFileName As String) As Long
Public Declare PtrSafe Function WritePrivateProfileString Lib "kernel32" Alias "WritePrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As Any, ByVal lpString As Any, ByVal lpFileName As String) As Long
Public Declare PtrSafe Function GetPrivateProfileSection Lib "kernel32" Alias "GetPrivateProfileSectionA" (ByVal lpAppName As String, ByVal lpReturnedString As String, ByVal nSize As Long, ByVal lpFileName As String) As Long
#Else
public declare Function GetPrivateProfileString Lib "kernel32" Alias "GetPrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As Any, ByVal lpDefault As String, ByVal lpReturnedString As String, ByVal nSize As Long, ByVal lpFileName As String) As Long
public declare Function WritePrivateProfileString Lib "kernel32" Alias "WritePrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As Any, ByVal lpString As Any, ByVal lpFileName As String) As Long
public declare Function GetPrivateProfileSection Lib "kernel32" Alias "GetPrivateProfileSectionA" (ByVal lpAppName As String, ByVal lpReturnedString As String, ByVal nSize As Long, ByVal lpFileName As String) As Long
#End If


Sub TestINI()
    '@AssignedModule F_Settings_INI
    '@INCLUDE PROCEDURE FollowLink
    '@INCLUDE PROCEDURE dp
    '@INCLUDE PROCEDURE IniSections
    '@INCLUDE PROCEDURE IniReadSection
    '@INCLUDE PROCEDURE IniSectionKeys
    '@INCLUDE PROCEDURE IniReadKey
    '@INCLUDE PROCEDURE IniWrite

    Dim FilePath    As String: FilePath = ThisWorkbook.path & "\test.INI"
    FollowLink ThisWorkbook.path

    IniWrite FilePath, "Settings1", "KeyName1", "Value1"
    IniWrite FilePath, "Settings1", "KeyName2", "2"
    IniWrite FilePath, "Settings1", "KeyName3", "3"     'SEE THE FILE
    Stop
    IniWrite FilePath, "Settings1", "KeyName1", "Updated Value"    'SEE THE FILE
    Stop

    Dim i           As Long
    For i = 1 To 5
        IniWrite FilePath, "Settings" & i, "KeyName" & i, i
    Next
    'SEE THE FILE
    Stop
    dp String(20, "~") & " Printing sections of " & FilePath
    dp IniSections(FilePath)
    Stop
    dp String(20, "~") & " Printing keys of section Settings1"
    dp IniSectionKeys(FilePath, "Settings1")
    Stop
    dp String(20, "~") & " Printing all lines of section Settings1"
    dp IniReadSection(FilePath, "Settings1")
    Stop
    dp String(20, "~") & " Printing value of Section: Settings1, Keyname: Keyname1"
    dp IniReadKey(FilePath, "Settings1", "KeyName1")

End Sub

Public Function IniSections(iniFile As String) As Variant
    '@INCLUDE PROCEDURE TxtRead
    '@AssignedModule F_Settings_INI

    '---sample file content---
    '[settings1]
    '    string1 = aaa
    '    string2 = bbb
    '[settings2]
    '    string1 = ccc
    '    string2 = ddd
    '-------------------------
    IniSections = Split(Replace(Replace(Join(Filter(Split(Replace(TxtRead(iniFile), vbLf, vbNewLine), vbNewLine), "[", True), vbNewLine), "[", ""), "]", ""), vbNewLine)
    '------Result------------------
    'Array("settings1","settings2")
End Function

Public Function IniReadSection(fileName As String, Section As String) As Variant
    '@INCLUDE DECLARATION GetPrivateProfileSection
    '@INCLUDE PROCEDURE ArrayRemoveEmptyElements
    '@AssignedModule F_Settings_INI
    Dim RetVal      As String * 255
    Dim V           As Long: V = GetPrivateProfileSection(Section, RetVal, 255, fileName)
    Dim S           As String: S = Left(RetVal, V + 0)
    Dim VL          As Variant: VL = Split(S, Chr$(0))
    VL = ArrayRemoveEmptyElements(VL)
    IniReadSection = VL
    '-----result for reading "settings1"-----
    'Array("string1=aaa","string2=bbb")
End Function

Public Function IniSectionKeys(fileName As String, Section As String) As Variant
    '@AssignedModule F_Settings_INI
    '@INCLUDE PROCEDURE IniReadSection
    '@INCLUDE PROCEDURE IniSectionExists
    Dim arr()       As Variant
    If Not IniSectionExists(fileName, Section) Then
        IniSectionKeys = arr
        Exit Function
    End If
    arr = IniReadSection(fileName, Section)
    Dim out         As Variant
    ReDim out(UBound(arr))
    Dim i           As Long
    For i = LBound(arr) To UBound(arr)
        out(i) = Trim(Split(arr(i), "=")(0))
    Next i
    IniSectionKeys = out
    '-----result for reading "settings1"-----
    'string1
    'string2
End Function

Public Function IniReadKey(IniFileName As String, ByVal Sect As String, ByVal Keyname As String, Optional ByVal Default As Variant)    'As String
    '@INCLUDE DECLARATION GetPrivateProfileString
    '@AssignedModule F_Settings_INI
    Dim Worked      As Long
    Dim RetStr      As String * 128
    Dim StrSize     As Long
    Dim iNoOfCharInIni As Long: iNoOfCharInIni = 0
    Dim sIniString  As String: sIniString = ""
    If Sect = "" Or Keyname = "" Then
        MsgBox "Section Or Key To Read Not Specified !!!", vbExclamation, "INI"
    Else
        Dim sProfileString As String: sProfileString = ""
        RetStr = Space(128)
        StrSize = Len(RetStr)
        Worked = GetPrivateProfileString(Sect, Keyname, "", RetStr, StrSize, IniFileName)
        If Worked Then
            iNoOfCharInIni = Worked
            sIniString = Left$(RetStr, Worked)
        End If
    End If

    If sIniString <> vbNullString Then
        IniReadKey = sIniString
    ElseIf sIniString = vbNullString And Not IsMissing(Default) Then
        IniReadKey = Default
    End If
    '---- result for reading "settings1", "string1" ----
    'aaa
End Function

Public Sub IniWrite(IniFileName As String, ByVal Sect As String, ByVal Keyname As String, ByVal Wstr As String)
    '@INCLUDE DECLARATION WritePrivateProfileString
    '@AssignedModule F_Settings_INI

    'This macro also creates the file & section & key if they doesn't exist

    Dim Worked      As Long
    Dim iNoOfCharInIni As Long

    iNoOfCharInIni = 0
    Dim sIniString  As String: sIniString = ""
    If Sect = "" Or Keyname = "" Then
        MsgBox "Section Or Key To Write Not Specified !!!", vbExclamation, "INI"
    Else
        Worked = WritePrivateProfileString(Sect, Keyname, Wstr, IniFileName)
        If Worked Then
            iNoOfCharInIni = Worked
            sIniString = Wstr
        End If
    End If

    '---- result for writing "settings1", "string1", "newval" ----
    '[settings1]
    '    string1 = newval
    '    string2 = bbb
    '[settings2]
    '    string1 = ccc
    '    string2 = ddd

    '---- result for writing "settings1", "string3", "newkey" ----
    '[settings1]
    '    string1 = newval
    '    string2 = bbb
    '    string3 = newkey
    '[settings2]
    '    string1 = ccc
    '    string2 = ddd
End Sub






'___NO API METHOD______
'
Public Sub TestReadKey()
    Debug.Print Join( _
                    Array( _
                        "INI File: " & ThisWorkbook.path & "\MyIniFile.ini", _
                        "Section: SETTINGS", _
                        "Section Exist: " & IniSectionExists(ThisWorkbook.path & "\MyIniFile.ini", "SETTINGS"), _
                        "Key: License", _
                        "Key Exist: " & IniKeyExists(ThisWorkbook.path & "\MyIniFile.ini", "SETTINGS", "License"), _
                        "Key Value: " & Ini_ReadKeyVal(ThisWorkbook.path & "\MyIniFile.ini", "SETTINGS", "License")), _
                    vbLf)
    'You can validate the value by checking the bSectionExists and bKeyExists variable to ensure they were actually found in the ini file
    '@AssignedModule F_Settings_INI
    '@INCLUDE PROCEDURE IniSectionExists
    '@INCLUDE PROCEDURE IniKeyExists
End Sub

Public Function IniSectionExists(iniFile As String, Section As String) As Boolean
    'Alex
    '@AssignedModule F_Settings_INI
    '@INCLUDE PROCEDURE TxtRead
    IniSectionExists = InStr(1, TxtRead(iniFile), "[" & Section & "]") > 0
End Function

Public Function IniKeyExists(iniFile As String, Section As String, Key As String) As Boolean
    'Alex
    '@AssignedModule F_Settings_INI
    IniKeyExists = (Ini_ReadKeyVal(iniFile, Section, Key) <> "")
End Function

Public Sub TestWriteKey()
    '@AssignedModule F_Settings_INI
    If Ini_WriteKeyVal(ThisWorkbook.path & "\MyIniFile.ini", "SETTINGS", "License", "JBXR-HHTY-LKIP-HJNB-GGGT") = True Then
        MsgBox "The key was written"
    Else
        MsgBox "An error occurred!"
    End If
End Sub

'---------------------------------------------------------------------------------------
' Procedure : Ini_ReadKeyVal
' Author    : Daniel Pineault, CARDA Consultants Inc.
' Website   : http://www.cardaconsultants.com
' Purpose   : Read an Ini file's Key
' Copyright : The following may be altered and reused as you wish so long as the
'             copyright notice is left unchanged (including Author, Website and
'             Copyright).  It may not be sold/resold or reposted on other sites (links
'             back to this site are allowed).
' Req'd Refs: Uses Late Binding, so none required
'             No APIs either! 100% VBA
'
' Input Variables:
' ~~~~~~~~~~~~~~~~
' sIniFile  : Full path and filename of the ini file to read
' sSection  : Ini Section to search for the Key to read the Key from
' sKey      : Name of the Key to read the value of
'
' Usage:
' ~~~~~~
' ? Ini_Read(Application.CurrentProject.Path & "\MyIniFile.ini", "LINKED TABLES", "Path")
'
' Revision History:
' Rev       Date(yyyy/mm/dd)        Description
' **************************************************************************************
' 1         2012-08-09              Initial Release
'---------------------------------------------------------------------------------------
Public Function Ini_ReadKeyVal(ByVal sIniFile As String, _
        ByVal sSection As String, _
        ByVal sKey As String) As String
    '@AssignedModule F_Settings_INI
    '@INCLUDE PROCEDURE FileExists
    '@INCLUDE PROCEDURE TxtRead
    '@INCLUDE PROCEDURE ArrayTrim
    On Error GoTo Error_Handler
    Dim bSectionExists As Boolean
    Dim bKeyExists  As Boolean
    Dim sIniFileContent As String
    Dim aIniLines() As String
    Dim sLine       As String
    Dim i           As Long

    sIniFileContent = ""
    bSectionExists = False
    bKeyExists = False

    'Validate that the file actually exists
    If FileExists(sIniFile) = False Then
        MsgBox "The specified ini file: " & vbCrLf & vbCrLf & _
                sIniFile & vbCrLf & vbCrLf & _
                "could not be found.", vbCritical + vbOKOnly, "File not found"
        GoTo Error_Handler_Exit
    End If

    sIniFileContent = TxtRead(sIniFile)    'Read the file into memory
    aIniLines = Split(sIniFileContent, vbLf)
    For i = 0 To UBound(aIniLines)
        sLine = Trim(aIniLines(i))
        sLine = VBA.Replace(sLine, vbTab, vbNullString)
        If InStr(1, sLine, "=") > 0 Then sLine = Join(ArrayTrim(Split(sLine, "=")), "=")    '<- Alex added this
        If bSectionExists = True And Left(sLine, 1) = "[" And Right(sLine, 1) = "]" Then
            Exit For    'Start of a new section
        End If
        If sLine = "[" & sSection & "]" Then
            bSectionExists = True
        End If
        If bSectionExists = True Then
            If sLine Like sKey & "=*" Then
                bKeyExists = True
                Ini_ReadKeyVal = Mid(sLine, InStr(sLine, "=") + 1)
            End If
        End If
    Next i

Error_Handler_Exit:
    On Error Resume Next
    Exit Function

Error_Handler:
    'Err.Number = 75 'File does not exist, Permission issues to write is denied,
    MsgBox Join( _
                Array( _
                    "The following error has occurred", _
                    "", _
                    "Error Number: " & Err.Number, _
                    "Error Source: Ini_ReadKeyVal", _
                    "Error Description: " & Err.Description & _
                    Switch(Erl = 0, "", Erl <> 0, vbCrLf & "Line No: " & Erl) _
                    , vbOKOnly + vbCritical, "An Error has Occurred!"), _
                vbLf)
                    
    Resume Error_Handler_Exit
End Function

'---------------------------------------------------------------------------------------
' Procedure : Ini_WriteKeyVal
' Author    : Daniel Pineault, CARDA Consultants Inc.
' Website   : http://www.cardaconsultants.com
' Purpose   : Writes a Key value to the specified Ini file's Section
'               If the file does not exist, it will be created
'               If the Section does not exist, it will be appended to the existing content
'               If the Key does not exist, it will be appended to the existing Section content
' Copyright : The following may be altered and reused as you wish so long as the
'             copyright notice is left unchanged (including Author, Website and
'             Copyright).  It may not be sold/resold or reposted on other sites (links
'             back to this site are allowed).
' Req'd Refs: Uses Late Binding, so none required
'             No APIs either! 100% VBA
'
' Input Variables:
' ~~~~~~~~~~~~~~~~
' sIniFile  : Full path and filename of the ini file to edit
' sSection  : Ini Section to search for the Key to edit
' sKey      : Name of the Key to edit
' sValue    : Value to associate to the Key
'
' Usage:
' ~~~~~~
' Call Ini_WriteKeyVal(Application.CurrentProject.Path & "\MyIniFile.ini", "LINKED TABLES", "Paths", "D:\")
'
' Revision History:
' Rev       Date(yyyy/mm/dd)        Description
' **************************************************************************************
' 1         2012-08-09              Initial Release
' 2         2020-01-27              Fix to address issue flagged by users
'---------------------------------------------------------------------------------------
Public Function Ini_WriteKeyVal(ByVal sIniFile As String, _
        ByVal sSection As String, _
        ByVal sKey As String, _
        ByVal sValue As String) As Boolean
    '@AssignedModule F_Settings_INI
    '@INCLUDE PROCEDURE FileExists
    '@INCLUDE PROCEDURE TxtOverwrite
    '@INCLUDE PROCEDURE TxtRead
    On Error GoTo Error_Handler
    Dim bSectionExists As Boolean
    Dim bKeyExists  As Boolean
    Dim sIniFileContent As String
    Dim aIniLines() As String
    Dim sLine       As String
    Dim sNewLine    As String
    Dim i           As Long
    Dim bFileExist  As Boolean
    Dim bInSection  As Boolean
    Dim bKeyAdded   As Boolean

    sIniFileContent = ""
    bSectionExists = False
    bKeyExists = False

    'Validate that the file actually exists
    If FileExists(sIniFile) = False Then
        GoTo SectionDoesNotExist
    End If
    bFileExist = True

    sIniFileContent = TxtRead(sIniFile)    'Read the file into memory
    aIniLines = Split(sIniFileContent, vbLf)    'Break the content into individual lines
    sIniFileContent = ""    'Reset it
    For i = 0 To UBound(aIniLines)    'Loop through each line
        sNewLine = ""
        sLine = Trim(aIniLines(i))
        If sLine = "[" & sSection & "]" Then
            bSectionExists = True
            bInSection = True
        End If
        If bInSection = True Then
            If sLine <> "[" & sSection & "]" Then
                If Left(sLine, 1) = "[" And Right(sLine, 1) = "]" Then
                    'Our section exists, but the key wasn't found, so append it
                    sNewLine = sKey & "=" & sValue
                    i = i - 1
                    bInSection = False    ' we're switching section
                    bKeyAdded = True
                End If
            End If
            If Len(sLine) > Len(sKey) Then
                If Left(sLine, Len(sKey) + 1) = sKey & "=" Then
                    sNewLine = sKey & "=" & sValue
                    bKeyExists = True
                    bKeyAdded = True
                End If
            End If
        End If
        If Len(sIniFileContent) > 0 Then sIniFileContent = sIniFileContent & vbCrLf
        If sNewLine = "" Then
            sIniFileContent = sIniFileContent & sLine
        Else
            sIniFileContent = sIniFileContent & sNewLine
        End If
    Next i

SectionDoesNotExist:
    'if not found, add it to the end
    If bSectionExists = False Then
        If Len(sIniFileContent) > 0 Then sIniFileContent = sIniFileContent & vbCrLf
        sIniFileContent = sIniFileContent & "[" & sSection & "]"
    End If
    If bKeyAdded = False Then
        sIniFileContent = sIniFileContent & vbCrLf & sKey & "=" & sValue
    End If

    'Write to the ini file the new content
    Call TxtOverwrite(sIniFile, sIniFileContent)
    Ini_WriteKeyVal = True

Error_Handler_Exit:
    On Error Resume Next
    Exit Function

Error_Handler:
    MsgBox Join( _
                Array( _
                    "The following error has occurred", _
                    "", _
                    "Error Number: " & Err.Number, _
                    "Error Source: Ini_WriteKeyVal", _
                    "Error Description: " & Err.Description & _
                    Switch(Erl = 0, "", Erl <> 0, vbCrLf & "Line No: " & Erl) _
                    , vbOKOnly + vbCritical, "An Error has Occurred!"), _
                vbLf)
                    
    Resume Error_Handler_Exit
End Function

'_____________________________________________________________


'aComboBox	Class


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Class      : aComboBox
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 27-06-2023 12:35    Alex                figured how to get the hwnd
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Public oComboBox    As ComboBox

Rem resize combobox List Portion
#If VBA7 Then
Private Declare PtrSafe Function GetDeviceCaps Lib "gdi32" (ByVal hdc As LongPtr, ByVal nIndex As Long) As Long
Private Declare PtrSafe Function CreateCompatibleDC Lib "gdi32" (ByVal hdc As LongPtr) As LongPtr
Private Declare PtrSafe Function DeleteDC Lib "gdi32" (ByVal hdc As LongPtr) As Long
Private Declare PtrSafe Function DrawText Lib "user32" Alias "DrawTextW" (ByVal hdc As LongPtr, ByVal lpStr As LongPtr, ByVal nCount As Long, lpRect As RECT, ByVal wFormat As Long) As Long
Private Declare PtrSafe Function SetMapMode Lib "gdi32" (ByVal hdc As LongPtr, ByVal nMapMode As Long) As Long
Private Declare PtrSafe Function GetTextExtentPoint32 Lib "gdi32" Alias "GetTextExtentPoint32W" (ByVal hdc As LongPtr, ByVal lpsz As LongPtr, ByVal cbString As Long, lpSize As ComboboxListSize) As Long
Private Declare PtrSafe Function SelectObject Lib "gdi32" (ByVal hdc As LongPtr, ByVal hObject As LongPtr) As LongPtr
Private Declare PtrSafe Function DeleteObject Lib "gdi32" (ByVal hObject As LongPtr) As Long
Private Declare PtrSafe Function GetSystemMetrics Lib "user32" (ByVal nIndex As Long) As Long
#Else
Private Enum LongPtr
    [_]
End Enum
Private Declare Function GetDeviceCaps Lib "gdi32" (ByVal hDC As LongPtr, ByVal nIndex As Long) As Long
Private Declare Function CreateCompatibleDC Lib "gdi32" (ByVal hDC As LongPtr) As LongPtr
Private Declare Function DeleteDC Lib "gdi32" (ByVal hDC As LongPtr) As Long
Private Declare Function DrawText Lib "user32" Alias "DrawTextW" (ByVal hDC As LongPtr, ByVal lpStr As LongPtr, ByVal nCount As Long, lpRect As RECT, ByVal wFormat As Long) As Long
Private Declare Function SetMapMode Lib "gdi32" (ByVal hDC As LongPtr, ByVal nMapMode As Long) As Long
Private Declare Function GetTextExtentPoint32 Lib "gdi32" Alias "GetTextExtentPoint32W" (ByVal hDC As LongPtr, ByVal lpsz As LongPtr, ByVal cbString As Long, lpSize As ComboboxListSize) As Long
Private Declare Function SelectObject Lib "gdi32" (ByVal hDC As LongPtr, ByVal hObject As LongPtr) As LongPtr
Private Declare Function DeleteObject Lib "gdi32" (ByVal hObject As LongPtr) As Long
Private Declare Function GetSystemMetrics Lib "user32" (ByVal nIndex As Long) As Long
#End If

#If Win64 Then
Private Const NULL_PTR = 0^
#Else
Private Const NULL_PTR = 0&
#End If

Private Type ComboboxListSize
    cx              As Long
    cy              As Long
End Type

Private Type RECT
    Left            As Long
    Top             As Long
    Right           As Long
    Bottom          As Long
End Type

Public Function Init(cbx As ComboBox) As aComboBox
    '@AssignedModule aComboBox
    '@INCLUDE CLASS aComboBox
    Set oComboBox = cbx
    Set Init = Me
End Function

Public Function AutoSizeDropDown(Optional ByVal JumpToWidestEntry As Boolean = False) As Long
    '@AssignedModule aComboBox
    '@INCLUDE CLASS aComboBox
    '@INCLUDE DECLARATION GetSystemMetrics

    Const MM_TEXT = 1&
    Const SM_CXVSCROLL = 2&

    Static bDropDownState As Boolean
    Dim hMemDc      As LongPtr
    Dim hPrevFont   As LongPtr
    Dim IFont       As stdole.IFont
    Dim lPrevMPMode As Long
    Dim lIndex      As Long
    Dim lMaxWidth   As Long
    Dim lMaxIndex   As Long
    Dim sItemText   As String
    Dim sWidestText As String
    Dim tSize       As ComboboxListSize

    hMemDc = CreateCompatibleDC(NULL_PTR)
    If hMemDc Then
        lPrevMPMode = SetMapMode(hMemDc, MM_TEXT)
        Set IFont = oComboBox.Font
        hPrevFont = SelectObject(hMemDc, IFont.hFont)
        With oComboBox
            For lIndex = 0& To .ListCount - 1&
                sItemText = .list(lIndex)
                Call GetTextExtentPoint32(hMemDc, StrPtr(sItemText), Len(sItemText), tSize)
                If lMaxWidth < tSize.cx Then
                    lMaxWidth = tSize.cx
                    sWidestText = sItemText
                    lMaxIndex = lIndex
                End If
            Next lIndex
            'Debug.Print lMaxIndex, sWidestText
            AutoSizeDropDown = lMaxIndex
            lMaxWidth = PXtoPT(hMemDc, lMaxWidth + 2.5 * GetSystemMetrics(SM_CXVSCROLL), False)
            Call SetMapMode(hMemDc, lPrevMPMode)
            Call SelectObject(hMemDc, hPrevFont)
            Call DeleteDC(hMemDc)
            .ListWidth = lMaxWidth
            If JumpToWidestEntry Then
                If bDropDownState = False Then
                    .ListIndex = lMaxIndex
                End If
            End If
            bDropDownState = Not bDropDownState
        End With
    End If

End Function

Private Function ScreenDPI(ByVal bVert As Boolean, ByVal hdc As LongPtr) As Long
    '@AssignedModule aComboBox
    '@INCLUDE CLASS aComboBox
    '@INCLUDE DECLARATION LOGPIXELSX
    '@INCLUDE DECLARATION LOGPIXELSY
    '@INCLUDE DECLARATION GetDeviceCaps
    Const LOGPIXELSX As Long = 88&
    Const LOGPIXELSY As Long = 90&
    Static lDPI(1&) As Long

    If lDPI(0&) = 0& Then
        lDPI(0&) = GetDeviceCaps(hdc, LOGPIXELSX)
        lDPI(1&) = GetDeviceCaps(hdc, LOGPIXELSY)
    End If
    ScreenDPI = lDPI(Abs(bVert))
End Function

Private Function PXtoPT(ByVal hdc As LongPtr, ByVal Pixels As Single, ByVal bVert As Boolean) As Single
    '@AssignedModule aComboBox
    '@INCLUDE CLASS aComboBox
    Const POINTSPERINCH As Long = 72&
    PXtoPT = (Pixels / (ScreenDPI(bVert, hdc) / POINTSPERINCH))
End Function



Public Sub LoadVBProjects()
    '@AssignedModule aComboBox
    '@INCLUDE PROCEDURE WorkbookProjectProtected
    '@INCLUDE CLASS aComboBox
    Dim coll        As New Collection
    Dim wb          As Workbook
    For Each wb In Workbooks
        If Len(wb.path) > 0 Then
            If WorkbookProjectProtected(wb) = False Then
                On Error Resume Next
                coll.Add wb.Name, wb.Name
                On Error GoTo 0
            End If
        End If
    Next
    Rem list addins
    Dim vbProj      As VBProject
    Dim wbPath      As String
    For Each vbProj In Application.VBE.VBProjects
        On Error GoTo ErrorHandler
        wbPath = vbProj.fileName
        If Right(wbPath, 4) = "xlam" Or Right(wbPath, 3) = "xla" Then
            Dim wbName As String
            wbName = Mid(wbPath, InStrRev(wbPath, "\") + 1)
            If WorkbookProjectProtected(Workbooks(wbName)) = False Then
                On Error Resume Next
                coll.Add wbName, wbName
                On Error GoTo 0
            End If
        End If
SKIP:
    Next vbProj

    Dim el          As Variant
    For Each el In coll
        oComboBox.AddItem el
    Next

    Exit Sub
ErrorHandler:
    If Err.Number = 76 Then GoTo SKIP
End Sub


'z_ListView	UserForm

Option Explicit



Private Sub Label2_Click()
    '@AssignedModule z_ListView
    '@INCLUDE USERFORM z_ListView

End Sub

Private Sub UserForm_Initialize()
    '@AssignedModule z_ListView
    '@INCLUDE CLASS aListView
    '@INCLUDE USERFORM z_ListView
    Dim i           As Long
    For i = 1 To 4
        ListView1.ListItems.Add , , "Test" & i
    Next
    With ListView1
        .FullRowSelect = True
        .LabelEdit = lvwManual
        .View = lvwReport
        .ColumnHeaders.Add , , "Filepath"
        .multiSelect = False    '@TODO multi drag drop
    End With

    With aListView.Init(ListView1)
        .AutofitColumns
        .EnableDropFilesFolders True, False, False, "*"
        .EnableDragSort
    End With


End Sub


'aListView	Class


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Class      : aListView
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 29-06-2023 13:45    Alex
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Public WithEvents EventDragSort As ListView
Public WithEvents EventDropFiles As ListView
Public WithEvents aListViewEvent As ListView

#If VBA7 Then
Private Declare PtrSafe Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long
Private Declare PtrSafe Function SendMessageLong Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
Private Declare PtrSafe Function GetDC Lib "user32" (ByVal hwnd As Long) As Long
Private Declare PtrSafe Function GetDeviceCaps Lib "gdi32" (ByVal hdc As Long, ByVal nIndex As Long) As Long
Private Declare PtrSafe Function ReleaseDC Lib "user32" (ByVal hwnd As Long, ByVal hdc As Long) As Long

Private Declare PtrSafe Sub mouse_event Lib "user32" (ByVal dwFlags As Long, ByVal dX As Long, ByVal dy As Long, ByVal cbuttons As Long, ByVal dwExtraInfo As Long)
Private Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
#Else
Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long
Private Declare Function SendMessageLong Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
private Declare Function GetDC Lib "user32" (ByVal hWnd As Long) As Long
private Declare Function GetDeviceCaps Lib "gdi32" (ByVal hDC As Long, ByVal nIndex As Long) As Long
private Declare Function ReleaseDC Lib "user32" (ByVal hWnd As Long, ByVal hDC As Long) As Long

Private Declare Sub mouse_event Lib "user32" (ByVal dwFlags As Long, ByVal dx As Long, ByVal dy As Long, ByVal cButtons As Long, ByVal dwExtraInfo As Long)
Private Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
#End If

Private Const MOUSEEVENTF_LEFTDOWN = &H2
Private Const MOUSEEVENTF_LEFTUP = &H4

'Windows API Constants
Private Const LOGPIXELSX = 88
Private Const LOGPIXELSY = 90

Private Const LVM_FIRST = &H1000
Private Const LVM_SETCOLUMNWIDTH = (LVM_FIRST + 30)

Private Const LVSCW_AUTOSIZE = -1
Private Const LVSCW_AUTOSIZE_USEHEADER = -2

Private Const LVM_GETNEXTITEM = (LVM_FIRST + 12)
Private Const LVNI_SELECTED = &H2
Private Const LVM_GETSELECTEDCOUNT = (LVM_FIRST + 50)

Public oListView    As ListView

Private option_DD_LogFiles As Boolean
Private option_DD_LogFolders As Boolean
Private option_DD_IncludeSubfolders As Boolean
Private option_DD_CommaSeparatedFilters As String


Public LstItmObj    As ListItem
Public swapNeeded   As Boolean    'swap mode

Private Type POINTAPI
    X               As Long
    Y               As Long
End Type
Private Type LVHITTESTINFO
    pt              As POINTAPI
    Flags           As Long
    iItem           As Long
    iSubItem        As Long
End Type

Private Const LVM_HITTEST As Long = &H418
Private Const LVM_SUBITEMHITTEST As Long = &H1039
Private Const LVHT_ONITEM As Long = &H2

Public Function Value()
    '@AssignedModule aListView
    '@INCLUDE CLASS aListView
    Dim headCount   As Long: headCount = oListView.ColumnHeaders.Count
    Dim rowCount    As Long: rowCount = oListView.ListItems.Count

    Dim arr()
    ReDim arr(1 To rowCount, 1 To headCount)
    Dim X           As Long
    Dim Y           As Long
    For Y = 1 To oListView.ColumnHeaders.Count
        arr(1, Y) = oListView.ColumnHeaders(Y)
    Next
    If oListView.ListItems.Count > 0 Then
        For X = 1 To oListView.ListItems.Count
            For Y = 1 To headCount
                If Y = 1 Then
                    arr(X, Y) = oListView.ListItems(X)
                Else
                    arr(X, Y) = oListView.ListItems(X).ListSubItems(Y - 1)
                End If
            Next
        Next
        Value = arr
    Else
        Value = Array()
    End If
End Function

Public Function RowArray(targetRow As Long)
    '@AssignedModule aListView
    '@INCLUDE CLASS aListView
    Dim headCount   As Long: headCount = oListView.ColumnHeaders.Count
    Dim arr
    ReDim arr(1 To headCount)
    Dim i           As Long
    For i = 1 To headCount
        If i = 1 Then
            arr(i) = oListView.ListItems(targetRow)
        Else
            arr(i) = oListView.ListItems(targetRow).ListSubItems(i - 1)
        End If
    Next
    RowArray = arr
End Function

Public Function SelectionArray()
    '@AssignedModule aListView
    '@INCLUDE CLASS aListView
    Dim item        As MSComctlLib.ListItem
    Dim targetRow   As Long
    Dim arr()
    Dim i As Long, counter As Long
    Dim headCount   As Long: headCount = oListView.ColumnHeaders.Count
    If oListView.multiSelect = False Then
        targetRow = oListView.SelectedItem.index
        arr = RowArray(targetRow)
    Else
        ReDim arr(1 To 1, 1 To headCount)
        For Each item In oListView.ListItems
            If item.Selected Then
                targetRow = item.index
                counter = counter + 1
                ReDim Preserve arr(1 To counter, 1 To headCount)
                For i = 1 To headCount
                    If i = 1 Then
                        arr(counter, i) = oListView.ListItems(targetRow)
                    Else
                        arr(counter, i) = oListView.ListItems(targetRow).ListSubItems(i - 1)
                    End If
                Next

            End If
        Next
    End If
    SelectionArray = arr
End Function

Public Function ClickedColumn(X, Y)
    'call from userform ListView1_MouseDown event and such
    '@AssignedModule aListView
    '@INCLUDE CLASS aListView
    '@INCLUDE DECLARATION SendMessage
    ClickedColumn = -1

    Dim hitTestInfo As LVHITTESTINFO
    hitTestInfo.pt.X = X
    hitTestInfo.pt.Y = Y
    SendMessage oListView.hwnd, LVM_SUBITEMHITTEST, 0, hitTestInfo

    If hitTestInfo.Flags = 4 Then
        Dim ColumnIndex As Long
        ColumnIndex = hitTestInfo.iSubItem
        ClickedColumn = ColumnIndex
    End If

End Function

Sub DeselectAll()
    '@AssignedModule aListView
    '@INCLUDE CLASS aListView
    '@INCLUDE DECLARATION SendMessage
    Dim sThisItem As Long, lLvHwnd As Long, lSelectedItems As Long, lItemIndex As Long

    On Error GoTo ErrFailed

    With oListView
        lLvHwnd = .hwnd
        lSelectedItems = SendMessage(lLvHwnd, LVM_GETSELECTEDCOUNT, 0, ByVal 0&)
        lItemIndex = -1
        For sThisItem = 1 To lSelectedItems
            lItemIndex = SendMessage(lLvHwnd, LVM_GETNEXTITEM, lItemIndex, ByVal LVNI_SELECTED)
            .ListItems(lItemIndex + 1).Selected = False
        Next
    End With
    Exit Sub

ErrFailed:
    Debug.Print Err.Description
    Debug.Assert False
End Sub

Public Sub EnableDragSort()
    '@AssignedModule aListView
    '@INCLUDE CLASS aListView
    Set EventDragSort = oListView
    swapNeeded = False
End Sub

Private Sub EventDragSort_OLEStartDrag(Data As MSComctlLib.DataObject, AllowedEffects As Long)
    '@AssignedModule aListView
    '@INCLUDE CLASS aListView
    Set LstItmObj = EventDragSort.SelectedItem
End Sub

'when drop occurs we make mouseclick to select next item and then set swap mode on
Private Sub EventDragSort_OLEDragDrop(Data As MSComctlLib.DataObject, Effect As Long, Button As Integer, Shift As Integer, X As Single, Y As Single)
    'that click will occur only after end of this Sub, that's why we can't make rows swaping here
    '@AssignedModule aListView
    '@INCLUDE CLASS aListView
    Call SingleClick
    swapNeeded = True
End Sub

'this Sub starts after OLEDragDrop ends so new row is already selected and old row is already saved to LstItmObj so here we just need to swap those two rows
Private Sub eventdragsort_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As stdole.OLE_XPOS_PIXELS, ByVal Y As stdole.OLE_YPOS_PIXELS)
    '@AssignedModule aListView
    '@INCLUDE CLASS aListView
    '@INCLUDE DECLARATION Sleep
    If LstItmObj Is Nothing Then Exit Sub
    If (swapNeeded) Then
        Sleep 30
        Dim insertedList As ListItem
        Dim SelectedIndex As Integer
        Dim newListSubItemObj As ListSubItem

        SelectedIndex = EventDragSort.SelectedItem.index
        EventDragSort.ListItems.Remove LstItmObj.index

        Set insertedList = EventDragSort.ListItems.Add(SelectedIndex, LstItmObj.Key, LstItmObj.TEXT, LstItmObj.Icon, LstItmObj.SmallIcon)
        For Each newListSubItemObj In LstItmObj.ListSubItems
            insertedList.ListSubItems.Add newListSubItemObj.index, newListSubItemObj.Key, newListSubItemObj.TEXT, newListSubItemObj.ReportIcon, newListSubItemObj.TooltipText
        Next newListSubItemObj    'swap mode off again
        swapNeeded = False
        Set EventDragSort.SelectedItem = EventDragSort.ListItems.item(SelectedIndex)
    End If
End Sub

Private Sub SingleClick()
    '@AssignedModule aListView
    '@INCLUDE CLASS aListView
    '@INCLUDE DECLARATION mouse_event
    mouse_event MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0
    mouse_event MOUSEEVENTF_LEFTUP, 0, 0, 0, 0
End Sub

Public Sub EnableDropFilesFolders(LogFiles As Boolean, LogFolders As Boolean, IncludeSubFolders As Boolean, Optional CommaSeparatedFilters As String = "*")
    '@AssignedModule aListView
    '@INCLUDE CLASS aListView
    option_DD_LogFiles = LogFiles
    option_DD_LogFolders = LogFolders
    option_DD_IncludeSubfolders = IncludeSubFolders
    option_DD_CommaSeparatedFilters = CommaSeparatedFilters
    oListView.OLEDragMode = ccOLEDragAutomatic    ' ccOLEDragManual
    oListView.OLEDropMode = ccOLEDropManual
    Set EventDropFiles = oListView
End Sub

Private Sub EventDropFiles_OLEDragDrop(Data As MSComctlLib.DataObject, Effect As Long, Button As Integer, Shift As Integer, X As Single, Y As Single)
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'The Format numbers used in the OLE DragDrop data structure, are:
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'Text = 1 (vbCFText)
    'Bitmap = 2 (vbCFBitmap)
    'Metafile = 3
    'Emetafile = 14
    'DIB = 8
    'Palette = 9
    'Files = 15 (vbCFFiles)
    'RTF = -16639
    '@AssignedModule aListView
    '@INCLUDE CLASS aListView

    Select Case True
        Case Data.GetFormat(15)    'Format 15 is an array of names from WinExplorer
            If Not option_DD_LogFiles And Not option_DD_LogFiles Then Exit Sub
            Dim FileFullPath As String
            Dim fileItem As Long
            For fileItem = 1 To Data.Files.Count
                FileFullPath = Data.Files(fileItem)
                DD_AddToListview FileFullPath
            Next fileItem
        Case Else
    End Select
End Sub

Private Sub DD_AddToListview(FileFullPath As String)
    '@AssignedModule aListView
    '@INCLUDE PROCEDURE IsFileFolderURL
    '@INCLUDE CLASS aListView
    Dim objFSO      As Scripting.FileSystemObject
    Dim objTopFolder As Scripting.Folder
    Set objFSO = CreateObject("Scripting.FileSystemObject")
    Dim fileName    As String
    Dim var As Variant, element As Variant
    var = Split(option_DD_CommaSeparatedFilters, ",")
    If option_DD_LogFiles = True Then
        If LCase(IsFileFolderURL(FileFullPath)) = "f" Then
            fileName = Mid(FileFullPath, InStrRev(FileFullPath, "\") + 1)
            On Error Resume Next
            If Left(fileName, 1) <> "~" And (var(0) = "*" Or var(0) = "") Then GoTo PASS
            For Each element In var
                If InStr(1, FileFullPath, element, vbTextCompare) > 0 And Left(fileName, 1) <> "~" Then
PASS:

                    'where:
                    'Constant    Value   Description
                    'lvwText     0       (Default) Matches the string with a ListItem object's Text property.
                    'lvwSubitem  1       Matches the string with any string in a ListItem object's SubItems property.
                    'lvwTag      2       Matches the string with any ListItem object's Tag property.

                    'match:
                    'The settings for match are:
                    'Constant        Value   Description
                    'lvwWholeWord    0       (Default) An integer or constant specifying that a match will occur if the item's Text property begins with the whole word being searched. Ignored if the criteria is not text.
                    'lvwPartial      1       An integer or constant specifying that a match will occur if the item's Text property begins with the string being searched. Ignored if the criteria is not text.

                    '                    For full match:
                    '                        Dim itm As MSComctlLib.listItem
                    '                        Set itm = oListView.FindItem(sz:="subitemtext", where:=lvwSubItem, index:=2, fPartial:=lvwPartial)
                    '                    for partial search use this:
                    'Set itm = oListView.FindItem(sz:="partial", where:=lvwSubItem, index:=2, fPartial:lvwPartial)

                    If Not oListView.FindItem(sz:=FileFullPath, where:=0, fPartial:=lvwWhole) Then
                        oListView.ListItems.Add , , FileFullPath
                    End If
                End If
            Next
        Else        'if drag dropped folder
            Set objTopFolder = objFSO.GetFolder(FileFullPath)
            DD_AddToListview objTopFolder.path
        End If
    End If

    If option_DD_LogFolders = True Then
        If UCase(IsFileFolderURL(FileFullPath)) = "D" Then
            Set objTopFolder = objFSO.GetFolder(FileFullPath)
            If Not oListView.FindItem(sz:=objTopFolder.path & "\", where:=0, fPartial:=lvwWhole) Then
                oListView.ListItems.Add , , objTopFolder.path
            End If
            DD_AddToListview objTopFolder.path
        End If
    End If
    Set objFSO = Nothing
    Set objTopFolder = Nothing
End Sub

Sub AutofitColumns()
    '@AssignedModule aListView
    '@INCLUDE CLASS aListView
    Dim counter     As Long
    For counter = 1 To oListView.ColumnHeaders.Count
        Call SendMessageLong(oListView.hwnd, LVM_SETCOLUMNWIDTH, counter - 1, LVSCW_AUTOSIZE_USEHEADER)
    Next
End Sub

Public Function Init(LV As ListView) As aListView
    'REFERENCE: Microsoft Windows Common Controls 6.0 (SP6)
    '@AssignedModule aListView
    '@INCLUDE CLASS aListView

    Set oListView = LV
    Set Init = Me

End Function
'Public Function Parent()
'
'End Function
Public Sub clear()
    '@AssignedModule aListView
    '@INCLUDE CLASS aListView
    oListView.ListItems.clear
    oListView.ColumnHeaders.clear
End Sub

Public Sub InitializeFromArray(inputArray As Variant)
    '@AssignedModule aListView
    '@INCLUDE CLASS aListView
    clear
    Dim vListItem   As ListItem
    Dim vChildItem  As ListSubItem
    Dim vHeader     As Variant
    Dim iRows As Long, iColumns As Long
    For iColumns = LBound(inputArray, 2) To UBound(inputArray, 2)
        Set vHeader = oListView.ColumnHeaders.Add(, , inputArray(LBound(inputArray, 1), iColumns))
    Next
    For iRows = LBound(inputArray, 1) + 1 To UBound(inputArray, 1)
        Set vListItem = oListView.ListItems.Add(, , inputArray(iRows, 1))
        For iColumns = LBound(inputArray, 2) + 1 To UBound(inputArray, 2)
            Set vChildItem = vListItem.ListSubItems.Add(, , inputArray(iRows, iColumns))
        Next
    Next
    oListView.View = lvwReport
End Sub

Public Sub AppendArray(inputArray As Variant)
    '@AssignedModule aListView
    '@INCLUDE PROCEDURE ArrayDimensions
    '@INCLUDE CLASS aListView
    If ArrayDimensions(inputArray) <> 2 Then Exit Sub
    If UBound(inputArray, 2) + IIf(LBound(inputArray, 2) = 0, 1, 0) <> oListView.ColumnHeaders.Count Then Exit Sub
    Dim vListItem   As ListItem
    Dim vChildItem  As ListSubItem
    Dim iRows As Long, iColumns As Long
    For iRows = LBound(inputArray, 1) To UBound(inputArray, 1)
        Set vListItem = oListView.ListItems.Add(, , inputArray(iRows, 1))
        For iColumns = LBound(inputArray, 2) + 1 To UBound(inputArray, 2)
            Set vChildItem = vListItem.ListSubItems.Add(, , inputArray(iRows, iColumns))
        Next
    Next
    '    oListView.View = lvwReport
End Sub

Public Sub EventListener()
    '@AssignedModule aListView
    '@INCLUDE CLASS aListView
    Set aListViewEvent = oListView
End Sub

'Private Sub aListViewEvent_Click()
'    MsgBox "Clicked the listview"
'End Sub

Private Sub aListViewEvent_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, _
        ByVal X As stdole.OLE_XPOS_PIXELS, ByVal Y As stdole.OLE_YPOS_PIXELS)
    '@AssignedModule aListView
    '@INCLUDE CLASS aListView
    '@INCLUDE DECLARATION LOGPIXELSX
    '@INCLUDE DECLARATION LOGPIXELSY
    '@INCLUDE DECLARATION GetDC
    '@INCLUDE DECLARATION GetDeviceCaps
    '@INCLUDE DECLARATION ReleaseDC

    'https://markdagosta.wordpress.com/2010/08/08/listview-hittest-right-click/
    Dim item        As MSComctlLib.ListItem
    Dim lngXPixelsPerInch As Long, lngYPixelsPerInch As Long
    Dim lngDeviceHandle As Long
    'Only capture the standard right-clicks; otherwise get out.
    If (Button <> xlSecondaryButton) Or (Shift <> 0) Then Exit Sub
    'We must determine the Pixels per Inch for the display device.
    lngDeviceHandle = GetDC(0)
    lngXPixelsPerInch = GetDeviceCaps(lngDeviceHandle, LOGPIXELSX)
    lngYPixelsPerInch = GetDeviceCaps(lngDeviceHandle, LOGPIXELSY)
    ReleaseDC 0, lngDeviceHandle
    'Convert the event's x and y arguments from Pixels to Twips
    Set item = oListView.hitTest(X * 1440 / lngXPixelsPerInch, Y * 1440 / lngYPixelsPerInch)
    MsgBox "List ID #" & item.index & ": " & item.TEXT & " has been right-clicked!"


End Sub

Public Sub RowsFormatOddEven()
    '@AssignedModule aListView
    '@INCLUDE CLASS aListView
    Dim i As Long, Y As Long
    For i = 1 To oListView.ListItems.Count
        If i Mod 2 Then
            oListView.ListItems(i).ForeColor = vbBlue
            For Y = 1 To oListView.ColumnHeaders.Count - 1
                oListView.ListItems(i).ListSubItems(Y).ForeColor = vbBlue
            Next
        Else
            oListView.ListItems(i).ForeColor = vbRed
            For Y = 1 To oListView.ColumnHeaders.Count - 1
                oListView.ListItems(i).ListSubItems(Y).ForeColor = vbRed
            Next
        End If
    Next
    oListView.Refresh
End Sub



'uAuthor	UserForm



'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Userform   : uAuthor
'* Created    : 06-10-2022 10:34
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* DONATE     : http://paypal.me/alexofrhodes
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Const AUTHOR_EMAIL = "anastasioualex@gmail.com"

#If VBA7 Then
Private Declare PtrSafe Function InternetGetConnectedState Lib "wininet.dll" (ByRef dwFlags As Long, ByVal dwReserved As Long) As Long
Private Declare PtrSafe Function GetSystemMetrics Lib "user32" (ByVal nIndex As Long) As Long

Private Declare PtrSafe Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Private Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Private Declare PtrSafe Function FindWindowA Lib "user32" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Private Declare PtrSafe Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long) As Long
Private Declare PtrSafe Function DrawMenuBar Lib "user32" (ByVal hwnd As Long) As Long
Private Declare PtrSafe Function SetLayeredWindowAttributes Lib "user32" (ByVal hwnd As Long, ByVal crKey As Long, ByVal bAlpha As Byte, ByVal dwFlags As Long) As Long
#Else
Private Declare Function InternetGetConnectedState Lib "wininet.dll" (ByRef dwflags As Long, ByVal dwReserved As Long) As Long
Private Declare Function GetSystemMetrics Lib "user32" (ByVal nIndex As Long) As Long


Private Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Private Declare Function FindWindowA Lib "user32" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Private Declare Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
Private Declare Function DrawMenuBar Lib "user32" (ByVal hWnd As Long) As Long
Private Declare Function SetLayeredWindowAttributes Lib "user32" (ByVal hWnd As Long, ByVal crKey As Long, ByVal bAlpha As Byte, ByVal dwFlags As Long) As Long
#End If


Private Const GWL_STYLE As Long = (-16)
Private Const GWL_EXSTYLE As Long = (-20)
Private Const WS_CAPTION As Long = &HC00000
Private Const WS_EX_DLGMODALFRAME As Long = &H1
Private Const WS_EX_LAYERED = &H80000
Private Const LWA_COLORKEY = &H1
Private Const LWA_ALPHA = &H2
Private m_sngDownX  As Single
Private m_sngDownY  As Single

Public Function GetInternetConnectedState() As Boolean
    '@AssignedModule uAuthor
    '@INCLUDE USERFORM uAuthor
    '@INCLUDE DECLARATION InternetGetConnectedState
    GetInternetConnectedState = InternetGetConnectedState(0&, 0&)
End Function

Private Sub MakeFormTransparent(frm As Object, Optional color As Variant)
    '@AssignedModule uAuthor
    '@INCLUDE USERFORM uAuthor
    '@INCLUDE DECLARATION GWL_EXSTYLE
    '@INCLUDE DECLARATION LWA_COLORKEY
    '@INCLUDE DECLARATION WS_EX_LAYERED
    '@INCLUDE DECLARATION FindWindow
    '@INCLUDE DECLARATION GetWindowLong
    '@INCLUDE DECLARATION SetLayeredWindowAttributes
    '@INCLUDE DECLARATION SetWindowLong
    Dim formhandle  As Long
    Dim bytOpacity  As Byte
    formhandle = CLng(FindWindow(vbNullString, frm.Caption))
    If IsMissing(color) Then color = vbWhite
    bytOpacity = 100
    SetWindowLong formhandle, GWL_EXSTYLE, GetWindowLong(formhandle, GWL_EXSTYLE) Or WS_EX_LAYERED
    frm.BackColor = color
    SetLayeredWindowAttributes formhandle, color, bytOpacity, LWA_COLORKEY
End Sub

Private Sub MakeFormBorderless(frm As Object)
    '@AssignedModule uAuthor
    '@INCLUDE USERFORM uAuthor
    '@INCLUDE DECLARATION GWL_EXSTYLE
    '@INCLUDE DECLARATION GWL_STYLE
    '@INCLUDE DECLARATION WS_CAPTION
    '@INCLUDE DECLARATION WS_EX_DLGMODALFRAME
    '@INCLUDE DECLARATION DrawMenuBar
    '@INCLUDE DECLARATION FindWindow
    '@INCLUDE DECLARATION GetWindowLong
    '@INCLUDE DECLARATION SetWindowLong
    Dim lngWindow   As Long
    Dim lFrmHdl     As Long
    lFrmHdl = CLng(FindWindow(vbNullString, frm.Caption))
    lngWindow = GetWindowLong(lFrmHdl, GWL_STYLE)
    lngWindow = lngWindow And (Not WS_CAPTION)
    SetWindowLong lFrmHdl, GWL_STYLE, lngWindow
    lngWindow = GetWindowLong(lFrmHdl, GWL_EXSTYLE)
    lngWindow = lngWindow And Not WS_EX_DLGMODALFRAME
    SetWindowLong lFrmHdl, GWL_EXSTYLE, lngWindow
    DrawMenuBar lFrmHdl
End Sub

Private Sub LVK_Click()
    '@AssignedModule uAuthor
    '@INCLUDE PROCEDURE FollowLink
    '@INCLUDE USERFORM uAuthor
    FollowLink ("https://vk.com/video/playlist/735281600_1")
End Sub

Private Sub LExit_Click()
    '@AssignedModule uAuthor
    '@INCLUDE USERFORM uAuthor
    Unload Me
End Sub

Private Sub LBLOG_Click()
    '@AssignedModule uAuthor
    '@INCLUDE PROCEDURE FollowLink
    '@INCLUDE USERFORM uAuthor
    FollowLink ("https://alexofrhodes.github.io")
End Sub

Private Sub LGitHub_Click()
    '@AssignedModule uAuthor
    '@INCLUDE PROCEDURE FollowLink
    '@INCLUDE USERFORM uAuthor
    FollowLink ("https://github.com/alexofrhodes")
End Sub

Private Sub LYouTube_Click()
    '@AssignedModule uAuthor
    '@INCLUDE PROCEDURE FollowLink
    '@INCLUDE USERFORM uAuthor
    FollowLink ("https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg")
End Sub

Private Sub LBuyMeACoffee_Click()
    '@AssignedModule uAuthor
    '@INCLUDE PROCEDURE FollowLink
    '@INCLUDE USERFORM uAuthor
    FollowLink "http://paypal.me/alexofrhodes"
End Sub

Private Function CLIP(Optional StoreText As String) As String
    '@AssignedModule uAuthor
    '@INCLUDE USERFORM uAuthor
    Dim X           As Variant
    X = StoreText
    With CreateObject("htmlfile")
        With .parentWindow.clipboardData
            Select Case True
                Case Len(StoreText)
                    .SetData "text", X
                Case Else
                    CLIP = .GetData("text")
            End Select
        End With
    End With
End Function

Private Sub LEmail_Click()
    '@AssignedModule uAuthor
    '@INCLUDE PROCEDURE CLIP
    '@INCLUDE PROCEDURE OutlookCheck
    '@INCLUDE PROCEDURE GetInternetConnectedState
    '@INCLUDE USERFORM uAuthor
    '@INCLUDE DECLARATION AUTHOR_EMAIL
    If GetInternetConnectedState = False Then
        MsgBox "Seems Internet is not available"
        Exit Sub
    End If
    If OutlookCheck = True Then
        MailDev
    Else
        Dim out     As String
        out = AUTHOR_EMAIL
        CLIP out
        MsgBox ("Seems Outlook is not available" & Chr(10) & _
                "DEV's email address " & vbNewLine & out & vbNewLine & "copied to clipboard")
    End If
End Sub

Function OutlookCheck() As Boolean
    '@AssignedModule uAuthor
    '@INCLUDE USERFORM uAuthor
    Dim xOLApp      As Object
    Set xOLApp = CreateObject("Outlook.Application")
    If Not xOLApp Is Nothing Then
        OutlookCheck = True
        Set xOLApp = Nothing
        Exit Function
    End If
    OutlookCheck = False
End Function


Sub MailDev()
    '@AssignedModule uAuthor
    '@INCLUDE USERFORM uAuthor
    '@INCLUDE DECLARATION AUTHOR_EMAIL
    Dim OutApp      As Object
    Dim OutMail     As Object
    Dim strBody     As String
    Set OutApp = CreateObject("Outlook.Application")
    Set OutMail = OutApp.CreateItem(0)
    On Error Resume Next
    With OutMail
        .To = AUTHOR_EMAIL
        .cc = vbNullString
        .BCC = vbNullString
        .Subject = "Feedback or request - " & ThisWorkbook.Name
        .body = strBody
        .display
    End With
    On Error GoTo 0
    Set OutMail = Nothing
    Set OutApp = Nothing
End Sub

Private Sub UserForm_Initialize()
    '@AssignedModule uAuthor
    '@INCLUDE USERFORM uAuthor
    '@INCLUDE DECLARATION GetSystemMetrics

    Dim screenWidth As Long
    Dim screenHeight As Long

    screenWidth = GetSystemMetrics(0)  ' SM_CXSCREEN
    screenHeight = GetSystemMetrics(1)  ' SM_CYSCREEN

    Me.Width = screenWidth
    Me.Height = screenHeight

    Frame1.Left = Me.Width / 2 - Image1.Width
    Frame1.Top = Me.Height / 2 - Image1.Height
    MakeFormBorderless Me
    '    MakeFormTransparent Me, vbYellow
End Sub




'z_TreeView	UserForm

Option Explicit

Private AT          As aTreeView
Private Sub Label1_Click()
    '@AssignedModule z_TreeView
    '@INCLUDE PROCEDURE dp
    '@INCLUDE CLASS aTreeView
    '@INCLUDE USERFORM z_TreeView
    '@INCLUDE DECLARATION AT
    dp AT.ToArray
End Sub

Private Sub Label2_Click()
    '@AssignedModule z_TreeView
    '@INCLUDE CLASS aTreeView
    '@INCLUDE USERFORM z_TreeView
    '@INCLUDE DECLARATION AT
    AT.LoadRange ThisWorkbook.Sheets("TV_Data").Range("A1"), True, True
End Sub

Private Sub Label3_Click()
    '@AssignedModule z_TreeView
    '@INCLUDE PROCEDURE dp
    '@INCLUDE CLASS aTreeView
    '@INCLUDE USERFORM z_TreeView
    '@INCLUDE DECLARATION AT
    dp AT.TreeviewArrayPaths
End Sub

Private Sub Label4_Click()
    '@AssignedModule z_TreeView
    '@INCLUDE CLASS aTreeView
    '@INCLUDE USERFORM z_TreeView
    '@INCLUDE DECLARATION AT
    AT.LoadVBProjects
End Sub

Private Sub Label5_Click()
    '@AssignedModule z_TreeView
    '@INCLUDE CLASS aTreeView
    '@INCLUDE USERFORM z_TreeView
    '@INCLUDE DECLARATION AT
    AT.clear
End Sub

Private Sub TreeView1_NodeCheck(ByVal Node As MSComctlLib.Node)
    '@AssignedModule z_TreeView
    '@INCLUDE CLASS aTreeView
    '@INCLUDE USERFORM z_TreeView
    '@INCLUDE DECLARATION AT
    AT.ChildrenCheck Node, Node.Checked
End Sub

Private Sub UserForm_Initialize()
    '@AssignedModule z_TreeView
    '@INCLUDE CLASS aTreeView
    '@INCLUDE USERFORM z_TreeView
    '@INCLUDE DECLARATION AT
    Set AT = New aTreeView
    AT.Init TreeView1
    TreeView1.CheckBoxes = True
End Sub


'z_ListBox	UserForm

Option Explicit

Private al          As aListBox

Sub LoadSample()
    '@AssignedModule z_ListBox
    '@INCLUDE USERFORM z_ListBox
    With ListBox1
        .columnCount = 10
        Dim X As Long, Y As Long
        Dim var(1 To 10, 1 To 10)
        For X = 1 To 10
            For Y = 1 To 10
                var(X, Y) = X * Y
            Next
        Next
        .list = var
        .multiSelect = fmMultiSelectSingle

    End With
End Sub
Private Sub Label10_Click()
    '@AssignedModule z_ListBox
    '@INCLUDE PROCEDURE RandomStringArray
    '@INCLUDE CLASS aListBox
    '@INCLUDE USERFORM z_ListBox
    '@INCLUDE DECLARATION al
    al.removeHeaders
    With ListBox1
        .columnCount = 10
        .clear
        .list = RandomStringArray(10, 10, 5)
    End With
End Sub


Private Sub CheckBox2_Click()
    '@AssignedModule z_ListBox
    '@INCLUDE CLASS aListBox
    '@INCLUDE USERFORM z_ListBox
    If CheckBox2.Value = True Then
        ListBox1.multiSelect = fmMultiSelectExtended
    Else
        ListBox1.multiSelect = fmMultiSelectSingle
    End If
End Sub



Private Sub Label11_Click()
    '    dp al.SelectedRowsText
    '@AssignedModule z_ListBox
    '@INCLUDE PROCEDURE dp
    '@INCLUDE CLASS aListBox
    '@INCLUDE USERFORM z_ListBox
    '@INCLUDE DECLARATION al
    dp al.SelectedRowsArray
End Sub



Private Sub Label12_Click()
    '@AssignedModule z_ListBox
    '@INCLUDE CLASS aListBox
    '@INCLUDE USERFORM z_ListBox
    '@INCLUDE DECLARATION al
    al.ListenToDoubleClick
End Sub

Private Sub Label13_Click()
    '@AssignedModule z_ListBox
    '@INCLUDE CLASS aListBox
    '@INCLUDE USERFORM z_ListBox
    '@INCLUDE DECLARATION al
    al.ListenToExtendedSelection
End Sub

Private Sub Label14_Click()
    '@AssignedModule z_ListBox
    '@INCLUDE CLASS aListBox
    '@INCLUDE USERFORM z_ListBox
    '@INCLUDE DECLARATION al
    al.ListenToDragDrop ListBox2
End Sub

Private Sub Label15_Click()
    '@AssignedModule z_ListBox
    '@INCLUDE CLASS aListBox
    '@INCLUDE USERFORM z_ListBox
    '@INCLUDE DECLARATION al
    Dim arr
    arr = Split(TextBox1.Value, ",")
    al.ShowTheseColumns arr
End Sub

Private Sub Label2_Click()
    '@AssignedModule z_ListBox
    '@INCLUDE CLASS aListBox
    '@INCLUDE CLASS aUserform
    '@INCLUDE USERFORM z_ListBox
    '@INCLUDE DECLARATION al
    al.AutofitColumns True
    aUserform.Init(Me).ResizeToFitControls 10, 10
End Sub

Private Sub Label3_Click()
    '@AssignedModule z_ListBox
    '@INCLUDE CLASS aListBox
    '@INCLUDE USERFORM z_ListBox
    '@INCLUDE DECLARATION al
    Me.Caption = "Add files to Listbox by Drag and Drop"
    al.AcceptFiles sExpansion:="*", iDeepSubPath:=999
End Sub

Private Sub Label4_Click()
    '@AssignedModule z_ListBox
    '@INCLUDE CLASS aListBox
    '@INCLUDE USERFORM z_ListBox
    '@INCLUDE DECLARATION al
    al.AddFilter
End Sub

Private Sub Label5_Click()
    '@AssignedModule z_ListBox
    '@INCLUDE USERFORM z_ListBox
    LoadSample
End Sub

Private Sub Label6_Click()
    '@AssignedModule z_ListBox
    '@INCLUDE CLASS aListBox
    '@INCLUDE USERFORM z_ListBox
    '@INCLUDE DECLARATION al
    al.RememberList
End Sub

Private Sub Label7_Click()
    '@AssignedModule z_ListBox
    '@INCLUDE CLASS aListBox
    '@INCLUDE USERFORM z_ListBox
    '@INCLUDE DECLARATION al
    Dim i           As Long: i = InputBox("How many rows to display?")
    If i >= 1 And i <= ListBox1.ListCount Then al.HeightToEntries i
End Sub

Private Sub Label8_Click()
    '@AssignedModule z_ListBox
    '@INCLUDE CLASS aListBox
    '@INCLUDE USERFORM z_ListBox
    '@INCLUDE DECLARATION al
    al.AddHeader
    Me.Caption = "Click on header to sort A to Z"
End Sub

Private Sub UserForm_Initialize()
    '@AssignedModule z_ListBox
    '@INCLUDE CLASS aListBox
    '@INCLUDE USERFORM z_ListBox
    '@INCLUDE DECLARATION al
    Set al = New aListBox
    al.Init ListBox1
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    '@AssignedModule z_ListBox
    '@INCLUDE CLASS aListBox
    '@INCLUDE USERFORM z_ListBox
    '@INCLUDE DECLARATION al
    Set al = Nothing
End Sub


'aFrame	Class

'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Class      : aFrame
'* Purpose    :
'* Copyright  :
'*
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 05-07-2023 07:26    Alex
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Private oFrame      As MSForms.Frame

Public Function Init(TargetFrame As Object) As aFrame
    '@AssignedModule aFrame
    '@INCLUDE CLASS aFrame
    Set oFrame = TargetFrame
    Set Init = Me
End Function

Public Sub ResizeToFitControls(Optional marginRight = 0, Optional marginBottom = 0)
    '@AssignedModule aFrame
    '@INCLUDE CLASS aFrame
    oFrame.Width = 0
    oFrame.Height = 0
    Dim ctr         As MSForms.control
    Dim myWidth: myWidth = 0
    Dim myHeight: myHeight = 0
    For Each ctr In oFrame.Controls
        If ctr.Parent.Name = oFrame.Name Then
            If ctr.Visible = True Then
                If ctr.Left + ctr.Width > myWidth Then myWidth = ctr.Left + ctr.Width
                If ctr.Top + ctr.Height > myHeight Then myHeight = ctr.Top + ctr.Height
            End If
        End If
    Next
    oFrame.Width = myWidth + (oFrame.Width - oFrame.InsideWidth) + marginRight
    oFrame.Height = myHeight + (oFrame.Height - oFrame.InsideHeight) + marginBottom
End Sub

Public Sub AddThemeControls()
    '@AssignedModule aFrame
    '@INCLUDE PROCEDURE aSwitch
    '@INCLUDE CLASS aFrame
    '@INCLUDE CLASS aColorScheme
    '@INCLUDE DECLARATION Ctrl
    Dim ctrl        As MSForms.control
    Dim i           As Long
    For i = 1 To 19
        Set ctrl = oFrame.Controls.Add("Forms.Label.1")
        ctrl.Visible = False
        ctrl.Top = i * ctrl.Height
        ctrl.Left = 12
        ctrl.Height = 20
        ctrl.Width = 120
        ctrl.Font.Size = 9
        ctrl.Font.Name = "Consolas"
        ctrl.WordWrap = False
        ctrl.Caption = aSwitch(i, 1, "ThemeBlackAndBlueDark", 2, "ThemeBlackAndBrownDark", 3, "ThemeBlackAndGrayDark", 4, "ThemeBlackAndGreenDark", 5, "ThemeBlackAndOrangeDark", 6, "ThemeBlackAndPinkDark", 7, "ThemeBlackAndPurpleDark", 8, "ThemeBlackAndRedDark", 9, "ThemeBlackAndYellowDark", 10, "ThemeBlueAndGreenLight", 11, "ThemeWhiteAndBlueLight", 12, "ThemeWhiteAndBrownLight", 13, "ThemeWhiteAndGrayLight", 14, "ThemeWhiteAndGreenLight", 15, "ThemeWhiteAndOrangeLight", 16, "ThemeWhiteAndPinkLight", 17, "ThemeWhiteAndPurpleLight", 18, "ThemeWhiteAndRedLight", 19, "ThemeWhiteAndYellowLight")
        ctrl.Visible = True
    Next
    '
    '    On Error Resume Next
    '        For Each ctrl In oframe.parent.Controls
    '            ctrl.Font.Name = "Consolas"
    '            ctrl.Font.Size = 9
    '            ctrl.Font.Bold = True
    '        Next
    '    On Error GoTo 0

    aColorScheme.Init oFrame.Parent
End Sub


'z_ColorSchemes	UserForm

Option Explicit

Private Sub UserForm_Initialize()
    '    aColorScheme.Init(Me.Frame1).ThemeBlackAndGreenDark
    '    aColorScheme.Init(Me).ThemeBlackAndGreenDark
    '@AssignedModule z_ColorSchemes
    '@INCLUDE CLASS aFrame
    '@INCLUDE CLASS aColorScheme
    '@INCLUDE USERFORM z_ColorSchemes
    '@INCLUDE DECLARATION Ctrl
    aFrame.Init(fColorSchemes).AddThemeControls


    Dim ctrl        As MSForms.control
    On Error Resume Next
    For Each ctrl In Me.Controls
        ctrl.Font.Name = "Consolas"
        ctrl.Font.Size = 9
        ctrl.Font.Bold = True
    Next
    On Error GoTo 0

End Sub

'aColorScheme	Class


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Class      : aColorScheme
'* Purpose    :
'* Copyright  :
'*
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 05-07-2023 12:04    Alex
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Private myTarget    As Object
Public WithEvents Emitter As EventListenerEmitter

Public NormalBackColor, NormalForeColor, HoverBackColor, HoverForeColor, SelectedColor
Public DefaultNormalBackColor, DefaultNormalForeColor

Dim cWhite          As Long
Dim cWhiteHover     As Long
Dim cBlueLight      As Long
Dim cBlueLightHover As Long
Dim cGreenLight     As Long
Dim cGreenLightHover As Long
Dim cPurpleLight    As Long
Dim cPurpleLightHover As Long
Dim cYellowLight    As Long
Dim cYellowLightHover As Long
Dim cRedLight       As Long
Dim cRedLightHover  As Long
Dim cOrangeLight    As Long
Dim cOrangeLightHover As Long
Dim cGrayLight      As Long
Dim cGrayLightHover As Long
Dim cBrownLight     As Long
Dim cBrownLightHover As Long
Dim cPinkLight      As Long
Dim cPinkLightHover As Long

Dim cBlack          As Long
Dim cBlackHover     As Long
Dim cBlueDark       As Long
Dim cBlueDarkHover  As Long
Dim cGreenDark      As Long
Dim cGreenDarkHover As Long
Dim cPurpleDark     As Long
Dim cPurpleDarkHover As Long
Dim cYellowDark     As Long
Dim cYellowDarkHover As Long
Dim cRedDark        As Long
Dim cRedDarkHover   As Long
Dim cOrangeDark     As Long
Dim cOrangeDarkHover As Long
Dim cGrayDark       As Long
Dim cGrayDarkHover  As Long
Dim cBrownDark      As Long
Dim cBrownDarkHover As Long
Dim cPinkDark       As Long
Dim cPinkDarkHover  As Long

Sub AssignColors()
    ' Light Themes
    '@AssignedModule aColorScheme
    '@INCLUDE CLASS aColorScheme
    '@INCLUDE DECLARATION red
    cWhite = RGB(255, 255, 255)
    cWhiteHover = RGB(230, 230, 230)
    cBlueLight = RGB(20, 61, 89)    ' Darker blue color
    cBlueLightHover = RGB(61, 129, 168)
    cGreenLight = RGB(33, 138, 33)    ' Darker green color
    cGreenLightHover = RGB(78, 160, 78)
    cPurpleLight = RGB(85, 47, 113)    ' Darker purple color
    cPurpleLightHover = RGB(130, 84, 151)
    cYellowLight = RGB(153, 123, 0)    ' Darker yellow color
    cYellowLightHover = RGB(193, 156, 0)
    cRedLight = RGB(169, 0, 0)    ' Darker red color
    cRedLightHover = RGB(204, 0, 0)
    cOrangeLight = RGB(201, 87, 0)    ' Darker orange color
    cOrangeLightHover = RGB(234, 113, 0)
    cGrayLight = RGB(51, 51, 51)    ' Darker gray color
    cGrayLightHover = RGB(85, 85, 85)
    cBrownLight = RGB(102, 34, 34)    ' Darker brown color
    cBrownLightHover = RGB(128, 42, 42)
    cPinkLight = RGB(163, 67, 111)    ' Darker pink color
    cPinkLightHover = RGB(207, 112, 145)

    ' Dark Themes
    cBlack = RGB(0, 0, 0)
    cBlackHover = RGB(64, 64, 64)
    cBlueDark = RGB(0, 0, 139)
    cBlueDarkHover = RGB(0, 0, 205)
    cGreenDark = RGB(0, 100, 0)
    cGreenDarkHover = RGB(0, 128, 0)
    cPurpleDark = RGB(128, 0, 128)
    cPurpleDarkHover = RGB(139, 0, 139)
    cYellowDark = RGB(128, 128, 0)
    cYellowDarkHover = RGB(184, 134, 11)
    cRedDark = RGB(139, 0, 0)
    cRedDarkHover = RGB(178, 34, 34)
    cOrangeDark = RGB(255, 140, 0)
    cOrangeDarkHover = RGB(255, 69, 0)
    cGrayDark = RGB(105, 105, 105)
    cGrayDarkHover = RGB(128, 128, 128)
    cBrownDark = RGB(139, 69, 19)
    cBrownDarkHover = RGB(160, 82, 45)
    cPinkDark = RGB(255, 105, 180)
    cPinkDarkHover = RGB(255, 20, 147)
End Sub

Sub ThemeWhiteAndBlueLight()
    '@AssignedModule aColorScheme
    '@INCLUDE CLASS aColorScheme
    Call color(cWhite, cBlueLight, cWhiteHover, cBlueLightHover)
End Sub

Sub ThemeWhiteAndGreenLight()
    '@AssignedModule aColorScheme
    '@INCLUDE CLASS aColorScheme
    Call color(cWhite, cGreenLight, cWhiteHover, cGreenLightHover)
End Sub

Sub ThemeWhiteAndPurpleLight()
    '@AssignedModule aColorScheme
    '@INCLUDE CLASS aColorScheme
    Call color(cWhite, cPurpleLight, cWhiteHover, cPurpleLightHover)
End Sub

Sub ThemeWhiteAndYellowLight()
    '@AssignedModule aColorScheme
    '@INCLUDE CLASS aColorScheme
    Call color(cWhite, cYellowLight, cWhiteHover, cYellowLightHover)
End Sub

Sub ThemeWhiteAndRedLight()
    '@AssignedModule aColorScheme
    '@INCLUDE CLASS aColorScheme
    Call color(cWhite, cRedLight, cWhiteHover, cRedLightHover)
End Sub

Sub ThemeWhiteAndOrangeLight()
    '@AssignedModule aColorScheme
    '@INCLUDE CLASS aColorScheme
    Call color(cWhite, cOrangeLight, cWhiteHover, cOrangeLightHover)
End Sub

Sub ThemeWhiteAndGrayLight()
    '@AssignedModule aColorScheme
    '@INCLUDE CLASS aColorScheme
    Call color(cWhite, cGrayLight, cWhiteHover, cGrayLightHover)
End Sub

Sub ThemeWhiteAndBrownLight()
    '@AssignedModule aColorScheme
    '@INCLUDE CLASS aColorScheme
    Call color(cWhite, cBrownLight, cWhiteHover, cBrownLightHover)
End Sub

Sub ThemeWhiteAndPinkLight()
    '@AssignedModule aColorScheme
    '@INCLUDE CLASS aColorScheme
    Call color(cWhite, cPinkLight, cWhiteHover, cPinkLightHover)
End Sub

Sub ThemeBlueAndGreenLight()
    '@AssignedModule aColorScheme
    '@INCLUDE CLASS aColorScheme
    Call color(cBlueLight, cGreenLight, cBlueLightHover, cGreenLightHover)
End Sub

Sub ThemeBlackAndBlueDark()
    '@AssignedModule aColorScheme
    '@INCLUDE CLASS aColorScheme
    Call color(cBlack, cBlueDark, cBlackHover, cBlueDarkHover)
End Sub

Sub ThemeBlackAndGreenDark()
    '@AssignedModule aColorScheme
    '@INCLUDE CLASS aColorScheme
    Call color(cBlack, cGreenDark, cBlackHover, cGreenDarkHover)
End Sub

Sub ThemeBlackAndPurpleDark()
    '@AssignedModule aColorScheme
    '@INCLUDE CLASS aColorScheme
    Call color(cBlack, cPurpleDark, cBlackHover, cPurpleDarkHover)
End Sub

Sub ThemeBlackAndYellowDark()
    '@AssignedModule aColorScheme
    '@INCLUDE CLASS aColorScheme
    Call color(cBlack, cYellowDark, cBlackHover, cYellowDarkHover)
End Sub

Sub ThemeBlackAndRedDark()
    '@AssignedModule aColorScheme
    '@INCLUDE CLASS aColorScheme
    Call color(cBlack, cRedDark, cBlackHover, cRedDarkHover)
End Sub

Sub ThemeBlackAndOrangeDark()
    '@AssignedModule aColorScheme
    '@INCLUDE CLASS aColorScheme
    Call color(cBlack, cOrangeDark, cBlackHover, cOrangeDarkHover)
End Sub

Sub ThemeBlackAndGrayDark()
    '@AssignedModule aColorScheme
    '@INCLUDE CLASS aColorScheme
    Call color(cBlack, cGrayDark, cBlackHover, cGrayDarkHover)
End Sub

Sub ThemeBlackAndBrownDark()
    '@AssignedModule aColorScheme
    '@INCLUDE CLASS aColorScheme
    Call color(cBlack, cBrownDark, cBlackHover, cBrownDarkHover)
End Sub

Sub ThemeBlackAndPinkDark()
    '@AssignedModule aColorScheme
    '@INCLUDE CLASS aColorScheme
    Call color(cBlack, cPinkDark, cBlackHover, cPinkDarkHover)
End Sub


Public Sub color( _
        NormalBackColorValue, _
        NormalForeColorValue, _
        HoverBackColorValue, _
        HoverForeColorValue, _
        Optional SelectedColorValue)
    '@AssignedModule aColorScheme
    '@INCLUDE CLASS aColorScheme

    NormalBackColor = NormalBackColorValue
    NormalForeColor = NormalForeColorValue
    HoverBackColor = HoverBackColorValue
    HoverForeColor = HoverForeColorValue
    SelectedColor = SelectedColorValue

    ApplyColorToParent myTarget
End Sub

Private Sub ApplyColorToParent(obj As Object)
    '@AssignedModule aColorScheme
    '@INCLUDE CLASS aMultiPage
    '@INCLUDE CLASS aColorScheme
    '@INCLUDE DECLARATION Ctrl
    On Error Resume Next
    obj.BackColor = NormalBackColor
    obj.ForeColor = NormalForeColor
    On Error GoTo 0
    Dim ctrl        As MSForms.control
    For Each ctrl In obj.Controls
        Select Case TypeName(ctrl)
            Case "CommandButton", "Label", "CheckBox", "OptionButton"
                ctrl.BackColor = NormalBackColor
                ctrl.ForeColor = NormalForeColor
            Case "Frame"
                ctrl.BackColor = NormalBackColor
                ctrl.ForeColor = NormalForeColor
                ApplyColorToParent ctrl
            Case "MultiPage"
                Dim i As Long
                With aMultiPage.Init(ctrl)
                    For i = 0 To ctrl.Pages.Count - 1
                        .SetBackColor i, CLng(NormalBackColor)
                    Next
                End With
            Case Else

        End Select
    Next
End Sub

Private Sub SetEmitter()
    '@AssignedModule aColorScheme
    '@INCLUDE PROCEDURE isUserform
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS aColorScheme
    '@INCLUDE DECLARATION Emitter
    Set Emitter = Nothing
    Set Emitter = New EventListenerEmitter
    Select Case TypeName(myTarget)
        Case "CommandButton", "Label", "OptionButton", "CheckBox"    '@TODO add controls to emitter class, this isn't working for all
            Emitter.AddEventListener myTarget
        Case "MultiPage", "Frame"
            Emitter.AddEventListenerAll myTarget
        Case Else
            If isUserform(myTarget) Then
                Emitter.AddEventListenerAll myTarget
            End If
    End Select

End Sub

Private Sub resetColors()
    '@AssignedModule aColorScheme
    '@INCLUDE CLASS aColorScheme
    NormalBackColor = 0
    NormalForeColor = 0
    HoverBackColor = 0
    HoverForeColor = 0
    SelectedColor = 0
End Sub

Public Function Init(FormFrameOrControl As Object) As aColorScheme
    '@AssignedModule aColorScheme
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS aColorScheme
    resetColors
    Set myTarget = FormFrameOrControl
    AssignColors
    SetEmitter
    Set Init = Me
End Function

Private Sub Emitter_Click(control As Object)
    '@AssignedModule aColorScheme
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS aColorScheme
    If control.Caption Like "Theme*" Then
        CallByName Me, control.Caption, VbMethod
    End If
End Sub

Private Sub Emitter_MouseOut(control As Object)
    '@AssignedModule aColorScheme
    '@INCLUDE PROCEDURE isUserform
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS aColorScheme
    If NormalBackColor + NormalForeColor + HoverBackColor + HoverForeColor = 0 Then Exit Sub
    If isUserform(control) Then Exit Sub
    Select Case TypeName(control)
        Case "MultiPage", "Frame": Exit Sub
    End Select
    control.BackColor = NormalBackColor
    control.ForeColor = NormalForeColor
End Sub

Private Sub Emitter_MouseOver(control As Object)
    '@AssignedModule aColorScheme
    '@INCLUDE PROCEDURE isUserform
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS aColorScheme
    If NormalBackColor + NormalForeColor + HoverBackColor + HoverForeColor = 0 Then Exit Sub
    If isUserform(control) Then Exit Sub
    Select Case TypeName(control)
        Case "MultiPage", "Frame": Exit Sub
    End Select
    control.BackColor = HoverBackColor
    control.ForeColor = HoverForeColor
End Sub


'uValidationDropdown	UserForm



Option Explicit
'Private Sub CommandButton1_Click()
'    If Me.Height > 224 Then
'        Me.Height = 175
'        CommandButton1.Caption = "V"
'    Else
'        Me.Height = 225
'        CommandButton1.Caption = ""
'    End If
'End Sub

Private Sub GetInfo_Click()
    '@AssignedModule uValidationDropdown
    '@INCLUDE PROCEDURE PlayTheSound
    '@INCLUDE CLASS aUserform
    '@INCLUDE USERFORM uAuthor
    '@INCLUDE USERFORM uValidationDropdown
    With aUserform.Init(Me)
        .Transition .Effect(GetInfo, "Top", GetInfo.Top - 10, 150)
        .Transition .Effect(GetInfo, "Top", GetInfo.Top + 10, 150)
    End With
    uAuthor.Show
End Sub


Private Sub ListBox1_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    '@AssignedModule uValidationDropdown
    '@INCLUDE USERFORM uValidationDropdown
    Dim lngValType  As Long
    On Error Resume Next
    lngValType = ActiveCell.Validation.Type
    On Error GoTo 0
    If lngValType = 3 Then updateData
End Sub

Private Sub ListBox1_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    '    If KeyCode = 13 Then
    '        updateData
    '    End If
    '    UVDRefreshList
    '@AssignedModule uValidationDropdown
    '@INCLUDE USERFORM uValidationDropdown
End Sub

Private Sub TextBox1_Change()
    '@AssignedModule uValidationDropdown
    '@INCLUDE USERFORM uValidationDropdown
    UVDRefreshList
End Sub

Private Sub TextBox1_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    '@AssignedModule uValidationDropdown
    '@INCLUDE USERFORM uValidationDropdown
    If KeyCode = 13 Then
        updateData
    End If
End Sub

Private Sub TextBox1_KeyUp(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    '@AssignedModule uValidationDropdown
    '@INCLUDE USERFORM uValidationDropdown
    Select Case KeyCode
        Case 27    'ESC
            Unload Me
    End Select
End Sub

Private Sub UserForm_Activate()
    '@AssignedModule uValidationDropdown
    '@INCLUDE USERFORM uValidationDropdown
    UVDRefreshList
End Sub

Sub updateData()
    '@INCLUDE UVDRefreshList
    '@AssignedModule uValidationDropdown
    '@INCLUDE USERFORM uValidationDropdown
    ActiveCell.Value = Me.ListBox1.Value
    If Me.oClose.Value = True Then
        Me.TextBox1.Value = ""
        Unload Me
    ElseIf Me.oDown.Value = True Then
        ActiveCell.offset(1, 0).Select
        If Me.TextBox1.Value <> "" Then
            Me.TextBox1.Value = ""
        Else
            UVDRefreshList
        End If
        If Me.ListBox1.ListCount = 0 Then Unload Me
    ElseIf Me.oRight.Value = True Then
        ActiveCell.offset(0, 1).Select
        If Me.TextBox1.Value <> "" Then
            Me.TextBox1.Value = ""
        Else
            UVDRefreshList
        End If
        If Me.ListBox1.ListCount = 0 Then Unload Me
    ElseIf Me.oNone.Value = True Then
        Me.TextBox1.Value = ""
    End If
End Sub

Sub UVDRefreshList()
    '@INCLUDE ValidRange
    '@INCLUDE isValidation
    '@AssignedModule uValidationDropdown
    '@INCLUDE CLASS aListBox
    '@INCLUDE USERFORM uValidationDropdown
    Me.ListBox1.clear
    Dim rng         As Range
    Dim cell        As Range
    If isValidation(ActiveCell) = False Then Exit Sub
    If ValidRange(ActiveCell.Validation.Formula1) = True Then
        Set rng = Range(Replace(ActiveCell.Validation.Formula1, "=", ""))
        For Each cell In rng
            If Me.TextBox1.Value = "" Then
                Me.ListBox1.AddItem cell.Value
            Else
                If InStr(1, cell.Value, Me.TextBox1.Value, vbTextCompare) > 0 Then
                    Me.ListBox1.AddItem cell.Value
                End If
            End If
        Next
    ElseIf InStr(1, ActiveCell.Validation.Formula1, ",") > 0 Then
        Dim var
        var = Split(ActiveCell.Validation.Formula1, ",")
        Dim element
        For Each element In var
            Me.ListBox1.AddItem element
        Next
    Else
        Unload Me
    End If

    aListBox.Init(ListBox1).FilterByColumn TextBox1.TEXT

    On Error Resume Next
    Me.ListBox1.ListIndex = 0
    On Error GoTo 0

End Sub

Function ValidRange(str As String) As Boolean
    '@AssignedModule uValidationDropdown
    '@INCLUDE USERFORM uValidationDropdown
    Dim rng         As Range
    On Error Resume Next
    Set rng = Range(Replace(str, "=", ""))
    On Error GoTo 0
    If rng Is Nothing Then
        ValidRange = False
    Else
        ValidRange = True
    End If
End Function

Function isValidation(rng As Range) As Boolean
    '@AssignedModule uValidationDropdown
    '@INCLUDE USERFORM uValidationDropdown
    Dim dvtype      As Integer
    On Error Resume Next
    dvtype = rng.Validation.Type
    On Error GoTo 0
    If dvtype = 3 Then
        isValidation = True
    Else
        isValidation = False
    End If
End Function

Private Sub UserForm_Initialize()
    '@INCLUDE LoadUserformOptions
    '@AssignedModule uValidationDropdown
    '@INCLUDE CLASS aUserform
    '@INCLUDE USERFORM uValidationDropdown
    aUserform.Init(Me).LoadOptions
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    '@INCLUDE SaveUserformOptions
    '@AssignedModule uValidationDropdown
    '@INCLUDE CLASS aUserform
    '@INCLUDE USERFORM uValidationDropdown
    aUserform.Init(Me).SaveOptions , , False, False
End Sub


'z_uRadialMenu	Module


Option Explicit

Public RadialMenuInstance As Long

'* Modified   : Date and Time       Author              Description
'* Updated    : 21-08-2023 12:18    Alex                (z_uRadialMenu.bas > NewRadialMenu)

Sub NewRadialMenu(Optional instanceCaller As MSForms.Label)
'@LastModified 2308211218
    Dim i As Long
    Dim u As z_RadialMenu
    
        Set u = New z_RadialMenu
        u.Show
        If Not instanceCaller Is Nothing Then
            Dim myParent As Object
            Set myParent = instanceCaller.Parent
            Do Until TypeOf myParent Is MSForms.UserForm And Not LCase(TypeName(myParent)) = "frame"
                Set myParent = myParent.Parent
            Loop
            u.Left = myParent.Left
            u.Top = myParent.Top
            u.Controls("iMain").Left = instanceCaller.Left
            u.Controls("iMain").Top = instanceCaller.Top
        End If
        u.Tag = RadialMenuCount
        u.createRadialMenu _
                        Array(6, 6), _
                        0, _
                        True, _
                        "redCircleGolderBorder"
End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 21-08-2023 12:18    Alex                (z_uRadialMenu.bas > RadialMenuCount)

Public Function RadialMenuCount()
'@LastModified 2308211218
    Dim frm As Object
    Dim counter As Long
    counter = 0
    For Each frm In VBA.Userforms
        If frm.Name = "z_RadialMenu" Then
            counter = counter + 1
        End If
    Next
    RadialMenuCount = counter
End Function

'* Modified   : Date and Time       Author              Description
'* Updated    : 21-08-2023 12:18    Alex                (z_uRadialMenu.bas > RadialMenuUnload)

Public Sub RadialMenuUnload()
'@LastModified 2308211218
    '@INCLUDE USERFORM z_RadialMenu
    '@AssignedModule z_uRadialMenu
'    Unload z_RadialMenu

    Dim frm As Object
    For Each frm In VBA.Userforms
        If frm.Name = "z_RadialMenu" And frm.Tag = RadialMenuInstance Then
            Unload frm
            Exit For
        End If
    Next frm
End Sub

Public Sub RefreshRadialMenuImages()
    '@INCLUDE PROCEDURE FileExists
    '@INCLUDE PROCEDURE IniReadKey
    '@INCLUDE USERFORM z_RadialMenu
    '@AssignedModule z_uRadialMenu
    Dim picForMenuExpanded As String
    picForMenuExpanded = IniReadKey(ThisWorkbook.path & "\Lib\config\radialmenu.ini", "Settings", "picForMenuExpanded")
    If picForMenuExpanded = "" Then picForMenuExpanded = "WhiteCircle"
    picForMenuExpanded = ThisWorkbook.path & "\Lib\img\" & picForMenuExpanded & ".jpg"
    
    Dim picForMenuCollapsed As String
    picForMenuCollapsed = IniReadKey(ThisWorkbook.path & "\Lib\config\radialmenu.ini", "Settings", "picForMenuCollapsed")
    If picForMenuCollapsed = "" Then picForMenuCollapsed = "PurpleCircle"
    picForMenuCollapsed = ThisWorkbook.path & "\Lib\img\" & picForMenuCollapsed & ".jpg"
    
    Dim picForItemsDefault As String
    picForItemsDefault = IniReadKey(ThisWorkbook.path & "\Lib\config\radialmenu.ini", "Settings", "picForItemsDefault")
    If picForItemsDefault = "" Then picForItemsDefault = "BlackCircle"
    picForItemsDefault = ThisWorkbook.path & "\Lib\img\" & picForItemsDefault & ".jpg"
    
    If Not FileExists(picForMenuCollapsed) Or Not FileExists(picForMenuExpanded) Or Not FileExists(picForItemsDefault) Then
        MsgBox "Could not fild image files"
        Stop
    End If
    Dim control     As MSForms.control
    For Each control In z_RadialMenu.Controls
        If control.Name = "iMain" Then
            If control.Tag = "collapsed" Then
                control.Picture = LoadPicture(picForMenuCollapsed)
                If InStr(1, picForMenuCollapsed, "White", vbTextCompare) > 0 Then
                    control.ForeColor = vbBlack
                ElseIf InStr(1, picForMenuCollapsed, "Black", vbTextCompare) > 0 Then
                    control.ForeColor = vbWhite
                End If
            Else
                control.Picture = LoadPicture(picForMenuExpanded)
                If InStr(1, picForMenuExpanded, "White", vbTextCompare) > 0 Then
                    control.ForeColor = vbBlack
                ElseIf InStr(1, picForMenuExpanded, "Black", vbTextCompare) > 0 Then
                    control.ForeColor = vbWhite
                End If
            End If
        ElseIf control.Tag <> "custom" Then
            control.Picture = LoadPicture(picForItemsDefault)
            If InStr(1, picForItemsDefault, "White", vbTextCompare) > 0 Then
                control.ForeColor = vbBlack
            ElseIf InStr(1, picForItemsDefault, "Black", vbTextCompare) > 0 Then
                control.ForeColor = vbWhite
            End If
        End If
        If InStr(1, picForMenuCollapsed, "White", vbTextCompare) Then control.ForeColor = vbWhite
    Next
'    z_RadialMenu.Repaint
End Sub
Sub setRadialMenuTheme(picForMenuCollapsed As String, picForMenuExpanded As String, picForItemsDefault As String)
    '@INCLUDE PROCEDURE IniWrite
    '@INCLUDE PROCEDURE RefreshRadialMenuImages
    '@AssignedModule z_uRadialMenu
    IniWrite ThisWorkbook.path & "\Lib\config\radialmenu.ini", "Settings", "picForMenuExpanded", picForMenuExpanded
    IniWrite ThisWorkbook.path & "\Lib\config\radialmenu.ini", "Settings", "picForMenuCollapsed", picForMenuCollapsed
    IniWrite ThisWorkbook.path & "\Lib\config\radialmenu.ini", "Settings", "picForItemsDefault", picForItemsDefault
    RefreshRadialMenuImages
End Sub
Sub SwitchThemeHexagon()
    '@INCLUDE PROCEDURE setRadialMenuTheme
    '@AssignedModule z_uRadialMenu
    setRadialMenuTheme "HexagonBlack", "HexagonWhite", "HexagonBlack"
End Sub
Sub SwitchThemeCircle()
    '@INCLUDE PROCEDURE setRadialMenuTheme
    '@AssignedModule z_uRadialMenu
    setRadialMenuTheme "PurpleCircle", "WhiteCircle", "BlackCircle"
End Sub


'M_Objects	Module

Option Explicit

'https://www.mrexcel.com/board/threads/get-list-of-all-properties-and-methods-for-an-object-with-vba-code-alone.1122930/
Private Type GUID
    Data1           As Long
    Data2           As Integer
    Data3           As Integer
    Data4(0 To 7)   As Byte
End Type

Private Type TTYPEDESC
#If Win64 Then
    pTypeDesc       As LongLong
#Else
    pTypeDesc       As Long
#End If
    vt              As Integer
End Type

Private Type TPARAMDESC
#If Win64 Then
    pPARAMDESCEX    As LongLong
#Else
    pPARAMDESCEX    As Long
#End If
    wParamFlags     As Integer
End Type

Private Type TELEMDESC
    tdesc           As TTYPEDESC
    pdesc           As TPARAMDESC
End Type

Type TYPEATTR
    aGUID           As GUID
    LCID            As Long
    dwReserved      As Long
    memidConstructor As Long
    memidDestructor As Long
#If Win64 Then
    lpstrSchema     As LongLong
#Else
    lpstrSchema     As Long
#End If
    cbSizeInstance  As Integer
    typekind        As Long
    cFuncs          As Integer
    cVars           As Integer
    cImplTypes      As Integer
    cbSizeVft       As Integer
    cbAlignment     As Integer
    wTypeFlags      As Integer
    wMajorVerNum    As Integer
    wMinorVerNum    As Integer
    tdescAlias      As Long
    idldescType     As Long
End Type

Type FUNCDESC
    memid           As Long
#If Win64 Then
    lReserved1      As LongLong
    lprgelemdescParam As LongLong
#Else
    lReserved1      As Long
    lprgelemdescParam As Long
#End If
    funckind        As Long
    INVOKEKIND      As Long
    CallConv        As Long
    cParams         As Integer
    cParamsOpt      As Integer
    oVft            As Integer
    cReserved2      As Integer
    elemdescFunc    As TELEMDESC
    wFuncFlags      As Integer
End Type

#If VBA7 Then
Private Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal Length As LongPtr)
Private Declare PtrSafe Function DispCallFunc Lib "oleAut32.dll" (ByVal pvInstance As LongPtr, ByVal offsetinVft As LongPtr, ByVal CallConv As Long, ByVal retTYP As Integer, ByVal paCNT As Long, ByRef paTypes As Integer, ByRef paValues As LongPtr, ByRef retVAR As Variant) As Long
Private Declare PtrSafe Sub SetLastError Lib "kernel32.dll" (ByVal dwErrCode As Long)
#Else
Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal Length As Long)
Private Declare Function DispCallFunc Lib "oleAut32.dll" (ByVal pvInstance As Long, ByVal offsetinVft As Long, ByVal CallConv As Long, ByVal retTYP As Integer, ByVal paCNT As Long, ByRef paTypes As Integer, ByRef paValues As Long, ByRef retVAR As Variant) As Long
Private Declare Sub SetLastError Lib "kernel32.dll" (ByVal dwErrCode As Long)
#End If

Function GetObjectFunctions(ByVal TheObject As Object, Optional ByVal FuncType As VbCallType) As Collection
    '@AssignedModule M_Objects
    '@INCLUDE DECLARATION CopyMemory

    Dim tTYPEATTR   As TYPEATTR
    Dim tFUNCDESC   As FUNCDESC

    Dim aGUID(0 To 11) As Long, lFuncsCount As Long

#If Win64 Then
    Const vTblOffsetFac_32_64 = 2
    Dim aTYPEATTR() As LongLong, aFUNCDESC() As LongLong, farPtr As LongLong
#Else
    Const vTblOffsetFac_32_64 = 1
    Dim aTYPEATTR() As Long, aFUNCDESC() As Long, farPtr As Long
#End If

    Dim ITypeInfo   As IUnknown
    Dim IDispatch   As IUnknown
    Dim sName As String, oCol As New Collection

    Const CC_STDCALL As Long = 4
    Const IUNK_QueryInterface As Long = 0
    Const IDSP_GetTypeInfo As Long = 16 * vTblOffsetFac_32_64
    Const ITYP_GetTypeAttr As Long = 12 * vTblOffsetFac_32_64
    Const ITYP_GetFuncDesc As Long = 20 * vTblOffsetFac_32_64
    Const ITYP_GetDocument As Long = 48 * vTblOffsetFac_32_64

    Const ITYP_ReleaseTypeAttr As Long = 76 * vTblOffsetFac_32_64
    Const ITYP_ReleaseFuncDesc As Long = 80 * vTblOffsetFac_32_64

    aGUID(0) = &H20400: aGUID(2) = &HC0&: aGUID(3) = &H46000000
    CallFunction_COM ObjPtr(TheObject), IUNK_QueryInterface, vbLong, CC_STDCALL, VarPtr(aGUID(0)), VarPtr(IDispatch)
    If IDispatch Is Nothing Then MsgBox "error": Exit Function

    CallFunction_COM ObjPtr(IDispatch), IDSP_GetTypeInfo, vbLong, CC_STDCALL, 0&, 0&, VarPtr(ITypeInfo)
    If ITypeInfo Is Nothing Then MsgBox "error": Exit Function

    CallFunction_COM ObjPtr(ITypeInfo), ITYP_GetTypeAttr, vbLong, CC_STDCALL, VarPtr(farPtr)
    If farPtr = 0& Then MsgBox "error": Exit Function

    CopyMemory ByVal VarPtr(tTYPEATTR), ByVal farPtr, LenB(tTYPEATTR)
    ReDim aTYPEATTR(LenB(tTYPEATTR))
    CopyMemory ByVal VarPtr(aTYPEATTR(0)), tTYPEATTR, UBound(aTYPEATTR)
    CallFunction_COM ObjPtr(ITypeInfo), ITYP_ReleaseTypeAttr, vbEmpty, CC_STDCALL, farPtr

    For lFuncsCount = 0 To tTYPEATTR.cFuncs - 1
        Call CallFunction_COM(ObjPtr(ITypeInfo), ITYP_GetFuncDesc, vbLong, CC_STDCALL, lFuncsCount, VarPtr(farPtr))
        If farPtr = 0 Then MsgBox "error": Exit For
        CopyMemory ByVal VarPtr(tFUNCDESC), ByVal farPtr, LenB(tFUNCDESC)
        ReDim aFUNCDESC(LenB(tFUNCDESC))
        CopyMemory ByVal VarPtr(aFUNCDESC(0)), tFUNCDESC, UBound(aFUNCDESC)
        Call CallFunction_COM(ObjPtr(ITypeInfo), ITYP_ReleaseFuncDesc, vbEmpty, CC_STDCALL, farPtr)
        Call CallFunction_COM(ObjPtr(ITypeInfo), ITYP_GetDocument, vbLong, CC_STDCALL, aFUNCDESC(0), VarPtr(sName), 0, 0, 0)
        Call CallFunction_COM(ObjPtr(ITypeInfo), ITYP_GetDocument, vbLong, CC_STDCALL, aFUNCDESC(0), VarPtr(sName), 0, 0, 0)

        With tFUNCDESC
            If FuncType Then
                If .INVOKEKIND = FuncType Then
                    'Debug.Print sName & vbTab & Switch(.INVOKEKIND = 1, "VbMethod", .INVOKEKIND = 2, "VbGet", .INVOKEKIND = 4, "VbLet", .INVOKEKIND = 8, "VbSet")
                    oCol.Add sName & vbTab & Switch(.INVOKEKIND = 1, "VbMethod", .INVOKEKIND = 2, "VbGet", .INVOKEKIND = 4, "VbLet", .INVOKEKIND = 8, "VbSet")
                End If
            Else
                'Debug.Print sName & vbTab & Switch(.INVOKEKIND = 1, "VbMethod", .INVOKEKIND = 2, "VbGet", .INVOKEKIND = 4, "VbLet", .INVOKEKIND = 8, "VbSet")
                oCol.Add sName & vbTab & Switch(.INVOKEKIND = 1, "VbMethod", .INVOKEKIND = 2, "VbGet", .INVOKEKIND = 4, "VbLet", .INVOKEKIND = 8, "VbSet")
            End If
        End With
        sName = vbNullString
    Next

    Set GetObjectFunctions = oCol

End Function

#If Win64 Then
Private Function CallFunction_COM(ByVal InterfacePointer As LongLong, ByVal VTableOffset As Long, ByVal FunctionReturnType As Long, ByVal CallConvention As Long, ParamArray FunctionParameters() As Variant) As Variant
    '@AssignedModule M_Objects
    '@INCLUDE DECLARATION DispCallFunc
    '@INCLUDE DECLARATION SetLastError

    Dim vParamPtr() As LongLong
#Else
Private Function CallFunction_COM(ByVal InterfacePointer As Long, ByVal VTableOffset As Long, ByVal FunctionReturnType As Long, ByVal CallConvention As Long, ParamArray FunctionParameters() As Variant) As Variant

    Dim vParamPtr() As Long
#End If

    If InterfacePointer = 0& Or VTableOffset < 0& Then Exit Function
    If Not (FunctionReturnType And &HFFFF0000) = 0& Then Exit Function

    Dim pIndex As Long, pCount As Long
    Dim vParamType() As Integer
    Dim vRtn As Variant, vParams() As Variant

    vParams() = FunctionParameters()
    pCount = Abs(UBound(vParams) - LBound(vParams) + 1&)
    If pCount = 0& Then
        ReDim vParamPtr(0 To 0)
        ReDim vParamType(0 To 0)
    Else
        ReDim vParamPtr(0 To pCount - 1&)
        ReDim vParamType(0 To pCount - 1&)
        For pIndex = 0& To pCount - 1&
            vParamPtr(pIndex) = VarPtr(vParams(pIndex))
            vParamType(pIndex) = VarType(vParams(pIndex))
        Next
    End If

    pIndex = DispCallFunc(InterfacePointer, VTableOffset, CallConvention, FunctionReturnType, pCount, _
            vParamType(0), vParamPtr(0), vRtn)
    If pIndex = 0& Then
        CallFunction_COM = vRtn
    Else
        SetLastError pIndex
    End If

End Function

'Example:
' List all Methods and Properties of the excel application Object.
Public Sub ObjectPropertiesList(oObject As Object)
    '@AssignedModule M_Objects
    '@INCLUDE PROCEDURE GetObjectFunctions
    Application.ScreenUpdating = False
    Dim oFuncCol As New Collection, i As Long, sObjName As String    ',oObject As Object

    '    Set oObject = Application '<=== Choose here target object as required.
    Set oFuncCol = GetObjectFunctions(TheObject:=oObject, FuncType:=0)
    Dim ws          As Worksheet
    Set ws = Workbooks.Add().Sheets(1)
    ws.Cells.CurrentRegion.offset(1).ClearContents
    For i = 1 To oFuncCol.Count
        ws.Range("A" & i + 1) = Split(oFuncCol.item(i), vbTab)(0)
        ws.Range("B" & i + 1) = Split(oFuncCol.item(i), vbTab)(1)
    Next
    ws.Range("D2") = oFuncCol.Count
    ws.Cells(1).Resize(, 2).EntireColumn.AutoFit

    ws.Range("A2").CurrentRegion.Resize(, 1).Sort Key1:=ws.Range("A2"), _
            Order1:=xlAscending, _
            Header:=xlNo

    Application.ScreenUpdating = True

    On Error Resume Next
    sObjName = oObject.Name
    If Len(sObjName) Then
        MsgBox "(" & oFuncCol.Count & ")  functions found for:" & vbCrLf & vbCrLf & sObjName
    End If
    On Error GoTo 0
End Sub




'Declarations_Table	Document

Option Explicit


'References	Document

Option Explicit

'uCalendar	UserForm



Option Explicit

Public gDate        As New clsDate

Public Function Datepicker(Optional DateInput As Object) As String
    '@AssignedModule uCalendar
    '@INCLUDE CLASS clsDate
    '@INCLUDE USERFORM uCalendar
    '@INCLUDE DECLARATION gDate
    Dim str         As String
    If VBA.TypeName(DateInput) = "Textbox" Or VBA.TypeName(DateInput) = "Range" Then str = DateInput.Value
    If VBA.TypeName(DateInput) = "CommandButton" Or VBA.TypeName(DateInput) = "Label" Then str = DateInput.Caption

    'If DatepInput <> "" Then <--- replaced with next line
    If str <> "" Then

        Dim curDate As String
        With uCalendar
            .txtYearName = year(DateInput)
            .txtMonthNumber = Format(DateInput, "mm")

        End With

        With gDate
            .createDates txtYearName, txtMonthNumber
            .SelectDate .dFrame.Controls("lblDate" & Day(DateInput))
        End With
    Else

        With uCalendar
            .lblSelectedDate = Day(Date)
            .lblSelectedMonth = Format(Date, "mmmm")
            .lblSelectedYear = year(Date)
            curDate = Day(Date) & "." & .txtMonthNumber Mod 12 & "." & .txtYearName
            .lblSelectedDateName = Format(curDate, "dddd")
            .txtSelectedDate = Format(curDate, "dd.mm.yyyy")
            .txtMonthNumber = Format(Date, "mm")
        End With

        With gDate.lblDateBack

        End With

    End If

    Me.Show

    Datepicker = Me.txtSelectedDate.Value

    If VBA.TypeName(DateInput) = "TextBox" Or VBA.TypeName(DateInput) = "Range" Then
        DateInput.Value = Me.txtSelectedDate.Value
    ElseIf VBA.TypeName(DateInput) = "CommandButton" Or VBA.TypeName(DateInput) = "Label" Then
        DateInput.Caption = Me.txtSelectedDate.Value
    Else
        'Datepicker = Me.txtSelectedDate.Value <--- put this before If to return the value anyway
    End If

End Function

Private Sub frameDate_Click()
    '@AssignedModule uCalendar
    '@INCLUDE USERFORM uCalendar
    frameMonth.Visible = False
    frameYear.Visible = False
End Sub

Private Sub lblChoose_Click()
    '@AssignedModule uCalendar
    '@INCLUDE USERFORM uCalendar
    Unload Me
End Sub

Private Sub lblChoose_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    '@AssignedModule uCalendar
    '@INCLUDE CLASS clsDate
    '@INCLUDE USERFORM uCalendar
    '@INCLUDE DECLARATION gDate
    gDate.dFrame.Controls("lblDateBack").Visible = False
    gDate.dayMouseOut

End Sub

Private Sub lblClose_Click()
    '@AssignedModule uCalendar
    '@INCLUDE USERFORM uCalendar
    txtSelectedDate = ""
    Unload Me

End Sub

Private Sub lblMonthName_Click()
    '@AssignedModule uCalendar
    '@INCLUDE CLASS clsDate
    '@INCLUDE USERFORM uCalendar
    '@INCLUDE DECLARATION gDate
    frameYear.Visible = False
    With frameMonth
        .Visible = True
        .Left = lblMonthName.Left
        .Top = lblMonthName.Top + 20

    End With
    gDate.createMonth txtMonthNumber
End Sub

Private Sub lblNextMonth_Click()
    '@AssignedModule uCalendar
    '@INCLUDE PROCEDURE getMonth
    '@INCLUDE CLASS clsDate
    '@INCLUDE USERFORM uCalendar
    '@INCLUDE DECLARATION gDate
    With txtMonthNumber
        .TEXT = .TEXT + 1
        lblMonthName = getMonth(.TEXT)

        If lblMonthName = "JANUARY" Then
            txtYearName = txtYearName + 1
        End If
        '        gDate.createDates txtYearName, .Text

    End With
End Sub

Private Sub lblPreviewMonth_Click()
    '@AssignedModule uCalendar
    '@INCLUDE PROCEDURE getMonth
    '@INCLUDE CLASS clsDate
    '@INCLUDE USERFORM uCalendar
    '@INCLUDE DECLARATION gDate
    With txtMonthNumber
        .TEXT = .TEXT - 1

        lblMonthName = getMonth(.TEXT)
        If lblMonthName.Caption = "DECEMBER" Then
            txtYearName = txtYearName - 1
        End If
        '       gDate.createDates txtYearName, .Text
    End With
End Sub

Private Sub lblRightBar_Click()
    '@AssignedModule uCalendar
    '@INCLUDE USERFORM uCalendar

End Sub

Private Sub lblRightBar_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    '@AssignedModule uCalendar
    '@INCLUDE PROCEDURE moverForm
    '@INCLUDE USERFORM uCalendar
    moverForm Me, Me, Button
End Sub

Private Sub lblToday_Click()
    '@AssignedModule uCalendar
    '@INCLUDE PROCEDURE getMonth
    '@INCLUDE CLASS clsDate
    '@INCLUDE USERFORM uCalendar
    '@INCLUDE DECLARATION gDate
    txtYearName = Format(Date, "yyyy")
    txtMonthNumber = Format(Date, "m")
    gDate.createDates Format(Date, "yyyy"), Format(Date, "mm")
    gDate.SelectDate gDate.dFrame.Controls("lblDate" & Day(Date))
End Sub

Private Sub txtMonthNumber_Change()
    '@AssignedModule uCalendar
    '@INCLUDE PROCEDURE getMonth
    '@INCLUDE CLASS clsDate
    '@INCLUDE USERFORM uCalendar
    '@INCLUDE DECLARATION gDate
    lblMonthName = getMonth(txtMonthNumber)
    gDate.createDates txtYearName, txtMonthNumber
End Sub

Private Sub txtSelectedYear_Change()
    '@AssignedModule uCalendar
    '@INCLUDE USERFORM uCalendar

End Sub

Private Sub txtYearName_Change()
    '@AssignedModule uCalendar
    '@INCLUDE CLASS clsDate
    '@INCLUDE USERFORM uCalendar
    '@INCLUDE DECLARATION gDate
    If Len(txtYearName.TEXT) = 4 Then
        gDate.createDates txtYearName, txtMonthNumber
    End If
End Sub

Private Sub txtYearName_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    '@AssignedModule uCalendar
    '@INCLUDE CLASS clsDate
    '@INCLUDE USERFORM uCalendar
    '@INCLUDE DECLARATION gDate
    frameMonth.Visible = False
    With frameYear
        .Left = txtYearName.Left
        .Top = txtYearName.Top + 20
        .Visible = True
    End With
    gDate.createYear txtYearName
End Sub

Private Sub UserForm_Activate()
    '@AssignedModule uCalendar
    '@INCLUDE USERFORM uCalendar
    lblToday_Click
End Sub

Private Sub UserForm_Click()
    '@AssignedModule uCalendar
    '@INCLUDE USERFORM uCalendar
    Me.frameMonth.Visible = False
    Me.frameYear.Visible = False
End Sub

Private Sub UserForm_Initialize()
    '@AssignedModule uCalendar
    '@INCLUDE PROCEDURE HideTitleBarAndBorder
    '@INCLUDE PROCEDURE removeTudo
    '@INCLUDE USERFORM uCalendar
    Dim sMonth      As Integer
    SelectedDay = ""
    removeTudo Me
    HideTitleBarAndBorder Me

    With Me
        .Height = 308
        .Width = 480
    End With

    IconDesign lblPreviewMonth, "E26C" '"&HE26C"
    IconDesign lblNextMonth, "E26B"

End Sub

Private Sub IconDesign(ctrl As control, IconCode As String)
    '@AssignedModule uCalendar
    '@INCLUDE USERFORM uCalendar
    '@INCLUDE DECLARATION Ctrl
    With ctrl
        .Font.Name = "Segoe MDL2 Assets"
        .Caption = ChrW("&H" & IconCode)
        .Font.Size = 12
        .ForeColor = RGB(191, 191, 191)
        .TextAlign = fmTextAlignLeft
        .BorderStyle = fmBorderStyleNone
        .BackStyle = fmBackStyleTransparent
    End With
End Sub

Private Sub UserForm_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    '    moverForm Me, Me, Button
    '@AssignedModule uCalendar
    '@INCLUDE PROCEDURE moverForm
    '@INCLUDE USERFORM uCalendar
End Sub


'clsDate	Class

Option Explicit
Public WithEvents dForm As MSForms.UserForm
Public WithEvents dFrame As MSForms.Frame
Public WithEvents mFrame As MSForms.Frame
Public WithEvents yFrame As MSForms.Frame
Public WithEvents lblDate As MSForms.Label
Public WithEvents lblMonth As MSForms.Label
Public WithEvents lblYear As MSForms.Label
Public WithEvents lblTodayBack As MSForms.Label
Public WithEvents lblSelectedDateBack As MSForms.Label
Public WithEvents lblDateBack As MSForms.Label
Public WithEvents lblMonthBack As MSForms.Label
Public WithEvents lblYearBack As MSForms.Label

Public colDate      As New Collection
Public aDate        As New clsDate
Public colMonth     As New Collection
Public aMonth       As New clsDate
Public colYear      As New Collection
Public aYear        As New clsDate

Public Sub createDates(cYear As Integer, cMonth As Integer)
    '@AssignedModule clsDate
    '@INCLUDE CLASS clsDate
    '@INCLUDE USERFORM uCalendar
    Dim lLeft As Integer, lTop As Integer
    Dim fDate       As Integer
    Set dForm = uCalendar
    Set dFrame = dForm.frameDate
    PassiveDay = "": SelectedDay = ""
    '  MsgBox cYear & "-" & cMonth
    '************************************
    '***********//frame date start//*****
    With dFrame
        .clear
    End With
    '***********//frame date start//*****
    '************************************
    Dim dt          As Date
    If cMonth Mod 12 = 0 Then cMonth = 12 Else cMonth = cMonth Mod 12
    dt = DateSerial(cYear, cMonth, 1)
    Dim firstDate   As Long
    firstDate = Weekday(dt, 2)
    Dim ilk         As Date
    ilk = DateSerial(year(dt), month(dt), 1 - (firstDate - 1))

    lLeft = 6: lTop = 6
    Dim gunsayi     As String
    Dim i           As Long
    For i = ilk To ilk + 41
        gunsayi = Format(Day(i), "#0")

        Set lblDate = dFrame.Controls.Add("Forms.Label.1", "lblDate" & gunsayi)
        With lblDate
            '            Debug.Print lblDate.Name
            .Left = lLeft
            .Top = lTop
            .Width = 32
            .Font.Name = "MontSerrat Medium"
            .Font.Size = 9
            .ForeColor = &H48372C
            .TextAlign = fmTextAlignCenter
            .BackStyle = fmBackStyleTransparent
            .Caption = gunsayi
            .Tag = i

            If CInt(year(CDate(i))) = CInt(year(CDate(dt))) And CInt(month(CDate(i))) = CInt(month(CDate(dt))) Then
                .Enabled = True
            Else
                .Enabled = False
            End If

            If Weekday(i, 2) = 7 Or Weekday(i, 2) = 6 Then
                .ForeColor = &H2144FF
            End If

            If i = Date And .Enabled = True Then

                Set lblTodayBack = dFrame.Controls.Add("Forms.Label.1", "lblTodayBack")
                With lblTodayBack
                    .Height = 1.2
                    .Width = 22
                    .Top = lblDate.Top + 16
                    .Left = lblDate.Left + 5
                    .BackColor = &H2144FF
                    .ZOrder (1)
                End With
            End If

            Set aDate = New clsDate
            Set aDate.lblDate = lblDate
            Set aDate.dFrame = dFrame
            Set aDate.dForm = dForm
            colDate.Add aDate

        End With

        If lLeft <= 238 Then
            lLeft = lLeft + 44

        Else
            lLeft = 6
            lTop = lTop + 30
        End If

    Next i
    Set lblSelectedDateBack = dFrame.Controls.Add("Forms.Label.1", "lblSelectedDateBack")
    With lblSelectedDateBack
        .Height = 26
        .Width = 30
        .Picture = dForm.lblSelectedDateBack.Picture

        .Visible = False
        .ZOrder (1)
    End With

    Set lblDateBack = dFrame.Controls.Add("Forms.Label.1", "lblDateBack")
    With lblDateBack
        .Height = 26
        .Width = 30
        .Picture = dForm.lblDateBack.Picture
        .Visible = False
        .ZOrder (1)

    End With

End Sub

Public Sub createMonth(snMonth As Integer)
    '@AssignedModule clsDate
    '@INCLUDE PROCEDURE getMonth
    '@INCLUDE CLASS clsDate
    '@INCLUDE USERFORM uCalendar
    Dim lTop As Integer, i As Integer
    Dim fDate       As Integer

    Set dForm = uCalendar
    Set mFrame = dForm.frameMonth

    With mFrame
        .clear
    End With

    lTop = 4
    For i = 1 To 12
        Set lblMonth = mFrame.Controls.Add("Forms.Label.1", "lblMonth" & i)
        With lblMonth
            .Left = 0
            .Top = lTop
            .Width = 90
            .Height = 14
            .Font.Name = "MontSerrat Medium"
            .Font.Size = 9

            If i = snMonth Then
                .ForeColor = vbWhite
                PassiveMonth = lblMonth.Name
            Else
                .ForeColor = vbGrayText
            End If

            .TextAlign = fmTextAlignCenter
            .BackStyle = fmBackStyleTransparent
            .Caption = getMonth(i)
            .Tag = i
        End With
        lTop = lTop + 18

        Set aMonth = New clsDate
        Set aMonth.lblMonth = lblMonth
        Set aMonth.mFrame = mFrame
        Set aMonth.dForm = dForm
        colMonth.Add aMonth

    Next i
    Set lblMonth = Nothing

    Set lblMonthBack = mFrame.Controls.Add("Forms.Label.1", "lblMonthBack")
    With lblMonthBack
        .Left = 0
        .Top = (snMonth - 1) * 18
        .Width = 90
        .BackColor = &H2144FF
        .TextAlign = fmTextAlignCenter
        .BorderStyle = fmBorderStyleNone
        .ZOrder (1)
    End With

End Sub

Public Sub createYear(snYear As Integer)
    '@AssignedModule clsDate
    '@INCLUDE CLASS clsDate
    '@INCLUDE USERFORM uCalendar
    Dim lTop As Integer, i As Integer

    Set dForm = uCalendar
    Set yFrame = dForm.frameYear

    With yFrame
        .clear
    End With

    lTop = 4
    For i = 1 To 12
        Set lblYear = yFrame.Controls.Add("Forms.Label.1", "lblYear" & i)
        With lblYear
            .Left = 0
            .Top = lTop
            .Width = 90
            .Height = 14
            .Font.Name = "MontSerrat Medium"
            .Font.Size = 9
            .ForeColor = vbGrayText
            .Caption = Format(Date, "yyyy") + i - 4

            If .Caption = snYear Then
                .ForeColor = vbWhite
                PassiveYear = lblYear.Name
            Else
                .ForeColor = vbGrayText
            End If

            .TextAlign = fmTextAlignCenter
            .BackStyle = fmBackStyleTransparent

            .Tag = i
        End With
        lTop = lTop + 18

        Set aYear = New clsDate
        Set aYear.lblYear = lblYear
        Set aYear.yFrame = yFrame
        Set aYear.dForm = dForm
        colYear.Add aYear

    Next i

    Set lblYearBack = yFrame.Controls.Add("Forms.Label.1", "lblYearBack")
    With lblYearBack
        .Left = 0
        .Top = yFrame.Controls(PassiveYear).Top - 4
        .Width = 90
        .BackColor = &H2144FF
        .TextAlign = fmTextAlignCenter
        .BorderStyle = fmBorderStyleNone
        .ZOrder (1)
    End With

End Sub

Private Sub dForm_Click()
    '@AssignedModule clsDate
    '@INCLUDE CLASS clsDate
    framevisibleFalse
End Sub

Private Sub dFrame_Click()
    '@AssignedModule clsDate
    '@INCLUDE CLASS clsDate
    framevisibleFalse
End Sub

Sub framevisibleFalse()
    '@AssignedModule clsDate
    '@INCLUDE CLASS clsDate
    '@INCLUDE USERFORM uCalendar
    uCalendar.frameMonth.Visible = False
    uCalendar.frameYear.Visible = False
End Sub

Private Sub lblDate_Click()
    '@AssignedModule clsDate
    '@INCLUDE CLASS clsDate

    If SelectedDay <> "" Then
        If Weekday(SelectedDayTag, 2) = 7 Or Weekday(SelectedDayTag, 2) = 6 Then
            dFrame.Controls(SelectedDay).ForeColor = &H2144FF
        Else
            dFrame.Controls(SelectedDay).ForeColor = &H48372C
        End If

    Else

    End If
    SelectDate lblDate
End Sub

Private Sub lblDate_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    '@AssignedModule clsDate
    '@INCLUDE CLASS clsDate
    '@INCLUDE USERFORM uCalendar
    SelectDate lblDate
    Unload uCalendar

End Sub

Sub SelectDate(ctrl As control)
    '@AssignedModule clsDate
    '@INCLUDE CLASS clsDate
    '@INCLUDE USERFORM uCalendar
    '@INCLUDE DECLARATION Ctrl
    Dim curDate     As Date
    With uCalendar
        .lblSelectedDate = ctrl.Caption
        .lblSelectedMonth = .lblMonthName
        .lblSelectedYear = .txtYearName
        .lblSelectedDateName = Format(ctrl.Tag, "dddd")
        .txtSelectedDate = Format(ctrl.Tag, "dd.mm.yyyy")

        lblSelectedDateBackPosition ctrl
        ctrl.ForeColor = vbWhite
        SelectedDay = ctrl.Name
        SelectedDayTag = ctrl.Tag
    End With
End Sub

Private Sub lblDate_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    '@AssignedModule clsDate
    '@INCLUDE CLASS clsDate
    framevisibleFalse
    lblDateBackPosition lblDate
    dayMouseOut
    lblDate.ForeColor = vbWhite
    PassiveDay = lblDate.Name
    PassiveDayTag = lblDate.Tag
End Sub

Private Sub lblDateBackPosition(ctrl As control)
    '@AssignedModule clsDate
    '@INCLUDE PROCEDURE MouseMoveIcon
    '@INCLUDE CLASS clsDate
    '@INCLUDE DECLARATION Ctrl
    MouseMoveIcon
    With dFrame.Controls("lblDateBack")
        .Visible = True
        .Top = ctrl.Top - 5
        .Left = ctrl.Left + 1
    End With
End Sub

Private Sub lblMonth_Click()
    '@AssignedModule clsDate
    '@INCLUDE PROCEDURE getMonth
    '@INCLUDE CLASS clsDate
    '@INCLUDE USERFORM uCalendar
    With uCalendar
        .txtMonthNumber = lblMonth.Tag
        .frameMonth.Visible = False
        .lblMonthName = getMonth(.txtMonthNumber)
        createDates .txtYearName, .txtMonthNumber
    End With
End Sub

Private Sub lblYear_Click()
    '@AssignedModule clsDate
    '@INCLUDE CLASS clsDate
    '@INCLUDE USERFORM uCalendar
    With uCalendar
        .txtYearName = lblYear
        .frameYear.Visible = False
        createDates .txtYearName, .txtMonthNumber
    End With

End Sub

Private Sub lblMonth_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    '    MsgBox PassiveMonth
    '@AssignedModule clsDate
    '@INCLUDE CLASS clsDate
    lblMonthBackPosition lblMonth
    monthMouseOut
    lblMonth.ForeColor = vbWhite
    PassiveMonth = lblMonth.Name

End Sub

Private Sub lblYear_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    '@AssignedModule clsDate
    '@INCLUDE CLASS clsDate

    lblYearBackPosition lblYear
    yearMouseOut
    lblYear.ForeColor = vbWhite
    PassiveYear = lblYear.Name

End Sub

Private Sub lblSelectedDateBackPosition(ctrl As control)
    '@AssignedModule clsDate
    '@INCLUDE CLASS clsDate
    '@INCLUDE DECLARATION Ctrl
    With dFrame.Controls("lblSelectedDateBack")
        .Visible = True
        .Top = ctrl.Top - 5
        .Left = ctrl.Left + 1
    End With
End Sub

Private Sub lblYearBackPosition(ctrl As control)
    '@AssignedModule clsDate
    '@INCLUDE PROCEDURE MouseMoveIcon
    '@INCLUDE CLASS clsDate
    '@INCLUDE DECLARATION Ctrl
    MouseMoveIcon
    dForm.Controls("lblYearBack").Top = ctrl.Top - 4
End Sub

Private Sub lblMonthBackPosition(ctrl As control)
    '@AssignedModule clsDate
    '@INCLUDE PROCEDURE MouseMoveIcon
    '@INCLUDE CLASS clsDate
    '@INCLUDE DECLARATION Ctrl
    MouseMoveIcon
    dForm.Controls("lblMonthBack").Top = ctrl.Top - 4
End Sub

Public Sub dayMouseOut()
    '@AssignedModule clsDate
    '@INCLUDE CLASS clsDate
    On Error Resume Next
    If PassiveDay <> "" Then

        If Weekday(PassiveDayTag, 2) = 7 Or Weekday(PassiveDayTag, 2) = 6 Then
            dFrame.Controls(PassiveDay).ForeColor = &H2144FF
        Else
            dFrame.Controls(PassiveDay).ForeColor = &H48372C
        End If

    End If
    If SelectedDay <> "" Then
        dFrame.Controls(SelectedDay).ForeColor = vbWhite
    End If

End Sub

Private Sub monthMouseOut()
    '@AssignedModule clsDate
    '@INCLUDE CLASS clsDate

    If PassiveMonth <> "" Then
        mFrame.Controls(PassiveMonth).ForeColor = vbGrayText
    End If
End Sub

Private Sub yearMouseOut()
    '@AssignedModule clsDate
    '@INCLUDE CLASS clsDate

    If PassiveYear <> "" Then
        yFrame.Controls(PassiveYear).ForeColor = vbGrayText
    End If
End Sub


'M_Calendar_API	Module

'-----------------------------------------------------------------------------------------------------------
#If VBA7 Then

Public Declare PtrSafe Sub ReleaseCapture Lib "user32" ()
Public Declare PtrSafe Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, _
        ByVal wMsg As Long, _
        ByVal wParam As Long, _
        lParam As Any) As Long
'----------------------------------------------------------------------------------------------------
Public Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwNilliseconds As Long)
Public Declare PtrSafe Function SetLayeredWindowAttributes Lib "user32" (ByVal hwnd As Long, ByVal crKey As Long, ByVal bAlpha As Byte, ByVal dwFlags As Long) As Long
Public Declare PtrSafe Function GetWindowLong Lib "user32.dll" Alias "GetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long) As Long
Public Declare PtrSafe Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Public Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Public Declare PtrSafe Function DrawMenuBar Lib "user32" (ByVal hwnd As Long) As Long
Public Declare PtrSafe Function FindWindowA Lib "user32" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Public Declare PtrSafe Function LoadCursorBynum Lib "user32" Alias "LoadCursorA" (ByVal hInstance As Long, ByVal lpCursorName As Long) As Long
Public Declare PtrSafe Function SetCursor Lib "user32" (ByVal hCursor As Long) As Long
Public Declare PtrSafe Function MoveJanela Lib "user32" Alias "SetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Public Declare PtrSafe Function CreateRoundRectRgn Lib "gdi32" (ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long, ByVal X3 As Long, ByVal Y3 As Long) As Long
Public Declare PtrSafe Function SetWindowRgn Lib "user32" (ByVal hwnd As Long, ByVal hRgn As Long, ByVal bRedraw As Boolean) As Long

#Else
Public Declare Sub ReleaseCapture Lib "user32" ()
Public Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hWnd As Long, _
        ByVal wMsg As Long, _
        ByVal wParam As Long, _
        lParam As Any) As Long
'----------------------------------------------------------------------------------------------------
Public Declare Sub Sleep Lib "kernel32" (ByVal dwNilliseconds As Long)
Public Declare Function SetLayeredWindowAttributes Lib "user32" (ByVal hWnd As Long, ByVal crKey As Long, ByVal bAlpha As Byte, ByVal dwFlags As Long) As Long
Public Declare Function GetWindowLong Lib "user32.dll" Alias "GetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
Public Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Public Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Public Declare Function DrawMenuBar Lib "user32" (ByVal hWnd As Long) As Long
Public Declare Function FindWindowA Lib "user32" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Public Declare Function LoadCursorBynum Lib "user32" Alias "LoadCursorA" (ByVal hInstance As Long, ByVal lpCursorName As Long) As Long
Public Declare Function SetCursor Lib "user32" (ByVal hCursor As Long) As Long
Public Declare Function MoveJanela Lib "user32" Alias "SetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Public Declare Function CreateRoundRectRgn Lib "gdi32" (ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long, ByVal X3 As Long, ByVal Y3 As Long) As Long
Public Declare Function SetWindowRgn Lib "user32" (ByVal hWnd As Long, ByVal hRgn As Long, ByVal bRedraw As Boolean) As Long

#End If

Private Const GWL_EXSTYLE As Long = (-20)
Private Const WS_EX_DLGMODALFRAME As Long = &H1
Private Const GWL_STYLE As Long = (-16)
Private Const WS_CAPTION = 55000000
Private Const WS_EX_LAYERED = &H80000
'Private Const LWA_COLORKEY = &H1
Private Const LWA_ALPHA = &H2
Private Const IDC_HAND = 32649&
Public MeuForm      As Long
Public ESTILO       As Long
Public Const ESTILO_ATUAL As Long = (-16)
Public Const HTCAPTION = 2
Public Const WM_NCLBUTTONDOWN = &HA1

Private lngPixelsX  As Long
Private lngPixelsY  As Long
Private strThunder  As String
Private blnCreate   As Boolean
Private lnghWnd_Form As Long
Private lnghWnd_Sub As Long

Private Const cstMask As Long = &H7FFFFFFF

Public PassiveMonth, PassiveDay, PassiveYear, PassiveDayTag, SelectedDay, SelectedDayTag

Public Function getMonth(iMonth As Integer, Optional language As String)
    '    Select Case languege
    '@AssignedModule M_Calendar_API

    Select Case iMonth Mod 12
        Case Is = 1, "-11"
            getMonth = "JANUARY"
        Case Is = 2, "-10"
            getMonth = "FEBRUARY"
        Case Is = 3, "-9"
            getMonth = "MARCH"
        Case Is = 4, "-8"
            getMonth = "APRIL"
        Case Is = 5, "-7"
            getMonth = "MAY"
        Case Is = 6, "-6"
            getMonth = "JUNE"
        Case Is = 7, "-5"
            getMonth = "JULY"
        Case Is = 8, "-4"
            getMonth = "AUGUST"
        Case Is = 9, "-3"
            getMonth = "SEPTEMBER"
        Case Is = 10, "-2"
            getMonth = "OCTOBER"
        Case Is = 11, "-1"
            getMonth = "NOVEMBER"
        Case Is = 0, 12
            getMonth = "DECEMBER"

    End Select
    '    End Select
End Function

Function HideTitleBarAndBorder(frm As Object)
    '@AssignedModule M_Calendar_API
    '@INCLUDE DECLARATION GWL_EXSTYLE
    '@INCLUDE DECLARATION GWL_STYLE
    '@INCLUDE DECLARATION WS_CAPTION
    '@INCLUDE DECLARATION WS_EX_DLGMODALFRAME
    '@INCLUDE DECLARATION DrawMenuBar
    '@INCLUDE DECLARATION FindWindow
    '@INCLUDE DECLARATION GetWindowLong
    '@INCLUDE DECLARATION SetWindowLong


    Dim lngWindow   As Long
    Dim lFrmHdl     As Long
    lFrmHdl = FindWindow(vbNullString, frm.Caption)
    lngWindow = GetWindowLong(lFrmHdl, GWL_STYLE)
    lngWindow = lngWindow And (Not WS_CAPTION)
    SetWindowLong lFrmHdl, GWL_STYLE, lngWindow
    lngWindow = GetWindowLong(lFrmHdl, GWL_EXSTYLE)
    lngWindow = lngWindow And Not WS_EX_DLGMODALFRAME
    SetWindowLong lFrmHdl, GWL_EXSTYLE, lngWindow
    DrawMenuBar lFrmHdl

End Function

Function MakeUserformTransparent(frm As Object, colorKey As Variant, Optional color As Variant)
    '@AssignedModule M_Calendar_API
    '@INCLUDE DECLARATION GWL_EXSTYLE
    '@INCLUDE DECLARATION LWA_COLORKEY
    '@INCLUDE DECLARATION WS_EX_LAYERED
    '@INCLUDE DECLARATION FindWindow
    '@INCLUDE DECLARATION GetWindowLong
    '@INCLUDE DECLARATION SetLayeredWindowAttributes
    '@INCLUDE DECLARATION SetWindowLong
    LWA_COLORKEY = colorKey

    Dim formhandle  As Long
    Dim bytOpacity  As Byte

    formhandle = FindWindow(vbNullString, frm.Caption)
    If IsMissing(color) Then color = &H8000&    '//rgbWhite
    bytOpacity = 130

    SetWindowLong formhandle, GWL_EXSTYLE, GetWindowLong(formhandle, GWL_EXSTYLE) Or WS_EX_LAYERED

    frm.BackColor = color
    SetLayeredWindowAttributes formhandle, color, bytOpacity, LWA_COLORKEY

End Function

Public Function MouseCursor(CursorType As Long)
    '@AssignedModule M_Calendar_API
    '@INCLUDE DECLARATION LoadCursorBynum
    '@INCLUDE DECLARATION SetCursor
    Dim lngRet      As Long
    lngRet = LoadCursorBynum(0&, CursorType)
    lngRet = SetCursor(lngRet)
End Function

Public Function MouseMoveIcon()
    '@AssignedModule M_Calendar_API
    '@INCLUDE PROCEDURE MouseCursor
    '@INCLUDE DECLARATION IDC_HAND
    Call MouseCursor(IDC_HAND)
End Function

Public Sub moverForm(Form As Object, obj As Object, Button As Integer)
    '@AssignedModule M_Calendar_API
    '@INCLUDE DECLARATION HTCAPTION
    '@INCLUDE DECLARATION WM_NCLBUTTONDOWN
    '@INCLUDE DECLARATION FindWindowA
    '@INCLUDE DECLARATION SendMessage
    '@INCLUDE DECLARATION ReleaseCapture
    Dim lngMyHandle As Long, lngCurrentStyle As Long, lngNewStyle As Long
    If val(Application.version) < 9 Then
        lngMyHandle = FindWindowA("ThunderXFrame", Form.Caption)
    Else
        lngMyHandle = FindWindowA("ThunderDFrame", Form.Caption)
    End If

    If Button = 1 Then
        With obj
            Call ReleaseCapture
            Call SendMessage(lngMyHandle, WM_NCLBUTTONDOWN, HTCAPTION, 0&)
        End With
    End If
End Sub
Public Sub removeTudo(ObjForm As Object)
    '@AssignedModule M_Calendar_API
    '@INCLUDE DECLARATION ESTILO_ATUAL
    '@INCLUDE DECLARATION WS_CAPTION
    '@INCLUDE DECLARATION FindWindowA
    '@INCLUDE DECLARATION MoveJanela
    '@INCLUDE DECLARATION ESTILO
    '@INCLUDE DECLARATION MeuForm
    MeuForm = FindWindowA(vbNullString, ObjForm.Caption)
    ESTILO = ESTILO Or WS_CAPTION
    MoveJanela MeuForm, ESTILO_ATUAL, (ESTILO)
End Sub



'z_RadialMenu	UserForm

Option Explicit
Private WithEvents Emitter As EventListenerEmitter

#If VBA7 Then
    Private Declare PtrSafe Function GetSystemMetrics Lib "user32" (ByVal nIndex As Long) As Long
#Else
    Private Declare Function GetSystemMetrics Lib "user32" (ByVal nIndex As Long) As Long
#End If

Private Sub Emitter_MouseMove(control As Object, Shift As Integer, X As Single, Y As Single)
    '@INCLUDE CLASS EventListenerEmitter
    '@AssignedModule z_RadialMenu
    
    Select Case control.Name
    Case "iMain", Me.Name, "background": Exit Sub
    Case Else: control.ZOrder (0)
    End Select
End Sub

Private Sub UserForm_Initialize()
    '@INCLUDE CLASS aUserform
    '@AssignedModule z_RadialMenu
    
    
    Me.Top = 0
    Me.Left = 0
    
    Dim appWidth As Long
    Dim appHeight As Long
    Application.WindowState = xlMaximized
    appWidth = Application.Width
    appHeight = Application.Height
    
    Me.Width = appWidth
    Me.Height = appHeight

    iMain.Left = Me.Width / 2 - iMain.Width / 2
    iMain.Top = Me.Height / 2 - iMain.Height / 2
    toggleMainImage

    Me.BackColor = vbMagenta
    With aUserform.Init(Me)
        .TRANSPARENT (vbMagenta)
        .Borderless
    End With
    
End Sub

Sub toggleMainImage()
    '@INCLUDE PROCEDURE FileExists
    '@INCLUDE PROCEDURE IniReadKey
    '@INCLUDE DECLARATION black
    '@AssignedModule z_RadialMenu
    
    
    Dim picForMenuExpanded As String
    picForMenuExpanded = IniReadKey(ThisWorkbook.path & "\Lib\config\radialmenu.ini", "Settings", "picForMenuExpanded", "WhiteCircle")
    picForMenuExpanded = ThisWorkbook.path & "\Lib\img\" & picForMenuExpanded & ".jpg"
    
    Dim picForMenuCollapsed As String
    picForMenuCollapsed = IniReadKey(ThisWorkbook.path & "\Lib\config\radialmenu.ini", "Settings", "picForMenuCollapsed", "PurpleCircle")
    picForMenuCollapsed = ThisWorkbook.path & "\Lib\img\" & picForMenuCollapsed & ".jpg"
    
    If Not FileExists(picForMenuCollapsed) Or Not FileExists(picForMenuExpanded) Then
        MsgBox "Could not fild image files"
        Stop
    End If
    Dim TargetFile  As String
    With iMain
        If .Picture Is Nothing Then
            .Picture = LoadPicture(picForMenuCollapsed)
            .Tag = "collapsed"
            TargetFile = picForMenuCollapsed
        ElseIf .Tag <> "collapsed" Then
            .Picture = LoadPicture(picForMenuCollapsed)
            .Tag = "collapsed"
            TargetFile = picForMenuCollapsed
        Else
            .Picture = LoadPicture(picForMenuExpanded)
            .Tag = "expanded"
            TargetFile = picForMenuExpanded
        End If
        .BorderStyle = fmBorderStyleNone
        .Width = 48
        .Height = 48
        .BackStyle = fmBackStyleTransparent
    End With
    Dim fileName As String
    fileName = Mid(TargetFile, InStrRev(TargetFile, "\"))
    If InStr(1, fileName, "white", vbTextCompare) > 0 Or InStr(1, fileName, "light", vbTextCompare) > 0 Then
        iMain.ForeColor = vbBlack
    ElseIf InStr(1, fileName, "black", vbTextCompare) > 0 Or InStr(1, fileName, "dark", vbTextCompare) > 0 Then
        iMain.ForeColor = vbWhite
    End If
'    Me.Repaint
End Sub
Private Sub iMain_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    'if left mouse is pressed
    '@INCLUDE PROCEDURE moverForm
    '@AssignedModule z_RadialMenu
    
    If Button = 1 Then moverForm Me, Me, Button
End Sub
Private Sub iMain_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    'if right click
    '@INCLUDE PROCEDURE SwitchThemeHexagon
    '@INCLUDE PROCEDURE SwitchThemeCircle
    '@AssignedModule z_RadialMenu
    
    If Button = 2 Then
    
        If Me.Tag = "" Then Me.Tag = RadialMenuCount
        RadialMenuInstance = Me.Tag
    
        Const popupName = "RM_Menu"
        On Error Resume Next
        CommandBars(popupName).Delete
        On Error GoTo 0
        With CommandBars.Add(popupName, msoBarPopup, , True)
            With .Controls.Add(msoControlButton)
                If Me.Tag = "" Then Me.Tag = 1
                .OnAction = "RadialMenuUnload"
                .Caption = "Unload Me"
            End With
            With .Controls.Add(msoControlPopup)
                .Caption = "Themes"
                .BeginGroup = True
                With .Controls.Add(msoControlButton)
                    .Caption = "Circle"
                    .OnAction = "SwitchThemeCircle"
                End With
                With .Controls.Add(msoControlButton)
                    .Caption = "Hexagon"
                    .OnAction = "SwitchThemeHexagon"
                End With
            End With
            .ShowPopup
        End With
    End If
End Sub
Private Sub iMain_Click()
    '@AssignedModule z_RadialMenu
    
    ToggleMenu
End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 21-08-2023 13:00    Alex                (z_RadialMenu.frm > ToggleMenu)

Public Sub ToggleMenu()
'@LastModified 2308211300
    '@INCLUDE CLASS EventListenerEmitter
    '@AssignedModule z_RadialMenu
    
    '@INCLUDE DECLARATION Emitter
    toggleMainImage
    Dim Visibility  As Boolean
    Dim control     As MSForms.control
    If Me.Controls.Count = 1 Then
        'createRadialMenu( numControls As Integer, _
                            startingAngle As Integer, _
                            ClockwisePlacement As Boolean, _
                            ParamArray Pairs() As Variant)
                            
                            'Pairs(1) = Target control name (layer-index eg 1-2)
                            'Pairs(2) = Caption
                            'Pairs(3) = Image       pass "" to keep default
        createRadialMenu _
                        Array(8, 6, 6), _
                        0, _
                        True, _
                        "blueCircle", _
                        "1-1", "Create Instance", ""          ', _
                        "1-1", "caption", "", _
                        "1-2", "2nd ctr", "purpleCircle", _
                        "1-3", ""       , "purpleCircle"
        Set Emitter = New EventListenerEmitter
        Emitter.AddEventListenerAll Me
        
    Else
        Visibility = Not Controls(1).Visible    'starts at 0 so iMain = 0th control
        If Me.Tag = "" Then Me.Tag = 1
'        If Me.Tag = 1 Then
            For Each control In Me.Controls
                If control.Name <> "iMain" Then control.Visible = Visibility
            Next
'        Else
'            Unload Me
'        End If
    End If
'    Me.Repaint
End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 21-08-2023 13:01    Alex                (z_RadialMenu.frm > createRadialMenu)

Public Sub createRadialMenu(controlsPerLayer As Variant, _
                            startingAngle As Integer, _
                            ClockwisePlacement As Boolean, _
                            backGround As String, _
                            ParamArray Pairs() As Variant)
'@LastModified 2308211301
    '@INCLUDE PROCEDURE FileExists
    '@INCLUDE PROCEDURE IniReadKey
    '@AssignedModule z_RadialMenu
    
    'example call:
'    createRadialMenu _
                        Array(3, 6, _
                        0, _
                        True, _
                        "backgroundImage" _
                        "1-1", "caption", "", _
                        "1-2", "2nd ctr", "purpleCircle", _
                        "1-3", ""       , "purpleCircle"
    Dim control     As MSForms.Label
    Dim centerX     As Single
    Dim centerY     As Single
    centerX = iMain.Left + iMain.Width / 2    ' X-coordinate of center point
    centerY = iMain.Top + iMain.Height / 2    ' Y-coordinate of center point
    
    Dim numLayers As Integer
    numLayers = UBound(controlsPerLayer) + 1
    Dim layerIndex  As Integer
    For layerIndex = 1 To numLayers
        Dim angleStep As Single
        angleStep = (IIf(ClockwisePlacement, -1, 1) * 360) / controlsPerLayer(layerIndex - 1)
        Dim radius  As Single
        radius = CalculateRadius(layerIndex, CInt(controlsPerLayer(layerIndex - 1)))    ' Calculate the radius
        Dim angle   As Single
        angle = startingAngle  'where to start
        Dim DefaultImage As String
        DefaultImage = IniReadKey(ThisWorkbook.path & "\Lib\config\radialmenu.ini", "Settings", "picForItemsDefault")
        If DefaultImage = "" Then DefaultImage = "BlackCircle"
        Dim TargetFile As String
        TargetFile = ThisWorkbook.path & "\Lib\img\" & DefaultImage & ".jpg"
        Dim controlIndex As Integer
        For controlIndex = 1 To controlsPerLayer(layerIndex - 1)
            Set control = Me.Controls.Add("Forms.Label.1", "control-" & layerIndex & "-" & controlIndex)
            If FileExists(TargetFile) Then
                control.Picture = LoadPicture(TargetFile)
            End If
            control.MousePointer = fmMousePointerCustom
            control.MouseIcon = LoadPicture(ThisWorkbook.path & "\Lib\img\Hand Cursor Pointer.ico")
            control.Caption = control.Name
            control.ForeColor = vbWhite
            control.BackStyle = fmBackStyleTransparent
            control.PicturePosition = fmPicturePositionCenter
            control.Height = iMain.Height
            control.Width = iMain.Height
            Dim xPosition As Single
            Dim yPosition As Single
            xPosition = centerX + radius * Cos(DegToRad(angle))
            yPosition = centerY - radius * Sin(DegToRad(angle))
            control.Left = xPosition - control.Width / 2
            control.Top = yPosition - control.Height / 2
            angle = angle + angleStep
        Next controlIndex
    Next layerIndex
    If Not IsMissing(Pairs) Then
        Dim i           As Long
        For i = LBound(Pairs) To UBound(Pairs) Step 3
            Set control = Controls("control-" & Split(Pairs(i), "-")(0) & "-" & Split(Pairs(i), "-")(1))
            With control
                Dim controlCaption As String
                controlCaption = Pairs(i + 1)
                control.Caption = controlCaption
                Dim controlImage As String
                controlImage = Pairs(i + 2)
                TargetFile = ThisWorkbook.path & "\Lib\img\" & controlImage & ".jpg"
                If FileExists(TargetFile) Then
                    control.Picture = LoadPicture(TargetFile)
                    control.Tag = "custom"
                End If
            End With
        Next
    End If
     
    Dim maxDistance As Single
    ' Calculate the maximum distance from the center to any control
    For Each control In Me.Controls
        Dim distance As Single
'        to the center of the outer controls
'        distance = Sqr((control.Left + control.Width / 2 - centerX) ^ 2 + (control.Top + control.Height / 2 - centerY) ^ 2)

'        to the outer edge of the outer controls
        distance = Sqr((control.Left + control.Width - centerX) ^ 2 + (control.Top + control.Height - centerY) ^ 2)

        If distance > maxDistance Then
            maxDistance = distance
        End If
    Next
    
    ' Create the covering control
    Dim coverControl As control
    Set coverControl = Me.Controls.Add("Forms.Label.1", "background")
    
    coverControl.Left = centerX - maxDistance
    coverControl.Top = centerY - maxDistance
    coverControl.Width = 2 * maxDistance
    coverControl.Height = 2 * maxDistance
    coverControl.BackStyle = fmBackStyleTransparent
    
    'if you pass nullstring then it won't add a background
    TargetFile = ThisWorkbook.path & "\Lib\img\" & backGround & ".jpg"
    If FileExists(TargetFile) Then
        coverControl.Picture = LoadPicture(TargetFile)
        coverControl.PicturePosition = fmPicturePositionCenter
    End If
    
    coverControl.ZOrder (1) ' Bring it to the front
End Sub
Function CalculateRadius(layerIndex As Integer, controlsPerLayer As Integer) As Single
    ' Implement your logic to calculate the radius for each layer (distance from the center)
    '@AssignedModule z_RadialMenu
    
    CalculateRadius = layerIndex * 50    ' adjust as needed
End Function
Function DegToRad(ByVal degrees As Single) As Single
    '@AssignedModule z_RadialMenu
    
    DegToRad = degrees * WorksheetFunction.Pi / 180
End Function
Private Sub Emitter_Click(control As Object)
    '@INCLUDE PROCEDURE ProcedureExists
    '@INCLUDE CLASS EventListenerEmitter
    '@AssignedModule z_RadialMenu
    
    Select Case control.Name
    Case "iMain", Me.Name, "background": Exit Sub
    End Select

    'we can either use the control's name to get its layer & index
    Dim controlIndex As String: controlIndex = Split(control.Name, "-", 2)(1)
    Select Case controlIndex
        Case "1-1"
            NewRadialMenu control
        Case "2-1"
            '... etc
        Case Else
    End Select
    'or we could use the caption
    Select Case control.Caption
        Case "Sample1"
        Case "Sample2"
        Case Else
            If ProcedureExists(ThisWorkbook, control.Caption) Then
                Application.Run control.Caption
            Else
                '
            End If
    End Select
End Sub

'EventListenerItem	Class

Rem Author Robert Todar

Option Explicit
Option Compare Text

'SET FROM AddEventListener - NEEDED TO EMIT EVENT BACK TO IT.
Private WithEvents Emitter As EventListenerEmitter

'CONTROLS THAT HAVE THE EVENTS
Private WithEvents Form As MSForms.UserForm
Private WithEvents Textbox As MSForms.Textbox
Private WithEvents Label As MSForms.Label
Private WithEvents CommandButton As MSForms.CommandButton
Private WithEvents ComboBox As MSForms.ComboBox
Private WithEvents Frame As MSForms.Frame

Private WithEvents Image As MSForms.Image

Private Type state
    control         As Object
    IsHoveredControl As Boolean
    IsFocusedControl As Boolean
End Type

Private this        As state

'TODO
' - ADD EVENTS FOR ALL USERFORM CONTROLS
' - ADD MORE EVENTS THAN THE LIST BELOW
' - DOUBLE CHECK THAT EMITTS ARE ALL CURRENT

'CURRENT EVENTS (WILL ADD MORE AS I HAVE NEED)
' - MouseOver
' - MouseOut
' - MouseMove
' - Click
' - DblClick
' - Focus
' - Blur
' - KeyUp
' - KeyDown

' The Only public method. This will be called from EventListeneRemitter class module
Public Sub AddEventListener(ByRef ControlOrForm As Object, ByRef EmitterReference As EventListenerEmitter)
    ' Capture the emitter class. This will be used to emit events from each control.
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    Set Emitter = EmitterReference

    ' This is used to compare and check to see if this is the control triggering the event.
    Set this.control = ControlOrForm

    ' Set control (or form) based on its type
    Select Case TypeName(ControlOrForm)
        Case "CommandButton"
            Set CommandButton = ControlOrForm

        Case "ComboBox"
            Set ComboBox = ControlOrForm

        Case "Frame"
            Set Frame = ControlOrForm

        Case "MultiPage"
            '
        Case "Label"
            Set Label = ControlOrForm

        Case "TextBox"
            Set Textbox = ControlOrForm
        Case "Image"
            Set Image = ControlOrForm
        Case Else

            If TypeOf ControlOrForm Is MSForms.UserForm Then
                Set Form = ControlOrForm
            Else
                Rem todo
                Rem err.Raise 5, TypeName(Me), "Invalid control: Currently unable to listen to events on " & TypeName(ControlOrForm)
            End If

    End Select
End Sub

'***********************************************************************************
' Helper functions
'***********************************************************************************

' Called on mousemove event. This is a way of creating a mouseover and mouseout event.
Private Sub CheckIfHoveredControl()
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    If Not this.IsHoveredControl Then
        this.IsHoveredControl = True
        Emitter.EmitEvent this.control, MouseOver
    End If
End Sub

' Called on mousemove event. This is a way of creating a mouseover and mouseout event.
Private Sub CheckIfFocusedControl()
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    If Not this.IsFocusedControl Then
        If TypeName(this.control) = "Frame" Then
            Emitter.SetFocusToControl this.control.ActiveControl
        Else
            this.IsFocusedControl = True
            Emitter.EmitEvent this.control, Focus
        End If
    End If
End Sub

' Simple Collection factory  for ease of use.
Private Function ToCollection(ParamArray keyValuePairs() As Variant) As Collection
    ' Check to see if there is even number of parameters
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerItem
    Dim ArrayLenght As Long
    ArrayLenght = UBound(keyValuePairs) - LBound(keyValuePairs) + 1

    If ArrayLenght Mod 2 <> 0 Then
        Err.Raise 5, TypeName(Me), "Invalid parameters: expecting key/value pairs, but received an odd number of arguments."
    End If

    Set ToCollection = New Collection
    Dim index       As Long
    For index = LBound(keyValuePairs) To UBound(keyValuePairs) Step 2
        ToCollection.Add keyValuePairs(index + 1), keyValuePairs(index)
    Next index
End Function

'***********************************************************************************
' EVENTS
'***********************************************************************************

' ONCE AN EVENT HAS EMMITED, EACH EVENTListenerITEM WILL LISTEN FOR THAT EVENT
Private Sub Emitter_EmittedEvent(ByRef control As Object, ByVal EventName As EmittedEvent, ByRef EventParameters As Collection)
    ' CREATE A MOUSEOVER MOUSEOUT EVENTS
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter

    '    On Error GoTo EH '<-- TODO proper error handling
    Select Case EventName
        Case MouseOver
            'todo catastrophic error occurs with dynamic controls??
            If this.control.Name <> control.Name And this.IsHoveredControl Then
                this.IsHoveredControl = False
                Emitter.EmitEvent this.control, MouseOut
            End If

        Case Focus
            If this.control.Name <> control.Name And this.IsFocusedControl Then
                this.IsFocusedControl = False
                Emitter.EmitEvent this.control, Blur
            ElseIf this.control.Name = control.Name And this.IsFocusedControl = False Then
                this.IsFocusedControl = True
            End If

    End Select
EH:
End Sub

'------------------------------------------------------------------------
' USERFORM
'------------------------------------------------------------------------
Private Sub Form_Click()
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent this.control, Click
End Sub

Private Sub Form_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent this.control, DoubleClick, ToCollection("Cancel", Cancel)
End Sub

Private Sub Form_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    CheckIfHoveredControl
    Emitter.EmitEvent this.control, MouseMove, ToCollection("Button", Button, "Shift", Shift, "X", X, "Y", Y)
End Sub

Private Sub Form_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent this.control, MouseDown, ToCollection("Button", Button, "Shift", Shift, "X", X, "Y", Y)
End Sub

Private Sub Form_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent this.control, MouseUp, ToCollection("Button", Button, "Shift", Shift, "X", X, "Y", Y)
End Sub

'------------------------------------------------------------------------
' COMMAND BUTTON
'------------------------------------------------------------------------
Private Sub CommandButton_Click()
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent this.control, Click
End Sub

Private Sub CommandButton_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent this.control, DoubleClick, ToCollection("Cancel", Cancel)
End Sub

Private Sub CommandButton_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    CheckIfHoveredControl
    Emitter.EmitEvent this.control, MouseMove, ToCollection("Button", Button, "Shift", Shift, "X", X, "Y", Y)
End Sub

Private Sub CommandButton_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    CheckIfFocusedControl
    Emitter.EmitEvent this.control, MouseUp, ToCollection("Button", Button, "Shift", Shift, "X", X, "Y", Y)
End Sub

Private Sub CommandButton_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent this.control, MouseDown, ToCollection("Button", Button, "Shift", Shift, "X", X, "Y", Y)
End Sub

Private Sub CommandButton_KeyUp(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    CheckIfFocusedControl
    Emitter.EmitEvent this.control, KeyUp, ToCollection("KeyCode", KeyCode, "Shift", Shift)
End Sub

Private Sub CommandButton_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent this.control, KeyDown, ToCollection("KeyCode", KeyCode, "Shift", Shift)
End Sub

'------------------------------------------------------------------------
' IMAGE
'------------------------------------------------------------------------
Private Sub Image_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent this.control, MouseDown
End Sub

'------------------------------------------------------------------------
' LABEL
'------------------------------------------------------------------------
Private Sub Label_Click()
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent this.control, Click
End Sub

Private Sub Label_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent this.control, DoubleClick, ToCollection("Cancel", Cancel)
End Sub

Private Sub Label_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    CheckIfHoveredControl
    Emitter.EmitEvent this.control, MouseMove, ToCollection("Button", Button, "Shift", Shift, "X", X, "Y", Y)
End Sub

Private Sub Label_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent this.control, MouseDown, ToCollection("Button", Button, "Shift", Shift, "X", X, "Y", Y)
End Sub

Private Sub Label_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent this.control, MouseUp, ToCollection("Button", Button, "Shift", Shift, "X", X, "Y", Y)
End Sub

'------------------------------------------------------------------------
' Frame
'------------------------------------------------------------------------
Private Sub Frame_Click()
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent this.control, Click
End Sub

Private Sub Frame_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent this.control, DoubleClick, ToCollection("Cancel", Cancel)
End Sub

Private Sub Frame_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    CheckIfHoveredControl
    Emitter.EmitEvent this.control, MouseMove, ToCollection("Button", Button, "Shift", Shift, "X", X, "Y", Y)
End Sub

Private Sub Frame_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    CheckIfFocusedControl        'FRAME DOESN'T TAKE FOCUS BUT ACTIVE CONTROL IN FRAME DOES
    Emitter.EmitEvent this.control, MouseDown
End Sub

Private Sub Frame_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent this.control, MouseUp, ToCollection("Button", Button, "Shift", Shift, "X", X, "Y", Y)
End Sub

'------------------------------------------------------------------------
' Textbox
'------------------------------------------------------------------------
Private Sub Textbox_Click()
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent this.control, Click
End Sub

Private Sub Textbox_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent this.control, DoubleClick, ToCollection("Cancel", Cancel)
End Sub

Private Sub Textbox_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    CheckIfHoveredControl
    Emitter.EmitEvent this.control, MouseMove, ToCollection("Button", Button, "Shift", Shift, "X", X, "Y", Y)
End Sub

Private Sub Textbox_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    CheckIfFocusedControl
    Emitter.EmitEvent this.control, MouseUp, ToCollection("Button", Button, "Shift", Shift, "X", X, "Y", Y)
End Sub

Private Sub Textbox_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent this.control, MouseDown, ToCollection("Button", Button, "Shift", Shift, "X", X, "Y", Y)
End Sub

Private Sub Textbox_KeyUp(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    CheckIfFocusedControl
    Emitter.EmitEvent this.control, KeyUp, ToCollection("KeyCode", KeyCode, "Shift", Shift)
End Sub

Private Sub Textbox_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent this.control, KeyDown, ToCollection("KeyCode", KeyCode, "Shift", Shift)
End Sub

Private Sub TextBox_Change()    'added
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent this.control, Change
End Sub

'------------------------------------------------------------------------
' Combobox
'------------------------------------------------------------------------
Private Sub ComboBox_Click()
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent this.control, Click
End Sub

Private Sub ComboBox_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent this.control, DoubleClick, ToCollection("Cancel", Cancel)
End Sub

Private Sub ComboBox_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    CheckIfHoveredControl
    Emitter.EmitEvent this.control, MouseMove, ToCollection("Button", Button, "Shift", Shift, "X", X, "Y", Y)
End Sub

Private Sub ComboBox_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)    'added
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent this.control, KeyDown, ToCollection("KeyCode", KeyCode, "Shift", Shift)
End Sub

Private Sub ComboBox_KeyUp(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)    'added
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    CheckIfFocusedControl
    Emitter.EmitEvent this.control, KeyUp, ToCollection("KeyCode", KeyCode, "Shift", Shift)
End Sub

Private Sub ComboBox_Change()    'added
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    Emitter.EmitEvent this.control, Change
End Sub

Private Sub ComboBox_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)    'added
    '@AssignedModule EventListenerItem
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS EventListenerItem
    '@INCLUDE DECLARATION Emitter
    CheckIfFocusedControl
    Emitter.EmitEvent this.control, MouseUp, ToCollection("Button", Button, "Shift", Shift, "X", X, "Y", Y)
End Sub

'z_MultiPage	UserForm



Option Explicit

Private Sub UserForm_Initialize()
    '@AssignedModule z_MutiPage
    '@INCLUDE CLASS aMultiPage
    '@INCLUDE CLASS aColorScheme
    '@INCLUDE USERFORM z_MutiPage
    SidebarRight.Visible = False
    SidebarBottom.Visible = False

    '// the class is predeclaredId = true but shouldn't this way still work?
    '    Dim am1 As aMultiPage
    '    Set am1 = New aMultiPage
    '    am1.Init(MultiPage1).BuildMenu createSidebarMinimizers:=True

    aMultiPage.Init(MultiPage1).BuildMenu createSidebarMinimizers:=True

End Sub


'aMultiPage	Class

'TODO
'test buildmenu targeting a multipage inside a multipage

'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Class      : aMultiPage
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 29-06-2023 13:41    Alex
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Private WithEvents Emitter As EventListenerEmitter

Const AUTHOR_EMAIL = "anastasioualex@gmail.com"

Private sbLeftWidth As Long
Private sbRightWidth As Long
Private sbBottomHeight As Long

#If Win64 Then
Public hwnd         As LongPtr    'LongLong
#Else
Public hwnd         As Long
#End If

Private oForm       As Object

Public oMultipage   As MultiPage


''''''''''''''''''''''''''
'Multipage BackColor start
''''''''''''''''''''''''''
Private Type RECT
    Left            As Long
    Top             As Long
    Right           As Long
    Bottom          As Long
End Type

Private Type uPicDesc
    Size            As Long
Type            As Long
#If VBA7 Then
    hPic            As LongPtr
    hPal            As LongPtr
#Else
    hPic            As Long
    hPal            As Long
#End If
End Type

Private Type GUID
    Data1           As Long
    Data2           As Integer
    Data3           As Integer
    Data4(0 To 7)   As Byte
End Type


#If VBA7 Then
Private Declare PtrSafe Function InternetGetConnectedState Lib "wininet.dll" (ByRef dwFlags As Long, ByVal dwReserved As Long) As Long
Private Declare PtrSafe Function LoadLibrary Lib "kernel32" Alias "LoadLibraryA" (ByVal lpLibFileName As String) As LongPtr
Private Declare PtrSafe Function FreeLibrary Lib "kernel32" (ByVal hLibModule As LongPtr) As Long
Private Declare PtrSafe Function OleCreatePictureIndirectAut Lib "oleAut32.dll" Alias "OleCreatePictureIndirect" (PicDesc As uPicDesc, RefIID As GUID, ByVal fPictureOwnsHandle As Long, iPic As IPicture) As Long
Private Declare PtrSafe Function OleCreatePictureIndirectPro Lib "olepro32.dll" Alias "OleCreatePictureIndirect" (PicDesc As uPicDesc, RefIID As GUID, ByVal fPictureOwnsHandle As Long, iPic As IPicture) As Long
Private Declare PtrSafe Function CopyImage Lib "user32" (ByVal handle As LongPtr, ByVal un1 As Long, ByVal n1 As Long, ByVal n2 As Long, ByVal un2 As Long) As LongPtr
Private Declare PtrSafe Function GetDC Lib "user32" (ByVal hwnd As LongPtr) As LongPtr
Private Declare PtrSafe Function ReleaseDC Lib "user32" (ByVal hwnd As LongPtr, ByVal hdc As LongPtr) As Long
Private Declare PtrSafe Function CreateCompatibleBitmap Lib "gdi32" (ByVal hdc As LongPtr, ByVal nWidth As Long, ByVal nHeight As Long) As LongPtr
Private Declare PtrSafe Function CreateCompatibleDC Lib "gdi32" (ByVal hdc As LongPtr) As LongPtr
Private Declare PtrSafe Function DeleteObject Lib "gdi32" (ByVal hObject As LongPtr) As Long
Private Declare PtrSafe Function SelectObject Lib "gdi32" (ByVal hdc As LongPtr, ByVal hObject As LongPtr) As LongPtr
Private Declare PtrSafe Function CreateSolidBrush Lib "gdi32" (ByVal crColor As Long) As LongPtr
Private Declare PtrSafe Function FillRect Lib "user32" (ByVal hdc As LongPtr, lpRect As RECT, ByVal hBrush As LongPtr) As Long
Private Declare PtrSafe Function SetRect Lib "user32" (lpRect As RECT, ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As Long

Private hdc As LongPtr, hMemDc As LongPtr, hMemBmp As LongPtr, hBrush As LongPtr, hCopy As LongPtr, ar() As LongPtr

#Else
Private Declare Function InternetGetConnectedState Lib "wininet.dll" (ByRef dwFlags As Long, ByVal dwReserved As Long) As Long
Private Declare Function LoadLibrary Lib "kernel32" Alias "LoadLibraryA" (ByVal lpLibFileName As String) As Long
Private Declare Function FreeLibrary Lib "kernel32" (ByVal hLibModule As Long) As Long
Private Declare Function OleCreatePictureIndirectAut Lib "oleAut32.dll" Alias "OleCreatePictureIndirect" (PicDesc As uPicDesc, RefIID As GUID, ByVal fPictureOwnsHandle As Long, iPic As IPicture) As Long
Private Declare Function OleCreatePictureIndirectPro Lib "olepro32.dll" Alias "OleCreatePictureIndirect" (PicDesc As uPicDesc, RefIID As GUID, ByVal fPictureOwnsHandle As Long, iPic As IPicture) As Long
Private Declare Function CopyImage Lib "user32" (ByVal handle As Long, ByVal un1 As Long, ByVal n1 As Long, ByVal n2 As Long, ByVal un2 As Long) As Long
Private Declare Function GetDC Lib "user32" (ByVal hwnd As Long) As Long
Private Declare Function ReleaseDC Lib "user32" (ByVal hwnd As Long, ByVal hdc As Long) As Long
Private Declare Function CreateCompatibleBitmap Lib "gdi32" (ByVal hdc As Long, ByVal nWidth As Long, ByVal nHeight As Long) As Long
Private Declare Function CreateCompatibleDC Lib "gdi32" (ByVal hdc As Long) As Long
Private Declare Function DeleteObject Lib "gdi32" (ByVal hObject As Long) As Long
Private Declare Function SelectObject Lib "gdi32" (ByVal hdc As Long, ByVal hObject As Long) As Long
Private Declare Function CreateSolidBrush Lib "gdi32" (ByVal crColor As Long) As Long
Private Declare Function FillRect Lib "user32" (ByVal hdc As Long, lpRect As RECT, ByVal hBrush As Long) As Long
Private Declare Function SetRect Lib "user32" (lpRect As RECT, ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As Long

Private hdc As Long, hMemDc As Long, hMemBmp As Long, hBrush As Long, hCopy As Long, ar() As Long

#End If


Private Const IMAGE_BITMAP = 0
Private Const PICTYPE_BITMAP = 1
Private Const LR_COPYRETURNORG = &H4
Private Const S_OK = 0
''''''''''''''''''''''''''
'Multipage BackColor end
''''''''''''''''''''''''''


'Public WithEvents oMultiPageEvent As MultiPage

'Private MenuLabels() As New aMultiPage

'Private MenuLabelCounter As Long
'Public WithEvents MenuLabelEvent As MSForms.Label
'
'Private Sub MenuLabelEvent_Click()
'    MsgBox MenuLabelEvent.Caption
'End Sub

Public Function Init(MP As control) As aMultiPage
    '@AssignedModule aMultiPage
    '@INCLUDE CLASS aMultiPage
    If TypeName(MP) <> "MultiPage" Then Stop
    Set oForm = MP.Parent
    Set oMultipage = MP
    '    Set oMultiPageEvent = oMultiPage
    hwnd = MP.[_GethWnd]
    Set Init = Me
End Function

Public Sub BuildMenu(createSidebarMinimizers As Boolean)
    '@AssignedModule aMultiPage
    '@INCLUDE PROCEDURE AvailableFormOrFrameRow
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS aUserform
    '@INCLUDE CLASS aMultiPage
    '@INCLUDE DECLARATION MyColors
    '@INCLUDE DECLARATION Ctrl
    '@INCLUDE DECLARATION Emitter
    Dim MP          As MultiPage: Set MP = oMultipage
    oForm.Height = MP.Height + oForm.Height - oForm.InsideHeight
    oForm.BackColor = MyColors.FormBackgroundDarkGray


    Dim SidebarLeft As Frame
    Set SidebarLeft = oForm.Controls.Add("forms.frame.1")
    SidebarLeft.Name = "SidebarLeft"
    With SidebarLeft
        .Caption = ""
        .SpecialEffect = fmSpecialEffectFlat
        '        .BorderStyle = fmBorderStyleSingle
        .Left = 0
        .Top = 0
        .Height = MP.Height
        .Width = 60
        .BackColor = MyColors.FormSidebarMediumGray

    End With

    With MP
        .Left = SidebarLeft.Left + SidebarLeft.Width
        .Top = 0
        '        .Width = oForm.InsideWidth - SidebarLeft.Width
        .Height = oForm.InsideHeight
        .Style = fmTabStyleNone
        Dim i       As Long
        For i = 0 To MP.Pages.Count - 1
            SetBackColor i, BackColor:=MyColors.FormBackgroundDarkGray
        Next
    End With

    Dim lbl         As MSForms.Label

    Dim page
    For Each page In MP.Pages
        Set lbl = SidebarLeft.Controls.Add("forms.label.1")
        lbl.Name = "sidebarLabel" & page.Name
        With lbl
            If page.index = 0 Then .BackColor = MyColors.FormSelectedGreen
            .BorderStyle = fmBorderStyleSingle
            '            .BorderColor = MyColors.FormSelectedGreen
            .WordWrap = False
            .AutoSize = True
            .Font.Size = 12
            .Top = AvailableFormOrFrameRow(SidebarLeft)
            .Left = 0
            .ForeColor = vbWhite
            .Caption = Space(4) & page.Caption
            .AutoSize = False
            .Height = 24
            .Tag = "page-" & page.index
            .ControlTipText = WorksheetFunction.Trim(.Caption)
        End With
        '        MenuLabelCounter = MenuLabelCounter + 1
        '        ReDim Preserve MenuLabels(1 To MenuLabelCounter)
        '        Set MenuLabels(MenuLabelCounter).MenuLabelEvent = lbl
    Next

    Dim ctrl        As control
    Dim maxWidth    As Long: maxWidth = 0
    For Each ctrl In SidebarLeft.Controls
        If maxWidth < ctrl.Width Then maxWidth = ctrl.Width
    Next
    For Each ctrl In SidebarLeft.Controls
        ctrl.Width = maxWidth + 12
    Next
    SidebarLeft.Width = maxWidth + 12

    MP.Left = SidebarLeft.Left + SidebarLeft.Width

    Dim SidebarRight As MSForms.Frame
    Dim SidebarBottom As MSForms.Frame
    On Error Resume Next
    Set SidebarRight = oForm.Controls("SidebarRight")
    Set SidebarBottom = oForm.Controls("SidebarBottom")
    If Not SidebarRight.Visible Then Set SidebarRight = Nothing
    If Not SidebarBottom.Visible Then Set SidebarBottom = Nothing
    On Error GoTo 0

    If Not SidebarRight Is Nothing Then
        If SidebarRight.Visible Then
            With SidebarRight
                .Caption = ""
                .SpecialEffect = fmSpecialEffectFlat
                .BorderStyle = fmBorderStyleNone
                .BackColor = MyColors.FormSidebarMediumGray    'vbred
                .Top = MP.Top
                .Left = MP.Left + MP.Width
                If SidebarBottom Is Nothing Then
                    .Height = MP.Height
                Else
                    If SidebarBottom.Visible = True Then
                        .Height = MP.Height + SidebarBottom.Height
                    Else
                        .Height = MP.Height
                    End If
                End If
            End With
        End If
    End If

    If Not SidebarBottom Is Nothing Then
        If SidebarBottom.Visible Then
            SidebarLeft.Height = SidebarLeft.Height + SidebarBottom.Height
            With SidebarBottom
                .Caption = ""
                .SpecialEffect = fmSpecialEffectFlat
                .BorderStyle = fmBorderStyleNone
                .BackColor = MyColors.FormSidebarMediumGray    'vbred
                .Top = MP.Top & MP.Height
                .Left = SidebarLeft.Left + SidebarLeft.Width - 1
                '            If SidebarRight Is Nothing Then
                .Width = MP.Width + 2
                '            Else
                '                .Width = MP.Width + SidebarRight.Width
                '            End If

            End With
        End If
    End If

    aUserform.Init(oForm).ResizeToFitControls

    sbLeftWidth = SidebarLeft.Width
    If Not SidebarRight Is Nothing Then sbRightWidth = SidebarRight.Width
    If Not SidebarBottom Is Nothing Then sbBottomHeight = SidebarBottom.Height

    If createSidebarMinimizers Then
        Dim item
        For Each item In Array("Left", "Right")
            If Not (item = "Right" And SidebarRight Is Nothing) Then
                Set lbl = oForm.Controls("Sidebar" & item).Controls.Add("forms.label.1", "ResizeSidebar" & item)
                With lbl
                    .Font.Name = "Consolas"
                    .AutoSize = False
                    .Width = oForm.Controls("Sidebar" & item).Width
                    .Height = 16
                    .Left = 0
                    .Top = oForm.Controls("Sidebar" & item).Top + oForm.Controls("Sidebar" & item).Height - lbl.Height    '- 6
                    .ForeColor = vbWhite
                    .Font.Bold = True
                    .Font.Size = 14
                    .Caption = "<"
                End With
            End If
        Next
    End If

    For Each ctrl In oForm.Controls
        If TypeName(ctrl) = "Label" Then
            ctrl.MouseIcon = LoadPicture(ThisWorkbook.path & "\Lib\img\Hand Cursor Pointer.ico")
            ctrl.MousePointer = fmMousePointerCustom
        End If
    Next

    Set Emitter = New EventListenerEmitter
    Emitter.AddEventListenerAll oForm

End Sub


Private Sub Emitter_LabelMouseOut(Label As MSForms.Label)
    '@AssignedModule aMultiPage
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS aMultiPage
    If InStr(1, Label.Tag, "page-") > 0 Or InStr(1, Label.Name, "ResizeSidebar") > 0 Then
        If Label.BackColor <> &H80B91E Then Label.BackColor = &H534848
    End If
End Sub

Private Sub Emitter_LabelMouseOver(Label As MSForms.Label)
    '@AssignedModule aMultiPage
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS aMultiPage
    If InStr(1, Label.Tag, "page-") > 0 Or InStr(1, Label.Name, "ResizeSidebar") > 0 Then
        If Label.BackColor <> &H80B91E Then Label.BackColor = &H808080
    End If
End Sub

Private Sub Emitter_LabelClick(ByRef Label As MSForms.Label)
    '@AssignedModule aMultiPage
    '@INCLUDE PROCEDURE FollowLink
    '@INCLUDE PROCEDURE CLIP
    '@INCLUDE PROCEDURE OutlookCheck
    '@INCLUDE PROCEDURE GetInternetConnectedState
    '@INCLUDE CLASS EventListenerEmitter
    '@INCLUDE CLASS aUserform
    '@INCLUDE CLASS aMultiPage
    '@INCLUDE DECLARATION AUTHOR_EMAIL
    '@INCLUDE DECLARATION Ctrl
    If InStr(1, Label.Tag, "page-") > 0 Then
        Dim ctrl    As control
        For Each ctrl In oForm.Controls
            If InStr(1, ctrl.Tag, "page-") > 0 Then ctrl.BackColor = &H534848
        Next
        Label.BackColor = &H80B91E
        If InStr(1, Label.Tag, "page-") > 0 Then
            oMultipage.Value = Split(Label.Tag, "-")(1)
        End If
    End If

    If InStr(1, Label.Caption, ">") > 0 Or InStr(1, Label.Caption, "<") > 0 Then
        Dim SidebarLeft As MSForms.control
        Dim SidebarRight As MSForms.control
        Dim SidebarBottom As MSForms.control
        Dim MP      As MSForms.control
        On Error Resume Next
        Set SidebarLeft = oForm.Controls("SidebarLeft")
        Set SidebarRight = oForm.Controls("SidebarRight")
        Set SidebarBottom = oForm.Controls("SidebarBottom")
        Set MP = oForm.Controls("MultiPage1")
        On Error GoTo 0

        If InStr(1, Label.Name, "Sidebar") > 0 Then
            If InStr(1, Label.Name, "Right") > 0 Then
                If SidebarRight.Width <> sbRightWidth Then
                    SidebarRight.Width = sbRightWidth
                    oForm.Controls("ResizeSidebarRight").Caption = "<"
                Else
                    SidebarRight.Width = 12
                    oForm.Controls("ResizeSidebarRight").Caption = ">"
                End If

            ElseIf InStr(1, Label.Name, "Bottom") > 0 Then
                '            oForm.Controls("SidebarBottom").Height = sbBottomHeight
            ElseIf InStr(1, Label.Name, "Left") > 0 Then
                If SidebarLeft.Width <> sbLeftWidth Then
                    SidebarLeft.Width = sbLeftWidth
                    oForm.Controls("ResizeSidebarLeft").Caption = "<"
                Else
                    SidebarLeft.Width = 12
                    oForm.Controls("ResizeSidebarLeft").Caption = ">"
                End If
                MP.Left = SidebarLeft.Left + SidebarLeft.Width
                If Not SidebarRight Is Nothing Then SidebarRight.Left = MP.Left + MP.Width
                If Not SidebarBottom Is Nothing Then SidebarBottom.Left = SidebarLeft.Left + SidebarLeft.Width
            End If

            '       aUserform.Init(oForm).ResizeToFitControls
            If SidebarRight Is Nothing Then
                oForm.Width = MP.Left + MP.Width
            Else
                If SidebarRight.Visible Then
                    oForm.Width = SidebarRight.Left + SidebarRight.Width + 12
                Else
                    oForm.Width = MP.Left + MP.Width
                End If
            End If
        End If
    End If

    If InStr(1, Label.Tag, "followlink-") > 0 Then
        Select Case Split(Label.Tag, "-")(1)
            Case "youtube": FollowLink "https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg"
            Case "github": FollowLink "https://github.com/alexofrhodes/"
            Case "blog": FollowLink "https://alexofrhodes.github.io/"
            Case "buymeacoffee": FollowLink "http://paypal.me/alexofrhodes"
            Case "email"
                If GetInternetConnectedState = False Then
                    MsgBox "Seems Internet is not available"
                    Exit Sub
                End If
                If OutlookCheck = True Then
                    MailDev
                Else
                    Dim out As String
                    out = AUTHOR_EMAIL
                    CLIP out
                    MsgBox ("Seems Outlook is not available" & Chr(10) & _
                            "DEV's email address " & vbNewLine & out & vbNewLine & "copied to clipboard")
                End If
        End Select
    End If
End Sub


Public Sub AddThemeControlsSidbarRight()
    '@AssignedModule aMultiPage
    '@INCLUDE CLASS aMultiPage
    '@INCLUDE CLASS aFrame
    aFrame.Init(oForm.Controls("SidebarRight")).AddThemeControls
End Sub

Public Sub AddContactsToSidebarBottom()
    '@AssignedModule aMultiPage
    '@INCLUDE PROCEDURE FileExists
    '@INCLUDE PROCEDURE AvailableFormOrFrameColumn
    '@INCLUDE CLASS aMultiPage
    Dim SidebarBottom As MSForms.Frame
    On Error Resume Next
    Set SidebarBottom = oForm.Controls("SidebarBottom")
    On Error GoTo 0
    If SidebarBottom Is Nothing Then Exit Sub
    Dim lbl         As MSForms.Label
    Dim newPicture  As IPictureDisp
    Dim FilePath    As String
    Dim myLinks(1 To 5)
    myLinks(1) = "github"
    myLinks(2) = "blog"
    myLinks(3) = "youtube"
    myLinks(4) = "buymeacoffee"
    myLinks(5) = "email"

    Dim item
    For Each item In myLinks
        FilePath = ThisWorkbook.path & "\Lib\img\" & item & ".bmp"
        If FileExists(FilePath) Then
            Set newPicture = LoadPicture(FilePath)
            Set lbl = SidebarBottom.Controls.Add("Forms.Label.1")
            lbl.Visible = False
            With lbl
                .Top = 6
                .Width = 24
                .Height = 24
                .Left = AvailableFormOrFrameColumn(SidebarBottom, 0, , 12)
                Set .Picture = Nothing
                .Picture = newPicture
                .Tag = "followlink-" & item
                .ControlTipText = item
            End With
            lbl.Visible = True
        End If
    Next
End Sub


Public Function ActivePage() As MSForms.page
    '@AssignedModule aMultiPage
    '@INCLUDE CLASS aMultiPage
    Set ActivePage = oMultipage.Pages(oMultipage.Value)
End Function

Public Sub SetBackColor(PageIndex, BackColor As Long)
    'eg
    '    Call SetBackColor(Page:=MultiPage1.Pages(0), BackColor:=vbRed)
    '    Call SetBackColor(Page:=MultiPage1.Pages(1), BackColor:=RGB(20, 200, 100))
    '@AssignedModule aMultiPage
    '@INCLUDE CLASS aMultiPage
    '@INCLUDE DECLARATION GUID
    '@INCLUDE DECLARATION GetDC
    '@INCLUDE DECLARATION ReleaseDC

    'by Jaafar
    'https://www.mrexcel.com/board/threads/can-a-userform-multipage-backcolor-be-changed.79069/page-4

    Dim page        As MSForms.page
    Set page = oMultipage.Pages(PageIndex)
#If VBA7 Then
    Dim hLib        As LongPtr
#Else
    Dim hLib        As Long
#End If

    Dim R           As RECT
    Dim IID_IDispatch As GUID
    Dim uPicinfo    As uPicDesc
    Dim iPic        As IPicture
    Dim lRet        As Long
    Static i        As Integer

    page.PictureSizeMode = fmPictureSizeModeStretch

    hdc = GetDC(0)
    SetRect R, 0, 0, 1, 1

    With R
        hMemBmp = CreateCompatibleBitmap(hdc, .Right - .Left, .Bottom - .Top)
    End With

    hMemDc = CreateCompatibleDC(hdc)
    DeleteObject SelectObject(hMemDc, hMemBmp)
    hBrush = CreateSolidBrush(BackColor)
    FillRect hMemDc, R, hBrush
    hCopy = CopyImage(hMemBmp, IMAGE_BITMAP, 0, 0, LR_COPYRETURNORG)

    With IID_IDispatch
        .Data1 = &H20400
        .Data4(0) = &HC0
        .Data4(7) = &H46
    End With

    With uPicinfo
        .Size = Len(uPicinfo)
        .Type = PICTYPE_BITMAP
        .hPic = hCopy
        .hPal = 0
    End With

    hLib = LoadLibrary("oleAut32.dll")
    If hLib Then
        lRet = OleCreatePictureIndirectAut(uPicinfo, IID_IDispatch, True, iPic)
    Else
        hLib = LoadLibrary("olepro32.dll")
        lRet = OleCreatePictureIndirectPro(uPicinfo, IID_IDispatch, True, iPic)
    End If
    FreeLibrary hLib

    If lRet = S_OK Then
        Set page.Picture = iPic
    Else
        MsgBox "Unable to create Picture", vbCritical, "Error."
    End If

    DeleteObject hMemBmp
    DeleteObject hMemDc
    DeleteObject hBrush
    ReleaseDC 0, hdc

    ReDim Preserve ar(i)
    ar(i) = hCopy
    i = i + 1

End Sub

Private Sub DeleteResources()
    'private sub userform_Terminate()
    'Call DeleteResources
    'end sub
    '@AssignedModule aMultiPage
    '@INCLUDE CLASS aMultiPage
    Dim element     As Variant

    For Each element In ar
        DeleteObject element
    Next

End Sub


Function OutlookCheck() As Boolean
    '@AssignedModule aMultiPage
    '@INCLUDE CLASS aMultiPage
    Dim xOLApp      As Object
    Set xOLApp = CreateObject("Outlook.Application")
    If Not xOLApp Is Nothing Then
        OutlookCheck = True
        Set xOLApp = Nothing
        Exit Function
    End If
    OutlookCheck = False
End Function


Sub MailDev()
    '@AssignedModule aMultiPage
    '@INCLUDE CLASS aMultiPage
    '@INCLUDE DECLARATION AUTHOR_EMAIL
    Dim OutApp      As Object
    Dim OutMail     As Object
    Dim strBody     As String
    Set OutApp = CreateObject("Outlook.Application")
    Set OutMail = OutApp.CreateItem(0)
    On Error Resume Next
    With OutMail
        .To = AUTHOR_EMAIL
        .cc = vbNullString
        .BCC = vbNullString
        .Subject = "Feedback or request - " & ThisWorkbook.Name
        .body = strBody
        .display
    End With
    On Error GoTo 0
    Set OutMail = Nothing
    Set OutApp = Nothing
End Sub


'uModules	UserForm


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* UserForm   : uModules
'* Purpose    :
'* Copyright  :
'*
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* BLOG       : https://alexofrhodes.github.io/
'* GITHUB     : https://github.com/alexofrhodes/
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'*
'* Modified   : Date and Time       Author              Description
'* Created    : 17-08-2023 13:31    Alex                merged forms for modules Add / Rename / Remove
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Option Explicit

Private Sub listOpenBooks_Click()
    '@AssignedModule uModulesRemove
    '@INCLUDE USERFORM uModulesRemove
    addCompsList Workbooks(listOpenBooks.list(listOpenBooks.ListIndex))
End Sub

Private Sub UserForm_Initialize()
    SidebarRight.Visible = True
    SidebarBottom.Visible = False

    '// the class is predeclaredId = true but shouldn't this way still work?
    '    Dim am1 As aMultiPage
    '    Set am1 = New aMultiPage
    '    am1.Init(MultiPage1).BuildMenu createSidebarMinimizers:=True

    aMultiPage.Init(MultiPage1).BuildMenu createSidebarMinimizers:=True

    aListBox.Init(listOpenBooks).LoadVBProjects
End Sub

Private Sub SelectFromList_Click()
    '@AssignedModule uModulesAdd
    '@INCLUDE USERFORM uModulesAdd
    If listOpenBooks.ListIndex = -1 Then
        MsgBox "No book selected"
        Exit Sub
    End If
    Dim TargetWorkbook As Workbook
    Set TargetWorkbook = Workbooks(listOpenBooks.list(listOpenBooks.ListIndex))
    ModulesAdd TargetWorkbook
End Sub



Private Sub AddComponent(TargetWorkbook As Workbook, Module_Class_Form_Sheet As Long, componentArray As Variant)
    '@INCLUDE ModuleExists
    '@AssignedModule uModulesAdd
    '@INCLUDE PROCEDURE ModuleExists
    '@INCLUDE PROCEDURE CreateOrSetSheet
    '@INCLUDE USERFORM uModulesAdd
    Dim CompType    As Long
    CompType = Module_Class_Form_Sheet
    Dim vbProj      As VBProject
    Set vbProj = TargetWorkbook.VBProject
    Dim vbComp      As VBComponent
    Dim NewSheet    As Worksheet
    Dim i           As Long
    Dim counter     As Long
    On Error GoTo ErrorHandler
    For i = LBound(componentArray) To UBound(componentArray)
        If componentArray(i) <> vbNullString Then
            Select Case CompType
                Case Is = 1, 2, 3
                    If ModuleExists(CStr(componentArray(i)), TargetWorkbook) = False Then
                        If CompType = 1 Then Set vbComp = vbProj.VBComponents.Add(vbext_ct_StdModule)
                        If CompType = 2 Then Set vbComp = vbProj.VBComponents.Add(vbext_ct_ClassModule)
                        If CompType = 3 Then Set vbComp = vbProj.VBComponents.Add(vbext_ct_MSForm)
                    End If
                    vbComp.Name = componentArray(i)
                Case Is = 4
                    If CompType = 4 Then
                        Set NewSheet = CreateOrSetSheet(CStr(componentArray(i)), TargetWorkbook)
                        NewSheet.Name = componentArray(i)
                    End If
            End Select
        End If
loop1:
    Next i
    On Error GoTo 0
    Exit Sub
ErrorHandler:
    counter = counter + 1
    componentArray(i) = componentArray(i) & counter
    GoTo loop1
End Sub


Private Sub ModulesAdd(TargetWorkbook As Workbook)
    '@AssignedModule uModulesAdd
    '@INCLUDE USERFORM uModulesAdd
    Dim coll        As Collection
    Set coll = New Collection
    Dim element     As Variant
    coll.Add Split(Me.tModule.TEXT, vbNewLine)
    coll.Add Split(Me.tClass.TEXT, vbNewLine)
    coll.Add Split(Me.tUserform.TEXT, vbNewLine)
    coll.Add Split(Me.tDocument.TEXT, vbNewLine)
    Dim typeCounter As Long
    For Each element In coll
        If UBound(element) <> -1 Then
            typeCounter = typeCounter + 1
            AddComponent TargetWorkbook, typeCounter, element
        End If
    Next element
    MsgBox typeCounter & " components added to " & TargetWorkbook.Name
End Sub


Private Sub GetInfo_Click()
    '@AssignedModule uModulesAdd
    '@INCLUDE USERFORM uModulesAdd
    '@INCLUDE USERFORM uAuthor
    uAuthor.Show
End Sub


Private Sub Remover_Click()
    '@AssignedModule uModulesRemove
    '@INCLUDE USERFORM uModulesRemove
    If listOpenBooks.ListIndex = -1 Then
        MsgBox "No book selected"
        Exit Sub
    End If
    Dim TargetWorkbook As Workbook
    Set TargetWorkbook = Workbooks(listOpenBooks.list(listOpenBooks.ListIndex))
    RemoveModules TargetWorkbook
End Sub

Private Sub RemoveModules(TargetWorkbook As Workbook)
    '@AssignedModule uModulesRemove
    '@INCLUDE CLASS aModule
    '@INCLUDE USERFORM uModulesRemove
    If LComponents.ListCount = 0 Then Exit Sub
    Dim module      As VBComponent
    Dim i           As Long
    For i = 0 To LComponents.ListCount - 1
        If LComponents.Selected(i) Then
            If oCode.Value = True Then
                Set module = TargetWorkbook.VBProject.VBComponents(LComponents.list(i, 1))
                aModule.Init(module).CodeRemove
            ElseIf oComps.Value = True Then
                Set module = TargetWorkbook.VBProject.VBComponents(LComponents.list(i, 1))
                aModule.Init(module).Delete
            End If
        End If
    Next i
    addCompsList TargetWorkbook
End Sub


Private Sub addCompsList(TargetWorkbook As Workbook)
    '@AssignedModule uModulesRename
    '@INCLUDE PROCEDURE GetSheetByCodeName
    '@INCLUDE CLASS aModule
    '@INCLUDE CLASS aListBox
    '@INCLUDE USERFORM uModulesRename
    LComponents.clear
    Dim vbComp      As VBComponent
    For Each vbComp In TargetWorkbook.VBProject.VBComponents
        If vbComp.Name <> "ThisWorkbook" Then
            LComponents.AddItem
            LComponents.list(LComponents.ListCount - 1, 0) = aModule.Init(vbComp).TypeToString
            LComponents.list(LComponents.ListCount - 1, 1) = vbComp.Name
            If vbComp.Type = vbext_ct_Document Then
                LComponents.list(LComponents.ListCount - 1, 2) = GetSheetByCodeName(TargetWorkbook, vbComp.Name).Name
            End If
        End If
    Next
    Me.Caption = "Comps of " & TargetWorkbook.Name
    aListBox.Init(LComponents).SortOnColumn 1

    SyncNames TargetWorkbook
End Sub

Private Sub RenameComponents_Click()
    '@AssignedModule uModulesRename
    '@INCLUDE PROCEDURE GetSheetByCodeName
    '@INCLUDE USERFORM uModulesRename
    If listOpenBooks.ListIndex = -1 Then
        MsgBox "No book selected"
        Exit Sub
    End If
    Dim TargetWorkbook As Workbook
    Set TargetWorkbook = Workbooks(listOpenBooks.list(listOpenBooks.ListIndex))
    Dim NewNames    As Variant
    Dim i           As Long
    NewNames = Split(textboxNewName, vbNewLine)
    For i = 0 To UBound(NewNames)
        If NewNames(i) = vbNullString Then
            NewNames(i) = LComponents.list(i)
        End If
    Next i
    For i = 0 To UBound(NewNames)
retry:
        On Error GoTo EH
        '        Select Case LComponents.list(i, 0)
        '        Case Is = "Module", "Class", "UserForm"
        If LComponents.list(i, 1) <> NewNames(i) Then
            TargetWorkbook.VBProject.VBComponents(LComponents.list(i, 1)).Name = NewNames(i)
        End If
        '        Case Is = "Document"
        '            If LComponents.list(i, 1) <> NewNames(i) Then
        '                GetSheetByCodeName(TargetWorkbook, LComponents.list(i, 1)).name = NewNames(i)
        '            End If
        '        End Select
    Next
    For i = 0 To LComponents.ListCount - 1
        LComponents.list(i, 1) = NewNames(i)
    Next i
    textboxNewName.TEXT = vbNullString
    Dim str         As String
    str = Join(NewNames, vbNewLine)
    textboxNewName.TEXT = str
    MsgBox "Components renamed"
    Exit Sub
EH:
    NewNames(i) = NewNames(i) & "_R"
    Resume retry:
End Sub



Private Sub SyncNames(TargetWorkbook As Workbook)
    '@AssignedModule uModulesRename
    '@INCLUDE USERFORM uModulesRename
    Dim str         As String
    Dim i           As Long
    For i = 0 To LComponents.ListCount - 1
        str = str & IIf(i > 0, vbNewLine, "") & LComponents.list(i, 1)
    Next
    textboxNewName.TEXT = str
    textboxNewName.ScrollBars = fmScrollBarsVertical
    textboxNewName.SetFocus
    textboxNewName.selStart = 0
End Sub

'z_zTest	Module


Option Explicit


Function tm2(X As Long, Y As Long) As Long

End Function

Function tm3() As Collection

End Function

'* Modified   : Date and Time       Author              Description
'* Updated    : 18-08-2023 13:12    Alex                (z_zTest.bas > GotoSelectedShapeOnAction)

Sub GotoSelectedShapeOnAction()
'@LastModified 2308181312
'@Description Something
'@INCLUDE PROCEDURE GotoShapeOnaction
    Dim shapeCount  As Long
    On Error Resume Next
    shapeCount = Selection.ShapeRange.Count
    On Error GoTo 0
    If shapeCount <> 1 Then Exit Sub
    Dim shp         As Shape
    Set shp = ActiveSheet.Shapes(Selection.Name)
    GotoShapeOnaction ActiveSheet.Shapes(Selection.Name)
End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 18-08-2023 13:12    Alex                (z_zTest.bas > GotoShapeOnaction)

Sub GotoShapeOnaction(shp As Shape)
'@LastModified 2308181312
'@INCLUDE CLASS aProcedure
    Dim Procedure   As String
    Procedure = shp.OnAction
    If Procedure = "" Then Exit Sub
    On Error GoTo ErrorHandler
    aProcedure.Init(ActiveWorkbook, , Procedure).Activate
    Exit Sub
ErrorHandler:
    MsgBox Procedure & " not found"
End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 21-08-2023 13:59    Alex                (z_zTest.bas > ShowInNotepad)

Sub ShowInNotepad(txt As String)
'@LastModified 2308211359
'@INCLUDE PROCEDURE FollowLink
'@INCLUDE PROCEDURE TxtOverwrite
    Dim TargetFile  As String
    TargetFile = ThisWorkbook.path & "\tmp.txt"
    TxtOverwrite TargetFile, txt
    FollowLink TargetFile
End Sub

'PrettyPrint	Class

Option Explicit
Option Base 1
'
' Pretty Print class
' |* Brian J. Satola
' |* https://chejunkie.com
'
'==========================================================================================================================
' Public Subs, Functions and Properties - oh my!
'==========================================================================================================================
' For additional details see About.
'==========================================================================================================================
'     |> Get | --- About                    :: String that describes the current class.
'     |> Get | Let BlankLineBeforeHeaders   :: Switch to insert a blank line before a header is printed.
'     |> Get | Let BlankLineBeforeTitles    :: Switch to insert a blank line before a title is printed.
'     |> Get | --- Name                     :: Returns the name of the class as a string.
'     |> --------- PrintHeader1             :: Print heading style 1 to the Immediate Window.
'     |> --------- PrintHeader2             :: Print heading style 2 to the Immediate Window.
'     |> --------- PrintLineElements        :: Prints a formatted line form single or multiple arguments.
'     |> --------- PrintTable               :: Prints a formatted table to the Immediate Window.
'     |> --------- PrintTitle               :: Prints a formatted title to the Immediate Window.
'     |> Get | --- Version                  :: Returns version string for the class [e.g. #.# (year)].
'
'==========================================================================================================================
' Application Constants
'==========================================================================================================================
Const C_MAX_LEN As Integer = 110
'
'==========================================================================================================================
' Private Variables
'==========================================================================================================================
Dim m_BlankLineBeforeTitles As Boolean
Dim m_BlankLineBeforeHeaders As Boolean
'''
''' Class constructor.
'''
Private Sub Class_Initialize()
    Debug.Print "|> Initializing:= " & Me.Name
    m_BlankLineBeforeTitles = True
    m_BlankLineBeforeHeaders = True
End Sub
'''
''' Returns a string that describes the current class/object.
'''
Public Property Get About() As String
    About = "ChE Junkie VBA Pretty Print class module, " & Me.version & "." & VBA.vbCrLf & VBA.vbCrLf
    About = About & "For additional details see https://chejunkie.com/knowledge-base/pretty-print-class-for-vba/"
End Property
'''
''' Switch addds a line before header prints when True.
'''
Public Property Get BlankLineBeforeHeaders() As Boolean
    BlankLineBeforeHeaders = m_BlankLineBeforeHeaders
End Property
'''
''' Switch addds a line before header prints when True.
'''
Public Property Let BlankLineBeforeHeaders(switchValue As Boolean)
    m_BlankLineBeforeHeaders = switchValue
End Property
'''
''' Switch addds a line before title prints when True.
'''
Public Property Get BlankLineBeforeTitles() As Boolean
    BlankLineBeforeTitles = m_BlankLineBeforeTitles
End Property
'''
''' Switch addds a line before title prints when True.
'''
Public Property Let BlankLineBeforeTitles(switchValue As Boolean)
    m_BlankLineBeforeTitles = switchValue
End Property
'''
''' Returns the class name of the object.
'''
Public Property Get Name() As String
    Name = VBA.TypeName(Me) & ".cls"
End Property
'''
''' Print heading style 1.
'''
Public Sub PrintHeader1(ParamArray Args() As Variant)
    If m_BlankLineBeforeHeaders Then
        Debug.Print ""
    End If
    Debug.Print Strings.String(C_MAX_LEN, "=")
    PrintLineElements Args
    Debug.Print Strings.String(C_MAX_LEN, "=")
End Sub
'''
''' Print heading style 2.
'''
Public Sub PrintHeader2(ParamArray Args() As Variant)
    If m_BlankLineBeforeHeaders Then
        Debug.Print ""
    End If
    Debug.Print Strings.String(C_MAX_LEN, "-")
    PrintLineElements Args
    Debug.Print Strings.String(C_MAX_LEN, "-")
End Sub
'''
''' Print bullet
'''
Sub PrintBullet(lvl As Long, stringToLog As Variant)
    If lvl < 1 Then Exit Sub
    stringToLog = VBA.Now & ": |" & String(2 * (lvl - 1), "-") & "> " & stringToLog
    Debug.Print stringToLog
End Sub
'''
''' Print line through
'''
Sub PrintLineThrough(ByVal stringToLog As Variant)
    Dim strg As String
    Dim nlen(2) As Integer
    nlen(1) = C_MAX_LEN - VBA.Len(VBA.Now & ": ")
    If (VBA.Len(stringToLog) <= nlen(1)) Then
        strg = VBA.Replace(stringToLog, " ", "-")
        strg = "---" & strg
        nlen(2) = nlen(1) - VBA.Len(stringToLog) - 3
        Dim ilen As Long
        For ilen = 1 To nlen(2)
            strg = strg & "-"
        Next ilen
        stringToLog = VBA.Now & ": " & strg
    End If
    Debug.Print CStr(stringToLog)
End Sub
'''
''' Print a blank line
'''
Public Sub PrintBlankLine()
    Debug.Print ""
End Sub
'''
''' Print a line : solid (default) or dashed.
'''
Public Sub PrintDividingLine(Optional includeBlankLineAfter As Boolean = True, Optional useDashLine As Boolean = False)
    If includeBlankLineAfter Then
        If Not useDashLine Then
            Debug.Print String("_", C_MAX_LEN) & vbNewLine
        Else
            Debug.Print String("-", C_MAX_LEN) & vbNewLine
        End If
    ElseIf Not useDashLine Then
        Debug.Print String("_", C_MAX_LEN)
    Else
         Debug.Print String("-", C_MAX_LEN)
    End If
End Sub

''' Prints a formatted line depending on the arguments structure:
''' ** Each string will have a length [number] when it exists.
''' |> number, string, string, string... all strings printed to same [number] length.
''' |> string, number, string, number... string-number pairs, where number defines string length.
''' |> string - equivalent to Debug.Print "string".
'''
'* Modified   : Date and Time       Author              Description
'* Updated    : 12-09-2023 14:03    Alex                (PrettyPrint.cls > PrintLineElements) fixed wrong length

Public Sub PrintLineElements(ParamArray Args() As Variant)
'@LastModified 2309121403
    Dim i           As Integer
    Dim line        As String
    Dim cbuff       As String
    On Error GoTo ErrHandler
    cbuff = String(100, " ")
    If (LBound(Args) = UBound(Args)) Then
        If (UBound(Args(0)) > 0) Then    ' array of elements
            If (IsNumeric(Args(0)(0))) Then
                ' First number sets the length of all strings
                For i = 1 To UBound(Args(0))
                    line = line & Left(CStr(Args(0)(i)) & cbuff, CInt(Args(0)(0))) & IIf(i < UBound(Args(0)), Space(1), "")
                Next i
            ElseIf (((UBound(Args(0)) - LBound(Args(0)) + 1) Mod 2 = 0) And IsNumeric(Args(0)(1))) Then
                ' String-length pairs
                For i = 0 To UBound(Args(0))
                    line = line & Left(CStr(Args(0)(i)) & cbuff, Args(0)(i + 1)) & IIf(i < UBound(Args(0)) - 1, Space(1), "")
                    i = i + 1
                Next i
            End If
        Else    ' Debug.Print "string" equivalent
            line = Args(0)(0)
        End If
    ElseIf IsNumeric(Args(0)) Then
        ' First number sets the length of all strings
        For i = 1 To UBound(Args)
            line = line & Left(CStr(Args(i)) & cbuff, CInt(Args(0))) & IIf(i < UBound(Args), Space(1), "")
        Next i
    ElseIf (((UBound(Args) - LBound(Args) + 1) Mod 2 = 0) And IsNumeric(Args(1))) Then
        ' String-length pairs
        For i = 0 To UBound(Args)
            line = line & Left(CStr(Args(i)) & cbuff, Args(i + 1)) & IIf(i < UBound(Args), Space(1), "")
            i = i + 1
        Next i
    Else
        Exit Sub
    End If
    Debug.Print line
    Exit Sub
ErrHandler:
    Debug.Print VBA.vbCrLf & "** PROBLEM OCCURED ** PRETTY PRINT LINE ELEMENTS**"
    Debug.Print Strings.String(C_MAX_LEN, "_")
End Sub
'''
''' Prints formatted table to the immediate widnow.
''' If [hasHeader] then first row entries are taken as column titles.
'''
Public Sub PrintTable(Table As Variant, Optional hasHeader As Boolean = True, Optional padding As Integer = 1)
    On Error GoTo ErrHandler
    Debug.Print ArrayToTable(Table, hasHeader, padding)
    Exit Sub
ErrHandler:
    Debug.Print VBA.vbCrLf & "** PROBLEM OCCURED ** PRETTY PRINT TABLE **"
    Debug.Print Strings.String(C_MAX_LEN, "_")
End Sub

'* Modified   : Date and Time       Author              Description
'* Updated    : 25-10-2023 14:49    Alex                (PrettyPrint.cls > ArrayToTable)

Function ArrayToTable(Table As Variant, Optional hasHeader As Boolean = True, Optional padding As Integer = 1)
'@LastModified 2310251449
    '@SOURCE https://chejunkie.com/knowledge-base/format-debug-print-messages-in-vba/
    Dim nrow        As Integer
    Dim ncol        As Integer
    Dim irow        As Integer
    Dim jcol        As Integer
    Dim vals()      As Variant
    Dim rowStart    As Integer
    Dim widths()    As Integer
    Dim cbuff       As String
    Dim line        As String
    Dim edge        As String
    Dim Output      As String
    
    '!! make sure there are no tabs or linefeeds
    ArrayReplace Table, vbTab, Space(4)
    ArrayReplace Table, vbNewLine, Space(1)
    ArrayReplace Table, vbLf, Space(1)

    nrow = UBound(Table, 1)
    ncol = UBound(Table, 2)
    ReDim vals(1 To ncol * 2)
    ReDim widths(1 To ncol)
    cbuff = String(200, " ")
    ' Define column widths
    For jcol = LBound(Table, 2) To ncol
        For irow = LBound(Table, 1) To nrow
            If (Len(Table(irow, jcol)) > widths(jcol)) Then
                widths(jcol) = Len(Table(irow, jcol))
            End If
        Next irow
    Next jcol
    ' Print top edge and header
    edge = ".-" & Left(String(Len(cbuff), "-"), widths(1) + padding) & "-"
    For jcol = (LBound(Table, 2) + 1) To ncol - 1
        edge = edge & "-" & Left(String(Len(cbuff), "-"), widths(jcol) + padding) & "-"
    Next jcol
    edge = edge & "-" & Left(String(Len(cbuff), "-"), widths(jcol) + padding) & "."
    Output = Output & IIf(Output <> "", vbNewLine, "") & edge
    If hasHeader Then
        line = "| " & Left(Table(LBound(Table, 1), 1) & cbuff, widths(1) + padding) & "|"
        For jcol = (LBound(Table, 2) + 1) To ncol
            line = line & " " & Left(Table(LBound(Table, 1), jcol) & cbuff, widths(jcol) + padding) & "|"
        Next jcol
        Output = Output & IIf(Output <> "", vbNewLine, "") & line
        Output = Output & IIf(Output <> "", vbNewLine, "") & edge
        rowStart = LBound(Table, 1) + 1
    Else
        rowStart = LBound(Table, 1)
    End If
    ' Print data
    For irow = rowStart To nrow
        line = "| " & Left(Table(irow, 1) & cbuff, widths(1) + padding) & "|"
        For jcol = (LBound(Table, 2) + 1) To ncol
            line = line & " " & Left(Table(irow, jcol) & cbuff, widths(jcol) + padding) & "|"
        Next jcol
        Output = Output & IIf(Output <> "", vbNewLine, "") & line
    Next irow
    Output = Output & IIf(Output <> "", vbNewLine, "") & edge
    ArrayToTable = Output
End Function

Sub PrintTitle(ParamArray titleToPrint() As Variant)
    'modified by Anastasiou Alex to print multiple lines
    'eg prettyprint.printtitle array(1, "this","that there")
    '//////////////////////////////////////////////////////////////////////////////////////////////////////////////
    '////                  ////////////////////////////////////////////////////////////////////////////////////////
    '////    1             ////////////////////////////////////////////////////////////////////////////////////////
    '////    this          ////////////////////////////////////////////////////////////////////////////////////////
    '////    that there    ////////////////////////////////////////////////////////////////////////////////////////
    '////                  ////////////////////////////////////////////////////////////////////////////////////////
    '//////////////////////////////////////////////////////////////////////////////////////////////////////////////
    Dim strg        As String
    Dim pads(2)     As String
    Dim nlen(2)     As Integer
    Dim ilen        As Long
    Dim i           As Long
    '// Preformatting
    '   [1] Padding for "stringToLog line.
    '   [2] Padding for spacer line.
    'mod
    Dim ll          As Long
    Dim element
    
        If IsArray(titleToPrint) Then
            For Each element In titleToPrint(0)
                If Len(CStr(element)) > ll Then ll = Len(CStr(element))
            Next
        Else
            For Each element In titleToPrint
                If Len(CStr(element)) > ll Then ll = Len(CStr(element))
            Next
        End If
    
    nlen(1) = C_MAX_LEN - (ll + 12)
    '/mod
    For ilen = 1 To nlen(1)
        pads(1) = pads(1) & "/"
    Next ilen
    pads(1) = "    " & pads(1)
    nlen(2) = ll                                     'mod
    For ilen = 1 To nlen(2)
        pads(2) = pads(2) & " "
    Next ilen
    '// Title definition.
    If m_BlankLineBeforeTitles Then
        strg = VBA.vbCrLf & VBA.vbCrLf
    End If
    strg = strg & VBA.String(C_MAX_LEN, "/") & VBA.vbCrLf
    strg = strg & "////    " & pads(2) & pads(1) & VBA.vbCrLf
    'mod
    If IsArray(titleToPrint) Then
        For i = LBound(titleToPrint(0)) To UBound(titleToPrint(0))
            strg = strg & "////    " & titleToPrint(0)(i) & Space(ll - Len(titleToPrint(0)(i))) & pads(1) & VBA.vbCrLf
        Next
    
    Else
        For i = LBound(titleToPrint) To UBound(titleToPrint)
            strg = strg & "////    " & titleToPrint(i) & Space(ll - Len(titleToPrint(i))) & pads(1) & VBA.vbCrLf
        Next
    End If
    '/mod
    strg = strg & "////    " & pads(2) & pads(1) & VBA.vbCrLf
    strg = strg & VBA.String(C_MAX_LEN, "/") & VBA.vbCrLf
    Debug.Print strg
End Sub
'''
''' Version string of the current class.
'''
Public Property Get version() As String
    '==========================================================================================================================
    ' Class changelog here.
    '==========================================================================================================================
    version = "Version 1.0 (2020)"  ' Initial (official) release.
End Property


'LogFile	Class

Rem INCLUDE class  ApplicationError
Rem INCLUDE class  RegistryEditor
Rem INCLUDE module mLogFile

Option Explicit
Option Base 1
'
' Log File Class
' |> Brian J. Satola
' |> https://chejunkie.com
' |> brian.satola@gmail.com
'
'==========================================================================================================================
' This class provides several methods for logging intermediate calculation results.
'==========================================================================================================================
' These routines rely on each other, so you should import this entire class module into your project
'   rather than just copying and pasting individual procedures into other modules.
' The Registry Editor class and Application Error class are also required.
'--------------------------------------------------------------------------------------------------------------------------
'
'==========================================================================================================================
' Public Subs, Functions and Properties - oh my!
'==========================================================================================================================
'   |> Get | --- About                  :: Returns description of the class.
'   |> --------- CreateLogFile          :: Creates a logfile for output and stores it in the specified [storageDirectory].
'   |> Get | Let DirectoryPath          :: Returns the directory location of the current logfile.
'   |> Get | --- FilePath               :: Returns the file path of the current logfile.
'   |> --------- PrintBlankLine           :: Outputs a blank line to the logfile.
'   |> Get | --- LogFileName            :: Returns the file name of the current logfile.
'   |> --------- LogDividingLine        :: Outputs a line to the logfile.
'   |> --------- Log                    :: Outputs strOutputMessage to the logfile.
'   |> Get | --- Name                   :: Returns name of the class.
'   |> --------- OpenDirectory          :: Opens the directory that the current logfile is stored in.
'   |> --------- OpenLogFile            :: Opens the current logfile (iff it exists).
'   |> Get | Let RegDirectoryScratch    :: Retrieves or sets the output directory used to save the logfile.
'   |> --------- RemoveRegistrySetting  :: Removes the registry setting for the default save location.
'   |> Get | --- Version                :: Returns version string for the class [e.g. #.# (year)].
'
'==========================================================================================================================
' References
'==========================================================================================================================
Dim m_AppErr        As New ApplicationError

'==========================================================================================================================
' Application constants
'==========================================================================================================================

Private Const C_NAME As String = "LogFile.cls"
Private Const C_DEFAULT_LOG_FILE_NAME As String = "Logger"
Private Const C_MAX_LEN As Integer = 96                 ' size/length of header boarders. (MUST BE AN EVEN NUMBER!)
' 96 seems to be a good size for wide-screen, else 90 or lower.

Private Enum LogOutputType
    LogAppend = 1
    LogOutput = 2
End Enum

'==========================================================================================================================
' Private variables
'==========================================================================================================================
Private m_LogFileExists As Boolean
Private m_FilePath  As String
Private m_DirectoryPath As String
Private m_FileName  As String
Private m_FileExt   As String


Const C_LINE_LENGTH As Integer = 110



'''
''' Version string of the current class.
'''
Public Property Get version() As String
    '==========================================================================================================================
    ' Class changelog here.
    '==========================================================================================================================

    'Version = "Version 1.0 (2015)"  ' Initial (official) release.
    'Version = "Version 2.0 (2015)"  ' Cleaned up code, including procedure descriptions.
    '   |> Added "About" Get property for use in e.g. display messages.
    '   |> Added "Version" Get property to track class changes.
    '   |> Added "Name" Get property (literal defintion).
    '   |> Added 'C_MAX_LEN' and "GetBufferString" to generalise the procedures for
    '       use in defining header titles, line outputs, etc.
    '   |> Updated "Log" procedure to use "GetBufferString" instead of literals.
    '   |> Updated "GetAppErrDisplayMessage" to include titles in dislpay messages.
    '   |> Removed the 'RegistryTRUxl.cls' reference; instead, directly handle read/write
    '       to the srcratch-directory location defined in the registry. This required
    '       adding a local reference to 'Registry.cls', and adding the appropriate
    '       property Get|Let procedures for "RegDirectoryScratch".
    '   |> Added "CreateFolder" procedure.
    '   |> Updated class constructor. If no valid "RegDirectoryScratch" definition exists,
    '       then "CreateFolder" is used to automatically create a scratch folder in the
    '       directory of the workbook to use for outputs. "RegDirectoryScratch" is then
    '       updated to match the new definition. If a valid "RegDirectoryScratch"
    '       defintion exists, then no changes are made.
    'Version = "Version 2.5 (2016)" ' SATOLA, BRIAN J. 26-AUG. 2016:
    '   |> Syntax corrections to module-level variables (prefix:= "m_").
    '   |> Changed enumeration names and values to use Pascal casing.
    '   |> Updated constructor print statement to use new "Name" property.
    '   |> Re-simplified ;) "AppErrDisplayMessage".
    '   |> Updated 'm_AppErr.Source =' definitions (simple formatting changes).
    '   |> FIXED CRITICAL ERROR in class constructor made during version 2 release.
    '       "RegDirectoryScratch" was returning Null to 'm_directoryPath',
    '       a string variable, which was preventing the routine from auto-creating
    '       a directory storage location for the logfile outputs.
    '   |> Fixed formatting problem for titles in the Log method.
    'Version = "3.0 (2017+)"  ' SATOLA, BRIAN J.
    '   |> Updated to use newest registry class (now called RegistryEditor).
    '   |> Removed the Let FileName property, CreateLogFile method already defines the name.
    '   |> Get FileName property is now called FileName_ to avoid naming conflicts.
    '   |> Reformated comments to new convention (for later automation).
    '   |> Replaced application error properties and methods with a new error object/holder.
    '   |> Renamed GetPaddedString to GetBufferString (which is more descriptive).
    '   |> Removed the 'Version' string from the get Version property (more intuitive this way).
    '   |> Added RemoveRegistrySetting() for testing purposes.
    version = "3.1 (2018)"  ' SATOLA, BRIAN J.
    '   |> Automatically define default file name if user does not provide:
    '       C_DEFAULT_LOG_FILE_NAME.

End Property
'''
''' Returns a string describing the class.
'''
Public Property Get About() As String
    About = "ChE Junkie VBA LogFile class module, v" & Me.version & "." & VBA.vbCrLf & VBA.vbCrLf
    About = About & "For additional details see https://chejunkie.com/knowledge-base/the-log-file-class-vba/"
End Property
'''
''' Returns the name of the class.
'''
Public Property Get Name() As String
    Name = C_NAME
End Property
'''
''' Returns the application error object of the class.
'''
Public Property Get AppErr() As ApplicationError
    Set AppErr = m_AppErr
End Property

'''
''' Initialize the class
'''
Public Sub Init(Optional storageDirectory As String = vbNullString, Optional ByRef LogFileName As String)
    '//// Class constructor.
    '--------------------------------------------------------------------------------------------------------------------------
    Debug.Print "|> Initializing:= " & C_NAME
    m_AppErr.Initialize C_NAME
    m_DirectoryPath = IniReadKey(ThisWorkbook.path & "\Lib\config\config.ini", "LogFile.cls", "FilePath")
    If Not FileFolderExists(m_DirectoryPath) Then    'key DNE, or invalid path.
        If Not FileFolderExists(ThisWorkbook.path & "\Lib\Log\") Then
            CreateFolder ThisWorkbook.path & "\Lib\Log\"
        End If
        m_DirectoryPath = ThisWorkbook.path & "\Lib\Log\"
    End If
    m_FileName = vbNullString
    m_FilePath = vbNullString
    m_FileExt = ".txt"
    CreateLogFile storageDirectory, LogFileName
End Sub

Private Sub Class_Initialize()
    Init
End Sub

'''
''' Creates a log file for output and stores it in the specified [storageDirectory].
''' If no [storageDirectory] is provided, then the [DirectoryPath] property is used.
'''
Public Function CreateLogFile(Optional storageDirectory As String = vbNullString, Optional ByRef LogFileName As String) As Boolean

    Dim sfx         As String
    Dim i           As Integer

    '//========================================================================================================================
    '// Initialize
    '//========================================================================================================================

    m_LogFileExists = False
    m_AppErr.clear

    If ((storageDirectory = vbNullString) And (m_DirectoryPath <> vbNullString)) Then    ' use existing directory definition.
        storageDirectory = m_DirectoryPath    ' e.g. class initializes to registry pointer.
    End If

    If ((storageDirectory <> vbNullString) And FileFolderExists(storageDirectory)) Then    ' valid input definition.
        m_DirectoryPath = storageDirectory
        If (LogFileName <> "") Then
            m_FileName = LogFileName
        Else
            LogFileName = C_DEFAULT_LOG_FILE_NAME
            m_FileName = LogFileName
        End If
        m_FilePath = m_DirectoryPath & m_FileName & m_FileExt
    Else    ' display application error
        With m_AppErr
            .Number = C_ERR_INVALID_DIRECTORY
            .Source = "CreateLogFile(...)"
            .DisplayMessage
        End With
        Exit Function
    End If

    '==========================================================================================================================
    ' Define LogFileName
    '==========================================================================================================================

    '// Ensure unique name (use integer suffix until found)
'    Do Until (FileFolderExists(m_FilePath) = False)
'        i = i + 1
'        sfx = " (" & i & ")"
'        m_FilePath = m_DirectoryPath & m_FileName & sfx & m_FileExt
'    Loop
    m_FileName = m_FileName & sfx

    m_LogFileExists = True

    '//========================================================================================================================
    '// Print Logfile Header
    '//========================================================================================================================

    '// Function WriteToFile(ByVal strLogMessage As String, ByVal iTypeOutput As EOutputType) As Boolean
    Call WriteToFile("LogFile       :    " & m_FileName, LogAppend)
    Call WriteToFile("Created       :    " & VBA.Now, LogAppend)
    Call WriteToFile(GetBufferString("_", C_MAX_LEN), LogAppend)
    Call WriteToFile("", LogAppend)

    CreateLogFile = True

End Function
'''
''' Creates a folder according to the specified <path> [fullPath].
'''
Private Function CreateFolder(ByVal fullPath As String) As Boolean

    If (fullPath <> vbNullString) Then    'create folder
        '// Ensure correct input format
        If (VBA.Right$(fullPath, 1) = "\") Then
            fullPath = VBA.Left$(fullPath, VBA.Len(fullPath) - 1)
        End If
        '// Create folder
        On Error GoTo ERR_HANDLER
        MkDir fullPath
        CreateFolder = True
        Exit Function
    End If

ERR_HANDLER:
End Function
'''
''' This method is just to change the order of the inputs for the CreateLogFile method.
''' Due to legacy support, the original method could not be directly changed etc.
'''
Public Function CreateLogFileByName(Optional ByRef LogFileName As String, Optional storageDirectory As String) As Boolean
    CreateLogFileByName = CreateLogFile(storageDirectory, LogFileName)
End Function
'''
''' Returns the file path of the current log file.
'''
Public Property Get FilePath() As String
    FilePath = m_FilePath
End Property
'''
''' Returns the file name of the current log file.
'''
Public Property Get fileName() As String
    fileName = m_FileName
End Property
'''
''' Returns the directory location for the current log file.
'''
Public Property Get DirectoryPath() As String
    DirectoryPath = m_DirectoryPath
End Property
'''
''' Sets the directory location in which the log file is saved.
'''
Private Property Let DirectoryPath(path As String)
    m_AppErr.clear
    If (VBA.Right(VBA.Trim(path), 1) <> "\") Then
        path = VBA.Trim(path) & "\"
    End If
    '// Check existence
    If (VBA.Dir(path, vbDirectory) = ".") Then
        m_DirectoryPath = path
    Else    ' display application error
        With m_AppErr
            .Number = C_ERR_INVALID_DIRECTORY
            .Source = "'Let' DirectoryPath"
            .DisplayMessage
        End With
    End If
End Property
'''
''' Function returns TRUE if the specified file or folder exists, FALSE if not.
'''
Private Function FileFolderExists(fullPath As String) As Boolean
    On Error Resume Next
    If Not (Dir(fullPath, vbDirectory) = vbNullString) And (fullPath <> vbNullString) Then
        FileFolderExists = True
    End If
End Function
'''
''' Opens the file/folder by the specified <path>.
'''
Private Sub OpenFileFolder(fullPath As String)
    m_AppErr.clear
    On Error Resume Next
    Excel.ActiveWorkbook.FollowHyperlink Address:=fullPath, NewWindow:=True
    Select Case Err.Number
        Case 0, -2147467260    '(-2147467260) results when someone hits cancel on Excel prompt.
            Exit Sub
        Case Else
            On Error Resume Next
            With m_AppErr
                If (VBA.InStr(VBA.Mid(fullPath, VBA.Len(fullPath) - VBA.Len(m_FileExt) - 1, VBA.Len(m_FileExt)), ".") <> 0) Then
                    .Number = C_ERR_INVALID_FILE
                Else
                    .Number = C_ERR_INVALID_DIRECTORY
                End If
                .Source = "OpenFileFolder(...)"
            End With
    End Select
End Sub
'''
''' Opens the directory location of the current Log File.
'''
Public Sub OpenDirectory()
    OpenFileFolder (DirectoryPath)
End Sub
'''
''' Opens the current log file (if it exists).
'''
Public Sub OpenLogFile()
    OpenFileFolder (m_FilePath)
End Sub









'''
''' Generates a string of singleCharaster(s) of length stringLength.
''' Used to generate outputs for e.g. header boarders.
'''
Private Function GetBufferString(singleCharacter As String, stringLength As Integer) As String
    Dim i           As Long
    m_AppErr.clear
    If (VBA.Len(singleCharacter) = 1) Then
        For i = 1 To stringLength
            GetBufferString = GetBufferString & singleCharacter
        Next i
    Else    'display application error
        With m_AppErr
            .Number = C_ERR_INVALID_INPUT
            .Source = "GetBufferString(...)"
            .DisplayMessage
        End With
    End If
End Function
'''
'''
'''
Public Sub Log(ByVal stringToLog As Variant)
    Dim strg As String
    If IsArray(stringToLog) Then
        strg = Join(stringToLog, vbNewLine)
    Else
        strg = stringToLog
    End If
    Call WriteToFile(CStr(stringToLog), LogAppend)
        
'        Case Else    ' display error message
'            With m_AppErr
'                .Number = C_ERR_INVALID_INPUT
'                .Source = "Log(...)"
'                .Description = GetAppErrDescription(.Number)
'                .DisplayMessage
'            End With
'            Exit Sub
End Sub
'''
'''
'''
Sub PrintLineThrough(ByVal stringToLog As Variant)
    Dim strg As String
    Dim nlen(2) As Integer
    nlen(1) = C_MAX_LEN - VBA.Len(VBA.Now & ": ")
    If (VBA.Len(stringToLog) <= nlen(1)) Then
        strg = VBA.Replace(stringToLog, " ", "-")
        strg = "---" & strg
        nlen(2) = nlen(1) - VBA.Len(stringToLog) - 3
        Dim ilen As Long
        For ilen = 1 To nlen(2)
            strg = strg & "-"
        Next ilen
        stringToLog = VBA.Now & ": " & strg
    End If
    Call WriteToFile(CStr(stringToLog), LogAppend)
End Sub
'''
''' Outputs a blank line to the log file.
'''
Public Sub PrintBlankLine()
    Call WriteToFile("", LogAppend)
End Sub
'''
''' Outputs a line to the Log file: solid (default) or dashed.
'''
Public Sub LogDividingLine(Optional includeBlankLineAfter As Boolean = True, Optional useDashLine As Boolean = False)
    If includeBlankLineAfter Then
        If Not useDashLine Then
            Call WriteToFile(GetBufferString("_", C_MAX_LEN) & VBA.vbCrLf, LogAppend)
        Else
            Call WriteToFile(GetBufferString("-", C_MAX_LEN) & VBA.vbCrLf, LogAppend)
        End If
    ElseIf Not useDashLine Then
        Call WriteToFile(GetBufferString("_", C_MAX_LEN), LogAppend)
    Else
        Call WriteToFile(GetBufferString("-", C_MAX_LEN), LogAppend)
    End If
End Sub
'''
''' Logs the stringToLog to the defined log file.
''' Formats the output according to LogFormatType.
'''
Sub LogTitle(ByVal stringToLog As Variant)
    m_AppErr.clear
    Dim strg As String
    Dim pads(2) As String
    Dim nlen(2) As Integer
    Dim ilen As Long
    Dim i   As Long
    '// Preformatting
    '   [1] Padding for "stringToLog line.
    '   [2] Padding for spacer line.
    Dim ll  As Long
    If IsArray(stringToLog) Then
        Dim element
        For Each element In stringToLog
            If Len(CStr(element)) > ll Then ll = Len(CStr(element))
        Next
    Else
        ll = Len(stringToLog)
    End If
    nlen(1) = C_MAX_LEN - (ll + 12)
    For ilen = 1 To nlen(1)
        pads(1) = pads(1) & "/"
    Next ilen
    pads(1) = "    " & pads(1)
    nlen(2) = ll
    For ilen = 1 To nlen(2)
        pads(2) = pads(2) & " "
    Next ilen
    '// Title definition.
    strg = VBA.vbCrLf & VBA.vbCrLf
    strg = strg & VBA.String(C_MAX_LEN, "/") & VBA.vbCrLf
    strg = strg & "////    " & pads(2) & pads(1) & VBA.vbCrLf
    If IsArray(stringToLog) Then
        For i = LBound(stringToLog) To UBound(stringToLog)
            strg = strg & "////    " & stringToLog(i) & Space(ll - Len(stringToLog(i))) & pads(1) & VBA.vbCrLf
        Next
    Else
        strg = strg & "////    " & stringToLog & pads(1) & VBA.vbCrLf
    End If
    strg = strg & "////    " & pads(2) & pads(1) & VBA.vbCrLf
    strg = strg & VBA.String(C_MAX_LEN, "/") & VBA.vbCrLf
    stringToLog = strg
    Call WriteToFile(CStr(stringToLog), LogAppend)
End Sub
'''
'''
'''
Sub LogHeader1(ByVal stringToLog As Variant)
    m_AppErr.clear
    '==================================================================================================================
    'LOG HEADER NO. 1
    '==================================================================================================================
    Dim strg As String
    '// Preformatting
    strg = VBA.vbCrLf
    '// Header definition
    strg = strg & GetBufferString("=", C_MAX_LEN) & VBA.vbCrLf
    'mod
    If IsArray(stringToLog) Then
        Dim i As Long
        For i = LBound(stringToLog) To UBound(stringToLog)
            strg = strg & stringToLog & VBA.vbCrLf
        Next
    Else
        strg = strg & stringToLog & VBA.vbCrLf
    End If
    '/mod
    strg = strg & GetBufferString("=", C_MAX_LEN) & VBA.vbCrLf
    stringToLog = strg
    Call WriteToFile(CStr(stringToLog), LogAppend)
End Sub
'''
'''
'''
Sub LogHeader2(ByVal stringToLog As Variant)
    '--------------------
    'Header 2
    '--------------------
    m_AppErr.clear
    Dim strg As String
    '// Preformatting
    strg = VBA.vbCrLf
    '// Header definition
    strg = strg & GetBufferString("-", C_MAX_LEN) & VBA.vbCrLf
    'mod
    If IsArray(stringToLog) Then
        Dim i As Long
        For i = LBound(stringToLog) To UBound(stringToLog)
            strg = strg & stringToLog & VBA.vbCrLf
        Next
    Else
        strg = strg & stringToLog & VBA.vbCrLf
    End If
    '/mod
    strg = strg & GetBufferString("-", C_MAX_LEN) & VBA.vbCrLf
    stringToLog = strg
    Call WriteToFile(CStr(stringToLog), LogAppend)
End Sub
'''
'''
'''
Sub LogBullet(lvl As Long, stringToLog As Variant)
    If lvl < 1 Then Exit Sub
    stringToLog = VBA.Now & ": |" & String(2 * (lvl - 1), "-") & "> " & stringToLog
    Call WriteToFile(CStr(stringToLog), LogAppend)
End Sub
'''
'''
'''
Public Sub LogTable(Table As Variant, Optional hasHeader As Boolean = True, Optional padding As Integer = 1)
    Dim nrow        As Integer
    Dim ncol        As Integer
    Dim irow        As Integer
    Dim jcol        As Integer
    Dim vals()      As Variant
    Dim rowStart    As Integer
    Dim widths()    As Integer
    Dim cbuff       As String
    Dim line        As String
    Dim edge        As String

    Dim Output      As String

    nrow = UBound(Table, 1)
    ncol = UBound(Table, 2)
    ReDim vals(1 To ncol * 2)
    ReDim widths(1 To ncol)
    cbuff = String(200, " ")

    ' Define column widths
    For jcol = LBound(Table, 2) To ncol
        For irow = LBound(Table, 1) To nrow
            If (Len(Table(irow, jcol)) > widths(jcol)) Then
                widths(jcol) = Len(Table(irow, jcol))
            End If
        Next irow
    Next jcol

    ' Print top edge and header
    edge = ".-" & Left(String(Len(cbuff), "-"), widths(1) + padding) & "-"
    For jcol = (LBound(Table, 2) + 1) To ncol - 1
        edge = edge & "-" & Left(String(Len(cbuff), "-"), widths(jcol) + padding) & "-"
    Next jcol
    edge = edge & "-" & Left(String(Len(cbuff), "-"), widths(jcol) + padding) & "."
    Output = Output & IIf(Output <> "", vbNewLine, "") & edge
    If hasHeader Then
        line = "| " & Left(Table(LBound(Table, 1), 1) & cbuff, widths(1) + padding) & "|"
        For jcol = (LBound(Table, 2) + 1) To ncol
            line = line & " " & Left(Table(LBound(Table, 1), jcol) & cbuff, widths(jcol) + padding) & "|"
        Next jcol
        Output = Output & IIf(Output <> "", vbNewLine, "") & line
        Output = Output & IIf(Output <> "", vbNewLine, "") & edge

        rowStart = LBound(Table, 1) + 1
    Else
        rowStart = LBound(Table, 1)
    End If

    ' Print data
    For irow = rowStart To nrow
        line = "| " & Left(Table(irow, 1) & cbuff, widths(1) + padding) & "|"
        For jcol = (LBound(Table, 2) + 1) To ncol
            line = line & " " & Left(Table(irow, jcol) & cbuff, widths(jcol) + padding) & "|"
        Next jcol
        Output = Output & IIf(Output <> "", vbNewLine, "") & line
    Next irow

    Output = Output & IIf(Output <> "", vbNewLine, "") & edge
    Call WriteToFile(CStr(Output), LogAppend)
    Exit Sub
ErrHandler:
    Debug.Print VBA.vbCrLf & "** PROBLEM OCCURED ** PRETTY PRINT TABLE **"
    Debug.Print Strings.String(C_LINE_LENGTH, "_")
End Sub
'''
''' Writes "message" to the current log file.
'''
Private Sub WriteToFile(message As String, outputType As LogOutputType)
    Dim lu          As Integer
    On Error Resume Next
    If m_LogFileExists Then
        lu = VBA.FreeFile
        Select Case outputType
            Case LogAppend: Open m_FilePath For Append As #lu
            Case LogOutput: Open m_FilePath For Output As #lu
        End Select
        Print #lu, message
        Close #lu
    Else    ' display application error number
        With m_AppErr
            .Number = C_ERR_LOG_FILE_DNE
            .Source = "WriteToFile(...)"
            .DisplayMessage
        End With
    End If
End Sub





'
''* @TODO Created: 21-08-2023 14:55 Author: Anastasiou Alex
''* @TODO switch to ini method
''''
'''' Returns the default directory save location (scratch folder).
'''' Returns NULL if an error occured.
''''
'Property Get RegDirectoryScratch() As Variant
'
'    Dim var         As Variant
'
'    m_AppErr.clear
'
'    '// Retrieve and check value.
'    var = m_RegEdit.RegistryGetValue(C_BASE_KEY, C_KEY_NAME, C_REG_SCRATCH)
'    If Not VBA.IsNull(var) Then
'        RegDirectoryScratch = VBA.CStr(var)
'    Else
'        RegDirectoryScratch = Null
'        With m_AppErr
'            .Source = "'Get' RegDirecotryScratch"
'            .Number = C_ERR_REGISTRY_CLASS
'            .Description = m_RegEdit.AppErr.Description
'        End With
'    End If
'End Property
'
''''
'''' Sets the directory path for the default save location (scratch folder).
''''
'Public Property Let RegDirectoryScratch(strDirectoryPath As Variant)
'
'    m_AppErr.clear
'
'    '// Force trailing slash
'    If (VBA.Right(VBA.Trim(strDirectoryPath), 1) <> "\") Then
'        strDirectoryPath = VBA.Trim(strDirectoryPath) & "\"
'    End If
'
'    '// Check and set value.
'    If (strDirectoryPath = vbNullString) Then
'        GoTo ErrHandler
'    ElseIf FileFolderExists(VBA.CStr(strDirectoryPath)) Then
'        If m_RegEdit.RegistryUpdateValue(C_BASE_KEY, C_KEY_NAME, C_REG_SCRATCH, VBA.CStr(strDirectoryPath), createKeyIfNotExist:=True) Then
'            Exit Property
'        Else
'            m_AppErr.Number = C_ERR_REGISTRY_CLASS
'        End If
'    Else
'        m_AppErr.Number = C_ERR_INVALID_DIRECTORY
'    End If
'
'ErrHandler:
'    With m_AppErr
'        If (.Number = 0) Then .Number = C_ERR_TYPE_MISMATCH
'        .Source = "'Let' RegDirectoryScratch"
'        .Description = GetAppErrDescription(.Number)
'    End With
'End Property
''''
'''' For testing purposes.
'''' The LogFile class will automatically create a default registry path if none is detected i.e. workbook.path/scr/
'''' This method alows me to remove the defined registry path, to verify that it is correctly created by the class.
''''
'Public Sub RemoveRegistrySetting()
'
'    m_AppErr.clear
'
'    If Not m_RegEdit.RegistryDeleteValue(C_BASE_KEY, C_KEY_NAME, C_REG_SCRATCH) Then    ' display error message
'        With m_AppErr
'            .Number = C_ERR_REGISTRY_CLASS
'            .Source = "RemoveRegistrySetting"
'            .Description = GetAppErrDescription(.Number)
'            .DisplayMessage
'        End With
'    End If
'
'End Sub







'ApplicationError	Class

Option Explicit
Option Base 1
'
' Application Error Class
' |> Brian J. Satola
' |> https://chejunkie.com
'
'==========================================================================================================================
' This class is an error container.
'==========================================================================================================================
' It can be added to other classes instead of creating separate properties etc. that handle errors in the same way.
'--------------------------------------------------------------------------------------------------------------------------
'
'==========================================================================================================================
' Public Subs, Functions and Properties - oh my!
'==========================================================================================================================
'   |> Get | --- About                  :: Returns description of the class.
'   |> --------- Clear                  :: Clears all error properties.
'   |> --------- Define                 :: Defines an error.
'   |> Get | Set Description            :: Description of an error Number. (NumberDLL description is appended.)
'   |> --------- DisplayMessage         :: Displays error information in a message box.
'   |> --------- HasError
'   |> --------- Initialize
'   |> Get | Set Number
'   |> Get | Set NumberDLL
'   |> Get | --- ParentName
'   |> --------- PrintMessage
'   |> Get | Set Source
'   |> Get | --- Version                :: Returns version string for the class, ##.## (yyyy).
'
'==========================================================================================================================
' Application constants
'==========================================================================================================================
Private Const C_NAME As String = "ApplicationError.cls"
Const C_ERR_OFFSET = 100
'==========================================================================================================================
' Error enum
'==========================================================================================================================
Public Enum ERR_ENUM
    C_ERR_NO_ERROR = 0
    C_ERR_INVALID_FILE = C_ERR_OFFSET + vbObjectError + 1
    C_ERR_INVALID_DIRECTORY = C_ERR_OFFSET + vbObjectError + 2
    C_ERR_LOG_FILE_DNE = C_ERR_OFFSET + vbObjectError + 3
    C_ERR_INVALID_INPUT = C_ERR_OFFSET + vbObjectError + 4
    C_ERR_TYPE_MISMATCH = C_ERR_OFFSET + vbObjectError + 5
End Enum
'==========================================================================================================================
' Private variables
'==========================================================================================================================
Private m_ErrNumber As Long
Private m_ErrNumberDLL As Long
Private m_ErrSource As String
Private m_ErrDescription As String
Private m_ErrDescriptionDLL As String
Private m_ParentName As String
Private m_HasError  As Boolean
'==========================================================================================================================
' API Constants
'==========================================================================================================================
' GetSystemErrorMessageText
' |> www.cpearson.com/Excel/FormatMessage.aspx
Private Const FORMAT_MESSAGE_ALLOCATE_BUFFER As Long = &H100
Private Const FORMAT_MESSAGE_ARGUMENT_ARRAY As Long = &H2000
Private Const FORMAT_MESSAGE_FROM_HMODULE As Long = &H800
Private Const FORMAT_MESSAGE_FROM_STRING As Long = &H400
Private Const FORMAT_MESSAGE_FROM_SYSTEM As Long = &H1000
Private Const FORMAT_MESSAGE_MAX_WIDTH_MASK As Long = &HFF
Private Const FORMAT_MESSAGE_IGNORE_INSERTS As Long = &H200
Private Const FORMAT_MESSAGE_TEXT_LEN As Long = &HA0                  ' from VC++ ERRORS.H file

'==========================================================================================================================
' API Declarations
'==========================================================================================================================
' GetSystemErrorMessageText
' |> www.cpearson.com/Excel/FormatMessage.aspx
Private Declare PtrSafe Function FormatMessage Lib "kernel32" _
        Alias "FormatMessageA" ( _
        ByVal dwFlags As Long, _
        ByVal lpSource As Any, _
        ByVal dwMessageId As Long, _
        ByVal dwLanguageId As Long, _
        ByVal lpBuffer As String, _
        ByVal nSize As Long, _
        ByRef Arguments As Long) As Long
' ToggleTrustAccess
' |> https://wellsr.com/vba/2017/excel/macro-to-enable-trust-access-to-the-VBA-project-object-model/
#If VBA7 Then
Private Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
#Else
Private Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
#End If

'''
''' Clears all property settings of the error object.
'''
''' The parent name is not cleared since this is often set just once at the
''' beginning i.e. using the Initialize method.
'''
Public Sub clear()
    m_ErrNumber = C_ERR_NO_ERROR
    m_ErrNumberDLL = C_ERR_NO_ERROR
    m_ErrDescription = ""
    m_ErrSource = ""
    m_HasError = False
End Sub

'''
''' Defines an error.
'''
Public Sub Define(errNumber As Long, errDescription As String, Optional errSource As String)
    clear
    Me.Number = errNumber
    m_ErrDescription = errDescription
    m_ErrSource = errSource
End Sub

'''
''' Returns a descriptive string associated with an error.
''' Instead of having a seperate property for DLL errors, I simply append the result.
'''
Public Property Get Description() As String
    Description = m_ErrDescription
End Property

'''
''' Sets a descriptive string associated with an error.
'''
Property Let Description(str As String)
    m_ErrDescription = str
End Property

'''
''' Displays error details in a message-box: error number, description and source (if available).
''' Option to display custom title using [displayTitle]; else, it is automatically generated.
''' Option to append custom message to error text using [appendMessage].
''' Option to define message box behaviour using [iType] using vbMsgBoxStyle enums.
'''
Public Sub DisplayMessage(Optional displayTitle As String, Optional appendMessage As String, Optional msgBoxStyle As VbMsgBoxStyle = vbExclamation)
    If (displayTitle = "") Then        ' define display title
        displayTitle = "--ERROR!--"
        '--If (m_ErrNumber <> C_ERR_NO_ERROR) And (m_ParentName <> "") Then ' parent error title.
        '--    displayTitle = "--ERROR!-- " & m_ParentName
        '--ElseIf (m_ErrNumber <> C_ERR_NO_ERROR) Then ' error object title
        '--    displayTitle = "--ERROR!-- " & C_NAME
        '--ElseIf (m_ParentName <> "") Then ' parent
        '--    displayTitle = m_ParentName
        '--Else ' error object for everything else
        '--    displayTitle = C_NAME
        '--End If
    End If
    '// Display message to user.
    If (appendMessage <> vbNullString) Then    ' append message to error information
        MsgBox GetDescription & VBA.vbCrLf & VBA.vbCrLf & appendMessage, Title:=displayTitle, Buttons:=msgBoxStyle
    Else
        MsgBox GetDescription, Title:=displayTitle, Buttons:=msgBoxStyle
    End If
End Sub

'
' Returns a detailed error description: source, number and description (including errors from DLL).
'
Private Function GetDescription() As String
    '// Define detailed error description.
    If (m_ParentName <> "") Then
        GetDescription = "|> Parent: " & m_ParentName & VBA.vbCrLf
    End If
    If (m_ErrSource <> "") Then
        GetDescription = GetDescription & _
                "|> Source: " & m_ErrSource & VBA.vbCrLf & _
                "|> Number: " & m_ErrNumber & VBA.vbCrLf & _
                "|> " & m_ErrDescription
    Else
        GetDescription = GetDescription & _
                "|> Number: " & m_ErrNumber & VBA.vbCrLf & _
                "|> " & m_ErrDescription
    End If
    '// Append DLL error information.
    If (m_ErrDescriptionDLL <> "") Then
        GetDescription = GetDescription & VBA.vbCrLf & VBA.vbCrLf & _
                String(50, "-") & VBA.vbCrLf & _
                "|> DLL error number: " & m_ErrNumberDLL & VBA.vbCrLf & _
                "|> " & m_ErrDescription
    End If
End Function

'''
''' Returns a string describing the class.
'''
Public Property Get About() As String
    About = "ChE Junkie VBA Application Error class module, Version " & Me.version & "." & VBA.vbCrLf & VBA.vbCrLf
    About = About & "For additional details see:" & VBA.vbCrLf & "https://chejunkie.com/knowledge-base/application-error-class-vba"
End Property

'''
''' Returns the name of the class.
'''
Public Property Get Name() As String
    Name = C_NAME
End Property

'''
''' Returns version information for the class.
'''
Public Property Get version() As String
    ' Contains a list of (historical) changes to the class within the comments of the procedure.
    '--------------------------------------------------------------------------------------------------------------------------
    version = "Version 1.0 (2017)"        ' Initial (official) release.
End Property

'''
''' Will return True if 'Number' and/or 'NumberDLL' error exists.
'''
Property Get HasError() As Boolean
    HasError = m_HasError
End Property

'''
''' The parent name is something that is typically initialized just one time.
'''
Public Sub Initialize(parentName_ As String)
    clear
    m_ParentName = parentName_
End Sub

'''
''' Returns a numeric value specifying an error.
'''
Public Property Get Number() As Long
    Number = m_ErrNumber
End Property

'''
''' Returns a numeric value specifying a DLL error.
'''
Public Property Get NumberDLL() As Long
    NumberDLL = m_ErrNumberDLL
End Property

'''
''' This function gets the system error message text that corresponds to the error code *errNumber*.
''' This value is the value returned by Err.LastDLLError or by GetLastError, or occasionally as the
''' returned result of a Windows API function.
'''
''' These are NOT the error numbers returned by Err.Number (for these errors, use Err.Description
''' to get the description of the error).
'''
''' In general, you should use Err.LastDllError rather than GetLastError because under some
''' circumstances the value of GetLastError will be reset to 0 before the value is returned to VBA.
''' Err.LastDllError will always reliably return the last error number raised in an API function.
'''
''' The function returns vbNullString is an error occurred or if there is no error text for the
''' specified error number.
'''
Private Function GetSystemErrorMessageText(errNumber As Long) As String
    '@INCLUDE Init
    Dim ErrorText   As String
    Dim textLen     As Long
    Dim FormatMessageResult As Long
    Dim langID      As Long
    ''''''''''''''''''''''''''''''''
    ' Initialize the variables
    ''''''''''''''''''''''''''''''''
    langID = 0&        ' Default language
    ErrorText = VBA.String$(FORMAT_MESSAGE_TEXT_LEN, vbNullChar)
    textLen = FORMAT_MESSAGE_TEXT_LEN
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Call FormatMessage to get the text of the error message text
    ' associated with errNumber.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    FormatMessageResult = FormatMessage( _
            dwFlags:=FORMAT_MESSAGE_FROM_SYSTEM Or _
            FORMAT_MESSAGE_IGNORE_INSERTS, _
            lpSource:=0&, _
            dwMessageId:=errNumber, _
            dwLanguageId:=langID, _
            lpBuffer:=ErrorText, _
            nSize:=textLen, _
            Arguments:=0&)
    If FormatMessageResult = 0& Then
        ''''''''''''''''''''''''''''''''''''''''''''''''''
        ' An error occured. Display the error number, but
        ' don't call GetSystemErrorMessageText to get the
        ' text, which would likely cause the error again,
        ' getting us into a loop.
        ''''''''''''''''''''''''''''''''''''''''''''''''''
        MsgBox "An error occurred with the FormatMessage" & _
                " API function call." & vbCrLf & _
                "Error: " & CStr(Err.LastDllError) & _
                " VBA.Hex(" & VBA.Hex(Err.LastDllError) & ")."
        GetSystemErrorMessageText = "An internal system error occurred with the" & vbCrLf & _
                "FormatMessage API function: " & CStr(Err.LastDllError) & ". No futher information" & vbCrLf & _
                "is available."
        Exit Function
    End If
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' If FormatMessageResult is not zero, it is the number
    ' of characters placed in the ErrorText variable.
    ' Take the left FormatMessageResult characters and
    ' return that text.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ErrorText = VBA.Left$(ErrorText, FormatMessageResult)
    '''''''''''''''''''''''''''''''''''''''''''''
    ' Get rid of the trailing vbCrLf, if present.
    '''''''''''''''''''''''''''''''''''''''''''''
    If VBA.Len(ErrorText) >= 2 Then
        If VBA.Right$(ErrorText, 2) = vbCrLf Then
            ErrorText = VBA.Left$(ErrorText, VBA.Len(ErrorText) - 2)
        End If
    End If
    ''''''''''''''''''''''''''''''''
    ' Return the error text as the
    ' result.
    ''''''''''''''''''''''''''''''''
    GetSystemErrorMessageText = ErrorText
End Function

'''
''' Sets a numeric value specifying an error.
'''
Property Let Number(lng As Long)
    If (lng <> C_ERR_NO_ERROR) Then
        m_ErrNumber = lng
        m_HasError = True
        Description = GetAppErrDescription(lng)
    End If
End Property

'''
''' Sets a numeric value specifying a DLL error.
'''
Property Let NumberDLL(lng As Long)
    If (lng <> C_ERR_NO_ERROR) Then
        m_ErrNumberDLL = lng
        m_ErrDescriptionDLL = GetSystemErrorMessageText(lng)
        m_HasError = True
    End If
End Property

'''
''' Returns the name of the parent that the error object belongs to.
'''
Private Property Get ParentName() As String
    ParentName = m_ParentName
End Property

'
' Prints error details to the immediate window: error number, description and source (if available).
'
Public Sub PrintMessage()
    Debug.Print ""
    Debug.Print String(50, "=")
    Debug.Print " Application Error"
    Debug.Print String(50, "=")
    Debug.Print GetDescription
End Sub

'''
''' Returns the name of the method, object etc. that originally generated the error.
'''
Public Property Get Source() As String
    Source = m_ErrSource
End Property

'''
''' Sets the name of the method, object etc. that originally generated the error.
'''
Property Let Source(str As String)
    m_ErrSource = str
End Property

Private Sub Class_Initialize()
    Debug.Print "|* Initializing Class:= " & C_NAME
End Sub
'''
''' Returns the text description of the application error number.
'''
Public Function GetAppErrDescription(errNumber As Long) As String

    Select Case errNumber
        Case C_ERR_NO_ERROR: GetAppErrDescription = vbNullString
        Case C_ERR_INVALID_FILE: GetAppErrDescription = "Invalid file."
        Case C_ERR_INVALID_DIRECTORY: GetAppErrDescription = "Invalid directory."
        Case C_ERR_LOG_FILE_DNE: GetAppErrDescription = "Logfile DNE."
        Case C_ERR_INVALID_INPUT: GetAppErrDescription = "Invalid input."
        Case C_ERR_TYPE_MISMATCH: GetAppErrDescription = "Type mismatch."
        Case Else
            GetAppErrDescription = "Undefined error."
    End Select
End Function

'M_Process	Module

Option Explicit

#If VBA7 Then
    Private Declare PtrSafe Function OpenProcess Lib "kernel32" (ByVal dwDesiredAccess As LongPtr, ByVal bInheritHandle As LongPtr, ByVal dwProcessId As LongPtr) As LongPtr
    Private Declare PtrSafe Function TerminateProcess Lib "kernel32" (ByVal hProcess As LongPtr, ByVal uExitCode As Long) As Long
    Private Declare PtrSafe Function CloseHandle Lib "kernel32" (ByVal hObject As LongPtr) As Long
#Else
    Private Declare Function OpenProcess Lib "kernel32" (ByVal dwDesiredAccess As Long, ByVal bInheritHandle As Long, ByVal dwProcessId As Long) As Long
    Private Declare Function TerminateProcess Lib "kernel32" (ByVal hProcess As Long,ByVal uExitCode As Long) As Long
    Private Declare Function CloseHandle Lib "kernel32" (ByVal hObject As Long) As Long
#End If

Public Function KillProcess(ByVal processId As Long) As Boolean
'@INCLUDE DECLARATION CloseHandle
'@INCLUDE DECLARATION OpenProcess
'@INCLUDE DECLARATION TerminateProcess
    Dim hProcess As LongPtr
    hProcess = OpenProcess(&H1F0FFF, 0, processId)
    
    If hProcess <> 0 Then
        Dim success As Long
        success = TerminateProcess(hProcess, 0)
        If success <> 0 Then
            CloseHandle hProcess
            KillProcess = True
        End If
    End If
End Function



'CallStackFrameInterface	Class

'https://codereview.stackexchange.com/questions/135926/managing-a-programmatically-accessible-stack-trace

Option Explicit

Public Property Get ModuleName() As String
End Property

Public Property Get MemberName() As String
End Property

Public Property Get ParameterValue(ByVal index As Integer) As Variant
End Property

Public Function ToString() As String
End Function

'CallStackFrame	Class

'https://codereview.stackexchange.com/questions/135926/managing-a-programmatically-accessible-stack-trace

Option Explicit
Implements CallStackFrameInterface

Private Type ThisStackFrame
    ModuleName As String
    MemberName As String
    values As Collection
End Type

Private this As ThisStackFrame

Public Function Create(ByVal module As String, ByVal member As String, ByRef parameterValues() As Variant) As CallStackFrameInterface
    With New CallStackFrame
        .ModuleName = module
        .MemberName = member

        Dim index As Integer
        For index = LBound(parameterValues) To UBound(parameterValues)
            .AddParameterValue parameterValues(index)
        Next

        Set Create = .Self
    End With
End Function

Public Property Get Self() As CallStackFrameInterface
    Set Self = Me
End Property

Public Property Get ModuleName() As String
    ModuleName = this.ModuleName
End Property

Public Property Let ModuleName(ByVal Value As String)
    this.ModuleName = Value
End Property

Public Property Get MemberName() As String
    MemberName = this.MemberName
End Property

Public Property Let MemberName(ByVal Value As String)
    this.MemberName = Value
End Property

Public Property Get ParameterValue(ByVal index As Integer) As Variant
    ParameterValue = this.values(index)
End Property

Public Sub AddParameterValue(ByRef Value As Variant)
    this.values.Add Value
End Sub

Private Sub Class_Initialize()
    Set this.values = New Collection
End Sub

Private Sub Class_Terminate()
    Set this.values = Nothing
End Sub

Private Property Get CallStackFrameInterface_MemberName() As String
    CallStackFrameInterface_MemberName = this.MemberName
End Property

Private Property Get CallStackFrameInterface_ModuleName() As String
    CallStackFrameInterface_ModuleName = this.ModuleName
End Property

Private Property Get CallStackFrameInterface_ParameterValue(ByVal index As Integer) As Variant
    CallStackFrameInterface_ParameterValue = this.values(index)
End Property

Private Function CallStackFrameInterface_ToString() As String

    Dim result As String
    result = this.ModuleName & "." & this.MemberName & "("

    Dim index As Integer
    Dim Value As Variant
    For Each Value In this.values

        index = index + 1

        result = result & "{" & TypeName(Value) & ":"
        If IsObject(Value) Then
            result = result & ObjPtr(Value)
        ElseIf IsArray(Value) Then
            result = result & "[" & LBound(Value) & "-" & UBound(Value) & "]"
        ElseIf VarType(Value) = vbString Then
            result = result & Chr$(34) & Value & Chr$(34)
        Else
            result = result & CStr(Value)
        End If
        result = result & "}" & IIf(index = this.values.Count, vbNullString, ",")

    Next

    result = result & ")"
    CallStackFrameInterface_ToString = result

End Function

'CallStack	Class

'https://codereview.stackexchange.com/questions/135926/managing-a-programmatically-accessible-stack-trace


''Example
'''''''''
'Sub DoSomething(ByVal value1 As Integer, ByVal value2 As Integer, ByVal value3 As String)
'    Const C_PROCEDURE_NAME = "DoSomething"
'    CallStack.Push C_MODULE_NAME, C_PROCEDURE_NAME, value1, value2, value3
'    TestSomethingElse value1
'NormalExit:
'    CallStack.Pop
'End Sub
'
'Private Sub TestSomethingElse(ByVal value1 As Integer)
'    Const C_PROCEDURE_NAME = "TestSomethingElse"
'    CallStack.Push C_MODULE_NAME, C_PROCEDURE_NAME, value1
'    On Error GoTo ErrorHandler
'
'    Debug.Print value1 / 0
'
'NormalExit:
'    CallStack.Pop
'    Exit Sub
'ErrorHandler:
'    CallStack.PrintErrorInfo
'    Resume NormalExit
'End Sub

Option Explicit
Private frames As New Collection

Public Sub Push(ByVal module As String, ByVal member As String, ParamArray parameterValues() As Variant)
    Dim values() As Variant
    values = parameterValues
    frames.Add CallStackFrame.Create(module, member, values)
End Sub

Public Function Pop() As CallStackFrameInterface
    Set Pop = Peek
    frames.Remove frames.Count
End Function

Public Function Peek() As CallStackFrameInterface
    Set Peek = frames(frames.Count)
End Function

Public Property Get Count() As Long
    Count = frames.Count
End Property

Public Function ToString() As String
    Dim result As String
    Dim index As Long
    For index = frames.Count To 1 Step -1
        result = result & "at " & frames(index).ToString & IIf(index = 1, vbNullString, vbNewLine)
    Next
    ToString = result
End Function

Public Function ErrorInfo() As String
    ErrorInfo = "Runtime error " & Err.Number & ": " & Err.Description & vbNewLine & CallStack.ToString
End Function

Public Sub PrintErrorInfo()
    Debug.Print ErrorInfo
End Sub

Public Sub LogErrorInfo()
    LogFile.Log ErrorInfo
End Sub

'M_API	Module


'* @TODO Created: 30-10-2023 11:08 Author: Anastasiou Alex
'* @TODO move all here??


'CVBECommandHandler	Class

Public WithEvents EvtHandler As VBIDE.CommandBarEvents

Public Sub EvtHandler_Click( _
                           ByVal CommandBarControl As Object, _
                           handled As Boolean, _
                           CancelDefault As Boolean)
    '@AssignedModule CVBECommandHandler
    '@INCLUDE CLASS CVBECommandHandler
    On Error Resume Next
    Application.Run CommandBarControl.OnAction
    handled = True
    CancelDefault = True
End Sub



'ChangeLog	Document

Option Explicit


'uChangeLog	UserForm

Option Explicit

Private Table As ListObject
Private TargetWorksheet As Worksheet
Private targetVersion As String
Private TargetWorkbook As Workbook


Sub DeleteLastMod()
    Dim cell As Range
    On Error Resume Next
    Set cell = Table.DataBodyRange.Cells(1, 2)
    targetVersion = cell.Value
    On Error GoTo 0
    If targetVersion = "" Then Exit Sub
    Application.ScreenUpdating = False
    Dim rng As Range
    Set rng = VersionRange(targetVersion)
    If rng Is Nothing Then Exit Sub
    Dim i As Long
    For i = 1 To rng.rows.Count
        Table.ListRows(1).Delete
    Next
    
    Dim targetFolder As String
    targetFolder = TargetWorkbook.path & "\ChangeLog\" & targetVersion
    FolderDelete targetFolder
    
    If targetVersion = "1.0.0" Then PushVersionInitial
    Application.ScreenUpdating = True
End Sub

Public Function PushVersionInitial()
'@LastModified 2310102011
    PushVersionInitial = ListModifications(False, False, False)
End Function
Public Function PushVersionMajor()
'@LastModified 2310102011
    PushVersionMajor = ListModifications(True, False, False)
End Function
Public Function PushVersionMinor()
'@LastModified 2310102011
    PushVersionMinor = ListModifications(False, True, False)
End Function
Public Function PushVersionPatch()
'@LastModified 2310102012
    PushVersionPatch = ListModifications(False, False, True)
End Function

'* Modified   : Date and Time       Author              Description
'* Updated    : 28-08-2023 07:36    Alex                (uChangeLog.frm > ListModifications)
'* Updated    : 10-10-2023 20:12    Alex                (uChangeLog.frm > ListModifications : Now we can create a mod table for any project)
'* Updated    : 30-10-2023 10:58    Alex                (uChangeLog.frm > ListModifications : + changelog.txt | + additional export options)
'* Updated    : 30-10-2023 22:18    Alex                (uChangeLog.frm > ListModifications : in Normal_Exit added important TargetWorkbook.Save)

Function ListModifications( _
                     major As Boolean, _
                     minor As Boolean, _
                     patch As Boolean) As Boolean
'@LastModified 2310302218
'@INCLUDE PROCEDURE ListModificationsAfterLastPush
    Dim paramIndex As Long: paramIndex = Abs(major) + Abs(minor) + Abs(patch)
    Select Case paramIndex
    Case 0, 1
        
    Case Else
        Toast "Choose only 0 or 1 semantic versioning category as True"
        Exit Function
    End Select
  
    Dim TableRow As ListRow
    
    Dim newVersion As String
    If major + minor + patch = 0 Or Table.ListRows.Count = 0 Then
        newVersion = "1.0.0"
        If Table.ListRows.Count = 0 Then 'Table.DataBodyRange.Cells(1, 1).value = vbNullString Then
            Dim ans As String
retry:
            ans = InputboxString("Initializing", "Select initialization date for this project." & vbLf & _
                "Code modifications marked up to this date" & vbLf & _
                "by aProcedure.active.InjectModification won't be noted." & vbLf & vbLf & _
                "Type in as YY-MM-DD", _
                Format(Date - 1, "YY-MM-DD"))
            If Not ans Like "??-??-??" Then
                If MsgBox("Abort?", vbYesNo) = vbYes Then
                    ToggleControls False
                    Exit Function
                Else
                    GoTo retry
                End If
            End If
            Set TableRow = Table.ListRows.Add '(1)
            TableRow.Range(1, 1) = Format(Date - 1, "YY-MM-DD")
            TableRow.Range(1, 2) = newVersion
            TableRow.Range(1, 3) = "Initial Release"
            TableRow.Range.Cells.Font.Bold = False
            GoTo Normal_Exit
        Else
            Toast "Already initialized"
            GoTo CLEANUP
        End If
    End If
    
    Dim previousVersion
    previousVersion = Table.DataBodyRange.Cells(1, 2).Value
      
    'repush in the same day
    If Table.ListRows(1).Range(1, 1) = Format(Date, "YY-MM-DD") Then
        DeleteLastMod
        ListModifications major, minor, patch
        Exit Function
    End If
    
    newVersion = Split(previousVersion, ".")(0) + Abs(major) & "." & _
                 IIf(major, 0, Split(previousVersion, ".")(1) + Abs(minor)) & "." & _
                 IIf(minor, 0, IIf(major, 0, Split(previousVersion, ".")(2) + Abs(patch)))

    Application.ScreenUpdating = False
    
    Dim var
        var = ListModificationsAfterLastPush
        
    Dim customMessage As String
        customMessage = InputboxString("Custom message", _
                        UBound(var) + 1 & " code modifications found since " & Table.ListRows(1).Range(1, 1) & _
                        vbLf & vbLf & _
                        "Optional description for version " & newVersion)
    
    If Not ArrayAllocated(var) And customMessage = "" Then
        Toast "No mods found after " & Table.DataBodyRange.Cells(1, 1).Value & vbLf & _
                "and no custom description." & vbLf & _
                "Aborting operation"
        GoTo CLEANUP
    Else
        If customMessage <> "" Then
            Set TableRow = Table.ListRows.Add(1, True)
            TableRow.Range(1, 1) = Format(Date, "YY-MM-DD")
            TableRow.Range(1, 2) = newVersion
            TableRow.Range(1, 3) = customMessage
            TableRow.Range.Cells.Font.Bold = False
        End If
        Dim dif As Long:  dif = IIf(LBound(var) = 0, 1, 0)
        Dim i As Long
        For i = 1 To UBound(var) + dif
            Set TableRow = Table.ListRows.Add(i + IIf(customMessage = "", 0, 1), True)
            If customMessage = "" And i = 1 Then
                TableRow.Range(1, 1) = Format(Date, "YY-MM-DD")
                TableRow.Range(1, 2) = newVersion
            End If
            TableRow.Range(1, 3) = var(i - dif)
            TableRow.Range.Cells.Font.Bold = False
        Next
    End If
    
Normal_Exit:
    TargetWorksheet.Columns.AutoFit
    TxtOverwrite TargetWorkbook.path & "\" & aWorkbook.Init(TargetWorkbook).NameClean & "_ChangeLog.txt", PrettyPrint.ArrayToTable(Table.Range.Value, True)
    Dim targetFolder As String
    targetFolder = TargetWorkbook.path & "\ChangeLog\" & newVersion & "\"
    FoldersCreate targetFolder
    TargetWorkbook.Save
    TargetWorkbook.SaveCopyAs targetFolder & TargetWorkbook.Name
    With aWorkbook.Init(TargetWorkbook)
        If chWorkbookBackup Then TargetWorkbook.SaveCopyAs targetFolder & .Name
        If chExportReferences Then .ExportReferences targetFolder
        If chExportUnified Then .ExportCodeUnified targetFolder
        If chExportComponents Then .ExportModules targetFolder
        If chExportProcedures Then .ExportProcedures targetFolder & "PROCEDURES\", createModuleSubfolders:=True
        If chExportXML Then .ExportXML targetFolder
    End With
    ListModifications = True
CLEANUP:
    Application.ScreenUpdating = True
    Toast "Complete"
End Function

'* Modified   : Date and Time       Author              Description
'* Updated    : 22-08-2023 13:48    Alex                (Dependencies.bas > ListModificationsAfterLastPush)
'* Updated    : 10-10-2023 20:14    Alex                (Dependencies.bas > ListModificationsAfterLastPush)

Function ListModificationsAfterLastPush() As Variant
'@LastModified 2310260039
'@INCLUDE PROCEDURE ListModificationsBetween
    Dim out
    If Table.ListRows.Count = 0 Then
        out = ListModificationsBetween
    Else
        out = ListModificationsBetween(afterYYMMDD:=dateAfterLastPush)
    End If
    Dim i As Long
    For i = LBound(out) To UBound(out)
'        out(i) = Replace(Split(out(i), "(")(1), ")", "")
        out(i) = Replace(Split(Split(out(i), ": ")(1), "  ")(0) & " " & Split(out(i), "(")(1), ")", "")
    Next
    ListModificationsAfterLastPush = out
End Function

Public Function dateAfterLastPush()
    Dim dateCell As Range: Set dateCell = Table.DataBodyRange.Cells(1, 1)
    dateAfterLastPush = CStr( _
                        Mid(dateCell.TEXT, 1, 2) & _
                        Mid(dateCell.TEXT, 4, 2) & _
                        Mid(dateCell.TEXT, 7, 2) + 1)
End Function

'* Modified   : Date and Time       Author              Description
'* Updated    : 22-08-2023 09:51    Alex                (Dependencies.bas > ListModificationsBetween)

Function ListModificationsBetween(Optional afterYYMMDD = 200000, Optional beforeYYMMDD = 300000) As Variant
'@LastModified 2308220951
'@INCLUDE CLASS aWorkbook
'@INCLUDE PROCEDURE ArrayQuickSort
'@INCLUDE PROCEDURE ArrayTrim
    Dim arr
    arr = ArrayTrim( _
            Split( _
                aWorkbook.Init(TargetWorkbook).Code, _
                vbNewLine))
    arr = ArrayTrim( _
            Filter( _
                Filter( _
                    arr, _
                    "'* Updated    : ", _
                    True, _
                    vbTextCompare), _
                """", _
                False) _
            )
    ArrayTrim arr
    ArrayQuickSort arr
    Dim out
    Dim line, element
    For Each line In arr
        element = Split(Split(line, ": ")(1), " ")(0)
        element = Mid(element, 9, 2) & Mid(element, 4, 2) & Mid(element, 1, 2)
        If (afterYYMMDD <= CLng(element)) And (CLng(element) <= beforeYYMMDD) Then
            out = out & IIf(out <> "", vbNewLine, "") & line
        End If
    Next
'    out = Split(out, vbNewLine)
    ListModificationsBetween = Filter(Split(out, vbNewLine), "(", True)
End Function



Private Sub GetInfo_Click()
    With aUserform.Init(Me)
        .Transition .Effect(GetInfo, "Top", GetInfo.Top - 10, 150)
        .Transition .Effect(GetInfo, "Top", GetInfo.Top + 10, 150)
    End With
    uAuthor.Show
End Sub

Private Sub Label1_Click()
    If MsgBox("Irreversible proccess. Proceed?", vbYesNo) = vbNo Then Exit Sub
    DeleteLastMod
    UpdateVersions
End Sub

Private Sub Label2_Click()
    PushVersionMajor
    UpdateVersions
End Sub

Private Sub Label3_Click()
    PushVersionMinor
    UpdateVersions
End Sub

Private Sub Label4_Click()
    PushVersionPatch
    UpdateVersions
End Sub

Sub UpdateVersions()
    Application.EnableEvents = False
    LB_Versions.clear
    TextBox1.Value = ""
    ListVersions
    Application.EnableEvents = True
    If LB_Versions.ListCount > 0 Then LB_Versions.ListIndex = 0
End Sub

Private Sub Label5_Click()
    If Not TargetWorkbook Is Nothing Then FollowLink TargetWorkbook.path
End Sub

Private Sub Label6_Click()
    FollowLink "https://semver.org/"
End Sub

Private Sub UserForm_Initialize()
    aListBox.Init(LB_Books).LoadVBProjects
    LB_Versions.columnCount = 2
    LB_Versions.ColumnWidths = "40;"
    TextBox1.Font.Name = "Consolas"
    TextBox1.ScrollBars = fmScrollBarsBoth
    
    TextBox1.Font.Size = 10
    LB_Versions.Font.Size = 10
    LB_Books.Font.Size = 10
    
    ToggleControls False

    chWorkbookBackup.Value = True
    chWorkbookBackup.Enabled = False
    
    chExportUnified.Value = True
    chExportUnified.Enabled = False
    
    chExportReferences.Value = True
    chExportReferences.Enabled = False
    
    chExportComponents.Value = True
    
    TextBox1.Tag = "wh"
    With aUserform.Init(Me)
        .Resizable
        .ShowMaximizeButton
        .ShowMinimizeButton
    End With
End Sub


Private Sub LB_Books_Change()
    ClearPreviouslyLoaded
    Set TargetWorkbook = Workbooks(LB_Books.list(LB_Books.ListIndex))
    
    If WorkbookProjectProtected(TargetWorkbook) Then
        
    End If
    
    If Not aWorkbook.Init(TargetWorkbook).HasProject Then
        
    End If
    
    If Not CanCreateAndEditWorksheet Then
        Toast "Can't create and/or edit worksheets"
        ToggleControls False
        Exit Sub
    End If
    
    If Not CheckIfInitialized(TargetWorkbook) Then Exit Sub
    ListVersions
    If LB_Versions.ListCount > 0 Then LB_Versions.ListIndex = 0
    ToggleControls True
End Sub

Sub ToggleControls(targetStatus As Boolean)
    Label1.Enabled = targetStatus
    Label2.Enabled = targetStatus
    Label3.Enabled = targetStatus
    Label4.Enabled = targetStatus
End Sub

Sub ListVersions()
    Dim i As Long
    Dim var
    var = myVersions
    If Not ArrayAllocated(var) Then Exit Sub
    For i = LBound(var) To UBound(var)
        LB_Versions.AddItem
        LB_Versions.list(LB_Versions.ListCount - 1, 0) = var(i, 1)
        LB_Versions.list(LB_Versions.ListCount - 1, 1) = var(i, 2)
    Next
End Sub
Sub ClearPreviouslyLoaded()
    LB_Versions.clear
    TextBox1.Value = ""
    Set TargetWorkbook = Nothing
    Set TargetWorksheet = Nothing
    Set Table = Nothing
End Sub

Private Sub LB_Versions_Change()
    If LB_Versions.ListIndex = -1 Then Exit Sub
    targetVersion = LB_Versions.list(LB_Versions.ListIndex)
    Dim out As String
    Dim rng As Range
    Set rng = VersionRange(targetVersion)
    Dim i As Long
    For i = 1 To rng.rows.Count
        out = out & IIf(out <> "", vbNewLine, "") & rng.Cells(i, 3).Value
    Next
    Dim var
    var = Split(out, vbNewLine)
'    var = Filter(var, ">", True)
'    var = Filter(var, ":", True)
    out = Join(var, vbNewLine)
    out = StringFormatAlignRowsElements(out, ">", True)
    out = StringFormatAlignRowsElements(out, ":", False)
    TextBox1.Value = out
End Sub

Function VersionRange(targetVersion As String) As Range
    If Table.ListRows.Count = 0 Then Exit Function
    Dim cell As Range
    Dim rng As Range
    For Each cell In Table.DataBodyRange.Columns(2).Cells
        If cell.Value = targetVersion Then
            Do While (cell.Value = targetVersion Or cell.Value = "") And (Not cell.ListObject Is Nothing)
                If rng Is Nothing Then
                    Set rng = cell.offset(0, -1).Resize(1, 3)
                Else
                    Set rng = rng.Resize(rng.rows.Count + 1)
                End If
                Set cell = cell.offset(1, 0)
            Loop
            Exit For
        End If
    Next
    Set VersionRange = rng
End Function

Function myVersions() As Variant
    Dim cell As Range
    Dim rng As Range
    On Error Resume Next
    Set rng = Table.ListColumns(2).DataBodyRange
    Set rng = Intersect(rng, rng.SpecialCells(xlCellTypeConstants))
    On Error GoTo 0
    If rng Is Nothing Then Exit Function
    Dim out
    Dim lim As Long: lim = rng.Count
    ReDim out(1 To lim, 1 To 2)
    Dim i As Long: i = 0
    For Each cell In rng
        i = i + 1
        If cell <> "" Then out(i, 1) = cell.Value
        If cell <> "" Then out(i, 2) = cell.offset(0, -1).Value
    Next
    myVersions = out
End Function

Function CheckIfInitialized(TargetWorkbook As Workbook) As Boolean
    On Error Resume Next
    Set TargetWorksheet = TargetWorkbook.Sheets("ChangeLog")
    If TargetWorksheet Is Nothing Then
        TargetWorkbook.Sheets.Add(Before:=Sheets(1)).Name = "ChangeLog"
        Set TargetWorksheet = TargetWorkbook.Sheets("ChangeLog")
    End If
    Set Table = TargetWorksheet.ListObjects("TB_ChangeLog")
    On Error GoTo 0
    If Table Is Nothing Then
        Dim cell As Range
        Set cell = getLastCell(TargetWorksheet)
        Set cell = TargetWorksheet.Cells(cell.Row + 3, 1)
        Dim rng As Range
        Set rng = TargetWorksheet.Range(cell, cell.offset(0, 2))
        rng.Value = Array("Date", "Version", "Changes")
        Set Table = TargetWorksheet.ListObjects.Add(SourceType:=xlSrcRange, Source:=rng, XlListObjecthasheaders:=xlYes)
        Table.Name = "TB_ChangeLog"
        CheckIfInitialized = PushVersionInitial
    ElseIf Table.ListRows.Count = 0 Then
        CheckIfInitialized = PushVersionInitial
    Else
        CheckIfInitialized = True
    End If
End Function

'modWindowCaption	Module

Option Explicit
Option Compare Text
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' modWindowCaption
' By Chip Pearson, 15-March-2008, chip@cpearson.com, www.cpearson.com
' http://www.cpearson.com/Excel/FileExtensions.aspx
'
' This module contains code for working with Excel.Window captions. This code
' is necessary if you are going to use the FindWindowEx API call to get the
' HWnd of an Excel.Window.  Windows has a property called "Hide extensions of
' known file types". If this setting is TRUE, the file extension is not displayed
' (e.g., "Book1.xls" is displayed as just "Book1"). However, the Caption of an
' Excel.Window always includes the ".xls" file extension, regardless of the hide
' extensions setting. FindWindowEx requires that the ".xls" extension be removed
' if the "hide extensions" setting is True.
'
' This module contains a function named DoesWindowsHideFileExtensions, which returns
' TRUE if Windows is hiding file extensions or FALSE if Windows is not hiding file
' extensions. This is determined by a registry key. The module also contains a
' function named WindowCaption that returns the Caption of a specified Excel.Window
' with the ".xls" removed if necessary. The string returned by this function
' is suitable for use in FindWindowEx regardless of the value of the Windows
' "Hide Extensions" setting.
'
' This module also contains a function named WindowHWnd which returns the HWnd of
' a specified Excel.Window object. This function works regardless of the value of the
' Windows "Hide Extensions" setting.
'
' This module also includes the functions WindowText and WindowClassName which are
' just wrappers for the GetWindowText and GetClassName API functions.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
#If VBA7 Then
    Private Declare PtrSafe Function FindWindowEx Lib "user32" Alias "FindWindowExA" (ByVal hWnd1 As Long, ByVal hWnd2 As Long, ByVal lpsz1 As String, ByVal lpsz2 As String) As Long
    Private Declare PtrSafe Function GetClassName Lib "user32" Alias "GetClassNameA" (ByVal hwnd As Long, ByVal lpClassName As String, ByVal nMaxCount As Long) As Long
    Private Declare PtrSafe Function GetWindowText Lib "user32" Alias "GetWindowTextA" (ByVal hwnd As Long, ByVal lpString As String, ByVal cch As Long) As Long
    Private Declare PtrSafe Function RegCloseKey Lib "advapi32.dll" (ByVal HKey As Long) As Long
    Private Declare PtrSafe Function RegOpenKeyEx Lib "advapi32.dll" Alias "RegOpenKeyExA" (ByVal HKey As Long, ByVal lpSubKey As String, ByVal ulOptions As Long, ByVal samDesired As Long, phkResult As Long) As Long
    Private Declare PtrSafe Function RegQueryValueEx Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal HKey As Long, ByVal lpValueName As String, ByVal lpReserved As Long, LPType As Long, LPData As Any, lpcbData As Long) As Long
#Else
    Private Declare Function FindWindowEx Lib "user32" Alias "FindWindowExA" (ByVal hWnd1 As Long,ByVal hWnd2 As Long,ByVal lpsz1 As String,ByVal lpsz2 As String) As Long
    Private Declare Function GetClassName Lib "user32" Alias "GetClassNameA" (ByVal hwnd As Long,ByVal lpClassName As String,ByVal nMaxCount As Long) As Long
    Private Declare Function GetWindowText Lib "user32" Alias "GetWindowTextA" (ByVal hwnd As Long,ByVal lpString As String,ByVal cch As Long) As Long
    Private Declare Function RegCloseKey Lib "advapi32.dll" (ByVal HKey As Long) As Long
    Private Declare Function RegOpenKeyEx Lib "advapi32.dll" Alias "RegOpenKeyExA" (ByVal HKey As Long,ByVal lpSubKey As String,ByVal ulOptions As Long,ByVal samDesired As Long,phkResult As Long) As Long
    Private Declare Function RegQueryValueEx Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal HKey As Long,ByVal lpValueName As String,ByVal lpReserved As Long,LPType As Long,LPData As Any,lpcbData As Long) As Long
#End If

Private Const HKEY_CURRENT_USER As Long = &H80000001
Private Const HKEY_LOCAL_MACHINE As Long = &H80000002
Private Const HKEY_CLASSES_ROOT  As Long = &H80000000
Private Const HKEY_CURRENT_CONFIG  As Long = &H80000005
Private Const HKEY_DYN_DATA  As Long = &H80000006
Private Const HKEY_PERFORMANCE_DATA  As Long = &H80000004
Private Const HKEY_USERS  As Long = &H80000003
Private Const KEY_ALL_ACCESS  As Long = &H3F
Private Const ERROR_SUCCESS  As Long = 0&
Private Const HKCU  As Long = HKEY_CURRENT_USER
Private Const HKLM  As Long = HKEY_LOCAL_MACHINE

Private Enum REG_DATA_TYPE
    REG_DATA_TYPE_DEFAULT = 0   ' Default based on data type of value.
    REG_INVALID = -1            ' Invalid
    REG_SZ = 1                  ' String
    REG_DWORD = 4               ' Long
End Enum

Private Const C_EXCEL_APP_CLASSNAME = "XLMain"
Private Const C_EXCEL_DESK_CLASSNAME = "XLDesk"
Private Const C_EXCEL_WINDOW_CLASSNAME = "EXCEL7"


Function DoesWindowsHideFileExtensions() As Boolean
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' DoesWindowsHideFileExtensions
    ' This function looks in the registry key
    '   HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced
    ' for the value named "HideFileExt" to determine whether the Windows Explorer
    ' setting "Hide Extensions Of Known File Types" is enabled. This function returns
    ' TRUE if this setting is in effect (meaning that Windows displays "Book1" rather
    ' than "Book1.xls"), or FALSE if this setting is not in effect (meaning that Windows
    ' displays "Book1.xls").
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'@AssignedModule modWindowCaption
'@INCLUDE DECLARATION ERROR_SUCCESS
'@INCLUDE DECLARATION HKCU
'@INCLUDE DECLARATION KEY_ALL_ACCESS
'@INCLUDE DECLARATION RegCloseKey
'@INCLUDE DECLARATION RegOpenKeyEx
'@INCLUDE DECLARATION RegQueryValueEx

    Dim Res As Long
    Dim RegKey As Long
    Dim V As Long

    Const KEY_NAME = "Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced"
    Const VALUE_NAME = "HideFileExt"

    ''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Open the registry key to get a handle (RegKey).
    ''''''''''''''''''''''''''''''''''''''''''''''''''
    Res = RegOpenKeyEx(HKey:=HKCU, _
    lpSubKey:=KEY_NAME, _
    ulOptions:=0&, _
    samDesired:=KEY_ALL_ACCESS, _
    phkResult:=RegKey)

    If Res <> ERROR_SUCCESS Then
        Exit Function
    End If
    ''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Get the value of the "HideFileExt" named value.
    ''''''''''''''''''''''''''''''''''''''''''''''''''
    Res = RegQueryValueEx(HKey:=RegKey, _
    lpValueName:=VALUE_NAME, _
    lpReserved:=0&, _
    LPType:=REG_DWORD, _
    LPData:=V, _
    lpcbData:=Len(V))

    If Res <> ERROR_SUCCESS Then
        RegCloseKey RegKey
        Exit Function
    End If

    ''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Close the key and return the result.
    ''''''''''''''''''''''''''''''''''''''''''''''''''
    RegCloseKey RegKey
    DoesWindowsHideFileExtensions = (V <> 0)


End Function


Function WindowCaption(W As Excel.Window) As String
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' WindowCaption
    ' This returns the Caption of the Excel.Window W with the ".xls" extension removed
    ' if required. The string returned by this function is suitable for use by
    ' the FindWindowEx API regardless of the value of the Windows "Hide Extensions"
    ' setting.
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'@AssignedModule modWindowCaption
'@INCLUDE PROCEDURE DoesWindowsHideFileExtensions
'@INCLUDE DECLARATION FindWindowEx

    Dim HideExt As Boolean
    Dim Cap As String
    Dim Pos As Long

    HideExt = DoesWindowsHideFileExtensions()
    Cap = W.Caption
    If HideExt = True Then
        Pos = InStrRev(Cap, ".")
        If Pos > 0 Then
            Cap = Left(Cap, Pos - 1)
        End If
    End If

    WindowCaption = Cap

End Function

Function WindowHWnd(W As Excel.Window) As Long
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' WindowHWnd
    ' This returns the HWnd of the Window referenced by W.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'@AssignedModule modWindowCaption
'@INCLUDE PROCEDURE WindowCaption
'@INCLUDE DECLARATION C_EXCEL_DESK_CLASSNAME
'@INCLUDE DECLARATION C_EXCEL_WINDOW_CLASSNAME
'@INCLUDE DECLARATION FindWindowEx

    Dim AppHWnd As Long
    Dim DeskHWnd As Long
    Dim WHWnd As Long
    Dim Cap As String

    AppHWnd = Application.hwnd
    DeskHWnd = FindWindowEx(AppHWnd, 0&, C_EXCEL_DESK_CLASSNAME, vbNullString)
    If DeskHWnd > 0 Then
        Cap = WindowCaption(W)
        WHWnd = FindWindowEx(DeskHWnd, 0&, C_EXCEL_WINDOW_CLASSNAME, Cap)
    End If
    WindowHWnd = WHWnd

End Function

Function WindowText(hwnd As Long) As String
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' WindowText
    ' This just wraps up GetWindowText.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'@AssignedModule modWindowCaption
'@INCLUDE DECLARATION GetWindowText
    Dim S As String
    Dim N As Long
    N = 255
    S = String$(N, vbNullChar)
    N = GetWindowText(hwnd, S, N)
    If N > 0 Then
        WindowText = Left(S, N)
    Else
        WindowText = vbNullString
    End If
End Function

Function WindowClassName(hwnd As Long) As String
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' WindowClassName
    ' This just wraps up GetClassName.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'@AssignedModule modWindowCaption
'@INCLUDE DECLARATION GetClassName
    
    Dim S As String
    Dim N As Long
    N = 255
    S = String$(N, vbNullChar)
    N = GetClassName(hwnd, S, N)
    If N > 0 Then
        WindowClassName = Left(S, N)
    Else
        WindowClassName = vbNullString
    End If

End Function
